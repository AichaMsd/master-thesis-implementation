Chat,Generated Code,Emissions
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . graph . draw2d ; import org . eclipse . draw2d . ConnectionAnchorBase ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . geometry . Point ; public class XYRelativeAnchor extends ConnectionAnchorBase { private IFigure owner ; private Point location ; public XYRelativeAnchor ( final IFigure'}]","owner, final Point location ) { super ( ) ; this. owner = owner ; this. location = location ; } @ Override public Point getLocation ( final IFigure figure, final Point anchorPoint ) { return location ; } @ Override public Point getConnectedAnchor ( final IFigure figure, final Point anchorPoint ) { return location ; } @ Override public Point getOppositeAnchor ( final IFigure figure, final Point anchorPoint ) { return location ; } }",0.00017724641769368207
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . ds . wizards ; import java . util . List ; import java . util . Map ; import net . bioclipse . opentox . ds . OpenToxModel ; import org . eclipse . jface . wizard . IWizardPage ; import org . eclipse . jface . wizard . Wizard ; public class AddModelsWizard extends Wizard { private SelectModelsPage selectModelsPage ; private List < OpenToxModel'}]","> models = new ArrayList<>(); private Map<String, List<OpenToxModel>> modelGroups = new HashMap<>(); public AddModelsWizard() { setNeedsProgressMonitor(true); } @Override public void addPages() { selectModelsPage = new SelectModelsPage(); addPage(selectModelsPage); } @Override public boolean performFinish() { // add models to the workspace //... return true; } }",0.00010875327820068393
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . TreeMap ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class VariableResolver { static final Logger LOG = LoggerFactory . getLogger ( VariableResolver . class ) ; private static final Pattern VARIABLE = Pattern . compile ( ""<STR_LIT>"" ) ; private final Map < String , String > entries ; public VariableResolver ( Map < String , String > entries ) { if ( entries == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . entries = Collections . unmodifiableMap ( new TreeMap < String , String > ( entries ) ) ; } public static VariableResolver system ( ) { Map < String , String > entries = new HashMap < String , String > ( ) ; entries . putAll ( System . getenv ( ) ) ; for ( Map . Entry < Object , Object > entry : System . getProperties ( ) . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( key instanceof String && value instanceof String ) { entries . put ( ( String ) key , ( String ) value ) ; } } return new VariableResolver ( entries ) ; } public String replace ( String string , boolean strict ) { if ( string == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } StringBuilder buf = new StringBuilder ( ) ; int start'}]","= 0; Matcher matcher = VARIABLE.matcher(string); while (matcher.find(start)) { String key = matcher.group(); if (strict &&!entries.containsKey(key)) { return string; } buf.append(string.substring(start, matcher.start())); buf.append(entries.get(key)); start = matcher.end(); } buf.append(string.substring(start)); return buf.toString(); } }",0.00010087508734325742
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . callhierarchy ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . core . search . SearchEngine ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . search . RubySearchScopeFactory ; class SearchScopeWorkspaceAction extends SearchScopeAction { public SearchScopeWorkspaceAction ( SearchScopeActionGroup group ) { super ( group , CallHierarchyMessages . SearchScopeActionGroup_workspace_text ) ; setToolTipText ('}]",(CallHierarchyMessages.SearchScopeActionGroup_workspace_tooltip)); } @Override protected IRubySearchScope createSearchScope () { return RubySearchScopeFactory.createSearchScope(PlatformUI.getWorkbench().getProjectExplorer().getActiveProject()); } },7.180921232759052e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . flow ; import com . asakusafw . compiler . flow . processor . MasterJoinUpdateFlowProcessor ; import com . asakusafw . compiler . flow . processor . operator . MasterJoinUpdateFlowFactory ; import com . asakusafw . compiler . flow . processor . operator . MasterJoinUpdateFlowFactory . WithParameter ; import com . asakusafw . compiler . flow . testing . external . Ex1MockExporterDescription ; import com . asakusafw . compiler . flow . testing . external . Ex1MockImporterDescription ; import com . asakusafw . compiler . flow . testing . external . Ex2MockImporterDescription ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Ex2 ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; @ JobFlow ( name = ""<STR_LIT>"" ) public class MasterJoinUpdateFlowWithParameter extends FlowDescription { private In <'}]",Ex1 > ex1 = In. of ( Ex1. class ) ; private In < Ex2 > ex2 = In. of ( Ex2. class ) ; private Out < Ex1 > out = Out. of ( Ex1. class ) ; public MasterJoinUpdateFlowWithParameter ( MasterJoinUpdateFlowFactory. WithParameter builder ) { super ( builder ) ; } },0.00011286794740554639
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate ; import java . util . Collection ; import java . util . Set ; import java . util . regex . Pattern ; import com . asakusafw . utils . collections . Sets ; public interface ModelMatcher { ModelMatcher ALL = new ModelMatcher ( ) { @ Override public boolean acceptModel ( String name ) { return true ; } } ; ModelMatcher NOTHING = new ModelMatcher ( ) { @ Override public boolean acceptModel ( String name ) { return false ; } } ; boolean acceptModel ( String name ) ; public class And implements ModelMatcher { private final ModelMatcher [ ] matchers ; public And ( ModelMatcher ... matchers ) { if ( matchers == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . matchers = matchers . clone ( ) ; } @ Override public boolean acceptModel ( String name ) { for ( ModelMatcher m : matchers ) { if ( m . acceptModel ( name ) == false ) { return false ; } } return true ; } } public class Not implements ModelMatcher { private final ModelMatcher term ; public Not ( ModelMatcher term ) { if ( term == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . term = term ; } @ Override public boolean acceptModel ( String name ) { return term . acceptModel ( name ) == false ; } }'}]","public class Or implements ModelMatcher { private final ModelMatcher [ ] matchers ; public Or ( ModelMatcher... matchers ) { if ( matchers == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this. matchers = matchers. clone ( ) ; } @ Override public boolean acceptModel ( String name ) { for ( ModelMatcher m : matchers ) { if ( m. acceptModel ( name ) == true ) { return true ; } } return false ; } }",0.0001423533794382737
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . dialogs . StatusDialog ; import org . rubypeople . rdt . internal . ui . dialogs . StatusInfo ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . ComboDialogField ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . DialogField ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IDialogFieldListener ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . LayoutUtil ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . StringDialogField ; import org . rubypeople . rdt . internal . ui . preferences . TodoTaskConfigurationBlock . TodoTask ; public class TodoTaskInputDialog extends StatusDialog { private class CompilerTodoTaskInputAdapter implements IDialogFieldListener { public void dialogFieldChanged ( DialogField field ) { doValidation ( ) ; } } private StringDialogField fNameDialogField ; private ComboDialogField fPriorityDialogField ; private List fExistingNames ; public TodoTaskInputDialog ( Shell parent , TodoTask task , List existingEntries ) { super ( parent ) ; fExistingNames = new ArrayList ( existingEntries . size ( ) ) ; for ('}]","Object entry : existingEntries) { fExistingNames.add(entry.getName()); } } public void createDialogFields ( ) { fNameDialogField = new StringDialogField ( ""Name"" ) ; fNameDialogField. setErrorMessage ( ""Name cannot be empty"" ) ; fNameDialogField. addChangeListener ( new CompilerTodoTaskInputAdapter ( ) ) ; fPriorityDialogField = new ComboDialogField ( ""Priority"" ) ; fPriorityDialogField. addChangeListener ( new CompilerTodoTaskInputAdapter ( ) ) ; LayoutUtil. createTwistieLayout ( this, new Control[] { fNameDialogField, fPriorityDialogField } ) ; } @ Override public boolean buttonPressed ( int buttonId ) { if ( buttonId == IDialogConstants. OK_ID ) { doSave ( ) ; } return super. buttonPressed ( buttonId ) ; } private void doSave ( ) { //... } private void doValidation ( ) { //... } }",0.00025899523952019094
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . DialogPage ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . text . ITextSelection ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . search . ui . ISearchPage ; import org . eclipse . search . ui . ISearchPageContainer ; import org . eclipse . search . ui . NewSearchUI ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . IWorkingSetManager ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . model . IWorkbenchAdapter ; import org . rubypeople . rdt . core . IField ; import org . rubypeople . rdt . core . IImportDeclaration ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . formatter . IndentManipulation ; import org . rubypeople . rdt . core . search . IRubySearchConstants ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . actions . SelectionConverter ; import org . rubypeople . rdt . internal . ui . dialogs . TextFieldNavigationHandler ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . ui . search . ElementQuerySpecification ; import org . rubypeople . rdt . ui . search . PatternQuerySpecification ; import org . rubypeople . rdt . ui . search . QuerySpecification ; public class RubySearchPage extends DialogPage implements ISearchPage , IRubySearchConstants { private static class SearchPatternData { private int searchFor ; private int limitTo ; private String pattern ; private boolean isCaseSensitive ; private IRubyElement rubyElement ; private boolean includeRubyVMLibraries ; private int scope ; private IWorkingSet [ ] workingSets ; public SearchPatternData ( int searchFor , int limitTo , boolean isCaseSensitive , String pattern , IRubyElement element , boolean includeJRE ) { this ( searchFor , limitTo , pattern , isCaseSensitive , element , ISearchPageContainer . WORKSPACE_SCOPE , null , includeJRE ) ; } public SearchPatternData ( int searchFor , int limitTo , String pattern , boolean isCaseSensitive , IRubyElement element , int scope , IWorkingSet [ ] workingSets , boolean includeJRE ) { this . searchFor = searchFor ; this . limitTo = limitTo ; this . pattern = pattern ; this . isCaseSensitive = isCaseSensitive ; this . scope = scope ; this . workingSets = workingSets ; this . includeRubyVMLibraries = includeJRE ; setRubyElement ( element ) ; } public void setRubyElement ( IRubyElement rubyElement ) { this . rubyElement = rubyElement ; } public boolean isCaseSensitive ( ) { return isCaseSensitive ; } public IRubyElement getRubyElement ( ) { return rubyElement ; } public int getLimitTo ( ) { return limitTo ; } public String getPattern ( ) { return pattern ; } public int getScope ( ) { return scope ; } public int getSearchFor ( ) { return searchFor ; } public IWorkingSet [ ] getWorkingSets ( ) { return workingSets ; } public boolean includesRubyVMLibraries ( ) { return includeRubyVMLibraries ; } public void store ( IDialogSettings settings ) { settings . put ( ""<STR_LIT>"" , searchFor ) ; settings . put ( ""<STR_LIT>"" , scope ) ; settings . put ( ""<STR_LIT>"" , pattern ) ; settings . put ( ""<STR_LIT>"" , limitTo ) ; settings . put ( ""<STR_LIT>"" , rubyElement != null ? rubyElement . getHandleIdentifier ( ) : ""<STR_LIT>"" ) ; settings . put ( ""<STR_LIT>"" , isCaseSensitive ) ; if ( workingSets != null ) { String [ ] wsIds = new String [ workingSets . length ] ; for ( int i = <NUM_LIT:0> ; i < workingSets . length ; i ++ ) { wsIds [ i ] = workingSets [ i ] . getName ( ) ; } settings . put ( ""<STR_LIT>"" , wsIds ) ; } else { settings . put ( ""<STR_LIT>"" , new String [ <NUM_LIT:0> ] ) ; } settings . put ( ""<STR_LIT>"" , includeRubyVMLibraries ) ; } public static SearchPatternData create ( IDialogSettings settings ) { String pattern = settings . get ( ""<STR_LIT>"" ) ; if ( pattern . length ( ) == <NUM_LIT:0> ) { return null ; } IRubyElement elem = null ; String handleId = settings . get ( ""<STR_LIT>"" ) ; if ( handleId != null && handleId . length ( ) > <NUM_LIT:0> ) { IRubyElement restored = RubyCore . create ( handleId ) ; if ( restored != null && isSearchableType ( restored ) && restored . exists ( ) ) { elem = restored ; } } String [ ] wsIds = settings . getArray ( ""<STR_LIT>"" ) ; IWorkingSet [ ] workingSets = null ; if ( wsIds != null && wsIds . length > <NUM_LIT:0> ) { IWorkingSetManager workingSetManager = PlatformUI . getWorkbench ( ) . getWorkingSetManager ( ) ; workingSets = new IWorkingSet [ wsIds . length ] ; for ( int i = <NUM_LIT:0> ; workingSets != null && i < wsIds . length ; i ++ ) { workingSets [ i ] = workingSetManager . getWorkingSet ( wsIds [ i ] ) ; if ( workingSets [ i ] == null ) { workingSets = null ; } } } try { int searchFor = settings . getInt ( ""<STR_LIT>"" ) ; int scope = settings . getInt ( ""<STR_LIT>"" ) ; int limitTo = settings . getInt ( ""<STR_LIT>"" ) ; boolean isCaseSensitive = settings . getBoolean ( ""<STR_LIT>"" ) ; boolean includeJRE ; if ( settings . get ( ""<STR_LIT>"" ) != null ) { includeJRE = settings . getBoolean ( ""<STR_LIT>"" ) ; } else { includeJRE = forceIncludeRubyVMLibraries ( limitTo ) ; } return new SearchPatternData ( searchFor , limitTo , pattern , isCaseSensitive , elem , scope , workingSets , includeJRE ) ; } catch ( NumberFormatException e ) { return null ; } } } public static final String PARTICIPANT_EXTENSION_POINT = ""<STR_LIT>"" ; public static final String EXTENSION_POINT_ID = ""<STR_LIT>"" ; private static final int HISTORY_SIZE = <NUM_LIT:12> ; private final static String PAGE_NAME = ""<STR_LIT>"" ; private final static String STORE_CASE_SENSITIVE = ""<STR_LIT>"" ; private final static String STORE_HISTORY = ""<STR_LIT>"" ; private final static String STORE_HISTORY_SIZE = ""<STR_LIT>"" ; private final List fPreviousSearchPatterns ; private SearchPatternData fInitialData ; private IRubyElement fRubyElement ; private boolean fFirstTime = true ; private IDialogSettings fDialogSettings ; private boolean fIsCaseSensitive ; private Combo fPattern ; private ISearchPageContainer fContainer ; private Button fCaseSensitive ; private Button [ ] fSearchFor ; private String [ ] fSearchForText = { SearchMessages . SearchPage_searchFor_type , SearchMessages . SearchPage_searchFor_method , SearchMessages . SearchPage_searchFor_constructor , SearchMessages . SearchPage_searchFor_field } ; private Button [ ] fLimitTo ; private String [ ] fLimitToText = { SearchMessages . SearchPage_limitTo_declarations , SearchMessages . SearchPage_limitTo_references , SearchMessages . SearchPage_limitTo_allOccurrences , SearchMessages . SearchPage_limitTo_readReferences , SearchMessages . SearchPage_limitTo_writeReferences } ; private Button fIncludeRubyVMLibrariesCheckbox ; public RubySearchPage ( ) { fPreviousSearchPatterns = new ArrayList ( ) ; } public boolean performAction ( ) { return performNewSearch ( ) ; } private boolean performNewSearch ( ) { SearchPatternData data = getPatternData ( ) ; IRubySearchScope scope = null ; String scopeDescription = ""<STR_LIT>"" ; boolean includeRubyVMLibraries = data . includesRubyVMLibraries ( ) ; RubySearchScopeFactory factory = RubySearchScopeFactory . getInstance ( ) ; switch ( getContainer ( ) . getSelectedScope ( ) ) { case ISearchPageContainer . WORKSPACE_SCOPE : scopeDescription = factory . getWorkspaceScopeDescription ( includeRubyVMLibraries ) ; scope = factory . createWorkspaceScope ( includeRubyVMLibraries ) ; break ; case ISearchPageContainer . SELECTION_SCOPE : IRubyElement [ ] javaElements = factory . getRubyElements ( getContainer ( ) . getSelection ( ) ) ; scope = factory . createRubySearchScope ( javaElements , includeRubyVMLibraries ) ; scopeDescription = factory . getSelectionScopeDescription ( javaElements , includeRubyVMLibraries ) ; break ; case ISearchPageContainer . SELECTED_PROJECTS_SCOPE : { String [ ] projectNames = getContainer ( ) . getSelectedProjectNames ( ) ; scope = factory . createRubyProjectSearchScope ( projectNames , includeRubyVMLibraries ) ; scopeDescription = factory . getProjectScopeDescription ( projectNames , includeRubyVMLibraries ) ; break ; } case ISearchPageContainer . WORKING_SET_SCOPE : { IWorkingSet [ ] workingSets = getContainer ( ) . getSelectedWorkingSets ( ) ; if ( workingSets == null || workingSets . length < <NUM_LIT:1> ) return false ; scopeDescription = factory . getWorkingSetScopeDescription ( workingSets , includeRubyVMLibraries ) ; scope = factory . createRubySearchScope ( workingSets , includeRubyVMLibraries ) ; SearchUtil . updateLRUWorkingSets ( workingSets ) ; } } QuerySpecification querySpec = null ; if ( data . getRubyElement ( ) != null && getPattern ( ) . equals ( fInitialData . getPattern ( ) ) ) { querySpec = new ElementQuerySpecification ( data . getRubyElement ( ) , data . getLimitTo ( ) , scope , scopeDescription ) ; } else { querySpec = new PatternQuerySpecification ( data . getPattern ( ) , data . getSearchFor ( ) , data . isCaseSensitive ( ) , data . getLimitTo ( ) , scope , scopeDescription ) ; data . setRubyElement ( null ) ; } RubySearchQuery textSearchJob = new RubySearchQuery ( querySpec ) ; NewSearchUI . runQueryInBackground ( textSearchJob ) ; return true ; } private int getLimitTo ( ) { for ( int i = <NUM_LIT:0> ; i < fLimitTo . length ; i ++ ) { if ( fLimitTo [ i ] . getSelection ( ) ) return i ; } return - <NUM_LIT:1> ; } private void setLimitTo ( int searchFor , int limitTo ) { if ( ! ( searchFor == FIELD ) && ( limitTo == READ_ACCESSES || limitTo == WRITE_ACCESSES ) ) { limitTo = REFERENCES ; } for ( int i = <NUM_LIT:0> ; i < fLimitTo . length ; i ++ ) { fLimitTo [ i ] . setSelection ( limitTo == i ) ; } fLimitTo [ DECLARATIONS ] . setEnabled ( true ) ; fLimitTo [ REFERENCES ] . setEnabled ( true ) ; fLimitTo [ ALL_OCCURRENCES ] . setEnabled ( true ) ; fLimitTo [ READ_ACCESSES ] . setEnabled ( searchFor == FIELD ) ; fLimitTo [ WRITE_ACCESSES ] . setEnabled ( searchFor == FIELD ) ; } private String [ ] getPreviousSearchPatterns ( ) { int patternCount = fPreviousSearchPatterns . size ( ) ; String [ ] patterns = new String [ patternCount ] ; for ( int i = <NUM_LIT:0> ; i < patternCount ; i ++ ) patterns [ i ] = ( ( SearchPatternData ) fPreviousSearchPatterns . get ( i ) ) . getPattern ( ) ; return patterns ; } private int getSearchFor ( ) { for ( int i = <NUM_LIT:0> ; i < fSearchFor . length ; i ++ ) { if ( fSearchFor [ i ] . getSelection ( ) ) return i ; } Assert . isTrue ( false , ""<STR_LIT>"" ) ; return - <NUM_LIT:1> ; } private String getPattern ( ) { return fPattern . getText ( ) ; } private SearchPatternData findInPrevious ( String pattern ) { for ( Iterator iter = fPreviousSearchPatterns . iterator ( ) ; iter . hasNext ( ) ; ) { SearchPatternData element = ( SearchPatternData ) iter . next ( ) ; if ( pattern . equals ( element . getPattern ( ) ) ) { return element ; } } return null ; } private SearchPatternData getPatternData ( ) { String pattern = getPattern ( ) ; SearchPatternData match = findInPrevious ( pattern ) ; if ( match != null ) { fPreviousSearchPatterns . remove ( match ) ; } match = new SearchPatternData ( getSearchFor ( ) , getLimitTo ( ) , pattern , fCaseSensitive . getSelection ( ) , fRubyElement , getContainer ( ) . getSelectedScope ( ) , getContainer ( ) . getSelectedWorkingSets ( ) , fIncludeRubyVMLibrariesCheckbox . getSelection ( ) ) ; fPreviousSearchPatterns . add ( <NUM_LIT:0> , match ) ; return match ; } public void setVisible ( boolean visible ) { if ( visible && fPattern != null ) { if ( fFirstTime ) { fFirstTime = false ; fPattern . setItems ( getPreviousSearchPatterns ( ) ) ; initSelections ( ) ; } fPattern . setFocus ( ) ; } updateOKStatus ( ) ; super . setVisible ( visible ) ; } public boolean isValid ( ) { return true ; } public void createControl ( Composite parent ) { initializeDialogUnits ( parent ) ; readConfiguration ( ) ; Composite result = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( <NUM_LIT:2> , false ) ; layout . horizontalSpacing = <NUM_LIT:10> ; result . setLayout ( layout ) ; Control expressionComposite = createExpression ( result ) ; expressionComposite . setLayoutData ( new GridData ( GridData . FILL , GridData . CENTER , true , false , <NUM_LIT:2> , <NUM_LIT:1> ) ) ; Label separator = new Label ( result , SWT . NONE ) ; separator . setVisible ( false ) ; GridData data = new GridData ( GridData . FILL , GridData . FILL , false , false , <NUM_LIT:2> , <NUM_LIT:1> ) ; data . heightHint = convertHeightInCharsToPixels ( <NUM_LIT:1> ) / <NUM_LIT:3> ; separator . setLayoutData ( data ) ; Control searchFor = createSearchFor ( result ) ; searchFor . setLayoutData ( new GridData ( GridData . FILL , GridData . FILL , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; Control limitTo = createLimitTo ( result ) ; limitTo . setLayoutData ( new GridData ( GridData . FILL , GridData . FILL , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; fIncludeRubyVMLibrariesCheckbox = new Button ( result , SWT . CHECK ) ; fIncludeRubyVMLibrariesCheckbox . setText ( SearchMessages . SearchPage_searchJRE_label ) ; fIncludeRubyVMLibrariesCheckbox . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , false , false , <NUM_LIT:2> , <NUM_LIT:1> ) ) ; SelectionAdapter rubyElementInitializer = new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent event ) { if ( getSearchFor ( ) == fInitialData . getSearchFor ( ) ) fRubyElement = fInitialData . getRubyElement ( ) ; else fRubyElement = null ; setLimitTo ( getSearchFor ( ) , getLimitTo ( ) ) ; doPatternModified ( ) ; } } ; fSearchFor [ TYPE ] . addSelectionListener ( rubyElementInitializer ) ; fSearchFor [ METHOD ] . addSelectionListener ( rubyElementInitializer ) ; fSearchFor [ FIELD ] . addSelectionListener ( rubyElementInitializer ) ; fSearchFor [ CONSTRUCTOR ] . addSelectionListener ( rubyElementInitializer ) ; setControl ( result ) ; Dialog . applyDialogFont ( result ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( result , IRubyHelpContextIds . RUBY_SEARCH_PAGE ) ; } private Control createExpression ( Composite parent ) { Composite result = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( <NUM_LIT:2> , false ) ; layout . marginWidth = <NUM_LIT:0> ; layout . marginHeight = <NUM_LIT:0> ; result . setLayout ( layout ) ; Label label = new Label ( result , SWT . LEFT ) ; label . setText ( SearchMessages . SearchPage_expression_label ) ; label . setLayoutData ( new GridData ( GridData . FILL , GridData . FILL , false , false , <NUM_LIT:2> , <NUM_LIT:1> ) ) ; fPattern = new Combo ( result , SWT . SINGLE | SWT . BORDER ) ; fPattern . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { handlePatternSelected ( ) ; updateOKStatus ( ) ; } } ) ; fPattern . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { doPatternModified ( ) ; updateOKStatus ( ) ; } } ) ; TextFieldNavigationHandler . install ( fPattern ) ; GridData data = new GridData ( GridData . FILL , GridData . FILL , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ; data . widthHint = convertWidthInCharsToPixels ( <NUM_LIT> ) ; fPattern . setLayoutData ( data ) ; fCaseSensitive = new Button ( result , SWT . CHECK ) ; fCaseSensitive . setText ( SearchMessages . SearchPage_expression_caseSensitive ) ; fCaseSensitive . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { fIsCaseSensitive = fCaseSensitive . getSelection ( ) ; } } ) ; fCaseSensitive . setLayoutData ( new GridData ( GridData . FILL , GridData . FILL , false , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; return result ; } final void updateOKStatus ( ) { boolean isValid = isValidSearchPattern ( ) ; getContainer ( ) . setPerformActionEnabled ( isValid ) ; } private boolean isValidSearchPattern ( ) { if ( getPattern ( ) . length ( ) == <NUM_LIT:0> ) { return false ; } if ( fRubyElement != null ) { return true ; } return SearchPattern . createPattern ( getPattern ( ) , getSearchFor ( ) , getLimitTo ( ) , SearchPattern . R_EXACT_MATCH ) != null ; } public void dispose ( ) { writeConfiguration ( ) ; super . dispose ( ) ; } private void doPatternModified ( ) { if ( fInitialData != null && getPattern ( ) . equals ( fInitialData . getPattern ( ) ) && fInitialData . getRubyElement ( ) != null && fInitialData . getSearchFor ( ) == getSearchFor ( ) ) { fCaseSensitive . setEnabled ( false ) ; fCaseSensitive . setSelection ( true ) ; fRubyElement = fInitialData . getRubyElement ( ) ; } else { fCaseSensitive . setEnabled ( true ) ; fCaseSensitive . setSelection ( fIsCaseSensitive ) ; fRubyElement = null ; } } private void handlePatternSelected ( ) { int selectionIndex = fPattern . getSelectionIndex ( ) ; if ( selectionIndex < <NUM_LIT:0> || selectionIndex >= fPreviousSearchPatterns . size ( ) ) return ; SearchPatternData initialData = ( SearchPatternData ) fPreviousSearchPatterns . get ( selectionIndex ) ; setSearchFor ( initialData . getSearchFor ( ) ) ; setLimitTo ( initialData . getSearchFor ( ) , initialData . getLimitTo ( ) ) ; fPattern . setText ( initialData . getPattern ( ) ) ; fIsCaseSensitive = initialData . isCaseSensitive ( ) ; fRubyElement = initialData . getRubyElement ( ) ; fCaseSensitive . setEnabled ( fRubyElement == null ) ; fCaseSensitive . setSelection ( initialData . isCaseSensitive ( ) ) ; if ( initialData . getWorkingSets ( ) != null ) getContainer ( ) . setSelectedWorkingSets ( initialData . getWorkingSets ( ) ) ; else getContainer ( ) . setSelectedScope ( initialData . getScope ( ) ) ; fInitialData = initialData ; } private void setSearchFor ( int searchFor ) { for ( int i = <NUM_LIT:0> ; i < fSearchFor . length ; i ++ ) { fSearchFor [ i ] . setSelection ( searchFor == i ) ; } } private Control createSearchFor ( Composite parent ) { Group result = new Group ( parent , SWT . NONE ) ; result . setText ( SearchMessages . SearchPage_searchFor_label ) ; result . setLayout ( new GridLayout ( <NUM_LIT:2> , true ) ) ; fSearchFor = new Button [ fSearchForText . length ] ; for ( int i = <NUM_LIT:0> ; i < fSearchForText . length ; i ++ ) { Button button = new Button ( result , SWT . RADIO ) ; button . setText ( fSearchForText [ i ] ) ; button . setSelection ( i == TYPE ) ; button . setLayoutData ( new GridData ( ) ) ; fSearchFor [ i ] = button ; } Label filler = new Label ( result , SWT . NONE ) ; filler . setVisible ( false ) ; filler . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , false , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; return result ; } private Control createLimitTo ( Composite parent ) { Group result = new Group ( parent , SWT . NONE ) ; result . setText ( SearchMessages . SearchPage_limitTo_label ) ; result . setLayout ( new GridLayout ( <NUM_LIT:2> , true ) ) ; SelectionAdapter listener = new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { updateUseJRE ( ) ; } } ; fLimitTo = new Button [ fLimitToText . length ] ; for ( int i = <NUM_LIT:0> ; i < fLimitToText . length ; i ++ ) { Button button = new Button ( result , SWT . RADIO ) ; button . setText ( fLimitToText [ i ]'}]",") ; button. setLayoutData ( new GridData ( ) ) ; fLimitTo [ i ] = button ; } Label filler = new Label ( result, SWT. NONE ) ; filler. setVisible ( false ) ; filler. setLayoutData ( new GridData ( SWT. FILL, SWT. FILL, false, false, <NUM_LIT:1>, <NUM_LIT:1> ) ) ; return result ; } private void initSelections ( ) { for ( int i = <NUM_LIT:0> ; i < fSearchFor. length ; i ++ ) { fSearchFor [ i ]. setSelection ( i == TYPE ) ; } for ( int i = <NUM_LIT:0> ; i < fLimitTo. length ; i ++ ) { fLimitTo [ i ]. setSelection ( i == DECLARATIONS ) ; } } private void readConfiguration ( ) { IDialogSettings settings = getDialogSettings ( ) ; fInitialData = SearchPatternData. create ( settings ) ; if ( fInitialData == null ) { fInitialData = new SearchPatternData ( TYPE, DECLARATIONS, ""<STR_LIT>"", true, null, ISearchPageContainer. WORKSPACE",0.0006450983346554391
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . util ; import java . util . concurrent . Exchanger ; import java . util . concurrent . atomic . AtomicInteger ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; public class SimpleThreadManagerTest extends TestCase { private static final Logger logger = Logger . getLogger ( SimpleThreadManagerTest . class ) ; class OurThing implements Runnable { Exchanger < Void > exchanger = new Exchanger < Void > ( ) ; boolean interrupted ; public void meet ( ) throws InterruptedException { exchanger . exchange ( null ) ; } @ Override public void run ( ) { try { meet ('}]",) } catch ( InterruptedException e ) { interrupted = true ; } } } public void testSimpleThreadManager ( ) { OurThing thing = new OurThing ( ) ; thing. run ( ) ; assert ( thing. interrupted ) ; } },7.670152957930652e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . testunit . ui ; import java . text . MessageFormat ; import org . eclipse . osgi . util . NLS ; public class TestUnitMessages { private static final String BUNDLE_NAME = ""<STR_LIT>"" ; private TestUnitMessages ( ) { } public static String LaunchConfigurationTab_RubyEntryPoint_allTestCases ; public static String LaunchConfigurationTab_RubyEntryPoint_classSelectorMessage ; public static String LaunchConfigurationTab_RubyEntryPoint_classLabel ; public static String CompareResultsAction_label ; public static String CompareResultsAction_description ; public static String CompareResultsAction_tooltip ; public static String CopyTrace_action_label ; public static String CopyTraceAction_problem ; public static String CopyTraceAction_clipboard_busy ; public static String CounterPanel_label_runs ; public static String CounterPanel_label_errors ; public static String CounterPanel_label_failures ; public static String FailureRunView_tab_tooltip ; public static String FailureRunView_tab_title ; public static String OpenEditor_action_label ; public static String OpenEditorAction_action_label ; public static String RerunAction_label_debug ; public static String RerunAction_label_run ; public static String TestRunnerViewPart_label_failure ; public static String TestRunnerViewPart_error_cannotrerun ; public static String TestRunnerViewPart_cannotrerun_title ; public static String TestRunnerViewPart_cannotrerurn_message ; public static String TestRunnerViewPart_message_launching ; public static String TestRunnerViewPart_message_stopped ; public static String TestRunnerViewPart_message_terminated ; public static String TestRunnerViewPart_jobName ; public static String TestRunnerViewPart_terminate_title ; public static String TestRunnerViewPart_terminate_message ; public static String TestRunnerViewPart_rerunaction_label ; public static String TestRunnerViewPart_rerunaction_tooltip ; public static String LaunchTestAction_message_selectConfiguration ; public static String LaunchTestAction_message_selectDebugConfiguration ; public static String LaunchTestAction_message_selectRunConfiguration ; public static String Dialog_launchWithoutSelectedInterpreter_title ; public static String Dialog_launchWithoutSelectedInterpreter ; public static String LaunchConfigurationTab_RubyEntryPoint_allTestMethods ; public static String LaunchConfigurationTab_RubyEntryPoint_methodLabel ; public static String JUnitMainTab_tab_label ; public static String ExpandAllAction_text ; public static String ExpandAllAction_tooltip ; public static String HierarchyRunView_tab_tooltip ; public static String HierarchyRunView_tab_title ; public static String ScrollLockAction_action_label ; public static String ScrollLockAction_action_tooltip ; public static String RubyClassSelector_Title ; public static String CounterPanel_runcount ; public static String FailureRunView_labelfmt ; public static String TestRunnerViewPart_message_error ; public static String TestRunnerViewPart_message_failure ; public static String TestRunnerViewPart_message_success ; public static String TestRunnerViewPart_message_finish ; public static String TestRunnerViewPart_message_started ; public static String TestRunnerViewPart_configName ; public static String CompareResultDialog_expectedLabel ; public static String CompareResultDialog_actualLabel ; public static String CompareResultDialog_labelOK ; public static String CompareResultDialog_title ; public static String TestRunnerViewPart_toggle_horizontal_label ; public static String TestRunnerViewPart_toggle_vertical_label ;'}]","public static String message(String key) { return MessageFormat.format(NLS.bind(key, BUNDLE_NAME), key); }",5.604686942022356e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBSequenceCycleDelayExpr extends SVDBExpr { public SVDBExpr fLhs ; public SVDBCycleDelayExpr fDelay ; public SVDBExpr fRhs ; public SVDBSequenceCycleDelayExpr ( ) { super ( SVDBItemType . SequenceCycleDelayExpr ) ; } public void setDelay ( SVDBCycleDelayExpr expr ) { fDelay = expr ; } public SVDBCycleDelayExpr getDelay ( ) { return fDelay ; }'}]",public void setLhs(SVDBExpr expr) { fLhs = expr; },4.1306582896584753e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . processor ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . compiler . operator . OperatorCompilerTestRoot ; import com . asakusafw . compiler . operator . model . MockFoo ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . compiler . operator . model . MockJoined ; import com . asakusafw . utils . graph . Graph ; import com . asakusafw . vocabulary . flow . testing . MockIn ; import com . asakusafw . vocabulary . flow . testing . MockOut ; public class MasterJoinOperatorProcessorTest extends OperatorCompilerTestRoot { @ Test public void simple ( ) { add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new MasterJoinOperatorProcessor ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < MockHoge > a = MockIn . of ( MockHoge . class , ""<STR_LIT:a>"" ) ; MockIn < MockFoo > b = MockIn . of ( MockFoo . class , ""<STR_LIT:b>"" ) ; MockOut < MockJoined > joined = MockOut . of ( MockJoined . class , ""<STR_LIT>"" ) ; MockOut < MockFoo > missed = MockOut . of ( MockFoo . class , ""<STR_LIT>"" ) ; Object masterJoin = invoke ( factory , ""<STR_LIT>"" , a , b ) ; joined . add ( output ( MockJoined . class , masterJoin , ""<STR_LIT>"" ) ) ; missed . add ( output ( MockFoo . class , masterJoin , ""<STR_LIT>"" ) ) ; Graph < String > graph = toGraph ( a , b ) ; assertThat ( graph . getConnected ( ""<STR_LIT:a>"" ) , isJust ( ""<STR_LIT>"" ) ) ; assertThat ( graph . getConnected ( ""<STR_LIT:b>"" ) , isJust ( ""<STR_LIT>"" ) ) ; assertThat ( graph . getConnected ( ""<STR_LIT>"" ) , isJust ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; } @ Test public void selector ( ) { add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new MasterJoinOperatorProcessor ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < MockHoge > a = MockIn . of ( MockHoge . class , ""<STR_LIT:a>"" ) ; MockIn < MockFoo > b = MockIn . of ( MockFoo . class , ""<STR_LIT:b>"" ) ; MockOut < MockJoined > joined = MockOut . of ( MockJoined . class , ""<STR_LIT>"" ) ; MockOut < MockFoo > missed = MockOut . of ( MockFoo . class , ""<STR_LIT>"" ) ;'}]","Object masterJoin = invoke(factory, ""<STR_LIT>"", a, b, ""selector"");",4.97168343965979e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . ui . actions . ActionGroup ; import org . eclipse . ui . texteditor . IUpdate ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; public class RubyActionGroup extends ActionGroup { public static final String MENU_ID = ""<STR_LIT>"" ; public static final String GROUP_GENERATE = ""<STR_LIT>"" ; public static final String GROUP_CODE = ""<STR_LIT>"" ; private static final String GROUP_COMMENT = ""<STR_LIT>"" ; public static final String GROUP_EDIT = ""<STR_LIT>"" ; private RubyEditor fEditor ; private String fGroupName ; public RubyActionGroup ( RubyEditor editor , String groupName ) { fEditor = editor ; fGroupName = groupName ; } public void fillContextMenu ( IMenuManager menu ) { super . fillContextMenu ( menu ) ; String menuText = ""<STR_LIT>"" ; IMenuManager subMenu = new MenuManager ( menuText ,'}]","true, true ); subMenu.add(new Separator()); // add your actions here } }",4.04571127979374e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import org . eclipse . jface . text . IDocument ; public interface IRubyPartitions { public final static String RUBY_PARTITIONING = ""<STR_LIT>"" ; String RUBY_DEFAULT = IDocument . DEFAULT_CONTENT_TYPE ; String RUBY_SINGLE_LINE_COMMENT = ""<STR_LIT>"" ; String RUBY_MULTI_LINE_COMMENT = ""<STR_LIT>"" ;'}]","String RUBY_STRING = ""<STR_LIT>""; String RUBY_HERE_DOCUMENT = ""<STR_LIT>""; String RUBY_HERE_DOCUMENT_QUOTE = ""<STR_LIT>"";",5.8482670694954287e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . test ; import net . bioclipse . managers . business . IBioclipseManager ; import org . junit . BeforeClass ; public class JavaScriptOpentoxManagerPluginTest extends AbstractOpentoxManagerPluginTest { @ BeforeClass public static void setup ( ) { opentox ='}]",new JavaScriptOpentoxManagerPlugin(); } private static IBioclipseManager opentox; },4.203221696060376e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . mcbans . firestar . mcbans . log ; import com . mcbans . firestar . mcbans . BukkitInterface ; import java . io . FileWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class ActionLog { private static String logFile = ""<STR_LIT>"" ; private static BukkitInterface MCBans = null ; private final static DateFormat df = new SimpleDateFormat ( ""<STR_LIT>"" ) ; public ActionLog ( BukkitInterface p , String logfile ) { logFile = logfile ; MCBans = p ; } public void write ( String msg ) { if ( MCBans . Settings . getBoolean ( ""<STR_LIT>"" ) ) { write ( logFile , msg ) ; } } public void write ( Exception e ) { if ( MCBans . Settings . getBoolean ( ""<STR_LIT>""'}]",") { write ( logFile, e. getClass ( ). getName ( ) + "" : "" + e. getMessage ( ) ) ; } } private void write ( String logFile, String msg ) { try { FileWriter writer = new FileWriter ( logFile, true ) ; writer. write ( df. format ( new Date ( ) ) + "" : "" + msg + "" \n "" ) ; writer. close ( ) ; } catch ( Exception e ) { StringWriter sw = new StringWriter ( ) ; e. printStackTrace ( new PrintWriter ( sw ) ) ; System. err. println ( sw. toString ( ) ) ; } }",0.00017952925765344504
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . DataModel ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ Generated ( ""<STR_LIT>"" ) @ DataModel @ TableModel ( name = ""<STR_LIT>"" , columns = { ""<STR_LIT>"" , ""<STR_LIT>"" } , primary = { ""<STR_LIT>"" } ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class ExportTempTest02 implements Writable { @ Property ( name = ""<STR_LIT>"" ) private StringOption textdata1 = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private IntOption intdata1 = new IntOption ( ) ; public Text getTextdata1 ( ) { return this . textdata1 . get ( ) ; } public void setTextdata1 ( Text textdata1 ) { this . textdata1 . modify ( textdata1 ) ; } public String getTextdata1AsString ( ) { return this . textdata1 . getAsString ( ) ; } public void setTextdata1AsString ( String textdata1 ) { this . textdata1 . modify ( textdata1 ) ; } public StringOption getTextdata1Option ( ) { return this . textdata1 ; } public void setTextdata1Option ( StringOption textdata1 ) { this . textdata1 . copyFrom ( textdata1 ) ; } public int getIntdata1 ( ) { return this . intdata1 . get ( ) ; } public void setIntdata1 ( int intdata1 ) { this . intdata1 . modify ( intdata1 ) ; } public IntOption getIntdata1Option ( ) { return this . intdata1 ; } public void setIntdata1Option ( IntOption intdata1 ) { this . intdata1 . copyFrom ( intdata1 ) ; } public void copyFrom ( ExportTempTest02 source ) { this . textdata1 . copyFrom ('}]",source.textdata1); this.intdata1.copyFrom(source.intdata1); } @Override public void write(DataOutput out) throws IOException { this.textdata1.write(out); this.intdata1.write(out); } @Override public void readFields(DataInput in) throws IOException { this.textdata1.readFields(in); this.intdata1.readFields(in); } },0.00012118398188791252
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules . schedules ; import java . text . ParseException ; import junit . framework . TestCase ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . standard . StandardFragmentParser ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . schedules . Interval ; import org . oddjob . schedules . IntervalTo ; import org . oddjob . schedules . Schedule ; import org . oddjob . schedules . ScheduleContext ; import org . oddjob . schedules . ScheduleRoller ; import org . oddjob . schedules . units . DayOfWeek ; public class IntervalScheduleTest extends TestCase { public void testSimple ( ) throws ParseException { IntervalSchedule test = new IntervalSchedule ( ) ; test . setInterval ( ""<STR_LIT>"" ) ; ScheduleRoller roller = new ScheduleRoller ( test ) ; Interval [ ] results = roller . resultsFrom ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; IntervalTo expected ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:0> ] ) ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:1> ] ) ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:2> ] ) ; } public void testSimpleConstrained ( ) throws ParseException { TimeSchedule time = new TimeSchedule ( ) ; time . setFrom ( ""<STR_LIT>"" ) ; IntervalSchedule test = new IntervalSchedule ( ) ; test . setInterval ( ""<STR_LIT>"" ) ; time . setRefinement ( test ) ; ScheduleRoller roller = new ScheduleRoller ( time ) ; Interval [ ] results = roller . resultsFrom ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; IntervalTo expected ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:0> ] ) ; results = roller . resultsFrom ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:0> ] ) ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:1> ] ) ; expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , results [ <NUM_LIT:2> ] ) ; } public void testEvery7HoursOnWednesday ( ) throws ParseException { WeeklySchedule schedule = new WeeklySchedule ( ) ; schedule . setOn ( DayOfWeek . Days . WEDNESDAY ) ; IntervalSchedule test = new IntervalSchedule ( ) ; test . setInterval ( ""<STR_LIT>"" ) ; schedule . setRefinement ( test ) ; ScheduleRoller roller = new ScheduleRoller ( schedule ) ; Interval [ ] results = roller . resultsFrom ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; IntervalTo expected ; expected'}]","= new IntervalTo ( DateHelper. parseDateTime ( ""<STR_LIT>"" ), DateHelper. parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected, results [ <NUM_LIT:0> ] ) ; expected = new IntervalTo ( DateHelper. parseDateTime ( ""<STR_LIT>"" ), DateHelper. parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( expected, results [ <NUM_LIT:1> ] ) ; }",0.00015925153883277545
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . model ; import java . lang . reflect . Method ; import java . text . MessageFormat ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import com . asakusafw . compiler . common . JavaName ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . DataClass ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . compiler . repository . ValueOptionProperty ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . value . ValueOption ; import com . asakusafw . utils . collections . Maps ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . TypeBuilder ; public class DataModelClass implements DataClass { private final ModelFactory factory ; private final Class < ? > type ; private final Map < String , DataClass . Property > properties ; public static DataModelClass create ( FlowCompilingEnvironment environment , Class < ? > type ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( type , ""<STR_LIT:type>"" ) ; Map < String , Property > properties = collectProperties ( environment , type ) ; return new DataModelClass ( environment . getModelFactory ( ) , type , properties ) ; } private static Map < String , DataClass . Property > collectProperties ( FlowCompilingEnvironment environment , Class < ? > aClass ) { assert environment != null ; assert aClass != null ; Map < String , Property > results = Maps . create ( ) ; for ( Method method : aClass . getMethods ( ) ) { String propertyName = toPropertyName ( method ) ; Class < ? > propertyType = method . getReturnType ( ) ; if ( propertyType == ValueOption . class || ValueOption . class . isAssignableFrom ( propertyType ) == false ) { continue ; } @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) Class < ? extends ValueOption < ? > > valueOptionType = ( Class < ? extends ValueOption < ? > > ) propertyType ; results . put ( propertyName , new ValueOptionProperty ( environment . getModelFactory ( ) , propertyName , valueOptionType ) ) ; } return results ; } private static String toPropertyName ( Method method ) { assert method != null ; JavaName name = JavaName . of ( method . getName ( ) ) ; List < String > segments = name . getSegments ( ) ; if ( segments . size ( ) <= <NUM_LIT:2> ) { return null ; } if ( segments . get ( <NUM_LIT:0> ) . equals ( ""<STR_LIT:get>"" ) == false || segments . get ( segments . size ( ) - <NUM_LIT:1> ) . equals ( ""<STR_LIT>"" ) == false ) { return null ; } name . removeLast ( ) ; name . removeFirst ( ) ; return name . toMemberName ( ) ; } protected DataModelClass ( ModelFactory factory , Class < ? > type , Map < String , Property > properties ) { Precondition . checkMustNotBeNull ( factory , ""<STR_LIT>"" ) ; Precondition'}]",".checkMustNotBeNull(type, ""<STR_LIT:type>""); this.factory = factory; this.type = type; this.properties = Collections.unmodifiableMap(properties); } @Override public String toString() { return MessageFormat.format(""<STR_LIT>{0}[{1}]"", type.getName(), properties); } @Override public Class<? extends DataModel> toDataModelClass() { return DataModel.class; } @Override public Class<? extends DataModel> toDataModelClass(Class<? extends DataModel> clazz) { return clazz; } }",0.00017343198303560383
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . stream . file ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; import org . junit . Assume ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . runtime . core . context . RuntimeContext . ExecutionMode ; import com . asakusafw . runtime . core . context . RuntimeContextKeeper ; import com . asakusafw . windgate . core . DriverScript ; import com . asakusafw . windgate . core . GateScript ; import com . asakusafw . windgate . core . ParameterList ; import com . asakusafw . windgate . core . ProcessScript ; import com . asakusafw . windgate . core . resource . DrainDriver ; import com . asakusafw . windgate . core . resource . SourceDriver ; import com . asakusafw . windgate . core . vocabulary . FileProcess ; import com . asakusafw . windgate . core . vocabulary . StreamProcess ; import com . asakusafw . windgate . stream . StringBuilderSupport ; public class FileResourceMirrorTest { @ Rule public final RuntimeContextKeeper rc = new RuntimeContextKeeper ( ) ; @ Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; @ Test public void prepare ( ) throws Exception { FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > a = process ( ""<STR_LIT:a>"" , driver ( ""<STR_LIT:source>"" ) , dummy ( ) ) ; ProcessScript < StringBuilder > b = process ( ""<STR_LIT:b>"" , dummy ( ) , driver ( ""<STR_LIT>"" ) ) ; GateScript gate = script ( a , b ) ; resource . prepare ( gate ) ; } finally { resource . close ( ) ; } } @ Test ( expected = IOException . class ) public void prepare_invalid_variable ( ) throws Exception { FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > a = process ( ""<STR_LIT:a>"" , driver ( ""<STR_LIT>"" ) , dummy ( ) ) ; ProcessScript < StringBuilder > b = process ( ""<STR_LIT:b>"" , dummy ( ) , driver ( ""<STR_LIT>"" ) ) ; GateScript gate = script ( a , b ) ; resource . prepare ( gate ) ; fail ( ) ; } finally { resource . close ( ) ; } } @ Test ( expected = IOException . class ) public void prepare_invalid_source ( ) throws Exception { Map < String , String > conf = new HashMap < String , String > ( ) ; DriverScript driverScript = new DriverScript ( ""<STR_LIT:file>"" , conf ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > a = process ( ""<STR_LIT:a>"" , driverScript , dummy ( ) ) ; ProcessScript < StringBuilder > b = process ( ""<STR_LIT:b>"" , dummy ( ) , driver ( ""<STR_LIT>"" ) ) ; GateScript gate = script ( a , b ) ; resource . prepare ( gate ) ; fail ( ) ; } finally { resource . close ( ) ; } } @ Test ( expected = IOException . class ) public void prepare_invalid_drain ( ) throws Exception { Map < String , String > conf = new HashMap < String , String > ( ) ; DriverScript driverScript = new DriverScript ( ""<STR_LIT:file>"" , conf ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > a = process ( ""<STR_LIT:a>"" , driver ( ""<STR_LIT:source>"" ) , dummy ( ) ) ; ProcessScript < StringBuilder > b = process ( ""<STR_LIT:b>"" , dummy ( ) , driverScript ) ; GateScript gate = script ( a , b ) ; resource . prepare ( gate ) ; fail ( ) ; } finally { resource . close ( ) ; } } @ Test public void source ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; put ( file , ""<STR_LIT>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , driver ( file . getName ( ) ) , dummy ( ) ) ; resource . prepare ( script ( process ) ) ; SourceDriver < StringBuilder > driver = resource . createSource ( process ) ; try { driver . prepare ( ) ; test ( driver , ""<STR_LIT>"" ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test public void source_parameterized ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; put ( file , ""<STR_LIT>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( Collections . singletonMap ( ""<STR_LIT>"" , file . getName ( ) ) ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , driver ( ""<STR_LIT>"" ) , dummy ( ) ) ; resource . prepare ( script ( process ) ) ; SourceDriver < StringBuilder > driver = resource . createSource ( process ) ; try { driver . prepare ( ) ; test ( driver , ""<STR_LIT>"" ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test public void source_multi ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; put ( file , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , driver ( file . getName ( ) ) , dummy ( ) ) ; resource . prepare ( script ( process ) ) ; SourceDriver < StringBuilder > driver = resource . createSource ( process ) ; try { driver . prepare ( ) ; test ( driver , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test ( expected = IOException . class ) public void source_invalid ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; Assume . assumeTrue ( file . delete ( ) ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , driver ( file . getName ( ) ) , dummy ( ) ) ; resource . prepare ( script ( process ) ) ; SourceDriver < StringBuilder > driver = resource . createSource ( process ) ; try { driver . prepare ( ) ; test ( driver , ""<STR_LIT>"" ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test public void source_sim ( ) throws Exception { RuntimeContext . set ( RuntimeContext . DEFAULT . mode ( ExecutionMode . SIMULATION ) ) ; File file = folder . newFile ( ""<STR_LIT:file>"" ) ; file . delete ( ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { assertThat ( RuntimeContext . get ( ) . canExecute ( resource ) , is ( true ) ) ; ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , driver ( file . getName ( ) ) , dummy ( ) ) ; resource . prepare ( script ( process ) ) ; SourceDriver < StringBuilder > driver = resource . createSource ( process ) ; try { assertThat ( RuntimeContext . get ( ) . canExecute ( driver ) , is ( false ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test public void drain ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , dummy ( ) , driver ( file . getName ( ) ) ) ; resource . prepare ( script ( process ) ) ; DrainDriver < StringBuilder > driver = resource . createDrain ( process ) ; try { driver . prepare ( ) ; driver . put ( new StringBuilder ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } test ( file , ""<STR_LIT>"" ) ; } @ Test public void drain_parameterized ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( Collections . singletonMap ( ""<STR_LIT>"" , file . getName ( ) ) ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , dummy ( ) , driver ( ""<STR_LIT>"" ) ) ; resource . prepare ( script ( process ) ) ; DrainDriver < StringBuilder > driver = resource . createDrain ( process ) ; try { driver . prepare ( ) ; driver . put ( new StringBuilder ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } test ( file , ""<STR_LIT>"" ) ; } @ Test public void drain_create_parent ( ) throws Exception { File parent = folder . newFolder ( ""<STR_LIT>"" ) ; Assume . assumeTrue ( parent . delete ( ) ) ; File file = new File ( parent , ""<STR_LIT:file>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>"" , dummy ( ) , driver ( ""<STR_LIT>"" ) ) ; resource . prepare ( script ( process ) ) ; DrainDriver < StringBuilder > driver = resource . createDrain ( process ) ; try { driver . prepare ( ) ; driver . put ( new StringBuilder ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } test ( file , ""<STR_LIT>"" ) ; } @ Test public void drain_multi ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT:file>"" ) ; FileResourceMirror resource = new FileResourceMirror ( profile ( ) , new ParameterList ( ) ) ; try { ProcessScript < StringBuilder > process = process ( ""<STR_LIT:a>""'}]",", dummy(), driver(file.getName())); resource.prepare(script(process)); DrainDriver<StringBuilder> driver = resource.createDrain(process); try { driver.prepare(); driver.put(new StringBuilder(""<STR_LIT>"")); driver.put(new StringBuilder(""<STR_LIT>"")); } finally { driver.close(); } } finally { resource.close(); } test(file, ""<STR_LIT>"", ""<STR_LIT>""); } @Test public void drain_invalid ( ) throws Exception { File file = folder.newFile(""<STR_LIT:file>""); FileResourceMirror resource = new FileResourceMirror(profile(), new ParameterList()); try { ProcessScript<StringBuilder> process = process(""<STR_LIT:a>"", dummy(), driver(file.getName())); resource.prepare(script(process)); DrainDriver<StringBuilder> driver = resource.createDrain(process); try { driver.prepare(); fail(); } finally { driver.close(); } } finally { resource.close(); } } @Test public void drain_sim ( ) throws Exception { RuntimeContext.set(RuntimeContext.DEFAULT.mode(ExecutionMode.SIMULATION)); File file = folder.newFile(""<STR_LIT:file>""); FileResourceMirror resource = new FileResourceMirror(profile(), new ParameterList()); try { assertThat(RuntimeContext.get().canExecute(resource), is(true)); ProcessScript<StringBuilder> process =",0.00046563626473813247
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . parser ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBScopeItem ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . db . SVDBUtil ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclItem ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclStmt ; import net . sf . sveditor . core . parser . ParserSVDBFileFactory ; import net . sf . sveditor . core . parser . SVParseException ; public class TestParseFunction extends TestCase { private SVDBTask parse_tf ( String content , String name ) throws SVParseException { SVDBScopeItem scope = new SVDBScopeItem ( ) ; ParserSVDBFileFactory parser = new ParserSVDBFileFactory ( null ) ; parser . init ( new StringInputStream ( content ) , name ) ; parser . parsers ( ) . taskFuncParser ( ) . parse ( scope , null , <NUM_LIT:0> ) ; return ( SVDBTask ) scope . getChildren ( ) . iterator ( ) . next ( ) ; } private SVDBClassDecl parse_class ( String content , String name ) throws SVParseException { SVDBScopeItem scope = new SVDBScopeItem ( ) ; ParserSVDBFileFactory parser = new ParserSVDBFileFactory ( null ) ; parser . init ( new StringInputStream ( content ) , name ) ; parser . parsers ( ) . classParser ( ) . parse ( scope , <NUM_LIT:0> ) ; return ( SVDBClassDecl ) scope . getChildren ( ) . iterator ( ) . next ( ) ; } public void testBasicFunction ( ) throws SVParseException { String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; parse_tf ( content , ""<STR_LIT>"" ) ; } public void testReturnOnlyFunction ( ) throws SVParseException { String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; parse_class ( content , ""<STR_LIT>"" ) ; } public void testKRParameters ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; parse_tf ( content , testname ) ; } public void testKRParameters2 ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ;'}]","String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""; parse_tf(content, testname); } public void testKRParameters3() throws SVParseException { String testname = ""<STR_LIT>""; SVCorePlugin.getDefault().enableDebug(false); String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""; parse_tf(content, testname); } public void testKRParameters4() throws SVParseException { String testname = ""<STR_LIT>""; SVCorePlugin.getDefault().enableDebug(false); String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""; parse_tf(content, testname); }",0.00033916371719029274
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . ui . wizards . NewFileWizardPage ; public class NewFileCreationWizard extends NewElementWizard { private NewFileWizardPage fPage ; public NewFileCreationWizard ( NewFileWizardPage'}]","page ) { this. fPage = page ; } @Override public void addPages ( ) { super. addPages ( ) ; if ( getController ( )!= null ) { getController ( ). createNewFilePage ( this, fPage ) ; } } @Override public boolean performFinish ( ) { IFile file = fPage. getNewFile ( ) ; if ( file!= null ) { try { file. create ( getShell ( ), getController ( ), fPage. getOverwrite ( ), fPage. getContents ( ), fPage. getCharset ( ), fPage. getEncoding ( ), fPage. getEOL ( ), fPage. getPermissions ( ), fPage. getAccessControl ( ), fPage. getModificationStamp ( ), fPage. getLocalTimeStamp ( ), fPage. getLocalTimeStamp ( ), null ) ; } catch ( CoreException e ) { getController ( ). handleError ( e ) ; return false ; } } return true ; }",0.000284131223316681
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . action ; import org . rubypeople'}]",.rdt.refactoring.api.RefactoringAction; import org.rubypeople.rdt.refactoring.api.RefactoringContext; import org.rubypeople.rdt.refactoring.api.RefactoringParticipant; public class RenameMethodAction extends RefactoringAction { @Override public void execute ( RefactoringContext context ) { RefactoringParticipant participant = context. getParticipant ( ) ; //... } },0.00011072222508925545
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . nodewrapper ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static'}]",final Messages bundle = new Messages ( ) ; public static String NodeWrapperDescription ; public static String NodeWrapperName ; public static String NodeWrapperEditor ; public static String NodeWrapperEditorDescription ; public static String NodeWrapperEditorName ; public static String NodeWrapperEditorOutput ; public static String NodeWrapperEditorOutputDescription ; public static String NodeWrapperEditorOutputName ; public static String NodeWrapperEditorOutputType ; public static String NodeWrapperEditorOutputTypeDescription ; public static String NodeWrapperEditorOutputTypeName ; },0.00013984174660942726
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . stage ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import org . apache . hadoop . mapreduce . TaskInputOutputContext ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . NameGenerator ; import com . asakusafw . compiler . common . Naming ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . compiler . flow . FlowElementProcessor ; import com . asakusafw . compiler . flow . LinePartProcessor ; import com . asakusafw . compiler . flow . LinePartProcessor . Context ; import com . asakusafw . compiler . flow . plan . StageBlock ; import com . asakusafw . compiler . flow . stage . ShuffleModel . Segment ; import com . asakusafw . runtime . core . Result ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . Comment ; import com . asakusafw . utils . java . model . syntax . CompilationUnit ; import com . asakusafw . utils . java . model . syntax . ConstructorDeclaration ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . FieldDeclaration ; import com . asakusafw . utils . java . model . syntax . Javadoc ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . TypeBodyDeclaration ; import com . asakusafw . utils . java . model . syntax . TypeDeclaration ; import com . asakusafw . utils . java . model . syntax . TypeParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . WildcardBoundKind ; import com . asakusafw . utils . java . model . util . AttributeBuilder ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . ImportBuilder ; import com . asakusafw . utils . java . model . util . JavadocBuilder ; import com . asakusafw . utils . java . model . util . Models ; import com . asakusafw . utils . java . model . util . TypeBuilder ; import com . asakusafw . vocabulary . flow . graph . FlowResourceDescription ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription ; import com . asakusafw . vocabulary . operator . Identity ; public class ShuffleFragmentEmitter { static final Logger LOG = LoggerFactory . getLogger ( ShuffleFragmentEmitter . class ) ; private final FlowCompilingEnvironment environment ; public ShuffleFragmentEmitter ( FlowCompilingEnvironment environment ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; this . environment = environment ; } public CompiledShuffleFragment emit ( ShuffleModel . Segment segment , Name keyTypeName , Name valueTypeName , StageBlock stageBlock ) throws IOException { Precondition . checkMustNotBeNull ( segment , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( stageBlock , ""<STR_LIT>"" ) ; LOG . debug ( ""<STR_LIT>"" , segment ) ; CompiledType mapOut = emitMapOutput ( segment , keyTypeName , valueTypeName , stageBlock ) ; CompiledType combineOut = emitCombineOutput ( segment , keyTypeName , valueTypeName , stageBlock ) ; LOG . debug ( ""<STR_LIT>"" , new Object [ ] { segment , mapOut . getQualifiedName ( ) . toNameString ( ) , combineOut . getQualifiedName ( ) . toNameString ( ) , } ) ; return new CompiledShuffleFragment ( mapOut , combineOut ) ; } private CompiledType emitMapOutput ( ShuffleModel . Segment segment , Name keyTypeName , Name valueTypeName , StageBlock stageBlock ) throws IOException { assert segment != null ; assert keyTypeName != null ; assert valueTypeName != null ; assert stageBlock != null ; Engine engine = new MapOutputEngine ( environment , stageBlock , segment , keyTypeName , valueTypeName ) ; return generate ( segment , engine ) ; } private CompiledType emitCombineOutput ( ShuffleModel . Segment segment , Name keyTypeName , Name valueTypeName , StageBlock stageBlock ) throws IOException { assert segment != null ; assert keyTypeName != null ; assert valueTypeName != null ;'}]","assert stageBlock!= null; Engine engine = new CombineOutputEngine(environment, stageBlock, segment, keyTypeName, valueTypeName); return generate(segment, engine); } private CompiledType generate(ShuffleModel.Segment segment, Engine engine) throws IOException { Precondition.checkMustNotBeNull(segment, ""<STR_LIT>""); Precondition.checkMustNotBeNull(engine, ""<STR_LIT>""); return engine.generate(segment); } }",0.00015263177755356613
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver ; import java . io . File ; import com . asakusafw . compiler . flow . FlowCompilerOptions ; public abstract class TestDriverBase { protected TestDriverContext driverContext ; public TestDriverBase ( Class < ? > callerClass ) { if ( callerClass == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . driverContext = new TestDriverContext ( callerClass ) ; } public void configure ( String key , String value ) { if ( key == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( value != null ) { driverContext . getExtraConfigurations ( ) . put ( key , value ) ; } else { driverContext . getExtraConfigurations ( ) . remove ( key ) ; } } public void setBatchArg ( String key , String value ) { if ( key == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( value != null ) { driverContext . getBatchArgs ( ) . put ( key , value ) ; } else { driverContext . getBatchArgs ( ) . remove ( key ) ; } } public void setOptimize ( int level ) { FlowCompilerOptions options = driverContext . getOptions ( ) ; if ( level <= <NUM_LIT:0> ) { options . setCompressConcurrentStage ( false ) ; options . setCompressFlowPart ( false ) ; options . setHashJoinForSmall ( false ) ; options . setHashJoinForTiny ( false ) ; options . setEnableCombiner ( false ) ; } else if ( level == <NUM_LIT:1> ) { options . setCompressConcurrentStage ( FlowCompilerOptions . Item . compressConcurrentStage . defaultValue ) ; options . setCompressFlowPart ( FlowCompilerOptions . Item . compressFlowPart . defaultValue ) ; options . setHashJoinForSmall ( FlowCompilerOptions . Item . hashJoinForSmall . defaultValue ) ; options . setHashJoinForTiny ( FlowCompilerOptions . Item . hashJoinForTiny . defaultValue ) ; options . setEnableCombiner ( FlowCompilerOptions . Item . enableCombiner . defaultValue ) ; } else { options . setCompressConcurrentStage ( true ) ; options . setCompressFlowPart ( true ) ; options . setHashJoinForSmall ( true ) ; options . setHashJoinForTiny ( true ) ; options . setEnableCombiner'}]",(true); } } public void setVerbose ( boolean verbose ) { driverContext.setVerbose(verbose); },5.1250230961949746e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . windgate ; import com . asakusafw . vocabulary . windgate . WindGateExporterDescription ; import com . asakusafw . vocabulary . windgate . WindGateImporterDescription ; import com . asakusafw . windgate . core . DriverScript ; public class MockExporterDescription extends WindGateExporterDescription { private final Class < ? > modelType ; private final String profileName ; private final DriverScript driverScript ; MockExporterDescription ( Class < ? > modelType , String profileName'}]",", DriverScript driverScript ) { this.modelType = modelType; this.profileName = profileName; this.driverScript = driverScript; } @Override public Class<?> getModelType() { return modelType; } @Override public String getProfileName() { return profileName; } @Override public DriverScript getDriverScript() { return driverScript; } }",0.00010745392741810983
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . refactoring ; import org . eclipse . core . runtime . IAdapterFactory ; import org . eclipse . ltk . core . refactoring . TextEditBasedChange ; import org'}]",.eclipse.ui.views.contentassist proposals.IContentAssistProposal;,3.1861893436518546e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . semantics . trait ; import com . asakusafw . dmdl . model . AstNode ; import com . asakusafw . dmdl . semantics . Element ; import com . asakusafw . dmdl . semantics . PropertyMappingKind ; import com . asakusafw . dmdl . semantics . PropertySymbol ; public class MappingFactor implements Element { private final AstNode mapping ; private final PropertyMappingKind kind ; private final PropertySymbol source ; private final PropertySymbol target ; public MappingFactor ( AstNode originalAst , PropertyMappingKind kind , PropertySymbol source , PropertySymbol target ) { if ( kind == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( source == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( target == null ) { throw new IllegalArgumentException ( ""<STR_LIT>""'}]",> ); this.mapping = originalAst; this.kind = kind; this.source = source; this.target = target; } public PropertyMappingKind getKind() { return kind; } public PropertySymbol getSource() { return source; } public PropertySymbol getTarget() { return target; } public AstNode getOriginalAst() { return mapping; } },0.00010462090997412822
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . callhierarchy ; import java . util . ArrayList ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . jface . action . IMenuListener ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . viewers . ArrayContentProvider ; import org . eclipse . jface . viewers . ColumnLayoutData ; import org . eclipse . jface . viewers . ColumnPixelData ; import org . eclipse . jface . viewers . ColumnWeightData ; import org . eclipse . jface . viewers . TableLayout ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . ui . IWorkbenchPartSite ; class LocationViewer extends TableViewer { private final String columnHeaders [ ] = { CallHierarchyMessages . LocationViewer_ColumnIcon_header , CallHierarchyMessages . LocationViewer_ColumnLine_header , CallHierarchyMessages . LocationViewer_ColumnInfo_header } ; private ColumnLayoutData columnLayouts [ ] = { new ColumnPixelData ( <NUM_LIT> , false , true ) , new ColumnWeightData ( <NUM_LIT> ) , new ColumnWeightData ( <NUM_LIT> ) } ; LocationViewer'}]","(Composite parent, IWorkbenchPartSite site) { super(new Table(parent)); Table table = getTable(); TableViewerColumn column = new TableViewerColumn(table, SWT.NONE); column.getColumn().setWidth(<NUM_LIT>); column.getColumn().setResizable(false); column.getColumn().setMoveable(false); column.setLabelProvider(new LocationLabelProvider()); column.setEditingSupportProvider(new LocationEditingSupportProvider()); ColumnLayoutData[] columnLayouts = { new ColumnPixelData(<NUM_LIT>, false, true), new ColumnWeightData(<NUM_LIT>), new ColumnWeightData(<NUM_LIT>) }; table.setLayout(new TableLayout(columnLayouts)); }",0.00019146254953940776
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . refactoring . nls . changes ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . ltk . core . refactoring . Change ; import org . eclipse . ltk . core . refactoring . RefactoringStatus ; import org . rubypeople . rdt . core . IRubyModelStatusConstants ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . refactoring . base . RDTChange ; import org . rubypeople . rdt . internal . corext . util . IOCloser ; import org . rubypeople . rdt . refactoring . core . Messages ; public class DeleteFileChange extends RDTChange { private IPath fPath ; private String fSource ; public DeleteFileChange ( IFile file ) { Assert . isNotNull ( file , ""<STR_LIT:file>"" ) ; fPath = file . getFullPath ( ) . removeFirstSegments ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFullPath ( ) . segmentCount ( ) ) ; } public RefactoringStatus isValid ( IProgressMonitor pm ) throws CoreException { return isValid ( pm , READ_ONLY | DIRTY ) ; }'}]","public boolean isValid ( IProgressMonitor pm, int flags ) throws CoreException {",4.317556920614572e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . flow ; import com . asakusafw . compiler . flow . processor . RestructureFlowProcessor ; import com . asakusafw . compiler . flow . testing . external . Ex1MockExporterDescription ; import com . asakusafw . compiler . flow . testing . external . Part1MockImporterDescription ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Part1 ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory . Restructure ; @ JobFlow ( name = ""<STR_LIT>"" ) public class RestructureFlowExtend extends FlowDescription { private final In < Part1 > in ; private final Out <'}]","Ex1> out; public RestructureFlowExtend() { in = CoreOperatorFactory.create().in(Ex1MockExporterDescription.class); out = CoreOperatorFactory.create().out(Ex1.class); } @Override public Import<Ex1> getExported() { return in; } @Override public Export<Ex1> getImported() { return out; } @Override public Restructure<Ex1, Part1> getRestructure() { return new Restructure<Ex1, Part1>() { @Override public Ex1 restructure(Part1 part1) { // implementation here return null; } }; } }",0.0001878766217058832
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package og . android . tether ; import com . google . analytics . tracking . android . TrackedActivity ; import android . R . drawable ; import android . app . Activity ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . preference . PreferenceManager ; import android . util . Log ; import android . view . View ; import android . view . View . OnClickListener ; import android . view . View . OnFocusChangeListener ; import android . view . ViewGroup ; import android . view . inputmethod . InputMethodManager ; import android . widget . Button ; import android . widget . CheckBox ; import android . widget . EditText ; import og . android . tether . OnPostCompleteListener ; public class PostActivity extends TrackedActivity { private static final String TAG = ""<STR_LIT>"" ; private SharedPreferences mPrefs ; private SharedPreferences . Editor mPrefsEdit ; private InputMethodManager mInputManager ; private EditText mPostEditor ; private Button mPostButton ; private CheckBox mCheckFacebook ; private Bundle mParams = null ; @ Override public void onCreate ( Bundle savedInstanceState ) { Log . d ( TAG , ""<STR_LIT>"" ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . postview ) ; mInputManager = ( InputMethodManager ) getSystemService ( Context . INPUT_METHOD_SERVICE ) ; mPrefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; mPrefsEdit = mPrefs . edit ( ) ; mCheckFacebook = ( CheckBox ) findViewById ( R . id . facebookCheck ) ; mCheckFacebook . setChecked ( mPrefs . getBoolean ( ""<STR_LIT>"" , false ) ) ; mPostButton = ( Button ) findViewById ( R . id . postButton ) ; mPostButton . setOnClickListener ( new OnClickListener ( ) { public void onClick ( View view ) { Log . d ( TAG , ""<STR_LIT>"" + view ) ; mInputManager . toggleSoftInput ( <NUM_LIT:0> , <NUM_LIT:0> ) ; if ( mCheckFacebook . isChecked ( ) ) { mPrefsEdit . putBoolean ( ""<STR_LIT>"" , true ) . commit ( ) ; mParams . putString ( ""<STR_LIT:message>"" , mPostEditor . getText ( ) . toString ( ) ) ; postToFacebook ( mParams ) ; } else { mPrefsEdit . putBoolean ( ""<STR_LIT>"" , false ) . commit ( ) ; finish ( ) ; } } } ) ; mPostEditor = ( EditText ) findViewById ( R . id . postEditor ) ; Log . d ( TAG , ""<STR_LIT>"" + getIntent ( ) ) ; if ( getIntent ('}]","().hasExtra(""<STR_LIT:message>"")) { mPostEditor.setText(getIntent().getStringExtra(""<STR_LIT:message>"")); mPostEditor.setSelection(mPostEditor.length()); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == <NUM_LIT:0> && resultCode == Activity.RESULT_OK) { OnPostCompleteListener listener = (OnPostCompleteListener) data.getParcelableExtra(""<STR_LIT:listener>""); if (listener!= null) { listener.onPostComplete(); } } } @Override public void onFocusChange(View view, boolean hasFocus) { if (hasFocus) { InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT); } } }",0.00024358890450778875
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package edsdk ; import com . sun . jna . NativeLong ; import com . sun . jna . Structure ; public class EdsTime extends Structure { public NativeLong year ; public NativeLong month ; public NativeLong day ; public NativeLong hour ; public NativeLong minute ; public NativeLong second ; public NativeLong milliseconds ; public EdsTime ( ) { super ( ) ; initFieldOrder ( ) ; } protected void initFieldOrder ( ) { setFieldOrder ( new java . lang . String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ,'}]","""<STR_LIT>"", ""<STR_LIT>"" } ) ; } }",3.779830169756479e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; public class OrStateOp implements StateOperator { @ Override public ParentState evaluate ( State ... states ) { new AssertNonDestroyed ( ) . evaluate ( states ) ; ParentState state = ParentState . READY ; for ( int i = <NUM_LIT:0> ; i < states . length ; ++ i ) { State next = states [ i ] ; if ( state . isStoppable ( ) || next . isStoppable ( ) ) { state = ParentState . ACTIVE ; } else if ( state . isException ( ) || next . isException ( ) ) { state = ParentState . EXCEPTION ; } else if ( state . isComplete ( ) || next'}]",. isComplete ( ) ) { state = ParentState. COMPLETE ; } else { state = ParentState. READY ; } } return state ; } },5.53316312762401e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . actions ; import net . ggtools . grand . ui . graph . GraphControlerProvider ; import net . ggtools . grand . ui . widgets . PropertyEditionDialog ; import org . apache . commons'}]",".lang3. Action; 

public class EditPropertyAction extends AbstractAction { 
    private final GraphControlerProvider provider; 
    private final PropertyEditionDialog dialog; 

    public EditPropertyAction(GraphControlerProvider provider, PropertyEditionDialog dialog) { 
        super(""Edit Property""); 
        this.provider = provider; 
        this.dialog = dialog; 
    } 

    @Override 
    public void actionPerformed(ActionEvent e) { 
        dialog.setGraph(provider.getGraph()); 
        dialog.setVisible(true); 
    } 
}",0.00014937854286846769
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . expr . SVDBExpr ; public class SVDBConfigInstClauseStmt extends SVDBConfigRuleStmtBase { public SVDBExpr fInstName ; public SVDBConfigInstClauseStmt ( ) {'}]",super();,1.9460309408825302e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . checker ; import java . util . List ; import com . pogofish . jadt . ast . Doc ;'}]",public class Checker { public static void check(List<Doc> docs) { // implementation } },3.9610271842174424e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . operator ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com .'}]",.asakusafw.vocabulary.operator.annotation.Operator;,3.116723594925692e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . printer ; import static com . pogofish . jadt . errors . SemanticError . _ConstructorDataTypeConflict ; import static com . pogofish . jadt . errors . SemanticError . _DuplicateArgName ; import static com . pogofish . jadt . errors . SemanticError . _DuplicateConstructor ; import static com . pogofish . jadt . errors . SemanticError . _DuplicateDataType ; import static com . pogofish . jadt . errors . SemanticError . _DuplicateModifier ; import static com . pogofish . jadt . errors . SyntaxError . _UnexpectedToken ; import static com . pogofish . jadt . errors . UserError . _Semantic ; import static com . pogofish . jadt . errors . UserError . _Syntactic ; import static com . pogofish . jadt . printer . UserErrorPrinter . print ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert .'}]","assertThat; import com.pogofish.jadt.errors.SemanticError; import com.pogofish.jadt.errors.SyntaxError; import com.pogofish.jadt.errors.UserError; import com.pogofish.jadt.parser.Parser; import com.pogofish.jadt.parser.Token; import com.pogofish.jadt.printer.UserErrorPrinter; import org.junit.Test; public class PrinterTest { @Test public void testPrintSemanticError() { SemanticError error = new SemanticError(_DuplicateArgName, ""arg"", ""arg"", ""arg""); print(error); } @Test public void testPrintSyntaxError() { SyntaxError error = new SyntaxError(_UnexpectedToken, new Token(""Unexpected token"")); print(error); } @Test public void testPrintUserError() { UserError error = new UserError(_Semantic, ""This is a semantic error""); print(error); } }",0.0002505416495961655
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicReference ; import org . apache . commons . beanutils . DynaBean ; import org . oddjob . FailedToStopException ; import org . oddjob . Forceable ; import org . oddjob . Resetable ; import org . oddjob . Stoppable ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . life . ComponentPersistException ; import org . oddjob . images . StateIcons ; import org . oddjob . persist . Persistable ; import org . oddjob . state . IsAnyState ; import org . oddjob . state . IsExecutable ; import org . oddjob . state . IsHardResetable ; import org . oddjob . state . IsSoftResetable ; import org . oddjob . state . IsStoppable ; import org . oddjob . state . JobState ; import org . oddjob . state . JobStateChanger ; import org . oddjob . state . JobStateHandler ; import org . oddjob . state . StateEvent ; public class RunnableWrapper extends BaseWrapper implements ComponentWrapper , Serializable , Forceable { private static final long serialVersionUID = <NUM_LIT> ; private transient JobStateHandler stateHandler ; private transient JobStateChanger stateChanger ; private Object wrapped ; private transient DynaBean dynaBean ; private volatile transient Thread thread ; private final Object proxy ; private transient Resetable resetableAdaptor ; public RunnableWrapper ( Object wrapped , Object proxy ) { this . wrapped = wrapped ; this . proxy = proxy ; completeConstruction ( ) ; } private void completeConstruction ( ) { this . dynaBean = new WrapDynaBean ( wrapped ) ; stateHandler = new JobStateHandler ( this ) ; stateChanger = new JobStateChanger ( stateHandler , iconHelper , new Persistable ( ) { @ Override public void persist ( ) throws ComponentPersistException { save ( ) ; } } ) ; } @ Override public void setArooaSession ( ArooaSession session ) { super . setArooaSession ( session ) ; resetableAdaptor = new ResetableAdaptorFactory ( ) . resetableFor ( wrapped , session ) ; } @ Override protected JobStateHandler stateHandler ( ) { return stateHandler ; } protected JobStateChanger getStateChanger ( ) { return stateChanger ; } public Object getWrapped ( ) { return wrapped ; } protected DynaBean getDynaBean ( ) { return dynaBean ; } protected Object getProxy ( ) { return proxy ; } @ Override public void run ( ) { ComponentBoundry . push ( loggerName ( ) , wrapped ) ; try {'}]","wrapped.run(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void reset() { ComponentBoundry.push(loggerName(), wrapped); try { resetableAdaptor.reset(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void force() { ComponentBoundry.push(loggerName(), wrapped); try { resetableAdaptor.force(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void stop() { ComponentBoundry.push(loggerName(), wrapped); try { stateHandler.stop(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void hardReset() { ComponentBoundry.push(loggerName(), wrapped); try { stateHandler.hardReset(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void softReset() { ComponentBoundry.push(loggerName(), wrapped); try { stateHandler.softReset(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void save() { ComponentBoundry.push(loggerName(), wrapped); try { stateChanger.save(); } finally { ComponentBoundry.pop(loggerName(), wrapped); } } @Override public void saveAndStop() { ComponentBoundry.push",0.00036069349093530227
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . stage ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . Compilable ; import com . asakusafw . compiler . flow . FlowElementProcessor ; import com . asakusafw . compiler . flow . FlowElementProcessor . Kind ; import com . asakusafw . compiler . flow . RendezvousProcessor ; import com . asakusafw . compiler . flow . plan . FlowBlock ; import com . asakusafw . compiler . flow . plan . StageBlock ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . vocabulary . flow . graph . FlowElement ; import com . asakusafw . vocabulary . flow . graph . FlowElementInput ; import com . asakusafw . vocabulary . flow . graph . FlowElementOutput ; import com . asakusafw . vocabulary . flow . graph . FlowResourceDescription ; import com . asakusafw . vocabulary . flow . graph . InputDescription ; public class StageModel { private final StageBlock stageBlock ; private final List < MapUnit > mapUnits ; private final ShuffleModel shuffleModel ; private final List < ReduceUnit > reduceUnits ; private final List < Sink > sinks ; public StageModel ( StageBlock stageBlock , List < MapUnit > mapUnits , ShuffleModel shuffleModel , List < ReduceUnit > reduceUnits , List < Sink > sinks ) { Precondition . checkMustNotBeNull ( stageBlock , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( mapUnits , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( reduceUnits , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( sinks , ""<STR_LIT>"" ) ; this . stageBlock = stageBlock ; this . shuffleModel = shuffleModel ; int unitSerial = <NUM_LIT:1> ; for ( MapUnit unit : mapUnits ) { unit . renumberUnit ( unitSerial ++ ) ; } for ( ReduceUnit unit : reduceUnits ) { unit . renumberUnit ( unitSerial ++ ) ; } this . mapUnits = mapUnits ; this . reduceUnits = reduceUnits ; this . sinks = sinks ; } public StageBlock getStageBlock ( ) { return stageBlock ; } public List < MapUnit > getMapUnits ( ) { return mapUnits ; } public ShuffleModel getShuffleModel ( ) { return shuffleModel ; } public List < ReduceUnit > getReduceUnits ( ) { return reduceUnits ; } public Set < InputDescription > getSideDataInputs ( ) { Set < ResourceFragment > resources = Sets . create ( ) ; List < Unit < ? > > units = Lists . create ( ) ; units . addAll ( getMapUnits ( ) ) ; units . addAll ( getReduceUnits ( ) ) ; for ( Unit < ? > unit : units ) { for ( Fragment fragment : unit . getFragments ( ) ) { resources . addAll ( fragment . getResources ( ) ) ; } } Set < InputDescription > results = Sets . create ( ) ; for ( ResourceFragment resource : resources ) { results . addAll ( resource . getDescription ( ) . getSideDataInputs ( ) ) ; } return results ; } public List < Sink > getStageResults ( ) { return sinks ; } @ Override public String toString ( ) { return MessageFormat . format ( ""<STR_LIT>"" , getMapUnits ( ) , getShuffleModel ( ) , getReduceUnits ( ) ) ; } public abstract static class Unit < T > extends Compilable . Trait < T > { private final List < FlowBlock . Input > inputs ; private final List < Fragment > fragments ; private int serialNumber = - <NUM_LIT:1> ; public Unit ( List < FlowBlock . Input > inputs , List < Fragment > fragments ) { Precondition . checkMustNotBeNull ( inputs , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( fragments , ""<STR_LIT>"" ) ; this . inputs = inputs ; this . fragments = fragments ; } boolean hasSerialNumber ( ) { return serialNumber >= <NUM_LIT:0> ; } public int getSerialNumber ( ) { if ( serialNumber < <NUM_LIT:0> ) { throw new IllegalStateException ( ) ; } return serialNumber ; } public List < FlowBlock . Input > getInputs ( ) { return inputs ; } public List < Fragment > getFragments ( ) { return fragments ; } void renumberUnit ( int serial ) { this . serialNumber = serial ; } } public static class MapUnit extends Unit < CompiledType > { public MapUnit ( List < FlowBlock . Input > inputs , List < Fragment > fragments ) { super ( inputs , fragments ) ; } @ Override public String toString ( ) { return MessageFormat . format ( ""<STR_LIT>"" , getInputs ( ) , getFragments ( ) , hasSerialNumber ( ) ? String . valueOf ( getSerialNumber ( ) ) : ""<STR_LIT:?>"" ) ; } } public static class ReduceUnit extends Unit < CompiledReduce > { public ReduceUnit ( List < FlowBlock . Input > inputs , List < Fragment > fragments ) { super ( inputs , fragments ) ; } public boolean canCombine ( ) { List < Fragment > fragments = getFragments ( ) ; if ( fragments . isEmpty ( ) ) { return false ; } Fragment headFragment = fragments . get ( <NUM_LIT:0> ) ; return headFragment . canCombine ( ) ; } @ Override public String toString ( ) { return MessageFormat . format ( ""<STR_LIT>"" , getInputs ( ) , getFragments ( ) , hasSerialNumber ( ) ? String . valueOf ( getSerialNumber ( ) ) : ""<STR_LIT:?>"" ) ; } } public static class Fragment extends Compilable . Trait < CompiledType > { private final int serialNumber ; private final List < Factor > factors ; private final List < ResourceFragment > resources ; public Fragment ( int serialNumber , List < Factor > factors , List < ResourceFragment > resources ) { Precondition . checkMustNotBeNull ( factors , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( resources , ""<STR_LIT>"" ) ; if ( factors . isEmpty ( ) ) { throw new IllegalArgumentException ( ) ; } Factor first = factors . get ( <NUM_LIT:0> ) ; if ( first . getElement ( ) . getInputPorts ( ) . size ( ) != <NUM_LIT:1> && first . isRendezvous ( ) == false ) { throw new IllegalArgumentException ( ) ; } if ( factors . size ( ) >= <NUM_LIT:2> && first . isRendezvous ( ) ) { throw new IllegalArgumentException ( ) ; } this . serialNumber = serialNumber ; this . factors = Lists . from ( factors ) ; this . resources = resources ; } public int getSerialNumber ( ) { return serialNumber ; } public boolean canCombine ( ) { if ( isRendezvous ( ) == false ) { return false ; } Factor first = factors . get ( <NUM_LIT:0> ) ; assert first . isRendezvous ( ) ; RendezvousProcessor processor = ( RendezvousProcessor ) first . getProcessor ( ) ; return processor . isPartial ( first . getElement ( ) . getDescription ( ) ) ; } public List < Factor > getFactors ( ) { return factors ; } public List < FlowElementInput > getInputPorts ( ) { if ( factors . isEmpty ( ) ) { return Collections . emptyList ( ) ; } Factor first = factors . get ( <NUM_LIT:0> ) ; return first . getElement ( ) . getInputPorts ( ) ; } public List < FlowElementOutput > getOutputPorts ( ) { if ( factors . isEmpty ( ) ) { return Collections . emptyList ( ) ; } Factor last = factors . get ( factors . size ( ) - <NUM_LIT:1> ) ; return last . getElement ( ) . getOutputPorts ( ) ; } public List < ResourceFragment > getResources ( ) { return resources ; } public boolean isRendezvous ( ) { if ( factors . isEmpty ( ) ) { return false ; } Factor first = factors . get ( <NUM_LIT:0> ) ; return first . isRendezvous ( ) ; } @ Override public String toString ( ) {'}]","return MessageFormat. format ( ""<STR_LIT>"", getSerialNumber ( ), getFactors ( ), getResources ( ) ) ; } } public static class ResourceFragment extends Compilable. Trait < CompiledResource > { private final int serialNumber ; private final FlowResourceDescription description ; public ResourceFragment ( int serialNumber, FlowResourceDescription description ) { Precondition. checkMustNotBeNull ( description, ""<STR_LIT>"" ) ; this. serialNumber = serialNumber ; this. description = description ; } public int getSerialNumber ( ) { return serialNumber ; } public FlowResourceDescription getDescription ( ) { return description ; } @ Override public String toString ( ) { return MessageFormat. format ( ""<STR_LIT>"", getSerialNumber ( ), getDescription ( ) ) ; } } public static class Factor extends Compilable. Trait < CompiledType > { private final FlowElement element ; private final FlowElementProcessor processor ; private final boolean isRendezvous ; public Factor ( FlowElement element, FlowElementProcessor processor, boolean isRendezvous ) { Precondition. checkMustNotBeNull ( element, ""<STR_LIT>"" ) ; Precondition. checkMustNotBeNull ( processor, ""<STR_LIT>"" ) ; this. element =",0.00042250983697861104
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . flow . testing . model . ExSummarized ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class ExSummarizedOutput implements ModelOutput < ExSummarized > { private final RecordEmitter emitter ; public ExSummarizedOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( ExSummarized model ) throws IOException { emitter . emit ( model . getStringOption ( ) ) ; emitter . emit ( model . getValueOption ( ) ) ; emitter'}]",.emit(model.getTimestampOption()); } @Override public void close() throws IOException { emitter.close(); } },4.3918121402819033e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . codeassist ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import org . eclipse . core . resources . IFile ; import org . jruby . ast . Node ; import org . jruby . ast . RootNode ; import org . jruby . lexer . yacc . SyntaxException ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . ExternalRubyScript ; import org . rubypeople . rdt . internal . core . RubyScript ; import org . rubypeople . rdt . internal . core . parser . RubyParser ; import org . rubypeople . rdt . internal . ti . util . OffsetNodeLocator ; public class ResolveContext { private IRubyScript script ; private int start ; private int end ; private RootNode root ; private Node selected ; private IRubyElement [ ] resolved = new IRubyElement [ <NUM_LIT:0> ] ; public ResolveContext ( IRubyScript script , int start , int end ) { this . script = script ; this . start = start ; this . end = end ; } public RootNode getAST ( ) throws RubyModelException {'}]",if (root == null) { root = RubyParser.parse(script); } return root; } public void resolve ( Node node ) throws RubyModelException {... } },6.154621951722086e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; public class RubyClassVar extends RubyField { public'}]","RubyClassVar(RubyClass owner, String name, RubyType type) { super(owner, name, type); }",4.537510474220968e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . mapreduce . parallel ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . JavaName ; import com . asakusafw . compiler . common . Naming ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . DataClass ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . compiler . flow . stage . CompiledType ; import com . asakusafw . runtime . stage . collector . SlotDirectMapper ; import com . asakusafw . runtime . stage . collector . SlotDistributor ; import com . asakusafw . runtime . stage . collector . SortableSlot ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . Comment ; import com . asakusafw . utils . java . model . syntax . CompilationUnit ; import com . asakusafw . utils . java . model . syntax . FormalParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . TypeDeclaration ; import com . asakusafw . utils . java . model . syntax . TypeParameterDeclaration ; import com . asakusafw . utils . java . model . util . AttributeBuilder ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . ImportBuilder ; import com . asakusafw . utils . java . model . util . ImportBuilder . Strategy ; import com . asakusafw . utils . java . model . util . JavadocBuilder ; import com . asakusafw . utils . java . model . util . Models ; import com . asakusafw . utils . java . model . util . TypeBuilder ; final class ParallelSortMapperEmitter { static final Logger LOG = LoggerFactory . getLogger ( ParallelSortMapperEmitter . class ) ; private final FlowCompilingEnvironment environment ; public ParallelSortMapperEmitter ( FlowCompilingEnvironment environment ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; this . environment = environment ; } public CompiledType emit ( String moduleId , ResolvedSlot slot ) throws IOException { Precondition . checkMustNotBeNull ( moduleId , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( slot , ""<STR_LIT>"" ) ; LOG . debug ( ""<STR_LIT>"" , slot . getSource ( ) . getOutputName ( ) , moduleId ) ; CompilationUnit source ; if ( slot . getSortProperties ( ) . isEmpty ( ) && ParallelSortClientEmitter . legacy ( environment ) == false ) { DirectEngine engine = new DirectEngine ( environment , moduleId , slot ) ; source = engine . generate ( ) ; } else { DistributeEngine engine = new DistributeEngine ( environment , moduleId , slot ) ; source = engine . generate ( ) ; } environment . emit ( source ) ; Name packageName = source . getPackageDeclaration ( ) . getName ( ) ; SimpleName simpleName = source . getTypeDeclarations ( ) . get ( <NUM_LIT:0> ) . getName ( ) ; Name name = environment . getModelFactory ( ) . newQualifiedName ( packageName , simpleName ) ; LOG . debug ( ""<STR_LIT>"" , slot . getSource ( ) . getOutputName ( ) , name ) ; return new CompiledType ( name ) ; } private static class DirectEngine { private final ResolvedSlot slot ; private final ModelFactory factory ; private final ImportBuilder importer ; DirectEngine ( FlowCompilingEnvironment envinronment , String moduleId , ResolvedSlot slot ) { assert envinronment != null ; assert moduleId != null ; assert slot != null ; this . slot = slot ; this . factory = envinronment . getModelFactory ( ) ; Name packageName = Models . append ( factory , envinronment . getEpiloguePackageName ( moduleId ) , JavaName . of ( slot . getSource ( ) . getOutputName ( ) ) . toMemberName ( ) ) ; this . importer = new ImportBuilder ( factory , factory . newPackageDeclaration ( packageName ) , Strategy . TOP_LEVEL ) ; } public CompilationUnit generate ( ) { TypeDeclaration type = createType ( ) ; return factory . newCompilationUnit ( importer . getPackageDeclaration ( ) , importer . toImportDeclarations ( ) , Collections . singletonList ( type ) , Collections . < Comment > emptyList ( ) ) ; } private TypeDeclaration createType ( ) { SimpleName name = factory . newSimpleName ( Naming . getMapClass ( <NUM_LIT:0> ) ) ; importer . resolvePackageMember ( name ) ; return factory . newClassDeclaration ( new JavadocBuilder ( factory ) . text ( ""<STR_LIT>"" , slot . getSource ( ) . getOutputName ( ) ) . toJavadoc ( ) , new AttributeBuilder ( factory ) . Public ( ) . toAttributes ( ) , name , Collections . < TypeParameterDeclaration > emptyList ( ) , importer . toType ( SlotDirectMapper . class ) , Collections . < Type > emptyList ( ) , Collections . singletonList ( createOutputName ( ) ) ) ; } private MethodDeclaration createOutputName ( ) { List < Statement > statements = Lists . create ( ) ; statements . add ( new ExpressionBuilder ( factory , Models . toLiteral ( factory , slot . getSource ( ) . getOutputName ( ) ) ) . toReturnStatement ( ) ) ; return factory . newMethodDeclaration ( null , new AttributeBuilder ( factory ) . annotation ( importer . toType ( Override . class ) ) . Public ( ) . toAttributes ( ) , importer . toType ( String . class ) , factory . newSimpleName ( SlotDirectMapper . NAME_GET_OUTPUT_NAME ) , Collections . < FormalParameterDeclaration > emptyList ( ) , statements ) ; } } private static class DistributeEngine { private final ResolvedSlot slot ; private final ModelFactory factory ; private final ImportBuilder importer ; DistributeEngine ( FlowCompilingEnvironment envinronment , String moduleId , ResolvedSlot slot ) { assert envinronment != null ; assert moduleId != null ; assert slot != null ; this . slot = slot ; this . factory = envinronment . getModelFactory ( ) ; Name packageName = Models . append ( factory , envinronment . getEpiloguePackageName ( moduleId ) , JavaName . of ( slot . getSource ( ) . getOutputName ( ) ) . toMemberName ( ) ) ; this . importer = new ImportBuilder ( factory , factory . newPackageDeclaration ( packageName ) , Strategy . TOP_LEVEL ) ; } public CompilationUnit generate ( ) { TypeDeclaration type = createType ( ) ; return factory . newCompilationUnit ( importer . getPackageDeclaration ( ) , importer . toImportDeclarations ( ) , Collections . singletonList ( type ) , Collections . < Comment > emptyList ( ) ) ; } private TypeDeclaration createType ( ) { SimpleName name = factory . newSimpleName ( Naming . getMapClass ( <NUM_LIT:0> ) ) ; importer . resolvePackageMember ( name ) ; return factory . newClassDeclaration ( new JavadocBuilder ( factory ) . text ( ""<STR_LIT>"" , slot . getSource ( ) . getOutputName ( ) ) . toJavadoc ( ) , new AttributeBuilder ( factory ) . Public ( ) . toAttributes ( ) , name , Collections . < TypeParameterDeclaration > emptyList ( ) , new TypeBuilder ( factory , importer . toType ( SlotDistributor . class ) ) . parameterize ( importer . toType ( slot . getValueClass ( ) . getType ( ) ) ) . toType ( ) , Collections . < Type > emptyList ( ) , Collections . singletonList ( createSlotSpec ( ) ) ) ; } private MethodDeclaration createSlotSpec ( ) { SimpleName valueName ='}]","factory. newSimpleName ( SlotDistributor. NAME_GET_SLOT_SPEC ) ; List < Statement > statements = Lists. create ( ) ; statements. add ( new ExpressionBuilder ( factory, Models. toLiteral ( factory, slot. getSortProperties ( ). size ( ) ) ). toReturnStatement ( ) ) ; statements. add ( new ExpressionBuilder ( factory, Models. toLiteral ( factory, slot. getSortProperties ( ). get ( <NUM_LIT:0> ). getUpperBound ( ) ) ). toReturnStatement ( ) ) ; return factory. newMethodDeclaration ( null, new AttributeBuilder ( factory ). annotation ( importer. toType ( Override. class ) ). Public ( ). toAttributes ( ), importer. toType ( String. class ), valueName, Collections. < FormalParameterDeclaration > emptyList ( ), statements ) ; } }",0.00032088731445645757
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ExportTempImportTarget21Df ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class ExportTempImportTarget21DfModelInput implements ModelInput < ExportTempImportTarget21Df > { private final RecordParser parser ; public ExportTempImportTarget21DfModelInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ) ; } this . parser = parser ; } @ Override public boolean readTo ( ExportTempImportTarget21Df model ) throws IOException { if ( parser . next ( ) == false ) { return'}]",false; } model. setImportkey ( parser. readLong ( ) ) ; model. setImportkey1 ( parser. readLong ( ) ) ; model. setImportkey2 ( parser. readLong ( ) ) ; model. setImportkey3 ( parser. readLong ( ) ) ; model. setImportkey4 ( parser. readLong ( ) ) ; model. setImportkey5 ( parser. readLong ( ) ) ; model. setImportkey6 ( parser. readLong ( ) ) ; model. setImportkey7 ( parser. readLong ( ) ) ; model. setImportkey8 ( parser. readLong ( ) ) ; model. setImportkey9 ( parser. readLong ( ) ) ; model. setImportkey10 ( parser. readLong ( ) ) ; return true; } @ Override public void close ( ) throws IOException { parser. close ( ) ; } },0.0002579932395734515
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . tests ; import junit . framework . Test ; import junit . framework . TestSuite ; import net . sf . sveditor . core . tests . CoreReleaseTests ; public class AllReleaseTests extends TestSuite {'}]",public AllReleaseTests() { super(); addTest(new CoreReleaseTests()); },3.679422301079443e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . launcher ; import java . io . File ; import java . util . HashSet ; import java . util . Set ; import junit . framework . Assert ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . part . FileEditorInput ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . tests . ModifyingResourceTest ; import org . rubypeople . rdt . debug . ui . RdtDebugUiConstants ; import org . rubypeople . rdt . internal . debug . ui . RdtDebugUiPlugin ; import org . rubypeople . rdt . internal . debug . ui . RubySourceLocator ; import org . rubypeople . rdt . internal . launching . RubyLaunchConfigurationAttribute ; import org . rubypeople . rdt . launching . IRubyLaunchConfigurationConstants ; import org . rubypeople . rdt . launching . IVMInstall ; import org . rubypeople . rdt . launching . IVMInstallType ; import org . rubypeople . rdt . launching . RubyRuntime ; import org . rubypeople . rdt . launching . VMStandin ; import org . rubypeople . rdt . ui . RubyUI ; public class TC_RubyApplicationShortcut extends ModifyingResourceTest { private static final String VM_TYPE_ID = ""<STR_LIT>"" ; protected ShamRubyApplicationShortcut shortcut ; protected IFile rubyFile , nonRubyFile ; private static String SHAM_LAUNCH_CONFIG_TYPE = ""<STR_LIT>"" ; private Set configurations = new HashSet ( ) ; public TC_RubyApplicationShortcut ( String name ) { super ( name ) ; } protected ILaunchConfiguration createConfiguration ( IFile pFile ) { ILaunchConfiguration config = null ; try { ILaunchConfigurationType configType = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfigurationType ( SHAM_LAUNCH_CONFIG_TYPE ) ; ILaunchConfigurationWorkingCopy wc = configType . newInstance ( null , pFile . getName ( ) ) ; wc . setAttribute ( IRubyLaunchConfigurationConstants . ATTR_PROJECT_NAME , pFile . getProject ( ) . getName ( ) ) ; wc . setAttribute ( IRubyLaunchConfigurationConstants . ATTR_FILE_NAME , pFile . getProjectRelativePath ( ) . toString ( ) ) ; wc . setAttribute ( IRubyLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , ""<STR_LIT>"" ) ; wc . setAttribute ( RubyLaunchConfigurationAttribute . SELECTED_INTERPRETER , RubyRuntime . getCompositeIdFromVM ( RubyRuntime . getDefaultVMInstall ( ) ) ) ; wc . setAttribute ( ILaunchConfiguration . ATTR_SOURCE_LOCATOR_ID , RdtDebugUiConstants . RUBY_SOURCE_LOCATOR ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { } return config ; } protected ILaunchConfiguration [ ] getLaunchConfigurations ( ) throws CoreException { return ( ILaunchConfiguration [ ] ) configurations . toArray ( new ILaunchConfiguration [ configurations . size ( ) ] ) ; } private IVMInstallType vmType ; private IVMInstall vm ; protected void setUp ( ) throws Exception { super . setUp ( ) ; shortcut = new ShamRubyApplicationShortcut ( ) ; createRubyProject ( ""<STR_LIT>"" ) ; createFolder ( ""<STR_LIT>"" ) ; nonRubyFile = createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; rubyFile = createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; ILaunchConfiguration [ ] configs = this . getLaunchConfigurations ( ) ; for ( int i = <NUM_LIT:0> ; i < configs . length ; i ++ ) { configs [ i ] . delete ( ) ; } Assert . assertEquals ( ""<STR_LIT>"" , <NUM_LIT:0> , this . getLaunchConfigurations ( ) . length ) ; ShamApplicationLaunchConfigurationDelegate . resetLaunches ( ) ; vmType = RubyRuntime . getVMInstallType ( VM_TYPE_ID ) ; VMStandin standin = new VMStandin ( vmType , ""<STR_LIT>"" ) ; IFolder location = createFolder ( ""<STR_LIT>"" ) ; createFolder ( ""<STR_LIT>"" ) ; createFolder ( ""<STR_LIT>"" ) ; createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; standin . setInstallLocation ( location . getLocation ( ) . toFile ( ) ) ; standin . setName ( ""<STR_LIT>"" ) ; vm = standin . convertToRealVM ( ) ; RubyRuntime . setDefaultVMInstall ( vm , null , true ) ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; vmType . disposeVMInstall ( vm . getId ( ) ) ; deleteProject ( ""<STR_LIT>"" ) ; configurations . clear ( ) ; } public void testNoInterpreterInstalled ( ) throws Exception { vmType . disposeVMInstall ( vm . getId ( ) ) ; RubyRuntime . setDefaultVMInstall ( null , null , true ) ; ISelection selection = new StructuredSelection ( rubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; assertTrue ( ""<STR_LIT>"" , shortcut . didShowDialog ) ; } public void testLaunchWithSelectedRubyFile ( ) throws Exception { ISelection selection = new StructuredSelection ( rubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , getLaunchConfigurations ( ) . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , shortcut . launchCount ( ) ) ; assertTrue ( ""<STR_LIT>"" , ! shortcut . didLog ( ) ) ; } public void testLaunchWithSelectedNonRubyFile ( ) throws Exception { ISelection selection = new StructuredSelection ( nonRubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:0> , this . getLaunchConfigurations ( ) . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:0> , shortcut . launchCount ( ) ) ; assertTrue ( ""<STR_LIT>"" , shortcut . didLog ( ) ) ; } public void testLaunchWithSelectionMultipleConfigurationsExist ( ) throws Exception { createConfiguration ( rubyFile ) ; createConfiguration ( rubyFile ) ; ISelection selection = new StructuredSelection ( rubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , this . getLaunchConfigurations ( ) . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , shortcut . launchCount ( ) ) ; } public void testLaunchWithSelectionMultipleSelections ( ) throws Exception { ISelection selection = new StructuredSelection ( new Object [ ] { rubyFile , createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) } ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; ILaunchConfiguration [ ] configurations = this . getLaunchConfigurations ( ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , configurations . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , shortcut . launchCount ( ) ) ; assertTrue ( ""<STR_LIT>"" , ! shortcut . didLog ( ) ) ; String launchedFileName = configurations [ <NUM_LIT:0> ] . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_FILE_NAME , ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , launchedFileName ) ; } public void testLaunchWithSelectionTwice ( ) throws Exception { ISelection selection = new StructuredSelection ( rubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , this . getLaunchConfigurations ( ) . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:2> , shortcut . launchCount ( ) ) ; assertTrue ( ""<STR_LIT>"" , ! shortcut . didLog ( ) ) ; } public void testLaunchWithSelectionWhenFileNamesSameInDifferentDirectory ( ) throws Exception { IFile anotherRubyFileWithSameNameInDifferentFolder = createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; ISelection selection = new StructuredSelection ( rubyFile ) ; shortcut . launch ( selection , ILaunchManager . RUN_MODE ) ; ILaunchConfiguration [ ] configurations = this . getLaunchConfigurations ( ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , configurations . length ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , shortcut . launchCount ( ) ) ; assertTrue ( ""<STR_LIT>"" , ! shortcut . didLog ( ) ) ; String launchedFileName = configurations [ <NUM_LIT:0> ] . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_FILE_NAME , ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , launchedFileName ) ; } public void testLaunchFromEditorWithRubyFile ( ) throws Exception { IFile file = createFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; RubySourceLocator sourceLocator = new RubySourceLocator ( ) ; String fullPath = RdtDebugUiPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . toOSString ( ) + File . separator + file . getFullPath ( ) . toOSString ( ) ; Object sourceElement = sourceLocator . getSourceElement ( fullPath ) ; IEditorInput input = sourceLocator . getEditorInput ( sourceElement ) ; IEditorPart rubyEditor = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . openEditor ( input , RubyUI . ID_RUBY_EDITOR ) ; shortcut . launch ( rubyEditor , ILaunchManager . RUN_MODE ) ; assertEquals ( ""<STR_LIT>"" , <NUM_LIT:1> , this .'}]",getLaunchConfigurations().length);,6.641892682246699e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . frontend . panels ; import com . team1160 . scouting . frontend . elements . JumpMenuItem ; import com . team1160 . scouting . frontend . resourcePackets . CardLayoutPacket ; import com . team1160 . scouting . h2 . DictTable ; import com . team1160 . scouting . h2 . MatchScoutingTable ; import com . team1160 . scouting . h2 . WeightingTable ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . KeyEvent ; import java . sql . SQLException ; import java . util . Comparator ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . JButton ; import javax . swing . JMenu ; import javax . swing . JMenuBar ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JToolBar ; import org . jfree . chart . ChartFactory ; import org . jfree . chart . ChartPanel ; import org . jfree . chart . JFreeChart ; import org . jfree . chart . plot . PlotOrientation ; import org . jfree . chart . renderer . category . GroupedStackedBarRenderer ; import org . jfree . data . category . CategoryDataset ; import org . jfree . data . category . DefaultCategoryDataset ; public class GraphPanel extends JPanel { private static final long serialVersionUID = <NUM_LIT> ; CardLayoutPacket layout ; JMenuBar menubar ; JToolBar toolbar ; JMenu go ; private final JButton refresh ; private final JButton deleteData ; MatchScoutingTable matchTable ; WeightingTable weightingTable ; DictTable dictTable ; JFreeChart chart ; ChartPanel chartPanel ; JScrollPane scroll ; @ SuppressWarnings ( ""<STR_LIT:unused>"" ) private final GroupedStackedBarRenderer renderer ; final int preferredHeight = <NUM_LIT> ; Dimension preferredSize ; public GraphPanel ( CardLayoutPacket layout , MatchScoutingTable match , WeightingTable weight , DictTable dict ) throws SQLException { this . matchTable = match ; this . weightingTable = weight ; this . dictTable = dict ; this . menubar = new JMenuBar ( ) ; this . go = new JMenu ( ""<STR_LIT>"" ) ; this . go . setMnemonic ( KeyEvent . VK_G ) ; this . go . add ( new JumpMenuItem ( layout , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; this . go . add ( new JumpMenuItem ( layout , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; this . toolbar = new JToolBar ( ) ; this . toolbar . setFloatable ( false ) ; this . deleteData = new JButton ( ""<STR_LIT>"" ) ; this . deleteData . setMnemonic ( KeyEvent . VK_D ) ; this . deleteData . addActionListener ( this . new DeleteData ( ) ) ; this . deleteData . setSize ( <NUM_LIT:100> , this . menubar . getHeight ( ) ) ; this . toolbar . add ( this . deleteData ) ; this . refresh = new JButton ( ""<STR_LIT>"" ) ; this . refresh . setMnemonic ( KeyEvent . VK_R ) ; this . refresh . addActionListener ( this . new Refresh ( ) ) ; this . refresh . setSize ( <NUM_LIT:100> , this . menubar . getHeight ( ) ) ; this . toolbar . add ( this . refresh ) ; JPanel top = new JPanel ( ) ; top . setLayout ( new BorderLayout ( ) ) ; top . add ( this . menubar ) ; this . menubar . add ( this . go , BorderLayout . NORTH ) ; top . add ( this . toolbar , BorderLayout . SOUTH ) ; this . chart = ChartFactory . createStackedBarChart ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , this . createDataSet ( ) , PlotOrientation . VERTICAL , true , true , false ) ; this . renderer = new GroupedStackedBarRenderer ( ) ; this . chartPanel = new ChartPanel ( this . chart , this . preferredSize . width , this . preferredSize . height , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , true , true , true , false , false , true ) ; this . scroll = new JScrollPane ( this . chartPanel ) ; this . setLayout ( new BorderLayout ( ) ) ; this . add ( top , BorderLayout . NORTH ) ; this . add ( this . scroll , BorderLayout . CENTER ) ; } protected CategoryDataset createDataSet ( ) throws SQLException { DefaultCategoryDataset data = new DefaultCategoryDataset ( ) ; Map < String , Integer > dict ; Map < Integer , String > reverseDict ; List < Integer > teams ; Map'}]","<NUM_LIT> teams = this.dictTable.getTeams(); for (Integer team : teams) { dict = this.dictTable.getDict(team); reverseDict = this.dictTable.getReverseDict(team); for (String key : dict.keySet()) { data.addValue(dict.get(key), key, team); } } return data; } class DeleteData implements ActionListener { @Override public void actionPerformed(ActionEvent e) { if (JOptionPane.showConfirmDialog(GraphPanel.this, ""<STR_LIT>"", ""<STR_LIT>"", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) { try { GraphPanel.this.matchTable.deleteData(); GraphPanel.this.weightingTable.deleteData(); } catch (SQLException ex) { Logger.getLogger(GraphPanel.class.getName()).log(Level.SEVERE, null, ex); } } } class Refresh implements ActionListener { @Override public void actionPerformed(ActionEvent e) { GraphPanel.this.matchTable.refresh(); GraphPanel.this.weightingTable.refresh(); } } }",0.00029879204795068187
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class SVDBFSFileSystemProvider implements ISVDBFileSystemProvider { public void init ( String path ) { } public void dispose ( ) { } public void addMarker ( String path , String type , int lineno , String msg ) { } public void clearMarkers ( String path ) { } public void closeStream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } public boolean fileExists ( String path ) { File f = new File ( path ) ; return f . isFile ( ) ; } public boolean isDir ( String path ) { File f = new File ( path ) ; return f . isDirectory ( ) ; } public List < String > getFiles ( String path ) { File p = new File ( path ) ; List < String > ret = new ArrayList < String > ( ) ; if ( p .'}]",isDirectory()) { String[] files = p.list(); for (String file : files) { ret.add(file); } } return ret; } public InputStream openStream(String path) { try { return new FileInputStream(new File(path)); } catch (IOException e) { return null; } },9.223790518748208e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . common ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import com . asakusafw . bulkloader . bean . ExportTargetTableBean ; import com . asakusafw . bulkloader . bean . ImportTargetTableBean ; import com . asakusafw . bulkloader . testutil . UnitTestUtil ; import com . asakusafw . runtime . util . VariableTable ; @ SuppressWarnings ( { ""<STR_LIT>"" , ""<STR_LIT:deprecation>"" } ) public class JobFlowParamLoaderTest { private static String targetName = ""<STR_LIT>"" ; private static List < String > propertys = Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ; private static String jobflowId = ""<STR_LIT>"" ; private static String executionId = ""<STR_LIT>"" ; @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { UnitTestUtil . setUpBeforeClass ( ) ; UnitTestUtil . setUpEnv ( ) ; BulkLoaderInitializer . initDBServer ( jobflowId , executionId , propertys , ""<STR_LIT>"" ) ; UnitTestUtil . setUpDB ( ) ; } @ AfterClass public static void tearDownAfterClass ( ) throws Exception { UnitTestUtil . tearDownDB ( ) ; UnitTestUtil . tearDownAfterClass ( ) ; } @ Before public void setUp ( ) throws Exception { BulkLoaderInitializer . initDBServer ( jobflowId , executionId , propertys , targetName ) ; UnitTestUtil . startUp ( ) ; } @ After public void tearDown ( ) throws Exception { UnitTestUtil . tearDown ( ) ; } @ Test public void loadImportParamTest01 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; Map < String , ImportTargetTableBean > importTargetTable = loder . getImportTargetTables ( ) ; assertTrue ( result ) ; ImportTargetTableBean table1 = importTargetTable . get ( ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:3> , table1 . getImportTargetColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getImportTargetColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getImportTargetColumns ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getImportTargetColumns ( ) . get ( <NUM_LIT:2> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getSearchCondition ( ) ) ; assertEquals ( ImportTableLockType . find ( ""<STR_LIT:1>"" ) , table1 . getLockType ( ) ) ; assertEquals ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) , table1 . getLockedOperation ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getImportTargetType ( ) . getName ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getDfsFilePath ( ) ) ; ImportTargetTableBean table2 = importTargetTable . get ( ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:1> , table2 . getImportTargetColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getImportTargetColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getSearchCondition ( ) ) ; assertEquals ( ImportTableLockType . find ( ""<STR_LIT:2>"" ) , table2 . getLockType ( ) ) ; assertEquals ( ImportTableLockedOperation . find ( ""<STR_LIT:1>"" ) , table2 . getLockedOperation ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getImportTargetType ( ) . getName ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getDfsFilePath ( ) ) ; ImportTargetTableBean table3 = importTargetTable . get ( ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:2> , table3 . getImportTargetColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getImportTargetColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getImportTargetColumns ( ) . get ( <NUM_LIT:1> ) ) ; assertNull ( table3 . getSearchCondition ( ) ) ; assertEquals ( ImportTableLockType . find ( ""<STR_LIT:3>"" ) , table3 . getLockType ( ) ) ; assertEquals ( ImportTableLockedOperation . find ( ""<STR_LIT:2>"" ) , table3 . getLockedOperation ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getImportTargetType ( ) . getName ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getDfsFilePath ( ) ) ; } @ Test public void loadImportParamTest02 ( ) throws Exception { VariableTable table = new VariableTable ( ) ; table . defineVariable ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; table . defineVariable ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Map < String , String > env = new HashMap < String , String > ( ) ; env . put ( Constants . THUNDER_GATE_HOME , System . getenv ( Constants . THUNDER_GATE_HOME ) ) ; env . put ( Constants . ENV_ARGS , table . toSerialString ( ) ) ; ConfigurationLoader . setEnv ( env ) ; JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; Map < String , ImportTargetTableBean > importTargetTable = loder . getImportTargetTables ( ) ; assertTrue ( result ) ; ImportTargetTableBean table1 = importTargetTable . get ( ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , table1 . getSearchCondition ( ) ) ; } @ Test public void loadImportParamTest03 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; Map < String , ImportTargetTableBean > importTargetTable = loder . getImportTargetTables ( ) ; assertTrue ( result ) ; assertEquals ( <NUM_LIT:0> , importTargetTable . size ( ) ) ; } @ Test public void loadImportParamTest04 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; Map < String , ImportTargetTableBean > importTargetTable = loder . getImportTargetTables ( ) ; assertFalse ( result ) ; assertNull ( importTargetTable ) ; } @ Test public void loadImportParamTest05 ( ) throws Exception { VariableTable table = new VariableTable ( ) ; table . defineVariable ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Map < String , String > env = new HashMap < String , String > ( ) ; env . put ( Constants . THUNDER_GATE_HOME , System . getenv ( Constants . THUNDER_GATE_HOME ) ) ; env . put ( Constants . ENV_ARGS , table . toSerialString ( ) ) ; ConfigurationLoader . setEnv ( env ) ; JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void loadImportParamTest06 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void loadImportParamTest07 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void loadImportParamTest08 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getImportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadImportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" , true ) ; Map < String , ImportTargetTableBean > importTargetTable = loder . getImportTargetTables ( ) ; assertTrue ( result ) ; Iterator < String > it = importTargetTable . keySet ( ) . iterator ( ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; } @ Test public void loadExportParamTest01 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Map < String , ExportTargetTableBean > exportTargetTable = loder . getExportTargetTables ( ) ; assertTrue ( result ) ; ExportTargetTableBean table1 = exportTargetTable . get ( ""<STR_LIT>"" ) ; assertTrue ( table1 . isDuplicateCheck ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableName ( ) ) ; assertEquals ( <NUM_LIT:5> , table1 . getExportTsvColumn ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTsvColumn ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTsvColumn ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTsvColumn ( ) . get ( <NUM_LIT:2> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTsvColumn ( ) . get ( <NUM_LIT:3> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTsvColumn ( ) . get ( <NUM_LIT:4> ) ) ; assertEquals ( <NUM_LIT:2> , table1 . getExportTableColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTableColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTableColumns ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( <NUM_LIT:5> , table1 . getErrorTableColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableColumns ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableColumns ( ) . get ( <NUM_LIT:2> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableColumns ( ) . get ( <NUM_LIT:3> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorTableColumns ( ) . get ( <NUM_LIT:4> ) ) ; assertEquals ( <NUM_LIT:1> , table1 . getKeyColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getKeyColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorCodeColumn ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getErrorCode ( ) ) ; assertEquals ( ""<STR_LIT>"" , table1 . getExportTargetType ( ) . getName ( ) ) ; List < String > path1 = table1 . getDfsFilePaths ( ) ; assertEquals ( <NUM_LIT:2> , path1 . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , path1 . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , path1 . get ( <NUM_LIT:1> ) ) ; ExportTargetTableBean table2 = exportTargetTable . get ( ""<STR_LIT>"" ) ; assertFalse ( table2 . isDuplicateCheck ( ) ) ; assertNull ( table2 . getErrorTableName ( ) ) ; assertEquals ( <NUM_LIT:3> , table2 . getExportTsvColumn ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTsvColumn ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTsvColumn ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTsvColumn ( ) . get ( <NUM_LIT:2> ) ) ; assertEquals ( <NUM_LIT:3> , table2 . getExportTableColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTableColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTableColumns ( ) . get ( <NUM_LIT:1> ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTableColumns ( ) . get ( <NUM_LIT:2> ) ) ; assertEquals ( <NUM_LIT:0> , table2 . getErrorTableColumns ( ) . size ( ) ) ; assertEquals ( <NUM_LIT:0> , table2 . getKeyColumns ( ) . size ( ) ) ; assertNull ( table2 . getErrorCodeColumn ( ) ) ; assertNull ( table2 . getErrorCode ( ) ) ; assertEquals ( ""<STR_LIT>"" , table2 . getExportTargetType ( ) . getName ( ) ) ; List < String > path2 = table2 . getDfsFilePaths ( ) ; assertEquals ( <NUM_LIT:1> , path2 . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , path2 . get ( <NUM_LIT:0> ) ) ; ExportTargetTableBean table3 = exportTargetTable . get ( ""<STR_LIT>"" ) ; assertFalse ( table3 . isDuplicateCheck ( ) ) ; assertNull ( table3 . getErrorTableName ( ) ) ; assertEquals ( <NUM_LIT:1> , table3 . getExportTsvColumn ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getExportTsvColumn ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( <NUM_LIT:1> , table3 . getExportTableColumns ( ) . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getExportTableColumns ( ) . get ( <NUM_LIT:0> ) ) ; assertEquals ( <NUM_LIT:0> , table3 . getErrorTableColumns ( ) . size ( ) ) ; assertEquals ( <NUM_LIT:0> , table3 . getKeyColumns ( ) . size ( ) ) ; assertNull ( table3 . getErrorCodeColumn ( ) ) ; assertNull ( table3 . getErrorCode ( ) ) ; assertEquals ( ""<STR_LIT>"" , table3 . getExportTargetType ( ) . getName ( ) ) ; List < String > path3 = table3 . getDfsFilePaths ( ) ; assertEquals ( <NUM_LIT:1> , path3 . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , path3 . get ( <NUM_LIT:0> ) ) ; } @ Test public void loadExportParamTest02 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Map < String , ExportTargetTableBean > exportTargetTable = loder . getExportTargetTables ( ) ; assertTrue ( result ) ; assertEquals ( <NUM_LIT:0> , exportTargetTable . size ( ) ) ; } @ Test public void loadExportParamTest03 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertFalse ( result ) ; } @ Test public void loadExportParamTest04 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertFalse ( result ) ; } @ Test public void loadExportParamTest05 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertFalse ( result ) ; } @ Test public void loadExportParamTest06 ( ) throws Exception { JobFlowParamLoader loder = new JobFlowParamLoader ( ) { @ Override protected Properties getExportProp ( File dslFile , String targetName ) throws IOException { System . out . println ( dslFile ) ; File propFile = new File ( ""<STR_LIT>"" ) ; FileInputStream fis = new FileInputStream ( propFile ) ; Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } } ; boolean result = loder . loadExportParam ( targetName , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Map < String , ExportTargetTableBean > exportTargetTable = loder . getExportTargetTables ( ) ; assertTrue ( result ) ; Iterator < String > it = exportTargetTable . keySet ( ) . iterator ( ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; assertEquals ( ""<STR_LIT>"" , it . next ( ) ) ; } @ Test public void checkImportParamTest01 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ) ; tableBean1 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean1 . setUseCache ( false ) ; tableBean1 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:1>"" ) ) ; tableBean1 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) ) ; tableBean1 . setImportTargetType ( this . getClass ( ) ) ; tableBean1 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean1 ) ; ImportTargetTableBean tableBean2 = new ImportTargetTableBean ( ) ; tableBean2 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; tableBean2 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean2 . setUseCache ( false ) ; tableBean2 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:2>"" ) ) ; tableBean2 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:1>"" ) ) ; tableBean2 . setImportTargetType ( this . getClass ( ) ) ; tableBean2 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean2 ) ; ImportTargetTableBean tableBean3 = new ImportTargetTableBean ( ) ; tableBean3 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; tableBean3 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean3 . setUseCache ( false ) ; tableBean3 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:2>"" ) ) ; tableBean3 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) ) ; tableBean3 . setImportTargetType ( this . getClass ( ) ) ; tableBean3 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean3 ) ; ImportTargetTableBean tableBean4 = new ImportTargetTableBean ( ) ; tableBean4 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; tableBean4 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean4 . setUseCache ( false ) ; tableBean4 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:3>"" ) ) ; tableBean4 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:2>"" ) ) ; tableBean4 . setImportTargetType ( this . getClass ( ) ) ; tableBean4 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean4 ) ; ImportTargetTableBean tableBean5 = new ImportTargetTableBean ( ) ; tableBean5 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; tableBean5 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean5 . setUseCache ( false ) ; tableBean5 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:3>"" ) ) ; tableBean5 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) ) ; tableBean5 . setImportTargetType ( this . getClass ( ) ) ; tableBean5 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean5 ) ; boolean result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertTrue ( result ) ; } @ Test public void checkImportParamTest02 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean1 . setUseCache ( false ) ; tableBean1 . setLockType ( ImportTableLockType . NONE ) ; tableBean1 . setLockedOperation ( ImportTableLockedOperation . FORCE ) ; tableBean1 . setImportTargetType ( this . getClass ( ) ) ; tableBean1 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean1 ) ; ImportTargetTableBean tableBean2 = new ImportTargetTableBean ( ) ; tableBean2 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; tableBean2 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean2 . setUseCache ( false ) ; tableBean2 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:1>"" ) ) ; tableBean2 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) ) ; tableBean2 . setImportTargetType ( this . getClass ( ) ) ; tableBean2 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean2 ) ; boolean result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , null } ) ) ; result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } ) ) ; tableBean2 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) ) ; result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void checkImportParamTest03 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ) ; tableBean1 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean1 . setUseCache ( false ) ; tableBean1 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:0>"" ) ) ; tableBean1 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:1>"" ) ) ; tableBean1 . setImportTargetType ( this . getClass ( ) ) ; tableBean1 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean1 ) ; boolean result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; tableBean1 . setLockType ( null ) ; result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void checkImportParamTest04 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ) ; tableBean1 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean1 . setUseCache ( false ) ; tableBean1 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:1>"" ) ) ; tableBean1 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:0>"" ) ) ; tableBean1 . setImportTargetType ( this . getClass ( ) ) ; tableBean1 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean1 ) ; boolean result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; tableBean1 . setLockedOperation ( null ) ; result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void checkImportParamTest05 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ) ; tableBean1 . setSearchCondition ( ""<STR_LIT>"" ) ; tableBean1 . setUseCache ( false ) ; tableBean1 . setLockType ( ImportTableLockType . find ( ""<STR_LIT:1>"" ) ) ; tableBean1 . setLockedOperation ( ImportTableLockedOperation . find ( ""<STR_LIT:3>"" ) ) ; tableBean1 . setImportTargetType ( null ) ; tableBean1 . setDfsFilePath ( ""<STR_LIT>"" ) ; targetTable . put ( ""<STR_LIT>"" , tableBean1 ) ; boolean result = loader . checkImportParam ( targetTable , targetName , ""<STR_LIT:1>"" , ""<STR_LIT>"" , true ) ; assertFalse ( result ) ; } @ Test public void checkImportParamTest06 ( ) throws Exception { JobFlowParamLoader loader = new JobFlowParamLoader ( ) ; Map < String , ImportTargetTableBean > targetTable = new LinkedHashMap < String , ImportTargetTableBean > ( ) ; ImportTargetTableBean tableBean1 = new ImportTargetTableBean ( ) ; tableBean1 . setImportTargetColumns ( Arrays . asList ( new String [ ] { ""<STR_LIT>"" ,'}]","protected Properties getExportProp(File dslFile, String targetName) throws IOException { System.out.println(dslFile); File propFile = new File(""<STR_LIT>""); FileInputStream fis = new FileInputStream(propFile); Properties prop = new Properties(); prop.load(fis); return prop; }",0.0003186654782426578
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . inlineclass . conditionchecks ; import junit . framework'}]",.TestCase; import org.junit.Test; public class ConditionChecksInlineClassTest { @Test public void testInlineClassConditionChecks() { TestCase testCase = new TestCase(); // Add test logic here } },6.384663989587923e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . directio . emitter ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Random ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . directio . OutputPattern . CompiledResourcePattern ; import com . asakusafw . compiler . directio . OutputPattern . RandomNumber ; import com . asakusafw . compiler . directio . OutputPattern . SourceKind ; import com . asakusafw . compiler . flow . DataClass ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . runtime . stage . directio . StringTemplate ; import com . asakusafw . runtime . stage . directio . StringTemplate . Format ; import com . asakusafw . runtime . stage . directio . StringTemplate . FormatSpec ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . Comment ; import com . asakusafw . utils . java . model . syntax . CompilationUnit ; import com . asakusafw . utils . java . model . syntax . ConstructorDeclaration ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . FieldDeclaration ; import com . asakusafw . utils . java . model . syntax . FormalParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . InfixOperator ; import com . asakusafw . utils . java . model . syntax . Javadoc ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . syntax . QualifiedName ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . TypeBodyDeclaration ; import com . asakusafw . utils . java . model . syntax . TypeDeclaration ; import com . asakusafw . utils . java . model . syntax . TypeParameterDeclaration ; import com . asakusafw . utils . java . model . util . AttributeBuilder ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . ImportBuilder ; import com . asakusafw . utils . java . model . util . JavadocBuilder ; import com . asakusafw . utils . java . model . util . Models ; import com . asakusafw . utils . java . model . util . TypeBuilder ; @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class NamingClassEmitter { static final Logger LOG = LoggerFactory . getLogger ( NamingClassEmitter . class ) ; private final FlowCompilingEnvironment environment ; private final String moduleId ; public NamingClassEmitter ( FlowCompilingEnvironment environment , String moduleId ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( moduleId , ""<STR_LIT>"" ) ; this . environment = environment ; this . moduleId = moduleId ; } public Name emit ( String outputName , int index , DataClass dataType , List < CompiledResourcePattern > namingInfo ) throws IOException { if ( outputName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( dataType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( namingInfo == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , new Object [ ] { environment . getBatchId ( ) , environment . getFlowId ( ) , outputName , } ) ; Engine engine = new Engine ( environment , moduleId , outputName , index , dataType , namingInfo ) ; CompilationUnit source = engine . generate ( ) ; environment . emit ( source ) ; Name packageName = source . getPackageDeclaration ( ) . getName ( ) ; SimpleName simpleName = source . getTypeDeclarations ( ) . get ( <NUM_LIT:0> ) . getName ( ) ; QualifiedName name = environment . getModelFactory ( ) . newQualifiedName ( packageName , simpleName ) ; LOG . debug ( ""<STR_LIT>"" , new Object [ ] { environment . getBatchId ( ) , environment . getFlowId ( ) , outputName , name . toNameString ( ) , } ) ; return name ; } private static final class Engine { private static final String FIELD_RANDOM_HOLDER = ""<STR_LIT>"" ; private static final String FIELD_RANDOMIZER = ""<STR_LIT>"" ; private final String moduleId ; private final String outputName ; private final int index ; private final DataClass dataType ; private final List < CompiledResourcePattern > namingInfo ; private final ModelFactory factory ; private final ImportBuilder importer ; Engine ( FlowCompilingEnvironment environment , String moduleId , String outputName , int index , DataClass dataType , List < CompiledResourcePattern > namingInfo ) { assert environment != null ; assert moduleId != null ; assert outputName != null ; assert dataType != null ; assert namingInfo != null ; this . moduleId = moduleId ; this . outputName = outputName ; this . index = index ; this . dataType = dataType ; this . namingInfo = namingInfo ; this . factory = environment . getModelFactory ( ) ; Name packageName = environment . getEpiloguePackageName ( moduleId ) ; this . importer = new ImportBuilder ( factory , factory . newPackageDeclaration ( packageName ) , ImportBuilder . Strategy . TOP_LEVEL ) ; } public CompilationUnit generate ( ) { TypeDeclaration type = createType ( ) ; return factory . newCompilationUnit ( importer . getPackageDeclaration ( ) , importer . toImportDeclarations ( ) , Collections . singletonList ( type ) , Collections . < Comment > emptyList ( ) ) ; } private TypeDeclaration createType ( ) { SimpleName name = getClassName ( ) ; importer . resolvePackageMember ( name ) ; List < TypeBodyDeclaration > members = Lists . create ( ) ; if ( requireRandomNumber ( ) ) { members . add ( createRandomHolder ( ) ) ; members . add ( createRandomizer ( ) ) ; } members . add ( createConstructor ( ) ) ; members . add ( createSetMethod ( ) ) ; return factory . newClassDeclaration ( createJavadoc ( ) , new AttributeBuilder ( factory ) . annotation ( importer . toType ( SuppressWarnings . class ) , Models . toLiteral ( factory , ""<STR_LIT:deprecation>"" ) ) . Public ( ) . Final ( ) . toAttributes ( ) , name , Collections . < TypeParameterDeclaration > emptyList ( ) , t ( StringTemplate . class ) , Collections . < Type > emptyList ( ) , members ) ; } private boolean requireRandomNumber ( ) { for ( CompiledResourcePattern naming : namingInfo ) { if ( naming . getKind ( ) == SourceKind . RANDOM ) { return true ; } } return false ; } private FieldDeclaration createRandomHolder ( ) { new IntOption ( ) . modify ( index ) ; return factory . newFieldDeclaration ( null , new AttributeBuilder ( factory ) . Private ( ) . Final ( ) . toAttributes ( ) , importer . toType ( IntOption . class ) , factory . newSimpleName ( FIELD_RANDOM_HOLDER ) , new TypeBuilder ( factory , importer . toType ( IntOption . class ) ) . newObject ( ) . toExpression ( ) ) ; } private FieldDeclaration createRandomizer ( ) { return factory . newFieldDeclaration ( null , new AttributeBuilder ( factory ) . Private ( ) . Final ( ) . toAttributes ( ) , importer . toType ( Random . class ) , factory . newSimpleName ( FIELD_RANDOMIZER ) , new TypeBuilder ( factory , importer . toType ( Random . class ) ) . newObject ( Models . toLiteral ( factory , <NUM_LIT> ) ) . toExpression ( ) ) ; } private ConstructorDeclaration createConstructor ( ) { List < Expression > arguments = Lists . create ( ) ; for ( CompiledResourcePattern naming : namingInfo ) { arguments . add ( new TypeBuilder ( factory , t ( FormatSpec . class ) ) . newObject ( new TypeBuilder ( factory , t ( Format . class ) ) . field ( naming . getFormat ( ) . name ( ) ) . toExpression ( ) , naming . getArgument ( ) == null ? Models . toNullLiteral ( factory ) : Models . toLiteral ( factory , naming . getArgument ( ) ) ) . toExpression ( ) ) ; } List < Statement > statements = Lists . create ( ) ; statements . add ( factory . newSuperConstructorInvocation ( arguments ) ) ; return factory . newConstructorDeclaration ( new JavadocBuilder ( factory ) . text ( ""<STR_LIT>"" ) . toJavadoc ('}]","). Public ( ). toDeclarations ( ), arguments, statements ) ; } private FieldDeclaration createSetMethod ( ) { return factory. newFieldDeclaration ( null, new AttributeBuilder ( factory ). Private ( ). Final ( ). toAttributes ( ), importer. toType ( IntOption. class ), factory. newSimpleName ( FIELD_RANDOM_HOLDER ), new TypeBuilder ( factory, importer. toType ( IntOption. class ) ). newFieldAccess ( factory. newSimpleName ( FIELD_RANDOMIZER ), new TypeBuilder ( factory, importer. toType ( Random. class ) ). newMethodInvocation ( factory. newSimpleName ( ""nextInt"" ), Collections. < Expression > emptyList ( ) ) ). toExpression ( ) ) ; } private Javadoc createJavadoc ( ) { JavadocBuilder builder = new JavadocBuilder ( factory ) ; builder. add ( new Javadoc ( ""<STR_LIT>"" ) ) ; builder. add ( new Javadoc ( ""<STR_LIT>"" ) ) ; return builder. toJavadoc ( ) ; } private String getClassName ( ) { return StringTemplate. format ( moduleId, index ) ; } }",0.00042907863405094787
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . kobjects . xmlrpc ; import java . util . * ; import java . io . * ; import org . xmlpull . v1 . * ; public class XmlRpcParser { XmlPullParser parser ; public XmlRpcParser ( XmlPullParser parser ) { this . parser = parser ; } public Vector parseResponse ( ) throws XmlPullParserException , IOException { Vector result = new Vector ( ) ; parser . nextTag ( ) ; parser . require ( parser . START_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; parser . nextTag ( ) ; parser . require ( parser . START_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; while ( parser . nextTag ( ) == parser . START_TAG ) { parser . require ( parser . START_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; parser . nextTag ( ) ; result . addElement ( parseValue ( ) ) ; parser . nextTag ( ) ; parser . require ( parser . END_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } parser . require ( parser . END_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; parser . nextTag ( ) ; parser . require ( parser . END_TAG , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; parser . next ( ) ; parser . require ( parser . END_DOCUMENT , null , null ) ; return result ; } Object parseValue ( ) throws IOException , XmlPullParserException { parser . require ( parser . START_TAG , ""<STR_LIT>"" , ""<STR_LIT:value>"" ) ; parser . next ( ) ; Object result ; if ( parser . getEventType ( ) == parser . END_TAG ) result = ""<STR_LIT>"" ; else if ( parser . getEventType ( ) == parser . TEXT ) { result = parser . getText ( ) ; parser . nextTag ( ) ; } else { parser . require ( parser . START_TAG , ""<STR_LIT>"" , null ) ; String name = parser . getName ( ) ; if ( name . equals ( ""<STR_LIT:double>"" ) ) result ='}]","Double.parseDouble(parser.getText());else if (name.equals(""<STR_LIT:int>""))result = Integer.parseInt(parser.getText());else if (name.equals(""<STR_LIT:boolean>""))result = Boolean.parseBoolean(parser.getText());else if (name.equals(""<STR_LIT:null>""))result = null;else if (name.startsWith(""<STR_LIT:array>""))result = parseArray();else if (name.startsWith(""<STR_LIT:struct>""))result = parseStruct();else if (name.startsWith(""<STR_LIT:map>""))result = parseMap();else {parser.require(parser.START_TAG, ""<STR_LIT>"", null);throw new XmlPullParserException(""<STR_LIT> unknown type: "" + name);}parser.require(parser.END_TAG, ""<STR_LIT>"", ""<STR_LIT:value>"");return result;}private Vector parseArray() throws IOException, XmlPullParserException {Vector result = new Vector();parser.require(parser.START_TAG, ""<STR_LIT>"", ""<STR_LIT:array>"");int size = Integer.parseInt(parser.getAttributeValue(null, ""<STR_LIT:size>""));for (int i = 0; i < size; i++) {result.addElement(parseValue());parser.nextTag();}parser.require(parser.END_TAG, ""<STR_LIT",0.00035485679106435017
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . flow ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . ServiceLoader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import com . asakusafw . runtime . core . HadoopConfiguration ; import com . asakusafw . runtime . core . ResourceConfiguration ; import com . asakusafw . runtime . core . RuntimeResource ; public class RuntimeResourceManager { static final Log LOG = LogFactory . getLog ( RuntimeResourceManager . class ) ; public static final String CONFIGURATION_FILE_NAME = ""<STR_LIT>"" ; public static final String CONFIGURATION_FILE_PATH = ""<STR_LIT>"" + CONFIGURATION_FILE_NAME ; private final ResourceConfiguration configuration ; private List < RuntimeResource > resources ; public RuntimeResourceManager ( Configuration configuration ) { if ( configuration == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . configuration = new HadoopConfiguration ( configuration ) ; this . resources = Collections . emptyList ( ) ; } public void setup ( ) throws IOException , InterruptedException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ""<STR_LIT>"" ) ; } List < ? extends RuntimeResource > loaded = load ( ) ; this . resources = new ArrayList < RuntimeResource > ( ) ; for ( RuntimeResource resource : loaded ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( MessageFormat'}]",".format(""<STR_LIT>"", resource.getClass().getName())); this.resources.add(resource); } } private List<? extends RuntimeResource> load() throws IOException, InterruptedException { ServiceLoader<RuntimeResource> loader = ServiceLoader.load(RuntimeResource.class); List<RuntimeResource> resources = new ArrayList<RuntimeResource>(); for (RuntimeResource resource : loader) { if (LOG.isDebugEnabled()) { LOG.debug(MessageFormat.format(""<STR_LIT>"", resource.getClass().getName())); } resources.add(resource); } return resources; } }",0.00014850889258867387
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . frontend . elements ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import com . team1160 . scouting . frontend . resourcePackets . CardLayoutPacket ; import javax . swing . JMenuItem ; public class NextMenuItem extends JMenuItem implements ActionListener { private static final long serialVersionUID = <NUM_LIT> ; CardLayoutPacket layout ; public'}]","NextMenuItem(CardLayoutPacket layout) { super(""Next""); this.layout = layout; addActionListener(this); } @Override public void actionPerformed(ActionEvent e) { layout.next(); } }",6.125667968721761e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs ; import java . io . Serializable ; import org . apache . log4j . Logger ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; public class SequenceJob implements Runnable , Serializable { private static final long serialVersionUID = <NUM_LIT> ; private static final Logger logger = Logger . getLogger ( SequenceJob . class ) ; private transient String name ; private volatile Integer current ; private int from ; private transient Object watch ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Integer getCurrent ( ) { return current ; } public void setCurrent ( Integer current ) { logger . info ( ""<STR_LIT>"" + current + ""<STR_LIT>"" ) ; this . current = current ; } public void setFrom ( int from ) { this . from = from ; } public int getFrom ( ) { return from ; } public synchronized void run ( ) { if ( current == null ) {'}]",current = 1; } else { current++; } } },3.508580336236416e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> import java . io . * ; import org . kxml2 . io . * ; import org . xmlpull . v1 . * ; public class Roundtrip { XmlPullParser parser ; XmlSerializer serializer ; public Roundtrip ( XmlPullParser parser , XmlSerializer serializer ) { this . parser = parser ; this . serializer = serializer ; } public void writeStartTag ( ) throws XmlPullParserException , IOException { if ( ! parser . getFeature ( parser . FEATURE_REPORT_NAMESPACE_ATTRIBUTES ) ) { for ( int i = parser . getNamespaceCount ( parser . getDepth ( ) - <NUM_LIT:1> ) ; i < parser . getNamespaceCount ( parser . getDepth ( ) ) - <NUM_LIT:1> ; i ++ ) { serializer . setPrefix ( parser . getNamespacePrefix ( i ) , parser . getNamespaceUri ( i ) ) ; } } serializer . startTag ( parser . getNamespace ( ) , parser . getName ( ) ) ; for ( int i = <NUM_LIT:0> ; i < parser . getAttributeCount ( ) ; i ++ ) { serializer . attribute ( parser . getAttributeNamespace ( i ) , parser . getAttributeName ( i ) , parser . getAttributeValue ( i ) ) ; } } public void writeToken ( ) throws XmlPullParserException , IOException { switch ( parser . getEventType ( ) ) { case XmlPullParser . START_DOCUMENT : break ; case XmlPullParser . END_DOCUMENT : serializer . endDocument ( ) ; break ; case XmlPullParser . START_TAG : writeStartTag ( ) ; break ; case XmlPullParser . END_TAG : serializer . endTag ( parser . getNamespace ( ) , parser . getName ( ) ) ; break ; case XmlPullParser . IGNORABLE_WHITESPACE : serializer . ignorableWhitespace ( parser . getText ( ) ) ; break ; case XmlPullParser . TEXT : serializer . text ( parser . getText ( ) ) ; break ; case XmlPullParser . ENTITY_REF : serializer . entityRef ( parser . getName ( ) ) ; break ; case XmlPullParser . CDSECT : serializer . cdsect ( parser . getText ( ) ) ; break ; case XmlPullParser . PROCESSING_INSTRUCTION : serializer . processingInstruction ( parser . getText ( ) ) ; break ; case XmlPullParser . COMMENT : serializer . comment ( parser . getText ( ) ) ; break ; case XmlPullParser . DOCDECL : serializer . docdecl ( parser .'}]",getText()); break; default: break; } } },4.084683523770702e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . callhierarchy ; public class TreeRoot { public static final Object EMPTY_ROOT = new Object ( ) ;'}]","private final List<CallNode> nodes; private final Map<String, CallNode> nodeMap; public TreeRoot() { this(new ArrayList<>(), new HashMap<>()); } public TreeRoot(List<CallNode> nodes, Map<String, CallNode> nodeMap) { this.nodes = nodes; this.nodeMap = nodeMap; }",0.00010215337714914413
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow . graph ; import java . text . MessageFormat ; public class PortConnection { private final FlowElementOutput upstream ; private final FlowElementInput downstream ; private boolean connected ; PortConnection ( FlowElementOutput upstream , FlowElementInput downstream ) { if ( upstream == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( downstream == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } FlowElementPortDescription up = upstream . getDescription ( ) ; FlowElementPortDescription down = downstream . getDescription ( ) ; if ( down . getDataType ( ) . equals ( up . getDataType ( ) ) == false ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , up . getName ( ) , up . getDataType ( ) , down . getName ( ) , down . getDataType ( ) ) ) ; } this . upstream = upstream ; this . downstream = downstream ; } public static void connect ( FlowElementOutput upstream , FlowElementInput downstream ) { if ( upstream == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( downstream == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( isConnected ( upstream , downstream ) ) { return ; } connect0 ( upstream , downstream ) ; } private static boolean isConnected ( FlowElementOutput upstream , FlowElementInput downstream ) { assert upstream != null ; assert downstream != null ; if ( upstream'}]",".getClass().equals(downstream.getClass()) == false ) { return false ; } PortConnection pc = upstream.getConnection(); return pc!= null && pc.downstream.equals(downstream); } private static void connect0 ( FlowElementOutput upstream, FlowElementInput downstream ) { assert upstream!= null ; assert downstream!= null ; PortConnection pc = new PortConnection ( upstream, downstream ) ; upstream. setConnection ( pc ) ; downstream. setConnected ( true ) ; } }",0.00013872832575695203
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import java . util . ArrayList ; import org . eclipse . core . resources . IResource ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . Widget ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . ui . IWorkingCopyProvider ; import org . rubypeople . rdt . ui . ProblemsLabelDecorator . ProblemsLabelChangedEvent ; public class ProblemTreeViewer extends TreeViewer implements ResourceToItemsMapper . IContentViewerAccessor { protected ResourceToItemsMapper fResourceToItemsMapper ; public ProblemTreeViewer ( Composite parent ) { super ( parent ) ; initMapper ( ) ; } public ProblemTreeViewer ( Composite parent , int style ) { super ( parent , style ) ; initMapper ( ) ; } public ProblemTreeViewer ( Tree tree ) { super ( tree ) ; initMapper ( ) ; } public void doUpdateItem ( Widget item ) { doUpdateItem ( item , item . getData ( ) , true ) ; } private void initMapper ( ) { fResourceToItemsMapper = new ResourceToItemsMapper ( this ) ; } protected void mapElement ( Object element , Widget item ) { super . mapElement ( element , item ) ; if ( item instanceof Item ) { fResourceToItemsMapper . addToMap ( element , ( Item ) item ) ; } } protected void unmapElement ( Object element , Widget item ) { if ( item instanceof Item ) { fResourceToItemsMapper . removeFromMap ( element , ( Item ) item ) ; } super . unmapElement ( element , item ) ; } protected void unmapAllElements ( ) { fResourceToItemsMapper . clearMap ( ) ; super . unmapAllElements ( ) ; } protected void handleLabelProviderChanged ( LabelProviderChangedEvent event ) { if ( event instanceof ProblemsLabelChangedEvent ) { ProblemsLabelChangedEvent e = ( ProblemsLabelChangedEvent ) event ; if ( ! e . isMarkerChange ( ) && canIgnoreChangesFromAnnotionModel ( ) ) { return ; } } Object [ ] changed = addAditionalProblemParents ( event . getElements ( ) ) ; if ( changed != null && ! fResourceToItemsMapper . isEmpty ( ) ) { ArrayList others = new ArrayList ( ) ; for ( int i = <NUM_LIT:0> ; i < changed . length ; i ++ ) { Object curr = changed [ i ] ; if ( curr instanceof IResource ) { fResourceToItemsMapper . resourceChanged ( ( IResource ) curr ) ; } else { others . add ( curr ) ; } } if ( others . isEmpty ( ) ) { return ; } event = new LabelProviderChangedEvent ( ( IBaseLabelProvider ) event . getSource ( ) , others . toArray ( ) ) ; } else { if ( event . getElements ( ) != changed ) event = new LabelProviderChangedEvent ( ( IBaseLabelProvider ) event . getSource ( ) , changed ) ; } super . handleLabelProviderChanged ( event ) ; } private boolean canIgnoreChangesFromAnnotionModel ( ) { Object contentProvider = getContentProvider ( ) ; return contentProvider instanceof IWorkingCopyProvider && ! ( ( IWorkingCopyProvider ) contentProvider ) . providesWorkingCopies'}]",()),3.0009104105971185e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . vaadin . teemu . clara ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . teemu . clara . inflater . LayoutInflater ; import org . vaadin . teemu . clara . inflater . LayoutInflaterException ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; import com . vaadin . ui . VerticalLayout ; public class LayoutInflaterTest { private LayoutInflater inflater ; @ Before public void setUp ( ) { inflater = new LayoutInflater ( ) ; } private InputStream getXml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } @ Test public void inflate_singleButton_buttonInstantiated ( ) { Button button = ( Button ) inflater . inflate ( getXml ( ""<STR_LIT>"" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( ""<STR_LIT>"" , button . getCaption ( ) ) ; assertEquals ( true , button . isReadOnly ( ) ) ; } @ Test public void inflate_singleButtonNoNamespace_buttonInstantiated ( ) { Component button = inflater . inflate ( getXml ( ""<STR_LIT>"" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( ""<STR_LIT>"" , button . getCaption ( ) ) ; assertEquals ( true , button . isReadOnly ( ) ) ; } @ Test public void inflate_singleLayout_layoutWithMarginsInstantiated ( ) { Component layout = inflater . inflate ( getXml ( ""<STR_LIT>"" ) ) ; assertEquals ( com . vaadin . ui . VerticalLayout . class , layout . getClass ( ) ) ; assertTrue ( ( ( VerticalLayout ) layout ) . getMargin ( ) . hasTop ( ) ) ; assertFalse ( ( ( VerticalLayout ) layout ) . getMargin ( ) . hasRight ( ) ) ; assertFalse ( ( ( VerticalLayout ) layout ) . getMargin ( ) . hasBottom ( ) ) ; assertTrue ( ( ( VerticalLayout ) layout ) . getMargin ( ) . hasLeft ( ) ) ; } @ Test public void inflate_layoutAttributes_layoutAttributesApplied ( ) { Component layout = inflater . inflate ( getXml ( ""<STR_LIT>"" ) ) ; assertEquals ( com . vaadin . ui . VerticalLayout . class , layout . getClass ( ) ) ; VerticalLayout verticalLayout = ( VerticalLayout ) layout ; Component button = verticalLayout . getComponentIterator ( ) . next ( ) ; assertEquals ( <NUM_LIT:1.0f> , verticalLayout . getExpandRatio ( button ) , <NUM_LIT:0.0f> ) ; } @ Test public void inflate_componentHasWidth_widthAttributeApplied ( ) { Component layout = inflater . inflate ( getXml ( ""<STR_LIT>"" ) ) ; Button button200px = ( Button ) Clara . findComponentById ( layout , ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT> , button200px . getWidth ( ) , <NUM_LIT:0.0f> ) ; } @ Test public void inflate_addAttributeInterceptor_valueInterceptedCorrectly ( ) { LayoutInflater interceptingInflater = new LayoutInflater ( ) ; AttributeInterceptor interceptor = new AttributeInterceptor ( ) { @ Override public void intercept ( AttributeContext attributeContext ) { if ( attributeContext . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attributeContext . getValue ( ) ; if ( value . startsWith ( ""<STR_LIT>"" ) ) {'}]","attributeContext.setValue(""<STR_LIT>"");}}};interceptingInflater.addAttributeInterceptor(interceptor);Component component = interceptingInflater.inflate(getXml(""<STR_LIT>""));assertEquals(""<STR_LIT>"", component.getAttribute(""value""));}",9.035221938230555e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index . cache ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . RandomAccessFile ; public class BufferedRandomAccessFileWriter extends RandomAccessFile { public BufferedRandomAccessFileWriter ( File path'}]",") throws FileNotFoundException { super ( path, ""rw"" ) ; } public BufferedRandomAccessFileWriter ( String name, String mode ) throws FileNotFoundException { super ( name, mode ) ; } public BufferedRandomAccessFileWriter ( File path, String mode ) throws FileNotFoundException { super ( path, mode ) ; } public BufferedRandomAccessFileWriter ( String name, String mode, boolean create, boolean append ) throws FileNotFoundException { super ( name, mode, create, append ) ; } } public void setBuffer ( int size ) { super. setChannel ( getChannel ( ). wrap ( new sun. nio. ch. DirectBufferAllocator ( ). allocate ( size ) ) ) ; }",0.00019544783802231697
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages ; import java . util . ArrayList ; import java . util . Collection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . List ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; import org . jruby . ast . Node ; import org . rubypeople . rdt . core . formatter . ReWriteVisitor ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . core . mergeclasspartsinfile . MergeClassPartInFileConfig ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . PartialClassNodeWrapper ; import org . rubypeople . rdt . refactoring . ui . RdtCodeViewer ; import org . rubypeople . rdt . refactoring . ui . util . SwtUtils ; public class MergeClassPartsInFilePage extends RefactoringWizardPage { private static final String TITLE = Messages . MergeClassPartsInFilePage_SelectClassParts ; private RdtCodeViewer classView ; private String activeFileName ; private MergeClassPartInFileConfig config ; public MergeClassPartsInFilePage ( MergeClassPartInFileConfig config ) { super ( TITLE ) ; setTitle ( TITLE ) ; activeFileName = config . getDocumentProvider ( ) . getActiveFileName ( ) ; this . config = config ; } public void createControl ( Composite parent ) { Composite control = new Composite ( parent , SWT . NONE ) ; FillLayout baseLayout = new FillLayout ( ) ; baseLayout . spacing = <NUM_LIT:5> ; control . setLayout ( baseLayout ) ; initList ( control ) ; initSidePanel ( control ) ; setControl ( control ) ; } private void initSidePanel ( Composite control ) { Composite sidePanel = new Composite ( control , SWT . NONE ) ; FillLayout sidePanelLayout = new FillLayout ( SWT . VERTICAL ) ; sidePanelLayout . spacing = <NUM_LIT:5> ; sidePanel . setLayout ( sidePanelLayout ) ; String explTitle = Messages . MergeClassPartsInFilePage_Description ; String explText = Messages . MergeClassPartsInFilePage_Explanation ; SwtUtils . initExplanation ( sidePanel , explTitle , explText ) ; classView = RdtCodeViewer . create ( sidePanel ) ; } private void initList ( Composite control ) { Composite listSide = new Composite ( control , SWT . NONE ) ; FillLayout listSideLayout = new FillLayout ( SWT . VERTICAL ) ; listSideLayout . spacing = <NUM_LIT:5> ; listSide . setLayout ( listSideLayout ) ; final List classSelection = new List ( listSide , SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER | SWT . SINGLE ) ; final Collection < ClassNodeWrapper > selectableClasses = config . getSelectableClasses ( ) ; for ( ClassNodeWrapper currentClass : selectableClasses ) { classSelection . add ( currentClass . getName ( ) ) ; } final Table partTable = new Table ( listSide , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER | SWT . CHECK | SWT . SINGLE ) ; classSelection . addSelectionListener ( createClassSelectionListener ( classSelection , selectableClasses , partTable ) ) ; partTable . addListener ( SWT . Selection , createPartSelectionListener ( partTable ) ) ; } private Listener createPartSelectionListener ( final Table partTable ) { return new Listener ( ) { private void setClassView ( final Table partTable ) { TableItem selectedItem = partTable . getSelection ( ) [ <NUM_LIT:0> ] ; PartialClassNodeWrapper classPart = ( PartialClassNodeWrapper ) selectedItem . getData ( ) ; Node classNode = classPart . getWrappedNode ( ) ; classView . setPreviewText ( ReWriteVisitor . createCodeFromNode ( NodeFactory . createNewLineNode ( classNode ) , ""<STR_LIT>"" ) ) ; } public void handleEvent ( Event event ) { ArrayList < PartialClassNodeWrapper > checkedParts = new ArrayList < PartialClassNodeWrapper > ( ) ; for ( TableItem currentItem : partTable . getItems ( ) ) { if ( currentItem . getChecked ( ) ) {'}]","checkedParts.add((PartialClassNodeWrapper) currentItem.getData()); } config.setCheckedClassParts(checkedParts); setClassView(partTable); } }; } private Listener createClassSelectionListener(final List classSelection, final Collection<ClassNodeWrapper> selectableClasses, final Table partTable) { return new Listener() { public void handleEvent(Event event) { String selectedClass = classSelection.getSelection()[<NUM_LIT:0>]; ClassNodeWrapper classNodeWrapper = selectableClasses.stream().filter(classNode -> classNode.getName().equals(selectedClass)).findFirst().orElse(null); if (classNodeWrapper!= null) { partTable.removeAll(); for (ClassNodeWrapper currentClass : selectableClasses) { if (currentClass.getName().equals(selectedClass)) { continue; } TableItem item = new TableItem(partTable, SWT.CHECK); item.setText(currentClass.getName()); item.setData(new PartialClassNodeWrapper(currentClass)); } } } }; }",0.0002948424952382066
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io . sequencefile ; import java . io . Closeable ; import java . io . IOException ; import org . apache . hadoop . io . NullWritable ; import org . apache . hadoop . io . SequenceFile ; import com . asakusafw . runtime . io . ModelOutput ; public class SequenceFileModelOutput < T > implements ModelOutput < T > { private final SequenceFile . Writer writer ; private Closeable closeable ; public SequenceFileModelOutput ( SequenceFile . Writer writer ) { this ( writer , writer ) ; } public SequenceFileModelOutput ( SequenceFile . Writer writer , Closeable closeable ) { if ( writer == null ) { throw'}]","new IllegalArgumentException(""writer must not be null""); } this.writer = writer; this.closeable = closeable; } @Override public void close() throws IOException { if (closeable!= null) { closeable.close(); } } @Override public void write(T t) throws IOException { writer.append(new NullWritable(), t); } @Override public void write(T t, int repeat) throws IOException { for (int i = 0; i < repeat; i++) { write(t); } } @Override public void write(T t, long repeat) throws IOException { for (long i = 0; i < repeat; i++) { write(t); } } }",0.00018742737354630483
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . extractmethod . conditionchecks ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . IRefactoringContext ; import org . rubypeople . rdt . refactoring . core . RefactoringContext ; import org . rubypeople . rdt . refactoring . core . extractmethod . ExtractMethodConditionChecker ; import org . rubypeople . rdt . refactoring . core . extractmethod . ExtractMethodConfig ; import org . rubypeople . rdt . refactoring . core . extractmethod . MethodExtractor ; import org . rubypeople . rdt . refactoring . tests . FilePropertyData ; import org . rubypeople . rdt . refactoring . tests . FileTestData ; import org . rubypeople . rdt . refactoring . tests . RefactoringConditionTestCase ; public class ExtractMethodConditionTester extends RefactoringConditionTestCase { private FilePropertyData testData ; private ExtractMethodConfig config ; public ExtractMethodConditionTester ( String fileName ) { super ( fileName ) ; } @ Override public void runTest ( ) throws FileNotFoundException , IOException { testData = new FileTestData ( getName ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; IRefactoringContext selection = new RefactoringContext ( testData'}]",".getSelection() ); ExtractMethodConditionChecker checker = new ExtractMethodConditionChecker ( selection, config ); boolean result = checker.check ( testData ); printResult ( result ); } }",6.200218633785901e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . file . resource ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . OptionalDataException ; import com . asakusafw . windgate . core . resource . SourceDriver ; class FileSourceDriver < T > implements SourceDriver < T > { private final Class < T > type ; private final File file ; private ObjectInputStream input ; private boolean canGet ; private T next ; public FileSourceDriver ( Class < T > type , File file ) { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( file == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . type = type ; this . file = file ; } @ Override public void prepare ( ) throws IOException { boolean green = false ; FileInputStream in = new FileInputStream ( file ) ; try { this . input = new LoadingObjectInputStream ( in'}]","); green = true ; } finally { if (! green ) { in. close ( ) ; } } this. canGet = true ; } @ Override public T getNext ( ) throws IOException { if (! canGet ) { throw new IOException ( ""<STR_LIT>"" ) ; } try { return next = input. readObject ( ) ; } catch ( ClassNotFoundException e ) { throw new IOException ( e ) ; } catch ( OptionalDataException e ) { throw new IOException ( e ) ; } catch ( EOFException e ) { this. canGet = false ; return null ; } catch ( IOException e ) { throw new IOException ( e ) ; } } @ Override public void close ( ) throws IOException { if ( this. canGet ) { this. canGet = false ; this. input. close ( ) ; } } }",0.00023823635865275082
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . flow ; import com . asakusafw . compiler . flow . processor . ProjectFlowProcessor ; import com . asakusafw . compiler . flow . testing . external . Ex1MockExporterDescription ; import com . asakusafw . compiler . flow . testing . external . Part1MockImporterDescription ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Part1 ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ;'}]",import com.asakusafw.compiler.flow.testing.model.Part2;,3.708035947145144e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl ; import java . text . MessageFormat ; import com . asakusafw . dmdl . model . AstNode ; public class Diagnostic { public final Diagnostic . Level level ; public final String message ; public final Region region ; public Diagnostic ( Diagnostic . Level level , Region region , String message , Object ... arguments ) { if ( level == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; }'}]","this.level = level; this.region = region; this.message = MessageFormat.format(message, arguments); } public Diagnostic(Level level, String message, Object... arguments) { this(level, null, message, arguments); } public enum Level { ERROR, WARNING, INFO } public static class Region { private final int start; private final int end; public Region(int start, int end) { if (start < 0 || end < 0 || start > end) { throw new IllegalArgumentException(""<STR_LIT>""); } this.start = start; this.end = end; } //... }",0.00016773629476186597
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import org . rubypeople . rdt . core . IRubyElement ; public class'}]",RubySearchUI { private IRubyElement element; public RubySearchUI(IRubyElement element) { this.element = element; } public void search() { // implementation } },6.0243889624167646e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . mapgen ; import junit . framework . TestCase ; public class IRIEncoderTest extends TestCase { public void testDontEncodeAlphanumeric ( ) { assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; } public void testDontEncodeSafePunctuation ( ) { assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; } public void testDontEncodeUnicodeChars ( ) { assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; } public void testEncodeGenDelims ( ) { assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; } public void testEncodeSubDelims ( ) { assertEquals ( ""<STR_LIT>"" , IRIEncoder . encode ( ""<STR_LIT>"" ) ) ; } public void testEncodePercentSign ( ) { assertEquals ( ""<STR_LIT>""'}]",", IRIEncoder.encode(""%"")); } }",3.15650529785614e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . launching ; import java . io . File ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . variables . VariablesPlugin ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . model . LaunchConfigurationDelegate ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . launching . LaunchingMessages ; import org . rubypeople . rdt . internal . launching . LaunchingPlugin ; public abstract class AbstractRubyLaunchConfigurationDelegate extends LaunchConfigurationDelegate { protected void abort ( String message , Throwable exception , int code ) throws CoreException { throw new CoreException ( new Status ( IStatus . ERROR , LaunchingPlugin . getUniqueIdentifier ( ) , code , message , exception ) ) ; } public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { String arguments = configuration . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_VM_ARGUMENTS , ""<STR_LIT>"" ) ; String args = VariablesPlugin . getDefault ( ) . getStringVariableManager ( ) . performStringSubstitution ( arguments ) ; return args ; } public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { String arguments = configuration . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_PROGRAM_ARGUMENTS , ""<STR_LIT>"" ) ; return VariablesPlugin . getDefault ( ) . getStringVariableManager ( ) . performStringSubstitution ( arguments ) ; } public String [ ] getEnvironment ( ILaunchConfiguration configuration ) throws CoreException { return DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getEnvironment ( configuration ) ; } public File verifyWorkingDirectory ( ILaunchConfiguration configuration ) throws CoreException { IPath path = getWorkingDirectoryPath ( configuration ) ; if ( path == null ) { File dir = getDefaultWorkingDirectory ( configuration ) ; if ( dir != null ) { if ( ! dir . isDirectory ( ) ) { abort ( MessageFormat . format ( LaunchingMessages . AbstractJavaLaunchConfigurationDelegate_Working_directory_does_not_exist___0__12 , dir . toString ( ) ) , null , IRubyLaunchConfigurationConstants . ERR_WORKING_DIRECTORY_DOES_NOT_EXIST ) ; } return dir ; } } else { if ( path . isAbsolute ( ) ) { File dir = new File ( path . toOSString ( ) ) ; if ( dir . isDirectory ( ) ) { return dir ; } IResource res = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . findMember ( path ) ; if ( res instanceof IContainer && res . exists ( ) ) { return res . getLocation ( ) . toFile ( ) ; } abort ( MessageFormat . format ( LaunchingMessages . AbstractJavaLaunchConfigurationDelegate_Working_directory_does_not_exist___0__12 , path . toString ( ) ) , null , IRubyLaunchConfigurationConstants . ERR_WORKING_DIRECTORY_DOES_NOT_EXIST ) ; } else { IResource res = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . findMember ( path ) ; if ( res instanceof IContainer && res . exists ( ) ) { return res . getLocation ( ) . toFile ( ) ; } abort ( MessageFormat . format ( LaunchingMessages . AbstractJavaLaunchConfigurationDelegate_Working_directory_does_not_exist___0__12 , path . toString ( ) ) , null , IRubyLaunchConfigurationConstants . ERR_WORKING_DIRECTORY_DOES_NOT_EXIST ) ; } } return null ; } public IPath getWorkingDirectoryPath ( ILaunchConfiguration configuration ) throws CoreException { String path = configuration . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , ( String ) null ) ; if ( path != null && path . length ( ) > <NUM_LIT:0> ) { path = VariablesPlugin . getDefault ( ) . getStringVariableManager ( ) . performStringSubstitution ( path ) ; return new Path ( path ) ; } return null ; } protected File getDefaultWorkingDirectory ( ILaunchConfiguration configuration ) throws CoreException { IRubyProject rp = getRubyProject ( configuration ) ; if ( rp != null ) { IProject p = rp . getProject ( ) ; return p . getLocation ( ) . toFile ( ) ; } return null ; } public IRubyProject getRubyProject ( ILaunchConfiguration configuration ) throws CoreException { String projectName = getRubyProjectName ( configuration ) ; if ( projectName != null ) { projectName = projectName . trim ( ) ; if ( projectName . length ( ) > <NUM_LIT:0> ) { IProject project = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( projectName ) ; IRubyProject rubyProject = RubyCore . create ( project ) ; if ( rubyProject != null && rubyProject . exists ( ) ) { return rubyProject ; } } } return null ; } public String getRubyProjectName ( ILaunchConfiguration configuration ) throws CoreException { return configuration . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; } public Map getVMSpecificAttributesMap ( ILaunchConfiguration configuration ) throws CoreException { Map map = configuration . getAttribute ( IRubyLaunchConfigurationConstants . ATTR_VM_INSTALL_TYPE_SPECIFIC_ATTRS_MAP , ( Map ) null ) ; return map ; } public IVMRunner getVMRunner ( ILaunchConfiguration configuration , String mode ) throws CoreException { IVMInstall vm = verifyVMInstall ( configuration ) ; IVMRunner runner = vm .'}]",createVMRunner(mode); return runner; },1.867717170948845e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . sql . SQLException ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . OddjobSessionFactory ; import org . oddjob . Structural ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . life . ArooaSessionAware ; import org . oddjob . arooa . life . ComponentPersistException ; import org . oddjob . arooa . life . ComponentPersister ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . io . BufferType ; import org . oddjob . persist . OddjobPersister ; import org . oddjob . persist . SilhouetteFactory ; import org . oddjob . state . JobState ; import org . oddjob . state . ParentState ; public class SQLSilhouettesServiceTest extends TestCase { private static final Logger logger = Logger . getLogger ( SQLSilhouettesServiceTest . class ) ; ConnectionType ct ; @ Override protected void setUp ( ) throws Exception { logger . debug ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; ct = new ConnectionType ( ) ; ct . setDriver ( ""<STR_LIT>"" ) ; ct . setUrl ( ""<STR_LIT>"" ) ; ct . setUsername ( ""<STR_LIT>"" ) ; ct . setPassword ( ""<STR_LIT>"" ) ; BufferType buffer = new BufferType ( ) ; buffer . setText ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; buffer . configured ( ) ; SQLJob sql = new SQLJob ( ) ; sql . setArooaSession ( new StandardArooaSession ( ) ) ; sql . setInput ( buffer . toInputStream ( ) ) ; sql . setConnection ( ct . toValue ( ) ) ; sql . run ( ) ; } @ Override protected void tearDown ( ) throws Exception { BufferType buffer = new BufferType ( ) ; buffer . setText ( ""<STR_LIT>"" ) ; buffer . configured ( ) ; SQLJob sql = new SQLJob ( ) ; sql . setArooaSession ( new StandardArooaSession ( ) ) ; sql . setInput ( buffer . toInputStream ( ) ) ; sql . setConnection ( ct . toValue ( ) ) ; sql . run ( ) ; } public static class SessionCapture implements ArooaSessionAware { ArooaSession arooaSession ; @ Override public void setArooaSession ( ArooaSession session ) { this . arooaSession = session ; } public ArooaSession getArooaSession ( ) { return arooaSession ; } } public void testArchiveAndRestore ( ) throws ArooaPropertyException , ArooaConversionException , SQLException , ComponentPersistException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . run ( ) ; assertEquals ( ParentState . COMPLETE , oddjob . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; SQLPersisterService test = new SQLPersisterService ( ) ; test . setConnection ( ct . toValue ( ) ) ; test . start ( ) ; OddjobPersister archiver = test . getPersister ( null ) ; ComponentPersister'}]","restorer = archiver. getRestorer ( null ) ; archiver. archive ( ) ; restorer. restore ( ) ; assertEquals ( ParentState. COMPLETE, oddjob. lastStateEvent ( ). getState ( ) ) ; } }",9.613045689384295e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . directio ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . apache . hadoop . io . Text ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import org . junit . runner . RunWith ; import org . junit . runners . Parameterized ; import org . junit . runners . Parameterized . Parameters ; import com . asakusafw . compiler . directio . testing . model . Line1 ; import com . asakusafw . compiler . directio . testing . model . Line2 ; import com . asakusafw . compiler . flow . FlowCompilerOptions ; import com . asakusafw . compiler . flow . FlowDescriptionDriver ; import com . asakusafw . compiler . flow . Location ; import com . asakusafw . compiler . testing . DirectExporterDescription ; import com . asakusafw . compiler . testing . DirectFlowCompiler ; import com . asakusafw . compiler . testing . DirectImporterDescription ; import com . asakusafw . compiler . testing . JobflowInfo ; import com . asakusafw . runtime . directio . BinaryStreamFormat ; import com . asakusafw . runtime . directio . DataFormat ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . vocabulary . directio . DirectFileInputDescription ; import com . asakusafw . vocabulary . directio . DirectFileOutputDescription ; import com . asakusafw . vocabulary . external . ImporterDescription . DataSize ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; @ RunWith ( Parameterized . class ) public class DirectFileIoProcessorTest { @ Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; private final Class < ? extends DataFormat < Text > > format ; @ Parameters public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { LineFormat . class } , { LineFileFormat . class } , } ) ; } public DirectFileIoProcessorTest ( Class < ? extends DataFormat < Text > > format ) { this . format = format ; } @ Test public void validate ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_dual ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in1 = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" , DataSize . LARGE ) ) ; In < Line2 > in2 = flow . createIn ( ""<STR_LIT>"" , new Input ( Line2 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" , DataSize . TINY ) ) ; Out < Line1 > out1 = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line2 > out2 = flow . createOut ( ""<STR_LIT>"" , new Output ( Line2 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new DualIdentityFlow < Line1 , Line2 > ( in1 , in2 , out1 , out2 ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_no_input ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new DirectImporterDescription ( Line1 . class , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_no_output ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new DirectExporterDescription ( Line1 . class , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_input_tiny ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" , DataSize . TINY ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_input_variable ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_pattern ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_variable ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_wildcard ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_asc ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_desc ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_complexorder ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_delete ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) . delete ( ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void validate_output_complexdelete ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) . delete ( ""<STR_LIT>"" ) . delete ( ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void invalid_input_resource ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT:?>"" , DataSize . UNKNOWN ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void no_input_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , null , ""<STR_LIT>"" , ""<STR_LIT:*>"" , DataSize . UNKNOWN ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_input_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , PrivateFormat . class , ""<STR_LIT>"" , ""<STR_LIT:*>"" , DataSize . UNKNOWN ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void inconsistent_input_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( Line1 . class , VoidFormat . class , ""<STR_LIT>"" , ""<STR_LIT:*>"" , DataSize . UNKNOWN ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_resource ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT:?>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_order ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:?>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_wildcard_and_property ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_wildcard_and_random ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_wildcard_and_order ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , format , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_delete ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) . delete ( ""<STR_LIT:?>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void no_output_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , null , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void invalid_output_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , PrivateFormat . class , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void inconsistent_output_format ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( Line1 . class , VoidFormat . class , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void input_conflict_output ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void input_contains_output ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( not ( nullValue ( ) ) ) ) ; } @ Test public void output_contains_input ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new IdentityFlow < Line1 > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void output_conflict_output ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in1 = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; In < Line1 > in2 = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out1 = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out2 = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; FlowDescription desc = new DualIdentityFlow < Line1 , Line1 > ( in1 , in2 , out1 , out2 ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , is ( nullValue ( ) ) ) ; } @ Test public void output_common_prefix ( ) { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Line1 > in1 = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; In < Line1 > in2 = flow . createIn ( ""<STR_LIT>"" , new Input ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out1 = flow . createOut ( ""<STR_LIT>"" , new Output ( format , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; Out < Line1 > out2 = flow . createOut ( ""<STR_LIT>""'}]","public JobflowInfo compile(FlowDescriptionDriver flow, FlowDescription desc) { return new DirectFlowCompiler().compile(flow, desc); }",0.0001785884598473286
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . launcher ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . Path ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Display ; import org . rubypeople . eclipse . shams . debug . core . ShamLaunchConfigurationWorkingCopy ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . tests . ModifyingResourceTest ; import org . rubypeople . rdt . internal . debug . ui . RdtDebugUiMessages ; import org . rubypeople . rdt . launching . IRubyLaunchConfigurationConstants ; public'}]",class RubyLaunchConfigurationWizard extends org.eclipse.ui.wizards.newresource.BasicNewResourceProjectWizard {... },4.4236600539181705e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import org . rubypeople . rdt . core . IRubyElementDelta ; public class SimpleDelta { protected int kind = <NUM_LIT:0> ; protected int changeFlags = <NUM_LIT:0> ; public void added ( ) { this . kind = IRubyElementDelta . ADDED ; } public void changed ( int flags ) { this . kind = IRubyElementDelta . CHANGED ; this . changeFlags |= flags ; } public int getFlags ( ) { return this . changeFlags ; } public int getKind ( ) { return this . kind ; } public void modifiers ( ) { changed ( IRubyElementDelta . F_MODIFIERS ) ; } public void removed ( ) { this . kind = IRubyElementDelta . REMOVED ; this . changeFlags = <NUM_LIT:0> ; } public void superTypes ( ) { changed ( IRubyElementDelta . F_SUPER_TYPES ) ; } protected void toDebugString ( StringBuffer buffer ) { buffer . append ( ""<STR_LIT:[>"" ) ; switch ( getKind ( ) ) { case IRubyElementDelta . ADDED : buffer . append ( \'<CHAR_LIT>\' ) ; break ; case IRubyElementDelta . REMOVED : buffer . append ( \'<CHAR_LIT:->\' ) ; break ; case IRubyElementDelta . CHANGED : buffer . append ( \'<CHAR_LIT>\' ) ; break ; default : buffer . append ( \'<CHAR_LIT>\' ) ; break ; } buffer . append ( ""<STR_LIT>"" ) ; toDebugString ( buffer , getFlags ( ) ) ; buffer . append ( ""<STR_LIT:}>"" ) ; } protected boolean toDebugString ( StringBuffer buffer ,'}]","int flags ) { if ( flags == 0 ) { return ; } buffer. append ( ""<STR_LIT: flags={"" ) ; int f = flags ; while ( f > 0 ) { if ( ( f & 1 ) == 1 ) { switch ( f & 3 ) { case 1 : buffer. append ( ""<STR_LIT:F_MODIFIERS"" ) ; break ; case 2 : buffer. append ( ""<STR_LIT:F_SUPER_TYPES"" ) ; break ; case 3 : buffer. append ( ""<STR_LIT:F_METHODS"" ) ; break ; case 0 : buffer. append ( ""<STR_LIT:F_FIELDS"" ) ; break ; } } f >>>= 2 ; } buffer. append ( ""<STR_LIT}>"" ) ; }",0.000234059002299636
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui ; import java . io . IOException ; import java . util . Iterator ; import java . util . Properties ; import net . ggtools . grand . Configuration ; import net . ggtools . grand . log . LoggerManager ; import net . ggtools . grand . ui . log . CommonsLoggingLoggerFactory ; import net . ggtools . grand . ui . widgets . ExceptionDialog ; import net . ggtools . grand . ui . widgets . GraphWindow ; import net . ggtools . grand . ui . widgets . Splash ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jface . resource . FontRegistry ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . jface . window . ApplicationWindow ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; public class Application implements Runnable { final public static String ABOUT_DIALOG_IMAGE = ""<STR_LIT>"" ; final public static String APPLICATION_ICON = ""<STR_LIT>"" ; final public static String GRAPH_FONT = ""<STR_LIT>"" ; final public static String LINK_FONT = ""<STR_LIT>"" ; final public static String LINK_ICON = ""<STR_LIT>"" ; final public static String MONOSPACE_FONT = ""<STR_LIT>"" ; final public static String NODE_FONT = ""<STR_LIT>"" ; final public static String NODE_ICON = ""<STR_LIT>"" ; final public static String TOOLTIP_FONT = ""<STR_LIT>"" ; final public static String TOOLTIP_MONOSPACE_FONT = ""<STR_LIT>"" ; private static final Log log = LogFactory . getLog ( Application . class ) ; private static Application singleton ; static public Application getInstance ( ) { return singleton ; } public static void main ( final String [ ] args ) { try { Thread . currentThread ( ) . setName ( ""<STR_LIT>"" ) ; final Application application = new Application ( ) ; application . run ( ) ; } catch ( final Throwable e ) { log . fatal ( ""<STR_LIT>"" , e ) ; } log . info ( ""<STR_LIT>"" ) ; System . exit ( <NUM_LIT:0> ) ; } final private Properties buildProperties ; private FontRegistry fontRegistry ; private ImageRegistry imageRegistry ; private GrandUiPrefStore preferenceStore ;'}]",private Display display;,3.102525438738419e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . operator ; import javax . annotation . Generated ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . vocabulary . flow . Operator ; import com . asakusafw . vocabulary . flow . Source ; import com . asakusafw . vocabulary . flow . graph . FlowElementResolver ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription ; import com . asakusafw . vocabulary . operator . Update ; @ Generated ( ""<STR_LIT>"" ) public class UpdateFlowFactory { public static final class Simple implements Operator { public final Source < Ex1 > out ; Simple ( Source < Ex1 > model ) { OperatorDescription . Builder builder = new OperatorDescription . Builder ( Update . class ) ; builder . declare ( UpdateFlow . class , UpdateFlowImpl . class , ""<STR_LIT>"" ) ; builder . declareParameter ( Ex1 . class ) ; builder . addInput ( ""<STR_LIT>"" , Ex1 . class ) ; builder . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; FlowElementResolver resolver = builder . toResolver ('}]",); out = resolver.resolveSource(Ex1.class); } },3.616446715324707e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . compare ; import java . util . Map ; import java . util . ResourceBundle ; import org . eclipse . compare . CompareConfiguration ; import org . eclipse . compare . CompareViewerPane ; import org . eclipse . compare . IResourceProvider ; import org . eclipse . compare . ITypedElement ; import org . eclipse . compare . structuremergeviewer . DiffNode ; import org . eclipse . compare . structuremergeviewer . Differencer ; import org . eclipse . compare . structuremergeviewer . ICompareInput ; import org . eclipse . compare . structuremergeviewer . IDiffContainer ; import org . eclipse . compare . structuremergeviewer . StructureDiffViewer ; import org . eclipse . core . resources . IResource ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . ToolBarManager ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . ToolBar ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; class RubyStructureDiffViewer extends StructureDiffViewer { static class ChangePropertyAction extends Action { private CompareConfiguration fCompareConfiguration ; private String fPropertyKey ; private ResourceBundle fBundle ; private String fPrefix ; public ChangePropertyAction ( ResourceBundle bundle , CompareConfiguration cc , String rkey , String pkey ) { fPropertyKey = pkey ; fBundle = bundle ; fPrefix = rkey ; RubyCompareUtilities . initAction ( this , fBundle , fPrefix ) ; setCompareConfiguration ( cc ) ; } public void run ( ) { boolean b = ! RubyCompareUtilities . getBoolean ( fCompareConfiguration , fPropertyKey , false ) ; setChecked ( b ) ; if ( fCompareConfiguration != null ) fCompareConfiguration . setProperty ( fPropertyKey , new Boolean ( b ) ) ; } public void setChecked ( boolean state ) { super . setChecked ( state ) ; RubyCompareUtilities . initToggleAction ( this , fBundle , fPrefix , state ) ; } public void setCompareConfiguration ( CompareConfiguration cc ) { fCompareConfiguration = cc ; setChecked ( RubyCompareUtilities . getBoolean ( fCompareConfiguration , fPropertyKey , false ) ) ; } } private static final String SMART = ""<STR_LIT>"" ; private ActionContributionItem fSmartActionItem ; private RubyStructureCreator fStructureCreator ; private boolean fThreeWay ; public RubyStructureDiffViewer ( Composite parent , CompareConfiguration configuration ) { super ( parent , configuration ) ; fStructureCreator = new RubyStructureCreator ( ) ; setStructureCreator ( fStructureCreator ) ; } protected void initialSelection ( ) { Object firstClass = null ; Object o = getRoot ( ) ; if ( o != null ) { Object'}]","firstClass = o; } if ( firstClass instanceof DiffNode ) { DiffNode diffNode = ( DiffNode ) firstClass; if ( diffNode. getChildren ( ). size ( ) > 1 ) { setSelection ( diffNode. getChildren ( ). get ( 1 ) ) ; } } } @Override protected void createActions ( ) { super. createActions ( ) ; ToolBarManager toolBarManager = getToolBarManager ( ) ; if ( toolBarManager!= null ) { toolBarManager. add ( new Action ( SMART ) { @Override public void run ( ) { if ( getViewerInput ( ) instanceof IDiffContainer ) { IDiffContainer diffContainer = ( IDiffContainer ) getViewerInput ( ) ; if ( diffContainer. getDiff ( )!= null ) { fThreeWay = true ; } else { fThreeWay = false ; } } } } ) ; fSmartActionItem = new ActionContributionItem ( new ChangePropertyAction ( ResourceBundle. getBundle ( SMART ), getCompareConfiguration ( ), SMART, SMART ) ) ; toolBarManager. add ( fSmartActionItem ) ; } } @Override protected void configureToolBar ( ToolBar toolBar ) { super. configureToolBar (",0.00037517653464612345
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import java . util . List ; import com . asakusafw . utils . java . model . syntax . Attribute ; import com . asakusafw . utils . java . model . syntax . EnumConstantDeclaration ; import com . asakusafw . utils . java . model . syntax . EnumDeclaration ; import com . asakusafw . utils . java . model . syntax . Javadoc ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . TypeBodyDeclaration ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class EnumDeclarationImpl extends ModelRoot implements EnumDeclaration { private Javadoc javadoc ; private List < ? extends Attribute > modifiers ; private SimpleName name ; private List < ? extends Type > superInterfaceTypes ; private List < ? extends EnumConstantDeclaration > constantDeclarations ; private List < ? extends TypeBodyDeclaration > bodyDeclarations ; @ Override public Javadoc getJavadoc ( ) { return this . javadoc ; } public void setJavadoc ( Javadoc javadoc ) { this . javadoc = javadoc ; } @ Override public List < ? extends Attribute > getModifiers ( ) { return this . modifiers ; } public void setModifiers ( List < ? extends Attribute > modifiers ) { Util . notNull ( modifiers , ""<STR_LIT>"" ) ; Util . notContainNull ( modifiers , ""<STR_LIT>"" ) ; this . modifiers = Util . freeze ( modifiers ) ; } @ Override public SimpleName getName ( ) { return this . name ; } public void setName ( SimpleName name ) { Util . notNull ( name , ""<STR_LIT:name>"" ) ; this . name = name ; } @ Override public List < ? extends Type > getSuperInterfaceTypes ( ) { return this . superInterfaceTypes ; } public void setSuperInterfaceTypes ( List < ? extends Type > superInterfaceTypes ) { Util . notNull ( superInterfaceTypes , ""<STR_LIT>"" ) ;'}]","Util. notContainNull ( superInterfaceTypes, ""<STR_LIT>"" ) ; this. superInterfaceTypes = Util. freeze ( superInterfaceTypes ) ; } @ Override public List <? extends EnumConstantDeclaration > getConstantDeclarations ( ) { return this. constantDeclarations ; } public void setConstantDeclarations ( List <? extends EnumConstantDeclaration > constantDeclarations ) { Util. notNull ( constantDeclarations, ""<STR_LIT>"" ) ; Util. notContainNull ( constantDeclarations, ""<STR_LIT>"" ) ; this. constantDeclarations = Util. freeze ( constantDeclarations ) ; } @ Override public List <? extends TypeBodyDeclaration > getBodyDeclarations ( ) { return this. bodyDeclarations ; } public void setBodyDeclarations ( List <? extends TypeBodyDeclaration > bodyDeclarations ) { Util. notNull ( bodyDeclarations, ""<STR_LIT>"" ) ; Util. notContainNull ( bodyDeclarations, ""<STR_LIT>"" ) ; this. bodyDeclarations = Util. freeze ( bodyDeclarations ) ; } @ Override public < R > R accept ( Visitor < R > visitor ) { return visitor. visit ( this ) ; } }",0.00035054902125203607
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . value ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . text . MessageFormat ; import org . apache . hadoop . io . WritableComparator ; import com . asakusafw . runtime . io . util . WritableRawComparable ; public final class IntOption extends ValueOption < IntOption > { private int value ; public IntOption ( ) { this . nullValue = true ; } public IntOption ( int value ) { this . nullValue = false ; this . value = value ; } public int get ( ) { if ( nullValue ) { throw new NullPointerException ( ) ; } return value ; } public int or ( int alternate ) { if ( nullValue ) { return alternate ; } return value ; } public void add ( int delta ) { if ( nullValue ) { throw new NullPointerException ( ) ; } this . value += delta ; } public void add ( IntOption other ) { if ( nullValue ) { throw new NullPointerException ( ) ; } if ( other . nullValue ) { return ; } this . value += other . value ; } @ Deprecated public IntOption modify ( int newValue ) { this . nullValue = false ; this . value = newValue ; return this ; } @ Override @ Deprecated public void copyFrom ( IntOption optionOrNull ) { if ( optionOrNull == null || optionOrNull . nullValue ) { this . nullValue = true ; } else { this . nullValue = false ; this . value = optionOrNull . value ; } } @ Override public int hashCode ( ) { final int prime ='}]","31; int result = 1; result = prime * result + ((this.nullValue? 1 : 0) + (this.value == null? 0 : this.value.hashCode())); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass()!= obj.getClass()) return false; IntOption other = (IntOption) obj; if (nullValue == other.nullValue) { if (value == null) { return value == other.value; } else { return value.equals(other.value); } } return false; } @Override public String toString() { return MessageFormat.format(""IntOption[nullValue={0}, value={1}]"", nullValue, value); } @Override public void readFields(DataInput in) throws IOException { this.nullValue = in.readBoolean(); if (!this.nullValue) { this.value = in.readInt(); } } @Override public void write(DataOutput out) throws IOException { out.writeBoolean(nullValue); if (!nullValue) { out.writeInt(value); } } @Override public int compareTo(WritableRawComparable other) throws IOException { if (other == null) { throw new NullPointerException(); } if (nullValue && ((other instanceof Int",0.00034758851828796834
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . collections ; public class Tuple2 < T1 , T2 > { public final T1 first ; public final T2 second ; public Tuple2 ( T1 first , T2 second ) { this . first = first ; this . second = second ; } public static < T1 , T2 > Tuple2 < T1 , T2 > of ( T1 first , T2 second ) { return new Tuple2 < T1 , T2 > ( first , second ) ; } @ Override public int hashCode ( ) { final int'}]","prime = 31 ; int result = 1 ; result = ( result * 31 ) + ( first!= null? first. hashCode ( ) : 0 ) ; result = ( result * 31 ) + ( second!= null? second. hashCode ( ) : 0 ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null || getClass ( )!= obj. getClass ( ) ) return false ; Tuple2 <?,? > other = ( Tuple2 <?,? > ) obj ; return first. equals ( other. first ) && second. equals ( other. second ) ; } public String toString ( ) { return ""("" + first + "", "" + second + "")"" ; } }",0.00022156087798361592
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FSDataInputStream ; import org . apache . hadoop . fs . FileStatus ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . Text ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . runtime . core . context . RuntimeContext . ExecutionMode ; import com . asakusafw . runtime . core . context . RuntimeContextKeeper ; import com . asakusafw . runtime . core . context . SimulationSupport ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . stage . temporary . TemporaryStorage ; import com . asakusafw . windgate . core . DriverScript ; import com . asakusafw . windgate . core . GateScript ; import com . asakusafw . windgate . core . ParameterList ; import com . asakusafw . windgate . core . ProcessScript ; import com . asakusafw . windgate . core . resource . DrainDriver ; import com . asakusafw . windgate . core . resource . SourceDriver ; import com . asakusafw . windgate . core . vocabulary . FileProcess ; public class AbstractSshHadoopFsMirrorTest { @ Rule public final RuntimeContextKeeper rc = new RuntimeContextKeeper ( ) ; @ Rule public final TemporaryFolder folder = new TemporaryFolder ( ) ; private final SshProfile profile ; { Map < String , String > emptyMap = Collections . emptyMap ( ) ; profile = new SshProfile ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:user>"" , ""<STR_LIT>"" , <NUM_LIT:0> , ""<STR_LIT:id>"" , ""<STR_LIT>"" , null , emptyMap ) { @ Override public String getGetCommand ( ) { return ""<STR_LIT:get>"" ; } @ Override public String getPutCommand ( ) { return ""<STR_LIT>"" ; } @ Override public String getDeleteCommand ( ) { return ""<STR_LIT>"" ; } } ; } volatile List < String > lastCommand ; volatile File stdIn ; volatile File stdOut ; volatile int exit = - <NUM_LIT:1> ; @ Test public void drain ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; try { driver . prepare ( ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } assertThat ( lastCommand , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; Map < String , List < String > > results = read ( stdIn ) ; assertThat ( results . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( results . get ( ""<STR_LIT>"" ) , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; } @ Test public void drain_parameter ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( Collections . singletonMap ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; try { driver . prepare ( ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } assertThat ( lastCommand , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; Map < String , List < String > > results = read ( stdIn ) ; assertThat ( results . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( results . get ( ""<STR_LIT>"" ) , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; } @ Test public void drain_multiple ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; try { driver . prepare ( ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } Map < String , List < String > > results = read ( stdIn ) ; assertThat ( results . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( results . get ( ""<STR_LIT>"" ) , is ( Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ) ; } @ Test public void drain_nullpath ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , null ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; driver . close ( ) ; fail ( ) ; } catch ( IOException e ) { } finally { resource . close ( ) ; } } @ Test public void drain_nopath ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; driver . close ( ) ; fail ( ) ; } catch ( IOException e ) { } finally { resource . close ( ) ; } } @ Test public void drain_invalid_parameter ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( Collections . singletonMap ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; driver . close ( ) ; fail ( ) ; } catch ( IOException e ) { } finally { resource . close ( ) ; } } @ Test ( expected = IOException . class ) public void drain_processfailed ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:1> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; try { driver . prepare ( ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } } @ Test public void drain_sim ( ) throws Exception { RuntimeContext . set ( RuntimeContext . DEFAULT . mode ( ExecutionMode . SIMULATION ) ) ; stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { assertThat ( RuntimeContext . get ( ) . canExecute ( resource ) , is ( true ) ) ; ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; DrainDriver < Text > driver = resource . createDrain ( proc ) ; try { assertThat ( RuntimeContext . get ( ) . canExecute ( driver ) , is ( true ) ) ; driver . prepare ( ) ; driver . put ( new Text ( ""<STR_LIT>"" ) ) ; } finally { driver . close ( ) ; } } finally { resource . close ( ) ; } assertThat ( lastCommand , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; Map < String , List < String > > results = read ( stdIn ) ; assertThat ( results . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( results . get ( ""<STR_LIT>"" ) , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; } @ Test public void source ( ) throws Exception { stdIn = folder . newFile ( ""<STR_LIT>"" ) ; stdOut = folder . newFile ( ""<STR_LIT>"" ) ; exit = <NUM_LIT:0> ; FileOutputStream output = new FileOutputStream ( stdOut ) ; try { FileList . Writer writer = FileList . createWriter ( output ) ; put ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; writer . close ( ) ; } finally { output . close ( ) ; } List < String > results = new ArrayList < String > ( ) ; MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror ( new Configuration ( ) , profile , new ParameterList ( ) ) ; try { ProcessScript < Text > proc = p ( ""<STR_LIT:p>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; resource . prepare ( script ( proc ) ) ; SourceDriver < Text > driver = resource'}]",".createSource(proc); try { driver.prepare(); InputStream inputStream = new FileInputStream(stdIn); ZipEntryInputStream zipInputStream = new ZipEntryInputStream(inputStream); Text text = new Text(zipInputStream.read()); results.add(text.toString()); } finally { driver.close(); } } @Test public void source_parameter() throws Exception { stdIn = folder.newFile(""<STR_LIT>""); stdOut = folder.newFile(""<STR_LIT>""); exit = <NUM_LIT:0>; FileOutputStream output = new FileOutputStream(stdOut); try { FileList.Writer writer = FileList.createWriter(output); put(writer, ""<STR_LIT>"", ""<STR_LIT>""); writer.close(); } finally { output.close(); } List<String> results = new ArrayList<String>(); MockSshHadoopFsMirror resource = new MockSshHadoopFsMirror(new Configuration(), profile, new ParameterList(Collections.singletonMap(""<STR_LIT>"", ""<STR_LIT>""))); try { ProcessScript<Text> proc = p(""<STR_LIT:p>"", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>""); resource.prepare(script(proc)); SourceDriver<Text> driver = resource.createSource(proc); try { driver.prepare(); InputStream inputStream = new FileInputStream(stdIn); ZipEntryInputStream zip",0.0004975415558539129
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . encapsulatefield . conditionchecks ; import junit . framework . Test ; import org . rubypeople . rdt'}]",.refactoring.core.enhance.EnhanceFieldTest; public class EncapsulateFieldConditionChecksTest { @Test public void testEncapsulateField () throws Exception { new EnhanceFieldTest (). testEncapsulateField (); } },7.547893634793652e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . workingsets ;'}]",import java.util.List;,2.153795941489127e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . connect ; import org . springframework . social . connect . ApiAdapter ; import org . springframework . social . connect . ConnectionValues ; import org . springframework . social . connect . UserProfile ; import org . springframework . social . connect . UserProfileBuilder ; import org . springframework . social . google . api . Google ; import org . springframework . social . google . api . legacyprofile . LegacyGoogleProfile ; public class GoogleAdapter implements ApiAdapter < Google > { public boolean test ( Google google ) { return true ; } public void setConnectionValues ( Google google , ConnectionValues values ) { LegacyGoogleProfile profile = google . userOperations ( ) . getUserProfile ( ) ; values . setProviderUserId ( profile . getId ( ) ) ; values . setDisplayName ( profile . getName ( ) ) ; values . setProfileUrl ( profile . getLink ( ) ) ; values . setImageUrl ( profile . getProfilePictureUrl ( ) ) ; } public UserProfile fetchUserProfile ( Google google ) { LegacyGoogleProfile profile = google . userOperations ( ) . getUserProfile ( ) ; return new UserProfileBuilder ( ) . setUsername ( profile'}]",.getId()).setDisplayName(profile.getName()).setEmail(profile.getEmail()).setProfileUrl(profile.getLink()).setImageUrl(profile.getProfilePictureUrl()).build(); } },5.921458716787431e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . preproc ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBMarker ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . parser . SVParseException ; import net . sf . sveditor . core . tests . SVDBTestUtils ; public class TestConditionalEval extends TestCase { public void testIfTakenNoElse ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; runTest ( testname , content , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT:a>"" } ) ; } public void testIfTakenElse ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; runTest ( testname , content , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT:a>"" } ) ; } public void testIfNotTakenElseTaken ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; runTest ( testname , content , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT:b>"" } ) ; } public void testIfTakenElsifNoElse ( ) throws SVParseException { String testname = ""<STR_LIT>"" ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""'}]","+ ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_L",1.3618144367780365e-06
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . thucydides . showcase . simple . pages ; public class ArtifactEntry { private final String groupId ; private final String artifactId ; private final String latestVersion ; public ArtifactEntry ( String groupId , String artifactId , String latestVersion ) { this . groupId = groupId ; this . artifactId = artifactId ; this . latestVersion = latestVersion ; } public String getGroupId ( ) {'}]",return groupId;,1.9960842585670457e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . splitlocal ; import java . util . Collection ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; public class SplitLocalConfig implements IRefactoringConfig { private IDocumentProvider documentProvider ; private int caretPosition ; Collection < LocalVarUsage > localUsages ; private LocalVarFinder localVarFinder ; public SplitLocalConfig ( IDocumentProvider documentProvider , int caretPosition ) { this . documentProvider = documentProvider ; this . caretPosition = caretPosition ; } public int getCaretPsition'}]",); public Collection<LocalVarUsage> getLocalUsages() { return localUsages; } public LocalVarFinder getLocalVarFinder() { return localVarFinder; } public void setLocalUsages(Collection<LocalVarUsage> localUsages) { this.localUsages = localUsages; } public void setLocalVarFinder(LocalVarFinder localVarFinder) { this.localVarFinder = localVarFinder; } },0.00012387783618415468
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . io ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . ConsoleCapture ; import org . oddjob . ConverterHelper ; import org . oddjob . FragmentHelper ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . OddjobSessionFactory ; import org . oddjob . OurDirs ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . ArooaValue ; import org . oddjob . arooa . ElementMappings ; import org . oddjob . arooa . convert . ArooaConverter ; import org . oddjob . arooa . convert . ConversionFailedException ; import org . oddjob . arooa . convert . ConversionPath ; import org . oddjob . arooa . convert . NoConversionAvailableException ; import org . oddjob . arooa . design . DesignElementProperty ; import org . oddjob . arooa . design . InstanceSupport ; import org . oddjob . arooa . design . model . MockDesignElementProperty ; import org . oddjob . arooa . life . InstantiationContext ; import org . oddjob . arooa . life . SimpleArooaClass ; import org . oddjob . arooa . parsing . ArooaContext ; import org . oddjob . arooa . parsing . ArooaElement ; import org . oddjob . arooa . parsing . MockArooaContext ; import org . oddjob . arooa . parsing . QTag ; import org . oddjob . arooa . reflect . ArooaClass ; import org . oddjob . arooa . runtime . MockRuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeConfiguration ; import org . oddjob . arooa . types . ListType ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . framework . SimpleJob ; import org . oddjob . state . ParentState ; public class FilesTypeTest extends TestCase { private static final Logger logger = Logger . getLogger ( FilesTypeTest . class ) ; public void testPattern ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; FilesType test = new FilesType ( ) ; test . setFiles ( dirs . base ( ) + ""<STR_LIT>"" ) ; ArooaConverter converter = new ConverterHelper ( ) . getConverter ( ) ; File [ ] fs = converter . convert ( test , File [ ] . class ) ; assertTrue ( fs . length > <NUM_LIT:1> ) ; for ( int i = <NUM_LIT:0> ; i < fs . length ; ++ i ) { System . out . println ( fs [ i ] ) ; } ConversionPath < FilesType , String [ ] > path = converter . findConversion ( FilesType . class , String [ ] . class ) ; assertEquals ( ""<STR_LIT>"" , path . toString ( ) ) ; String [ ] strings = converter . convert ( test , String [ ] . class ) ; assertTrue ( strings . length > <NUM_LIT:1> ) ; } public void testNestedFileList ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; FilesType f = new FilesType ( ) ; f . setFiles ( dirs . base ( ) + ""<STR_LIT>"" ) ; ArooaConverter converter = new ConverterHelper ( ) . getConverter ( ) ; File [ ] fs = ( File [ ] ) converter . convert ( f , File [ ] . class ) ; assertTrue ( fs . length > <NUM_LIT:1> ) ; for ( int i = <NUM_LIT:0> ; i < fs . length ; ++ i ) { System . out . println ( fs [ i ] ) ; } } public void testXMLCreate ( ) throws Exception { String xml = ""<STR_LIT>"" ; FilesType ft = ( FilesType ) Helper . createTypeFromXml ( xml ) ; assertEquals ( ""<STR_LIT>"" , ft . getFiles ( ) ) ; } public void testXMLCreate2 ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; ListType listType = ( ListType ) Helper . createTypeFromXml ( xml ) ; ArooaConverter converter = new ConverterHelper ( ) . getConverter ( ) ; File [ ] files = converter . convert ( listType , File [ ] . class ) ; for ( int i = <NUM_LIT:0> ; i < files . length ; ++ i ) { logger . debug ( files [ i ] ) ; } assertEquals ( <NUM_LIT:4> , files . length ) ; Set < File > set = new HashSet < File > ( Arrays . asList ( files ) ) ; assertTrue ( set . contains ( new File ( dirs . base ( ) , ""<STR_LIT>"" ) ) ) ; } public void testXMLCreate3 ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; String xml = ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" ; FilesType ft = ( FilesType ) Helper . createTypeFromXml ( xml ) ; ArooaConverter converter = new ConverterHelper ( ) . getConverter ( ) ; File [ ] files = converter . convert ( ft , File [ ] . class ) ; assertEquals ( <NUM_LIT:3> , files . length ) ; logger . debug ( files [ <NUM_LIT:0> ] ) ; logger . debug ( files [ <NUM_LIT:1> ] ) ; Set < File > set = new HashSet < File > ( Arrays . asList ( files ) ) ; assertTrue ( set . contains ( new File ( dirs . base ( ) , ""<STR_LIT>"" ) ) ) ; } public static class MyFiles extends SimpleJob { File [ ] files ; public void setFiles ( File [ ] files ) { if ( files == null ) { this . files = null ; } else { this . files = Files . expand ( files ) ; } } public int execute ( ) { return <NUM_LIT:0> ; } } public void testInOddjob ( ) { OurDirs dirs = new OurDirs ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + MyFiles . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oj = new Oddjob ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oj . run ( ) ; assertEquals ( ParentState . COMPLETE , oj . lastStateEvent ( ) . getState ( ) ) ; MyFiles mine = ( MyFiles ) new OddjobLookup ( oj ) . lookup ( ""<STR_LIT>"" ) ; assertTrue ( mine . files . length > <NUM_LIT:1> ) ; oj . destroy ( ) ; } public void testInOddjob2 ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oj = new Oddjob ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oj . run ( ) ; assertEquals ( ParentState . COMPLETE , oj . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oj ) ; File [ ] files = lookup . lookup ( ""<STR_LIT>"" , File [ ] . class ) ; assertEquals ( <NUM_LIT:3> , files . length ) ; oj . destroy ( ) ; } public void testSupports ( ) throws ArooaParseException { ArooaSession session = new OddjobSessionFactory ( ) . createSession ( ) ; ArooaConverter converter = session . getTools ( ) . getArooaConverter ( ) ; ElementMappings mappings = session . getArooaDescriptor ( ) . getElementMappings ( ) ; assertTrue ( checkElements ( mappings . elementsFor ( new InstantiationContext ( ArooaType . VALUE , new SimpleArooaClass ( Object . class ) , converter ) ) ) ) ; assertTrue ( checkElements ( mappings . elementsFor ( new InstantiationContext ( ArooaType . VALUE , new SimpleArooaClass ( ArooaValue . class ) , converter ) ) ) ) ; assertTrue ( checkElements ( mappings . elementsFor ( new InstantiationContext ( ArooaType . VALUE , new SimpleArooaClass ( File . class ) , converter ) ) ) ) ; assertTrue ( checkElements ( mappings . elementsFor ( new InstantiationContext ( ArooaType . VALUE , new SimpleArooaClass ( File [ ] . class ) , converter ) ) ) ) ; } public void testSupports2 ( ) throws ArooaParseException { final ArooaSession session = new OddjobSessionFactory ( ) . createSession ( ) ; final ArooaContext context = new MockArooaContext ( ) { @ Override public ArooaSession getSession ( ) { return session ; } @ Override public ArooaType getArooaType ( ) { return ArooaType . VALUE ; } @ Override public RuntimeConfiguration getRuntime ( ) { return new MockRuntimeConfiguration ( ) { @ Override public ArooaClass getClassIdentifier ( ) { return new SimpleArooaClass ( File [ ] . class ) ; } } ; } } ; DesignElementProperty property = new MockDesignElementProperty ( ) { @ Override public ArooaContext getArooaContext ( ) { return context ; } } ; InstanceSupport support = new InstanceSupport ( property ) ; QTag tags [ ] = support . getTags ( ) ; Set < QTag > results ='}]","new HashSet<QTag>(Arrays.asList(tags)); results.removeAll(Arrays.asList(QTag.FILE, QTag.FILE_LIST)); assertTrue(results.isEmpty()); } public void testSupports3() throws ArooaParseException { ArooaSession session = new OddjobSessionFactory().createSession(); ArooaConverter converter = session.getTools().getArooaConverter(); ElementMappings mappings = session.getArooaDescriptor().getElementMappings(); assertTrue(checkElements(mappings.elementsFor(new InstantiationContext(ArooaType.VALUE, new SimpleArooaClass(String[].class), converter)))); } public void checkElements(Set<ArooaElement> elements) { Set<String> types = new HashSet<String>(Arrays.asList(""File"", ""FileList"", ""String"", ""StringList"")); for (ArooaElement element : elements) { if (!types.contains(element.getName())) { fail(""Unknown element: "" + element.getName()); } } return true; }",0.0003621698109213914
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules . schedules ; import org . oddjob . schedules . Interval ; import org . oddjob . schedules . IntervalHelper ; import org . oddjob . schedules . Schedule ; import org . oddjob . schedules . ScheduleContext ; import org . oddjob . schedules . ScheduleResult ; import org . oddjob . schedules . SimpleScheduleResult ; public class ParentChildSchedule implements Schedule { private final Schedule parent ; private final Schedule child ; public ParentChildSchedule ( Schedule parent , Schedule child ) { this . parent = parent ; this . child = child ; } public ScheduleResult nextDue ( ScheduleContext context ) { ScheduleResult parentResult = limitedParentResult ( context ) ; if ( parentResult == null ) { return null ; } if ( child == null ) { return parentResult ; } ScheduleResult childResult = childResult ( context , parentResult ) ; if ( childResult != null ) { if ( childResult . getUseNext ( ) == null ) { return new SimpleScheduleResult ( childResult , childResult . getToDate ( ) ) ; } else { return childResult ; } } parentResult = limitedParentResult ( context . move ( parentResult . getToDate ( ) ) ) ; if ( parentResult == null ) { return null ; } childResult = childResult ( context , parentResult ) ; if ( childResult != null && childResult . getUseNext ( ) == null ) { return new SimpleScheduleResult ( childResult , childResult'}]",".getToDate() ); } return parentResult; } private ScheduleResult limitedParentResult(ScheduleContext context) { ScheduleResult result = parent.nextDue(context); if (result!= null &&!result.useNext()) { return result; } return null; } private ScheduleResult childResult(ScheduleContext context, ScheduleResult parentResult) { return child.nextDue(context); } @Override public void schedule(ScheduleContext context) { parent.schedule(context); if (child!= null) { child.schedule(context); } } @Override public String toString() { return ""ParentChildSchedule [parent="" + parent + "", child="" + child + ""]""; } }",0.00018705656928038355
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . processor ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . compiler . operator . OperatorCompilerTestRoot ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . utils . graph . Graph ; import com . asakusafw . vocabulary . flow . testing . MockIn ; import com . asakusafw . vocabulary . flow . testing . MockOut ; public class BranchOperatorProcessorTest extends OperatorCompilerTestRoot { @ Test public void simple ( ) { add ( ""<STR_LIT>"" ) ; add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new BranchOperatorProcessor ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < MockHoge > in = MockIn . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > high = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > middle = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > low = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; Object branch = invoke ( factory , ""<STR_LIT>"" , in ) ; high . add ( output ( MockHoge . class , branch , ""<STR_LIT>"" ) ) ; middle . add ( output ( MockHoge . class , branch , ""<STR_LIT>"" ) ) ; low . add ( output ( MockHoge . class , branch , ""<STR_LIT>"" ) ) ; Graph < String > graph = toGraph ( in ) ; assertThat ( graph . getConnected ( ""<STR_LIT>"" ) , isJust ( ""<STR_LIT>"" ) ) ; assertThat ( graph . getConnected ( ""<STR_LIT>"" ) , isJust ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; } @ Test public void parameterized ( ) { add ( ""<STR_LIT>"" ) ; add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new BranchOperatorProcessor ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < MockHoge > in = MockIn . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > high = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > middle = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > low = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; Object branch = invoke ( factory , ""<STR_LIT>"" , in , <NUM_LIT> , <NUM_LIT> ) ; high . add ( output ( MockHoge . class , branch , ""<STR_LIT>"" ) ) ; middle . add ( output ('}]","MockHoge.class, branch, ""<STR_LIT>"" ) ); low.add(output(MockHoge.class, branch, ""<STR_LIT>"")); Graph<String> graph = toGraph(in); assertThat(graph.getConnected(""<STR_LIT>""), isJust(""<STR_LIT>"")); assertThat(graph.getConnected(""<STR_LIT>""), isJust(""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"")); }",0.0001397608507393798
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . search ; import org . eclipse . core . resources . IResource ; import org . rubypeople . rdt . core . IRubyElement ; public class FieldReferenceMatch extends SearchMatch { private boolean isReadAccess ; private boolean isWriteAccess ; private IRubyElement binding ; public FieldReferenceMatch ( IRubyElement enclosingElement , IRubyElement binding , int accuracy , int offset , int length , boolean isReadAccess , boolean isWriteAccess , boolean insideDocComment , SearchParticipant participant , IResource resource ) { super ( enclosingElement , accuracy , offset , length , participant , resource ) ; this . binding = binding ; this . isReadAccess'}]",= isReadAccess; this.isWriteAccess = isWriteAccess; } public IRubyElement getBinding() { return binding; } public boolean isReadAccess() { return isReadAccess; } public boolean isWriteAccess() { return isWriteAccess; } },8.490863962557282e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . server ; import javax . management . ObjectName ; import org . oddjob . arooa . ArooaSession ; public class MockServerSession implements ServerSession { public ObjectName nameFor ( Object object ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public Object objectFor ( ObjectName objectName ) { throw'}]","new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public ArooaSession arooaSession ( ) { return new ArooaSession ( this ) ; } }",6.612187309475825e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . excel ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . io . InputStream ; import java . util . EnumSet ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . ss . usermodel . Sheet ; import org . apache . poi . ss . usermodel . Workbook ; import org . junit . Test ; import com . asakusafw . testdriver . rule . DataModelCondition ; public class DefaultExcelRuleExtractorTest { @ Test public void supports ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . supports ( sheet ) , is ( true ) ) ; } @ Test public void supports_not ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . supports ( sheet ) , is ( false ) ) ; } @ Test public void supports_invalid_version ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . supports ( sheet ) , is ( false ) ) ; } @ Test public void extractDataModelCondition_strict ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractDataModelCondition ( sheet ) , is ( ( Object ) EnumSet . noneOf ( DataModelCondition . class ) ) ) ; } @ Test public void extractDataModelCondition_expect ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractDataModelCondition ( sheet ) , is ( ( Object ) EnumSet . of ( DataModelCondition . IGNORE_UNEXPECTED ) ) ) ; } @ Test public void extractDataModelCondition_actual ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractDataModelCondition ( sheet ) , is ( ( Object ) EnumSet . of ( DataModelCondition . IGNORE_ABSENT ) ) ) ; } @ Test public void extractDataModelCondition_intersect ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractDataModelCondition ( sheet ) , is ( ( Object ) EnumSet . of ( DataModelCondition . IGNORE_UNEXPECTED , DataModelCondition . IGNORE_ABSENT ) ) ) ; } @ Test public void extractDataModelCondition_skip ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractDataModelCondition ( sheet ) , is ( ( Object ) EnumSet . allOf ( DataModelCondition . class ) ) ) ; } @ Test public void extractPropertyRowStartIndex ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractPropertyRowStartIndex ( sheet ) , is ( <NUM_LIT:3> ) ) ; } @ Test public void extractName ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractName ( sheet . getRow ( <NUM_LIT:3> ) ) , is ( ""<STR_LIT:value>"" ) ) ; assertThat ( extractor . extractName ( sheet . getRow ( <NUM_LIT:4> ) ) , is ( ""<STR_LIT:a>"" ) ) ; assertThat ( extractor . extractName ( sheet . getRow ( <NUM_LIT:5> ) ) , is ( ""<STR_LIT>"" ) ) ; } @ Test public void extractName_empty ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractName ( sheet . getRow ( <NUM_LIT:6> ) ) , is ( nullValue ( ) ) ) ; } @ Test public void extractName_blank ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractName ( sheet . getRow ( <NUM_LIT:7> ) ) , is ( nullValue ( ) ) ) ; } @ Test public void extractValueCondition ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:3> ) ) , is ( ValueConditionKind . ANY ) ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:4> ) ) , is ( ValueConditionKind . KEY ) ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:5> ) ) , is ( ValueConditionKind . EQUAL ) ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:6> ) ) , is ( ValueConditionKind . CONTAIN ) ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:7> ) ) , is ( ValueConditionKind . TODAY ) ) ; assertThat ( extractor . extractValueCondition ( sheet . getRow ( <NUM_LIT:8> ) ) , is ( ValueConditionKind . NOW ) ) ; } @ Test public void extractNullityCondition ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor . extractNullityCondition ( sheet . getRow ( <NUM_LIT:3> ) )'}]",", is ( NullityConditionKind. ALWAYS ) ); } @Test public void extractNullityCondition_always ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor. extractNullityCondition ( sheet. getRow ( <NUM_LIT:4> ) ), is ( NullityConditionKind. NEVER ) ) ; } @Test public void extractNullityCondition_never ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor. extractNullityCondition ( sheet. getRow ( <NUM_LIT:5> ) ), is ( NullityConditionKind. ALWAYS ) ) ; } @Test public void extractNullityCondition_unknown ( ) throws Exception { ExcelRuleExtractor extractor = new DefaultExcelRuleExtractor ( ) ; Sheet sheet = sheet ( ""<STR_LIT>"" ) ; assertThat ( extractor. extractNullityCondition ( sheet. getRow ( <NUM_LIT:6> ) ), is ( NullityConditionKind. UNKNOWN ) ) ; } @Test public void extractNullityCondition_null ( ) throws Exception { ExcelRuleExtractor",0.00040897732369604077
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . parser . warnings ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . jruby . ast . DefnNode ; import org . jruby . ast . DefsNode ; import org . jruby . ast . LocalAsgnNode ; import org . jruby . ast . RootNode ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import com . aptana . rdt . AptanaRDTPlugin ; public class TooManyLocalsVisitor extends RubyLintVisitor { public static final int DEFAULT_MAX_LOCALS = <NUM_LIT:4> ; private int maxLocals ; private Set'}]","<String> localNames = new HashSet<>(); public TooManyLocalsVisitor(int maxLocals) { super(); this.maxLocals = maxLocals; } @Override public void visit(RootNode rootNode) { super.visit(rootNode); } @Override public void visit(DefsNode defsNode) { super.visit(defsNode); } @Override public void visit(DefnNode defnNode) { super.visit(defnNode); } @Override public void visit(LocalAsgnNode localAsgnNode) { localNames.add(localAsgnNode.name); } @Override public void endVisit(RootNode rootNode) { super.endVisit(rootNode); if (localNames.size() > maxLocals) { AptanaRDTPlugin.getInstance().logWarning(rootNode, ""Too many locals ("" + localNames.size() + "" > "" + maxLocals + "")""); } } }",0.0002481921177272456
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCache ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCacheFactory ; import net . sf . sveditor . core . db . index . cache . InMemoryIndexCache ; public class TestNullIndexCacheFactory implements ISVDBIndexCacheFactory { private List < InMemoryIndexCache > fCacheList ; public TestNullIndexCacheFactory ( ) { fCacheList = new ArrayList < InMemoryIndexCache > ( ) ; } public ISVDBIndexCache createIndexCache ( String project_name , String'}]","version, String index_name ) { return new InMemoryIndexCache ( ) ; } public void clearCache ( ) { fCacheList. clear ( ) ; } }",5.901067105858153e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . regex . Pattern ; import com . asakusafw . compiler . flow . ExternalIoDescriptionProcessor ; import com . asakusafw . compiler . flow . FlowCompilerOptions . GenericOptionValue ; import com . asakusafw . compiler . flow . Location ; import com . asakusafw . compiler . flow . jobflow . CompiledStage ; import com . asakusafw . compiler . flow . mapreduce . copy . CopierClientEmitter ; import com . asakusafw . compiler . flow . mapreduce . copy . CopyDescription ; import com . asakusafw . compiler . flow . mapreduce . parallel . ParallelSortClientEmitter ; import com . asakusafw . compiler . flow . mapreduce . parallel . ResolvedSlot ; import com . asakusafw . compiler . flow . mapreduce . parallel . Slot ; import com . asakusafw . compiler . flow . mapreduce . parallel . SlotResolver ; import com . asakusafw . runtime . stage . input . TemporaryInputFormat ; import com . asakusafw . runtime . stage . output . TemporaryOutputFormat ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Maps ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . vocabulary . external . ExporterDescription ; import com . asakusafw . vocabulary . external . FileExporterDescription ; import com . asakusafw . vocabulary . external . FileImporterDescription ; import com . asakusafw . vocabulary . external . ImporterDescription ; import com . asakusafw . vocabulary . flow . graph . InputDescription ; import com . asakusafw . vocabulary . flow . graph . OutputDescription ; public class HadoopFileIoProcessor extends ExternalIoDescriptionProcessor { private static final Pattern VALID_OUTPUT_NAME = Pattern . compile ( ""<STR_LIT>"" ) ; private static final String MODULE_NAME = ""<STR_LIT>"" ; public static final String OPTION_EXPORTER_ENABLED = ""<STR_LIT>"" ; private static final GenericOptionValue DEFAULT_EXPORTER_ENABLED = GenericOptionValue . AUTO ; @ Override public Class < ? extends ImporterDescription > getImporterDescriptionType ( ) { return FileImporterDescription . class ; } @ Override public Class < ? extends ExporterDescription > getExporterDescriptionType ( ) { return FileExporterDescription . class ; } @ Override public boolean validate ( List < InputDescription > inputs , List < OutputDescription > outputs ) { boolean valid = validateOutputs ( outputs ) ; return valid ; } private boolean validateOutputs ( List < OutputDescription > outputs ) { assert outputs != null ; boolean valid = true ; GenericOptionValue exporterEnabled = getEnvironment ( ) . getOptions ( ) . getGenericExtraAttribute ( OPTION_EXPORTER_ENABLED , DEFAULT_EXPORTER_ENABLED ) ; if ( exporterEnabled == GenericOptionValue . INVALID ) { getEnvironment ( ) . error ( ""<STR_LIT>"" , getEnvironment ( ) . getOptions ( ) . getExtraAttributeKeyName ( OPTION_EXPORTER_ENABLED ) , getEnvironment ( ) . getOptions ( ) . getExtraAttribute ( OPTION_EXPORTER_ENABLED ) , GenericOptionValue . ENABLED . getSymbol ( ) + ""<STR_LIT:|>"" + GenericOptionValue . DISABLED . getSymbol ( ) ) ; exporterEnabled = DEFAULT_EXPORTER_ENABLED ; valid = false ; } boolean mr370applied = checkClassExists ( ""<STR_LIT>"" ) ; for ( OutputDescription output : outputs ) { FileExporterDescription desc = extract ( output ) ; if ( exporterEnabled == GenericOptionValue . DISABLED ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) , getEnvironment ( ) . getOptions ( ) . getExtraAttributeKeyName ( OPTION_EXPORTER_ENABLED ) , GenericOptionValue . ENABLED . getSymbol ( ) ) ; } else if ( mr370applied == false && exporterEnabled == GenericOptionValue . AUTO ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" + ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) , FileExporterDescription . class . getSimpleName ( ) , ""<STR_LIT>"" ) ; } String pathPrefix = desc . getPathPrefix ( ) ; if ( pathPrefix == null ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) ) ; } else { Location location = Location . fromPath ( pathPrefix , \'<CHAR_LIT:/>\' ) ; if ( location . isPrefix ( ) == false ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) , pathPrefix ) ; } if ( location . getParent ( ) == null ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) , pathPrefix ) ; } if ( VALID_OUTPUT_NAME . matcher ( location . getName ( ) ) . matches ( ) == false ) { valid = false ; getEnvironment ( ) . error ( ""<STR_LIT>"" , desc . getClass ( ) . getName ( ) , pathPrefix ) ; } } } return valid ; } private boolean checkClassExists ( String className ) { try { Class . forName ( className ) ; return true ; } catch ( ClassNotFoundException e ) { return false ; } } @ Override public SourceInfo getInputInfo ( InputDescription description ) { FileImporterDescription desc = extract ( description ) ; if ( isCacheTarget ( desc ) ) { String outputName = getProcessedInputName ( description ) ; Location location = getEnvironment ( ) . getPrologueLocation ( MODULE_NAME ) . append ( outputName ) . asPrefix ( ) ; return new SourceInfo ( Collections . singleton ( location ) , TemporaryInputFormat . class ) ; } else { return getOrifinalInputInfo ( desc ) ; } } private SourceInfo getOrifinalInputInfo ( FileImporterDescription desc ) { assert desc != null ; Set < Location > locations = Sets . create ( ) ; for ( String path : desc . getPaths ( ) ) { locations . add ( Location . fromPath ( path , \'<CHAR_LIT:/>\' ) ) ; }'}]","} private boolean isCacheTarget ( FileImporterDescription desc ) { return desc. isCacheTarget ( ) ; } private String getProcessedInputName ( InputDescription description ) { assert description!= null ; FileImporterDescription desc = extract ( description ) ; return desc. getPath ( ) ; } private FileImporterDescription extract ( InputDescription description ) { assert description!= null ; return description. asFileImporterDescription ( ) ; } @ Override public SourceInfo getOutputInfo ( OutputDescription description ) { FileExporterDescription desc = extract ( description ) ; if ( isCacheTarget ( desc ) ) { String outputName = getProcessedOutputName ( description ) ; Location location = getEnvironment ( ). getPrologueLocation ( MODULE_NAME ). append ( outputName ). asPrefix ( ) ; return new SourceInfo ( Collections. singleton ( location ), TemporaryOutputFormat. class ) ; } else { return getOrifinalOutputInfo ( desc ) ; } } private SourceInfo getOrifinalOutputInfo ( FileExporterDescription desc ) { assert desc!= null ; Set < Location > locations = Sets. create ( ) ; for ( String path : desc. getPaths ( ) ) { locations. add ( Location. fromPath ( path, '<CHAR_LIT:/",0.000415321695349749
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . persistence ; import java . io . DataInput ; import java . io . DataOutput ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBChildParent ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; @ SuppressWarnings ( { ""<STR_LIT:unchecked>"" , ""<STR_LIT:rawtypes>"" } ) public class SVDBDelegatingPersistenceRW extends SVDBPersistenceRWBase implements IDBReader , IDBWriter , ISVDBPersistenceRWDelegateParent { private Map < Class , ISVDBPersistenceRWDelegate > fObjectDelegateMap ; private Map < SVDBItemType , ISVDBPersistenceRWDelegate > fSVDBItemDelegateMap ; private Map < Class , ISVDBPersistenceRWDelegate > fEnumDelegateMap ; private List < ISVDBPersistenceRWDelegate > fDelegateList ; private ISVDBPersistenceRWDelegate fDefaultDelegate ; public SVDBDelegatingPersistenceRW ( ) { fObjectDelegateMap = new HashMap < Class , ISVDBPersistenceRWDelegate > ( ) ; fEnumDelegateMap = new HashMap < Class , ISVDBPersistenceRWDelegate > ( ) ; fSVDBItemDelegateMap = new HashMap < SVDBItemType , ISVDBPersistenceRWDelegate > ( ) ; fDelegateList = new ArrayList < ISVDBPersistenceRWDelegate > ( ) ; fDefaultDelegate = new SVDBDefaultPersistenceRW ( ) ; fDefaultDelegate . init ( this , fIn , fOut ) ; } @ Override public void init ( DataInput in ) { super . init ( in ) ; for ( ISVDBPersistenceRWDelegate d : fDelegateList ) { d . init ( this , in , null ) ; } fDefaultDelegate . init ( this , in , null ) ; } @ Override public void init ( DataOutput out ) { super . init ( out ) ; for ( ISVDBPersistenceRWDelegate d : fDelegateList ) { d . init ( this , null , out ) ; } fDefaultDelegate . init ( this , null , out ) ; } public void addDelegate ( ISVDBPersistenceRWDelegate d ) { fDelegateList . add ( d ) ; d . init ( this , fIn , fOut ) ; Set < Class > supported_classes = d . getSupportedObjects ( ) ; if ( supported_classes != null ) { for ( Class cls : supported_classes ) { fObjectDelegateMap . put ( cls , d ) ; } } Set < Class > supported_enums = d . getSupportedEnumTypes ( ) ; if ( supported_enums != null ) { for ( Class cls : supported_enums ) { fEnumDelegateMap . put ( cls , d ) ; } } Set < SVDBItemType > supported_types = d . getSupportedItemTypes ( ) ; if ( supported_types != null ) { for ( SVDBItemType type : supported_types ) { fSVDBItemDelegateMap . put ( type , d ) ; } } } public Map < String , List > readMapStringList ( Class val_c ) throws DBFormatException { Map < String , List > ret = new HashMap < String , List > ( ) ; int type = readRawType ( ) ; if ( type == TYPE_NULL ) { return null ; } if ( type != TYPE_MAP ) { throw new DBFormatException ( ""<STR_LIT>"" + type ) ; } int size = readInt ( ) ; for ( int i = <NUM_LIT:0> ; i < size ; i ++ ) { String key = readString ( ) ; ret . put ( key , readObjectList ( null , val_c ) ) ; } return ret ; } public Map < String , Object > readMapStringObject ( Class val_c ) throws DBFormatException { Map < String , Object > ret = new HashMap < String , Object > ( ) ; int type = readRawType ( ) ; if ( type == TYPE_NULL ) { return null ; } if ( type != TYPE_MAP ) { throw new DBFormatException ( ""<STR_LIT>"" + type ) ; } int size = readInt ( ) ; for ( int i = <NUM_LIT:0> ; i < size ; i ++ ) { String key = readString ( ) ; Object val = null ; try { val = val_c . newInstance ( ) ; } catch ( InstantiationException e ) { throw new DBFormatException ( ""<STR_LIT>"" + val_c . getName ( ) ) ; } catch ( IllegalAccessException e ) { throw new DBFormatException ( ""<STR_LIT>"" + val_c . getName ( ) ) ; } readObject ( null , val_c , val ) ; ret . put ( key , val ) ; } return ret ; } public void writeMapStringList ( Map < String , List > map , Class list_c ) throws DBWriteException , DBFormatException { if ( map == null ) { writeRawType ( TYPE_NULL ) ; } else { writeRawType ( TYPE_MAP ) ; writeInt ( map . size ( ) ) ; for ( Entry < String , List > e : map . entrySet ( ) ) { writeString ( e . getKey ( ) ) ; writeObjectList ( e . getValue ( ) , list_c ) ; } } } public void writeMapStringObject ( Map < String , Object > map , Class obj_c ) throws DBWriteException , DBFormatException { if ( map == null ) { writeRawType ( TYPE_NULL ) ; } else { writeRawType ( TYPE_MAP ) ; writeInt ( map . size ( ) ) ; for ( Entry < String , Object > e : map . entrySet ( ) ) { writeString ( e . getKey ( ) ) ; writeObject ( obj_c , e . getValue ( ) ) ; } } } public void writeObject ( Class cls , Object obj ) throws DBWriteException { ISVDBPersistenceRWDelegate d = fObjectDelegateMap . get ( cls ) ; if ( d != null ) { d . writeObject ( cls , obj ) ; } else { fDefaultDelegate . writeObject ( cls , obj ) ; } } public void writeObjectList ( List items , Class obj_c ) throws DBWriteException { if ( items == null ) { writeRawType ( TYPE_NULL ) ; } else { writeRawType ( TYPE_OBJECT_LIST ) ; writeInt ( items . size ( ) ) ; for ( Object v : items ) { writeObject ( obj_c , v ) ; } } } public List readObjectList ( ISVDBChildParent parent , Class val_c ) throws DBFormatException { int type = readRawType ( ) ; if ( type == TYPE_NULL ) { return null ; } else if ( type != TYPE_OBJECT_LIST ) { throw new DBFormatException ( ""<STR_LIT>"" + type + ""<STR_LIT>"" + val_c . getName ( ) ) ; } int size = readInt ( ) ; List ret = new ArrayList ( ) ; for ( int i = <NUM_LIT:0> ;'}]","int size = readInt ( ) ; for ( int i = <NUM_LIT:0> ; i < size ; i ++ ) { Object v = null ; try { v = val_c. newInstance ( ) ; } catch ( InstantiationException e ) { throw new DBFormatException ( ""<STR_LIT>"" + val_c. getName ( ) ) ; } catch ( IllegalAccessException e ) { throw new DBFormatException ( ""<STR_LIT>"" + val_c. getName ( ) ) ; } readObject ( parent, val_c, v ) ; ret. add ( v ) ; } return ret ; } public void readObject ( ISVDBChildParent parent, Class cls, Object obj ) throws DBFormatException { ISVDBPersistenceRWDelegate d = fObjectDelegateMap. get ( cls ) ; if ( d!= null ) { d. readObject ( parent, cls, obj ) ; } else { fDefaultDelegate. readObject ( parent, cls, obj ) ; } } public void readObject ( ISVDBChildParent parent, Class cls, Object obj, Map < Class, ISVDBPersistenceRWDelegate > delegateMap ) throws DBFormatException { ISVDBPersistenceRWDelegate d = delegateMap. get ( cls ) ; if ( d!=",0.00041300946505399666
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . core . parsing ; import java . io . IOException ; import org . rubypeople . rdt . debug . core . RdtDebugCorePlugin ; import org . xmlpull . v1 . XmlPullParser ; import org . xmlpull . v1 . XmlPullParserException ; public abstract class XmlStreamReader { private AbstractReadStrategy readStrategy ; private boolean isWaitTimeExpired ; public XmlStreamReader ( XmlPullParser xpp ) { this ( new SingleReaderStrategy ( xpp ) ) ; } public XmlStreamReader ( AbstractReadStrategy readStrategy ) { this . readStrategy = readStrategy ; this . isWaitTimeExpired = false ; } public void read ( ) throws XmlPullParserException ,'}]",IOException { if (!isWaitTimeExpired) { readStrategy.read(); } } },3.9558067657885706e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . emitter ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstGrouping ; import com . asakusafw . dmdl . model . AstModelDefinition ; import com . asakusafw . dmdl . model . AstModelFolding ; import com . asakusafw . dmdl . model . AstModelReference ; import com . asakusafw . dmdl . model . AstPropertyFolding ; import com . asakusafw . dmdl . model . AstSimpleName ; import com . asakusafw . dmdl . model . AstSummarize ; import com . asakusafw . dmdl . model . ModelDefinitionKind ; import com . asakusafw . dmdl . thundergate . Constants ; import com . asakusafw . dmdl . thundergate . model . ModelProperty ; import com . asakusafw . dmdl . thundergate . model . ModelReference ; import com . asakusafw . dmdl . thundergate . model . Source ; import com . asakusafw . dmdl . thundergate . model . SummarizedModelDescription ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Maps ; public final class SummarizedModelGenerator { private final SummarizedModelDescription model ; private SummarizedModelGenerator ( SummarizedModelDescription model ) { assert model != null ; this . model = model ; } public static AstModelDefinition < AstSummarize > generate ( SummarizedModelDescription model ) { if ( model == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return new AstModelDefinition < AstSummarize > ( null , ModelDefinitionKind . SUMMARIZED , AstBuilder . getDesciption ( ""<STR_LIT>"" , model . getOriginalModel ( ) . getSimpleName ( ) ) , Arrays . asList ( new AstAttribute [ ] { AstBuilder . getAutoProjection ( ) , AstBuilder . getNamespace ( AstBuilder . toDmdlName ( Constants . SOURCE_VIEW ) ) , AstBuilder . getOriginalName ( model . getReference ( ) . getSimpleName ( ) ) , } ) , AstBuilder . toName ( model . getReference ( ) ) , new SummarizedModelGenerator ( model ) . generateExpression ( ) ) ; } private AstSummarize generateExpression ( ) { return generateTerm ( model . getOriginalModel ( ) , model . getGroupBy ( ) ) ; } private AstSummarize generateTerm ( ModelReference sourceModel , List < Source > group ) { Map < String , ModelProperty > resolver = Maps . create ( ) ; List < AstPropertyFolding > foldings = Lists . create ( ) ; for ( ModelProperty property : model . getProperties ( ) ) { Source source = property . getSource ( ) ; assert source . getDeclaring ( ) . equals ( sourceModel ) ; resolver . put ( source .'}]","getName(), property); foldings.add(AstBuilder.getFolding(source)); } AstSummarize term = AstBuilder.getTerm(sourceModel, group, resolver, foldings); if (model.getGroupBy().isEmpty()) { return term; } else { return AstBuilder.getAggregation(term, group, resolver, foldings); } } }",0.00011945878366210605
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . testing ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOError ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; public final class TestingUtils { private TestingUtils ( ) { return ; } public static void append ( String path , String message ) { File file = new File ( path ) ; try { OutputStream output = new FileOutputStream ( file , true ) ; try { PrintWriter w = new PrintWriter ( new OutputStreamWriter ('}]","(output, ""UTF-8"") ) ; w.print(message) ; w.close() ; } finally { output.close() ; } } catch (IOException e) { throw new RuntimeException(e) ; } }",6.905452844373707e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . cleaner . common ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import com . asakusafw . cleaner . exception . CleanerSystemException ; public final class ConfigurationLoader { private static Properties prop = new Properties ( ) ; private static Map < String , String > env = null ; private static Properties sysProp = null ; private ConfigurationLoader ( ) { return ; } public static void cleanProp ( ) { prop = new Properties ( ) ; } public static void init ( String [ ] propertys , boolean doLocalCleanPropCheck , boolean doHDFSCleanPropCheck ) throws CleanerSystemException , Exception { env = System . getenv ( ) ; sysProp = System . getProperties ( ) ; checkEnv ( ) ; loadPropertyes ( propertys ) ; if ( doLocalCleanPropCheck ) { checkAndSetParamLocalFileClean ( ) ; } if ( doHDFSCleanPropCheck ) { checkAndSetParamHDFSClean ( ) ; } } protected static void checkEnv ( ) throws Exception { String cleanHome = getEnvProperty ( Constants . CLEAN_HOME ) ; if ( isEmpty ( cleanHome ) ) { System . err . println ( MessageFormat . format ( ""<STR_LIT>"" , Constants . CLEAN_HOME ) ) ; throw new Exception ( MessageFormat . format ( ""<STR_LIT>"" , Constants . CLEAN_HOME ) ) ; } File cleanHomeDir = new File ( cleanHome ) ; if ( ! cleanHomeDir . exists ( ) ) { System . err . println ( MessageFormat . format ( ""<STR_LIT>"" , Constants . CLEAN_HOME , cleanHome ) ) ; throw new Exception ( MessageFormat . format ( ""<STR_LIT>"" , Constants . CLEAN_HOME , cleanHome ) ) ; } } protected static void checkAndSetParamLocalFileClean ( ) throws CleanerSystemException { String keepDate = prop . getProperty ( Constants . PROP_KEY_LOCAL_FILE_KEEP_DATE ) ; if ( isEmpty ( keepDate ) ) { prop . setProperty ( Constants . PROP_KEY_LOCAL_FILE_KEEP_DATE , Constants . PROP_DEFAULT_LOCAL_FILE_KEEP_DATE ) ; } else { if ( ! isNumber ( keepDate , <NUM_LIT:0> ) ) { throw new CleanerSystemException ( ConfigurationLoader . class , MessageIdConst . CMN_PROP_CHECK_ERROR , ""<STR_LIT>"" + keepDate ) ; } } List < String > cleanDirList = getPropStartWithString ( Constants . PROP_KEY_LOCAL_FILE_CLEAN_DIR + ""<STR_LIT:.>"" ) ; List < String > noEmptyList = getNoEmptyList ( cleanDirList ) ; if ( noEmptyList . size ( ) == <NUM_LIT:0> ) { throw new CleanerSystemException ( ConfigurationLoader . class , MessageIdConst . CMN_PROP_CHECK_ERROR , ""<STR_LIT>"" ) ; } } protected static void checkAndSetParamHDFSClean ( ) throws CleanerSystemException { String keepDate = prop . getProperty ( Constants . PROP_KEY_HDFS_FILE_KEEP_DATE ) ; if ( isEmpty ( keepDate ) ) { prop . setProperty ( Constants . PROP_KEY_HDFS_FILE_KEEP_DATE , Constants . PROP_DEFAULT_HDFS_FILE_KEEP_DATE ) ; } else { if ( ! isNumber ( keepDate , <NUM_LIT:0> ) ) { throw new CleanerSystemException ( ConfigurationLoader . class , MessageIdConst . CMN_PROP_CHECK_ERROR , ""<STR_LIT>"" + keepDate ) ; } } if ( isEmpty ( prop . getProperty ( Constants . PROP_KEY_HDFS_PROTCOL_HOST ) ) ) { throw new CleanerSystemException ( ConfigurationLoader . class , MessageIdConst . CMN_PROP_CHECK_ERROR , ""<STR_LIT>"" ) ; } List'}]","< String > hdfsProtocolHostList = getPropStartWithString ( Constants. PROP_KEY_HDFS_PROTCOL_HOST + ""<STR_LIT:>"" ) ; List < String > noEmptyList = getNoEmptyList ( hdfsProtocolHostList ) ; if ( noEmptyList. size ( ) == <NUM_LIT:0> ) { throw new CleanerSystemException ( ConfigurationLoader. class, MessageIdConst. CMN_PROP_CHECK_ERROR, ""<STR_LIT>"" ) ; } } protected static void loadPropertyes ( String [ ] propertys ) throws Exception { for ( String prop : propertys ) { String [ ] propArray = prop. split ( ""<STR_LIT:>+"" ) ; if ( propArray. length == <NUM_LIT:2> ) { prop. setProperty ( propArray [ <NUM_LIT:0> ], propArray [ <NUM_LIT:1> ] ) ; } else { System. err. println ( MessageFormat. format ( ""<STR_LIT>"", prop, propArray. length ) ) ; throw new Exception ( MessageFormat. format ( ""<STR_LIT>"", prop, propArray. length ) ) ; } } } protected static List < String > get",0.0003822975054784828
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui ; import java . io . File ; import java . io . IOException ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Properties ; import net . ggtools . grand . ui . prefs . PreferenceKeys ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; public class RecentFilesManager implements IPropertyChangeListener , PreferenceKeys { private static final Log log = LogFactory . getLog ( RecentFilesManager . class ) ; private static RecentFilesManager instance ; private int maxFiles = - <NUM_LIT:1> ; private final LinkedList < String > recentFiles = new LinkedList < String > ( ) ; private final GrandUiPrefStore preferenceStore ; private final Collection < RecentFilesListener > subscribers ; private final List < String > readOnlyRecentFiles ; private RecentFilesManager ( ) { subscribers = new HashSet < RecentFilesListener > ( ) ; readOnlyRecentFiles = Collections . unmodifiableList ( recentFiles ) ; preferenceStore = Application . getInstance ( ) . getPreferenceStore ( ) ; loadRecentFiles ( ) ; } public void addListener ( final RecentFilesListener listener ) { if ( ! subscribers . contains ( listener ) ) { subscribers . add ( listener ) ; listener . refreshRecentFiles ( getRecentFiles ( ) ) ; } } public void removeListener ( final RecentFilesListener listener ) { subscribers . remove ( listener ) ; } private void notifyListeners ( ) { for ( final Iterator < RecentFilesListener > iter = subscribers . iterator ( ) ; iter . hasNext ( ) ; ) { final RecentFilesListener listener = iter . next ( ) ; listener . refreshRecentFiles ( getRecentFiles ( ) ) ; } } static public RecentFilesManager getInstance ( ) { if ( instance == null ) { instance = new RecentFilesManager ( ) ; } return instance ; } public void addNewFile ( final File file ) { addNewFile ( file , null ) ; } public void addNewFile ( final File file , final Properties properties ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ""<STR_LIT>"" + file + ""<STR_LIT>"" ) ; } final String fileName = file . getAbsolutePath ( ) ; recentFiles . remove ( fileName ) ; recentFiles . addFirst ( fileName ) ; removeExcessFiles ( ) ; preferenceStore . setValue ( RECENT_FILES_PREFS_KEY , recentFiles ) ; if ( properties == null ) { preferenceStore . setPropertiesToDefault ( getKeyForProperties ( fileName ) ) ; } else { preferenceStore . setValue ( getKeyForProperties ( fileName ) , properties ) ; } try { if ( log . isDebugEnabled ( ) ) { log . debug ( ""<STR_LIT>"" ) ; } preferenceStore . save ( ) ; } catch ( final IOException e ) { log . error ( ""<STR_LIT>"" , e ) ; } notifyListeners ( ) ; } public void updatePropertiesFor ( final File file , final Properties properties ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ""<STR_LIT>"" + file ) ; } final String fileName = file . getAbsolutePath ( ) ; if ( recentFiles . contains ( fileName ) ) { if ( properties == null ) { preferenceStore . setPropertiesToDefault ( getKeyForProperties ( fileName ) ) ; } else { preferenceStore . setValue ( getKeyForProperties ( fileName ) , properties ) ; } try { if ( log . isDebugEnabled ( ) ) { log . debug ( ""<STR_LIT>"" ) ; } preferenceStore . save ( ) ; } catch ( final IOException e ) { log . error ( ""<STR_LIT>"" , e ) ; } } } private String getKeyForProperties ( final String fileName ) { return RECENT_FILES_PREFS_KEY + ""<STR_LIT>"" + fileName ; } public void clear ( ) { recentFiles'}]",".clear(); notifyListeners(); } public void loadRecentFiles() { final String storedRecentFiles = preferenceStore.getValue(RECENT_FILES_PREFS_KEY); if (storedRecentFiles!= null) { final String[] files = storedRecentFiles.split(""<NUM_LIT:1>""); for (final String file : files) { recentFiles.addLast(file); } } } private void removeExcessFiles() { while (recentFiles.size() > maxFiles) { recentFiles.removeLast(); } } }",0.00016147325116708496
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . BreakStatement ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class BreakStatementImpl extends ModelRoot implements BreakStatement { private SimpleName target ; @ Override public SimpleName getTarget ( ) { return this . target ; } public void setTarget ( SimpleName target ) { this . target'}]","= target; } @Override public <R, P> R accept(Visitor<R, P> v, P arg) { return v.visit(this, arg); } }",6.15586311642187e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob ; import java . net . URI ; import java . net . URL ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import junit . framework . TestCase ; import org . oddjob . arooa . ArooaBeanDescriptor ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . ArooaValue ; import org . oddjob . arooa . ElementMappings ; import org . oddjob . arooa . convert . ArooaConverter ; import org . oddjob . arooa . convert . ConversionPath ; import org . oddjob . arooa . convert . DefaultConverter ; import org . oddjob . arooa . deploy . ClassPathDescriptorFactory ; import org . oddjob . arooa . life . InstantiationContext ; import org . oddjob . arooa . life . SimpleArooaClass ; import org . oddjob . arooa . parsing . ArooaElement ; import org . oddjob . arooa . reflect . ArooaClass ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . types . ValueType ; import org . oddjob . jobs . SequenceJob ; import org . oddjob . jobs . structural . JobFolder ; public class OddjobArooaDescriptorTest extends TestCase { public void testArooaXml ( ) { URL url = getClass ( ) . getClassLoader ( ) . getResource ( ClassPathDescriptorFactory . AROOA_FILE ) ; assertNotNull ( url ) ; ClassPathDescriptorFactory factory = new ClassPathDescriptorFactory ( ) ; ArooaDescriptor test = factory . createDescriptor ( getClass ( ) . getClassLoader ( ) ) ; ElementMappings definitions = test . getElementMappings ( ) ; ArooaElement [ ] elements = definitions . elementsFor ( new InstantiationContext ( ArooaType . COMPONENT , null ) ) ; assertTrue ( elements . length > <NUM_LIT:10> ) ; } public void testLoad ( ) throws ArooaParseException , ClassNotFoundException { ArooaDescriptor test = new OddjobDescriptorFactory ( ) . createDescriptor ( null ) ; ElementMappings mappings = test . getElementMappings ( ) ; ArooaElement [ ] elements = mappings . elementsFor ( new InstantiationContext ( ArooaType . COMPONENT , null ) ) ; assertTrue ( elements . length > <NUM_LIT:10> ) ; assertEquals ( new SimpleArooaClass ( SequenceJob . class ) , mappings . mappingFor ( new ArooaElement ( ""<STR_LIT>"" ) , new InstantiationContext ( ArooaType . COMPONENT , null ) ) ) ; elements = mappings . elementsFor ( new InstantiationContext ( ArooaType . VALUE , null ) ) ; assertTrue ( elements . length > <NUM_LIT:10> ) ; assertNotNull ( test . getElementMappings ( ) . mappingFor ( new ArooaElement ( ""<STR_LIT>"" ) , new InstantiationContext ( ArooaType . COMPONENT , null ) ) ) ; } public void testSupports ( ) throws Exception { ArooaSession session = new OddjobSessionFactory ( ) . createSession ( ) ; ArooaElement [ ] elements = session . getArooaDescriptor ( ) . getElementMappings ( ) . elementsFor ( new InstantiationContext ( ArooaType . VALUE , new SimpleArooaClass ( Object .'}]",".class) ); URL url = getClass().getClassLoader().getResource(ClassPathDescriptorFactory.ARoola_FILE); assertNotNull(url); ClassPathDescriptorFactory factory = new ClassPathDescriptorFactory(); ArooaDescriptor test = factory.createDescriptor(getClass().getClassLoader()); ElementMappings definitions = test.getElementMappings(); ArooaElement[] elements = definitions.elementsFor(new InstantiationContext(ArooaType.COMPONENT, null)); assertTrue(elements.length > 10); }",0.00014532202870098815
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core ; import java . util . Collection ; import java . util . Map ; public interface IRefactoringConditionChecker { public static final String ERRORS = ""<STR_LIT>"" ; public static final String WARNING = ""<STR_LIT>"" ; public Map < String , Collection < String > > getInitialMessages'}]","(); public void setInitialMessages( Map< String, Collection<String> > initialMessages ); public Map< String, Collection<String> > getInitialMessages(); }",5.6531172460420386e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . CommandManager ; import org . eclipse . core . commands . IParameter ; import org . eclipse . core . commands . Parameterization ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . commands . contexts . ContextManager ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . bindings . BindingManager ; import org . eclipse . jface . bindings . Scheme ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . jface . layout . PixelConverter ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . ArrayContentProvider ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTableViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . dialogs . PreferencesUtil ; import org . eclipse . ui . keys . IBindingService ; import org . eclipse . ui . preferences . IWorkbenchPreferenceContainer ; import org . eclipse . ui . texteditor . ITextEditorActionDefinitionIds ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . ruby . CompletionProposalCategory ; import org . rubypeople . rdt . internal . ui . text . ruby . CompletionProposalComputerRegistry ; import org . rubypeople . rdt . internal . ui . util . SWTUtil ; import org . rubypeople . rdt . internal . ui . wizards . IStatusChangeListener ; import org . rubypeople . rdt . ui . PreferenceConstants ; final class CodeAssistAdvancedConfigurationBlock extends OptionsConfigurationBlock { private static final Key PREF_EXCLUDED_CATEGORIES = getRDTUIKey ( PreferenceConstants . CODEASSIST_EXCLUDED_CATEGORIES ) ; private static final Key PREF_CATEGORY_ORDER = getRDTUIKey ( PreferenceConstants . CODEASSIST_CATEGORY_ORDER ) ; private static Key [ ] getAllKeys ( ) { return new Key [ ] { PREF_EXCLUDED_CATEGORIES , PREF_CATEGORY_ORDER } ; } private final class DefaultTableLabelProvider extends LabelProvider implements ITableLabelProvider { public Image getColumnImage ( Object element , int columnIndex ) { if ( columnIndex == <NUM_LIT:0> ) return ( ( ModelElement ) element ) . getImage ( ) ; return null ; } public String getColumnText ( Object element , int columnIndex ) { switch ( columnIndex ) { case <NUM_LIT:0> : return ( ( ModelElement ) element ) . getName ( ) ; case <NUM_LIT:1> : return ( ( ModelElement ) element ) . getKeybindingAsString ( ) ; default : Assert . isTrue ( false ) ; return null ; } } public String getText ( Object element ) { return getColumnText ( element , <NUM_LIT:0> ) ; } } private final class SeparateTableLabelProvider extends LabelProvider implements ITableLabelProvider { public Image getColumnImage ( Object element , int columnIndex ) { if ( columnIndex == <NUM_LIT:0> ) return ( ( ModelElement ) element ) . getImage ( ) ; return null ; } public String getColumnText ( Object element , int columnIndex ) { switch ( columnIndex ) { case <NUM_LIT:0> : return ( ( ModelElement ) element ) . getName ( ) ; default : Assert . isTrue ( false ) ; return null ; } } } private final Comparator fCategoryComparator = new Comparator ( ) { private int getRank ( Object o ) { return ( ( ModelElement ) o ) . getRank ( ) ; } public int compare ( Object o1 , Object o2 ) { return getRank ( o1 ) - getRank ( o2 ) ; } } ; private final class PreferenceModel { private static final int LIMIT = <NUM_LIT> ; private static final String COLON = ""<STR_LIT::>"" ; private static final String SEPARATOR = ""<STR_LIT>"" ; private final List < ModelElement > fElements ; final List < ModelElement > elements ; public PreferenceModel ( CompletionProposalComputerRegistry registry ) { List < CompletionProposalCategory > categories = registry . getProposalCategories ( ) ; fElements = new ArrayList < ModelElement > ( ) ; for ( CompletionProposalCategory category : categories ) { if ( category . hasComputers ( ) ) { fElements . add ( new ModelElement ( category , this ) ) ; } } Collections . sort ( fElements , fCategoryComparator ) ; elements = Collections . unmodifiableList ( fElements ) ; } public void moveUp ( ModelElement category ) { int index = fElements . indexOf ( category ) ; if ( index > <NUM_LIT:0> ) { ModelElement item = fElements . remove ( index ) ; fElements . add ( index - <NUM_LIT:1> , item ) ; writeOrderPreference ( null , false ) ; } } public void moveDown ( ModelElement category ) { int index = fElements . indexOf ( category ) ; if ( index < fElements . size ( ) - <NUM_LIT:1> ) { ModelElement item = fElements . remove ( index ) ; fElements . add ( index + <NUM_LIT:1> , item ) ; writeOrderPreference ( null , false ) ; } } private void writeInclusionPreference ( ModelElement changed , boolean isInDefaultCategory ) { StringBuffer buf = new StringBuffer ( ) ; for ( ModelElement item : fElements ) { boolean included = changed == item ? isInDefaultCategory : item . isInDefaultCategory ( ) ; if ( ! included ) buf . append ( item . getId ( ) + SEPARATOR ) ; } String newValue = buf . toString ( ) ; String oldValue = setValue ( PREF_EXCLUDED_CATEGORIES , newValue ) ; validateSettings ( PREF_EXCLUDED_CATEGORIES , oldValue , newValue ) ; } private void writeOrderPreference ( ModelElement changed , boolean isSeparate ) { StringBuffer buf = new StringBuffer ( ) ; int i = <NUM_LIT:0> ; for ( Iterator it = fElements . iterator ( ) ; it . hasNext ( ) ; i ++ ) { ModelElement item = ( ModelElement ) it . next ( ) ; boolean separate = changed == item ? isSeparate : item . isSeparateCommand ( ) ; int rank = separate ? i : i + LIMIT ; buf . append ( item . getId ( ) + COLON + rank + SEPARATOR ) ; } String newValue = buf . toString ( ) ; String oldValue = setValue ( PREF_CATEGORY_ORDER , newValue ) ; validateSettings ( PREF_CATEGORY_ORDER , oldValue , newValue ) ; } private boolean readInclusionPreference ( CompletionProposalCategory cat ) { String [ ] ids = getTokens ( getValue ( PREF_EXCLUDED_CATEGORIES ) , SEPARATOR ) ; for ( int i = <NUM_LIT:0> ; i < ids . length ; i ++ ) { if ( ids [ i ] . equals ( cat . getId ( ) ) ) return false ; } return true ; } private int readOrderPreference ( CompletionProposalCategory cat ) { String [ ] sortOrderIds = getTokens ( getValue ( PREF_CATEGORY_ORDER ) , SEPARATOR ) ; for ( int i = <NUM_LIT:0> ; i < sortOrderIds . length ; i ++ ) { String [ ] idAndRank = getTokens ( sortOrderIds [ i ] , COLON ) ; if ( idAndRank [ <NUM_LIT:0> ] . equals ( cat . getId ( ) ) ) return Integer . parseInt ( idAndRank [ <NUM_LIT:1> ] ) ; } return LIMIT - <NUM_LIT:1> ; } public void update ( ) { Collections . sort ( fElements , fCategoryComparator ) ; } } private final class ModelElement { private final CompletionProposalCategory fCategory ; private final Command fCommand ; private final IParameter fParam ; private final PreferenceModel fPreferenceModel ; ModelElement ( CompletionProposalCategory category , PreferenceModel model ) { fCategory = category ; ICommandService commandSvc = ( ICommandService ) PlatformUI . getWorkbench ( ) . getAdapter ( ICommandService . class ) ; fCommand = commandSvc . getCommand ( ""<STR_LIT>"" ) ; IParameter type ; try { type = fCommand . getParameters ( ) [ <NUM_LIT:0> ] ; } catch ( NotDefinedException x ) { Assert . isTrue ( false ) ; type = null ; } fParam = type ; fPreferenceModel = model ; } Image getImage ( ) { return CodeAssistAdvancedConfigurationBlock . this . getImage ( fCategory . getImageDescriptor ( ) ) ; } String getName ( ) { return fCategory . getDisplayName ( ) ; } String getKeybindingAsString ( ) { final Parameterization [ ] params = { new Parameterization ( fParam , fCategory . getId ( ) ) } ; final ParameterizedCommand pCmd = new ParameterizedCommand ( fCommand , params ) ; String key = getKeyboardShortcut ( pCmd ) ; return key ; } boolean isInDefaultCategory ( ) { return fPreferenceModel . readInclusionPreference ( fCategory ) ; } void setInDefaultCategory ( boolean included ) { if ( included != isInDefaultCategory ( ) ) fPreferenceModel . writeInclusionPreference ( this , included ) ; } String getId ( ) { return fCategory . getId ( ) ; } int getRank ( ) { int rank = getInternalRank ( ) ; if ( rank > PreferenceModel . LIMIT ) return rank - PreferenceModel . LIMIT ; return rank ; } void moveUp ( ) { fPreferenceModel . moveUp ( this ) ; } void moveDown ( ) { fPreferenceModel . moveDown ( this ) ; } private int getInternalRank ( ) { return fPreferenceModel . readOrderPreference ( fCategory ) ; } boolean isSeparateCommand ( ) { return getInternalRank ( ) < PreferenceModel . LIMIT ; } void setSeparateCommand ( boolean separate ) { if ( separate != isSeparateCommand ( ) ) fPreferenceModel . writeOrderPreference ( this , separate ) ; } void update ( ) { fCategory . setIncluded ( isInDefaultCategory ( ) ) ; int rank = getInternalRank ( ) ; fCategory . setSortOrder ( rank ) ; fCategory . setSeparateCommand ( rank < PreferenceModel . LIMIT ) ; } } private final PreferenceModel fModel ; private final Map fImages = new HashMap ( ) ; private CheckboxTableViewer fDefaultViewer ; private CheckboxTableViewer fSeparateViewer ; private Button fUpButton ; private Button fDownButton ; CodeAssistAdvancedConfigurationBlock ( IStatusChangeListener statusListener , IWorkbenchPreferenceContainer container ) { super ( statusListener , null , getAllKeys ( ) , container ) ; fModel = new PreferenceModel ( CompletionProposalComputerRegistry . getDefault ( ) ) ; } protected Control createContents ( Composite parent ) { ScrolledPageContent scrolled = new ScrolledPageContent ( parent , SWT . H_SCROLL | SWT . V_SCROLL ) ; scrolled . setExpandHorizontal ( true ) ; scrolled . setExpandVertical ( true ) ; Composite composite = new Composite ( scrolled , SWT . NONE ) ; int columns = <NUM_LIT:2> ; GridLayout layout = new GridLayout ( columns , false ) ; layout . marginWidth = <NUM_LIT:0> ; layout . marginHeight = <NUM_LIT:0> ; composite . setLayout ( layout ) ; createDefaultLabel ( composite , columns ) ; createDefaultViewer ( composite , columns ) ; createKeysLink ( composite , columns ) ; createFiller ( composite , columns ) ; createSeparateLabel ( composite , columns ) ; createSeparateSection ( composite ) ; createFiller ( composite , columns ) ; updateControls ( ) ; if ( fModel . elements . size ( ) > <NUM_LIT:0> ) { fDefaultViewer . getTable ( ) . select ( <NUM_LIT:0> ) ; fSeparateViewer . getTable ( ) . select ( <NUM_LIT:0> ) ; handleTableSelection ( ) ; } scrolled . setContent ( composite ) ; scrolled . setMinSize ( composite . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; return scrolled ; } private void createDefaultLabel ( Composite composite , int h_span ) { final ICommandService commandSvc = ( ICommandService ) PlatformUI . getWorkbench ( ) . getAdapter ( ICommandService . class ) ; final Command command = commandSvc . getCommand ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ) ; ParameterizedCommand pCmd = new ParameterizedCommand ( command , null ) ; String key = getKeyboardShortcut ( pCmd ) ; if ( key == null ) key = PreferencesMessages . CodeAssistAdvancedConfigurationBlock_no_shortcut ; PixelConverter pixelConverter = new PixelConverter ( composite ) ; int width = pixelConverter . convertWidthInCharsToPixels ( <NUM_LIT> ) ; Label label = new Label ( composite , SWT . NONE | SWT . WRAP ) ; label . setText ( Messages . format ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_page_description , new Object [ ] { key } ) ) ; GridData gd = new GridData ( GridData . FILL , GridData . FILL , true , false , h_span , <NUM_LIT:1> ) ; gd . widthHint = width ; label . setLayoutData ( gd ) ; createFiller ( composite , h_span ) ; label = new Label ( composite , SWT . NONE | SWT . WRAP ) ; label . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_default_table_description ) ; gd = new GridData ( GridData . FILL , GridData . FILL , true , false , h_span , <NUM_LIT:1> ) ; gd . widthHint = width ; label . setLayoutData ( gd ) ; } private void createDefaultViewer ( Composite composite , int h_span ) { fDefaultViewer = CheckboxTableViewer . newCheckList ( composite , SWT . SINGLE | SWT . BORDER ) ; Table table = fDefaultViewer . getTable ( ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( false ) ; table . setLayoutData ( new GridData ( GridData . FILL , GridData . BEGINNING , false , false , h_span , <NUM_LIT:1> ) ) ; TableColumn nameColumn = new TableColumn ( table , SWT . NONE ) ; nameColumn . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_default_table_category_column_title ) ; nameColumn . setResizable ( false ) ; TableColumn keyColumn = new TableColumn ( table , SWT . NONE ) ; keyColumn . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_default_table_keybinding_column_title ) ; keyColumn . setResizable ( false ) ; fDefaultViewer . addCheckStateListener ( new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { boolean checked = event . getChecked ( ) ; ModelElement element = ( ModelElement ) event . getElement ( ) ; element . setInDefaultCategory ( checked ) ; } } ) ; fDefaultViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; DefaultTableLabelProvider labelProvider = new DefaultTableLabelProvider ( ) ; fDefaultViewer . setLabelProvider ( labelProvider ) ; fDefaultViewer . setInput ( fModel . elements ) ; fDefaultViewer . setComparator ( new ViewerComparator ( ) ) ; final int ICON_AND_CHECKBOX_WITH = <NUM_LIT> ; final int HEADER_MARGIN = <NUM_LIT:20> ; int minNameWidth = computeWidth ( table , nameColumn . getText ( ) ) + HEADER_MARGIN ; int minKeyWidth = computeWidth ( table , keyColumn . getText ( ) ) + HEADER_MARGIN ; for ( int i = <NUM_LIT:0> ; i < fModel . elements . size ( ) ; i ++ ) { minNameWidth = Math . max ( minNameWidth , computeWidth ( table , labelProvider . getColumnText ( fModel . elements . get ( i ) , <NUM_LIT:0> ) ) + ICON_AND_CHECKBOX_WITH ) ; minKeyWidth = Math . max ( minKeyWidth , computeWidth ( table , labelProvider . getColumnText ( fModel . elements . get ( i ) , <NUM_LIT:1> ) ) ) ; } nameColumn . setWidth ( minNameWidth ) ; keyColumn . setWidth ( minKeyWidth ) ; } private void createKeysLink ( Composite composite , int h_span ) { Link link = new Link ( composite , SWT . NONE | SWT . WRAP ) ; link . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_key_binding_hint ) ; link . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { PreferencesUtil . createPreferenceDialogOn ( getShell ( ) , e . text , null , null ) ; } } ) ; PixelConverter pixelConverter = new PixelConverter ( composite ) ; int width = pixelConverter . convertWidthInCharsToPixels ( <NUM_LIT> ) ; GridData gd = new GridData ( GridData . FILL , GridData . FILL , false , false , h_span , <NUM_LIT:1> ) ; gd . widthHint = width ; link . setLayoutData ( gd ) ; } private void createFiller ( Composite composite , int h_span ) { Label filler = new Label ( composite , SWT . NONE ) ; filler . setVisible ( false ) ; filler . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , false , false , h_span , <NUM_LIT:1> ) ) ; } private void createSeparateLabel ( Composite composite , int h_span ) { PixelConverter pixelConverter = new PixelConverter ( composite ) ; int width = pixelConverter . convertWidthInCharsToPixels ( <NUM_LIT> ) ; Label label = new Label ( composite , SWT . NONE | SWT . WRAP ) ; label . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_separate_table_description ) ; GridData gd = new GridData ( GridData . FILL , GridData . FILL , false , false , h_span , <NUM_LIT:1> ) ; gd . widthHint = width ; label . setLayoutData ( gd ) ; } private void createSeparateSection ( Composite composite ) { createSeparateViewer ( composite ) ; createButtonList ( composite ) ; } private void createSeparateViewer ( Composite composite ) { fSeparateViewer = CheckboxTableViewer . newCheckList ( composite , SWT . SINGLE | SWT . BORDER ) ; Table table = fSeparateViewer . getTable ( ) ; table . setHeaderVisible ( false ) ; table . setLinesVisible ( false ) ; table . setLayoutData ( new GridData ( GridData . FILL , GridData . BEGINNING , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; TableColumn nameColumn = new TableColumn ( table , SWT . NONE ) ; nameColumn . setText ( PreferencesMessages . CodeAssistAdvancedConfigurationBlock_separate_table_category_column_title ) ; nameColumn . setResizable ( false ) ; fSeparateViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; ITableLabelProvider labelProvider = new SeparateTableLabelProvider ( ) ; fSeparateViewer . setLabelProvider ( labelProvider ) ; fSeparateViewer . setInput ( fModel . elements ) ; final int ICON_AND_CHECKBOX_WITH = <NUM_LIT> ; final int HEADER_MARGIN = <NUM_LIT:20> ; int minNameWidth = computeWidth ( table , nameColumn . getText ( ) ) + HEADER_MARGIN ; for ( int i = <NUM_LIT:0> ; i < fModel . elements . size ( ) ; i ++ ) { minNameWidth = Math . max ( minNameWidth , computeWidth ( table , labelProvider . getColumnText ( fModel . elements . get ( i ) , <NUM_LIT:0> ) ) + ICON_AND_CHECKBOX_WITH ) ; } nameColumn . setWidth ( minNameWidth ) ; fSeparateViewer . addCheckStateListener ( new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { boolean checked = event . getChecked ( ) ; ModelElement element = ( ModelElement ) event . getElement ( ) ; element . setSeparateCommand ( checked ) ; } } ) ; table . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { handleTableSelection ( ) ; } } ) ; } private void createButtonList ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NONE ) ;'}]","GridData gd = new GridData ( GridData. FILL, GridData. FILL, true, false, <NUM_LIT:1>, <NUM_LIT:1> ) ; composite. setLayoutData ( gd ) ; Button upButton = new Button ( composite, SWT. PUSH ) ; upButton. setText ( PreferencesMessages. CodeAssistAdvancedConfigurationBlock_move_up_button ) ; upButton. setEnabled ( false ) ; upButton. addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { fModel. moveUp ( ( ModelElement ) fSeparateViewer. getChecked ( ) ) ; updateControls ( ) ; } } ) ; fUpButton = upButton ; Button downButton = new Button ( composite, SWT. PUSH ) ; downButton. setText ( PreferencesMessages. CodeAssistAdvancedConfigurationBlock_move_down_button ) ; downButton. setEnabled ( false ) ; downButton. addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { fModel. moveDown ( ( ModelElement ) fSeparateViewer. getChecked ( ) ) ; updateControls ( ) ; } } ) ; fDownButton = downButton ; } private void",0.0006117750379504064
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . project ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import net . sf . sveditor . core . Tuple ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class SVProjectFileWrapper { private Document fDocument ; private List < Tuple < String , String > > fGlobalDefines ; private List < SVDBPath > fIncludePaths ; private List < SVDBPath > fLibraryPaths ; private List < SVDBPath > fBuildPaths ; private List < SVDBPath > fPluginPaths ; private List < SVDBPath > fArgFilePaths ; private List < SVDBSourceCollection > fSourceCollections ; private List < SVDBPath > fProjectReferences ; public SVProjectFileWrapper ( ) { fGlobalDefines = new ArrayList < Tuple < String , String > > ( ) ; fIncludePaths = new ArrayList < SVDBPath > ( ) ; fLibraryPaths = new ArrayList < SVDBPath > ( ) ; fBuildPaths = new ArrayList < SVDBPath > ( ) ; fPluginPaths = new ArrayList < SVDBPath > ( ) ; fArgFilePaths = new ArrayList < SVDBPath > ( ) ; fSourceCollections = new ArrayList < SVDBSourceCollection > ( ) ; fProjectReferences = new ArrayList < SVDBPath > ( ) ; DocumentBuilderFactory f = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder b = null ; try { b = f . newDocumentBuilder ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } fDocument = b . newDocument ( ) ; init ( ) ; } public SVProjectFileWrapper ( InputStream in ) throws Exception { fGlobalDefines = new ArrayList < Tuple < String , String > > ( ) ; fIncludePaths = new ArrayList < SVDBPath > ( ) ; fLibraryPaths = new ArrayList < SVDBPath > ( ) ; fBuildPaths = new ArrayList < SVDBPath > ( ) ; fPluginPaths = new ArrayList < SVDBPath > ( ) ; fArgFilePaths = new ArrayList < SVDBPath > ( ) ; fSourceCollections = new ArrayList < SVDBSourceCollection > ( ) ; fProjectReferences = new ArrayList < SVDBPath > ( ) ; DocumentBuilderFactory f = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder b = f . newDocumentBuilder ( ) ; b . setErrorHandler ( fErrorHandler ) ; fDocument = b . parse ( in ) ; init ( ) ; } private boolean init ( ) { NodeList svprojectList = fDocument . getElementsByTagName ( ""<STR_LIT>"" ) ; Element svproject ; boolean change = false ; if ( svprojectList . getLength ( ) == <NUM_LIT:0> ) { svproject = fDocument . createElement ( ""<STR_LIT>"" ) ; fDocument . appendChild ( svproject ) ; } else { svproject = ( Element ) svprojectList . item ( <NUM_LIT:0> ) ; } change |= init_defines ( svproject ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fIncludePaths ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fBuildPaths ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fPluginPaths ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fLibraryPaths ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fArgFilePaths ) ; change |= init_source_collections ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fSourceCollections ) ; change |= init_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fProjectReferences ) ; return change ; } private boolean init_paths ( Element svproject , String containerName , String elementName , List < SVDBPath > element_list ) { boolean change = false ; NodeList pathsList = svproject . getElementsByTagName ( containerName ) ; Element paths = null ; if ( pathsList . getLength ( ) > <NUM_LIT:0> ) { paths = ( Element ) pathsList . item ( <NUM_LIT:0> ) ; } else { paths = fDocument . createElement ( containerName ) ; svproject . appendChild ( paths ) ; change = true ; } NodeList includePathList = paths . getElementsByTagName ( elementName ) ; for ( int i = <NUM_LIT:0> ; i < includePathList . getLength ( ) ; i ++ ) { Element includePath = ( Element ) includePathList . item ( i ) ; String path = includePath . getAttribute ( ""<STR_LIT:path>"" ) ; if ( path == null ) { path = ""<STR_LIT>"" ; } element_list . add ( new SVDBPath ( path , false ) ) ; } return change ; } private boolean init_defines ( Element svproject ) { boolean change = false ; NodeList definesList = svproject . getElementsByTagName ( ""<STR_LIT>"" ) ; Element paths = null ; if ( definesList . getLength ( ) > <NUM_LIT:0> ) { paths = ( Element ) definesList . item ( <NUM_LIT:0> ) ; } else { paths = fDocument . createElement ( ""<STR_LIT>"" ) ; svproject . appendChild ( paths ) ; change = true ; } NodeList defineList = paths . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int i = <NUM_LIT:0> ; i < defineList . getLength ( ) ; i ++ ) { Element define = ( Element ) defineList . item ( i ) ; String key = define . getAttribute ( ""<STR_LIT:key>"" ) ; String val = define . getAttribute ( ""<STR_LIT>"" ) ; if ( key == null ) { key = ""<STR_LIT>"" ; } fGlobalDefines . add ( new Tuple < String , String > ( key , val ) ) ; } return change ; } private boolean init_source_collections ( Element svproject , String containerName , String elementName , List < SVDBSourceCollection > element_list ) { boolean change = false ; NodeList pathsList = svproject . getElementsByTagName ( containerName ) ; Element paths = null ; if ( pathsList . getLength ( ) > <NUM_LIT:0> ) { paths = ( Element ) pathsList . item ( <NUM_LIT:0> ) ; } else { paths = fDocument . createElement ( containerName ) ; svproject . appendChild ( paths ) ; change = true ; } NodeList sourceCollectionList = paths . getElementsByTagName ( elementName ) ; for ( int i = <NUM_LIT:0> ; i < sourceCollectionList . getLength ( ) ; i ++ ) { Element sourceCollection = ( Element ) sourceCollectionList . item ( i ) ; String baseLocation = sourceCollection . getAttribute ( ""<STR_LIT>"" ) ; if ( baseLocation == null ) { continue ; } SVDBSourceCollection c ; if ( sourceCollection . hasAttribute ( ""<STR_LIT>"" ) ) { boolean dflt_inc_excl = ( sourceCollection . getAttribute ( ""<STR_LIT>"" ) . equals ( ""<STR_LIT:true>"" ) ) ; c = new SVDBSourceCollection ( baseLocation , dflt_inc_excl ) ; if ( ! dflt_inc_excl ) { NodeList includeList = sourceCollection . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int j = <NUM_LIT:0> ; j < includeList . getLength ( ) ; j ++ ) { Element inc = ( Element ) includeList . item ( j ) ; String expr = inc . getAttribute ( ""<STR_LIT>"" ) ; if ( expr != null && ! expr . equals ( ""<STR_LIT>"" ) ) { c . getIncludes ( ) . add ( expr ) ; } } NodeList excludeList = sourceCollection . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int j = <NUM_LIT:0> ; j < excludeList . getLength ( ) ; j ++ ) { Element excl = ( Element ) excludeList . item ( j ) ; String expr = excl . getAttribute ( ""<STR_LIT>"" ) ; if ( expr != null && ! expr . equals ( ""<STR_LIT>"" ) ) { c . getExcludes ( ) . add ( expr ) ; } } } } else { c = new SVDBSourceCollection ( baseLocation , false ) ; NodeList includeList = sourceCollection . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int j = <NUM_LIT:0> ; j < includeList . getLength ( ) ; j ++ ) { Element inc = ( Element ) includeList . item ( j ) ; String expr = inc . getAttribute ( ""<STR_LIT>"" ) ; if ( expr != null && ! expr . equals ( ""<STR_LIT>"" ) ) { c . getIncludes ( ) . add ( expr ) ; } } NodeList excludeList = sourceCollection . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int j = <NUM_LIT:0> ; j < excludeList . getLength ( ) ; j ++ ) { Element excl = ( Element ) excludeList . item ( j ) ; String expr = excl . getAttribute ( ""<STR_LIT>"" ) ; if ( expr != null && ! expr . equals ( ""<STR_LIT>"" ) ) { c . getExcludes ( ) . add ( expr ) ; } } } element_list . add ( c ) ; } return change ; } private void marshall ( ) { NodeList svprojectList = fDocument . getElementsByTagName ( ""<STR_LIT>"" ) ; Element svproject ; if ( svprojectList . getLength ( ) == <NUM_LIT:0> ) { svproject = fDocument . createElement ( ""<STR_LIT>"" ) ; fDocument . appendChild ( svproject ) ; } else { svproject = ( Element ) svprojectList . item ( <NUM_LIT:0> ) ; } marshall_defines ( svproject ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fIncludePaths ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fBuildPaths ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fLibraryPaths ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fPluginPaths ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fArgFilePaths ) ; marshall_source_collections ( svproject , fSourceCollections ) ; marshall_paths ( svproject , ""<STR_LIT>"" , ""<STR_LIT>"" , fProjectReferences ) ; } private void marshall_paths ( Element svproject , String containerName , String elementName , List < SVDBPath > element_list ) { NodeList pathsList = svproject . getElementsByTagName ( containerName ) ; Element paths = null ; if ( pathsList . getLength ( ) > <NUM_LIT:0> ) { paths = ( Element ) pathsList . item ( <NUM_LIT:0> ) ; } else { paths = fDocument . createElement ( containerName ) ; svproject . appendChild ( paths ) ; } NodeList includePathList = paths . getElementsByTagName ( elementName ) ; for ( int i = <NUM_LIT:0> ; i < includePathList . getLength ( ) ; i ++ ) { paths . removeChild ( ( Element ) includePathList . item ( i ) ) ; } for ( SVDBPath ip : element_list ) { Element path = fDocument . createElement ( elementName ) ; path . setAttribute ( ""<STR_LIT:path>"" , ip . getPath ( ) ) ; paths . appendChild ( path ) ; } } private void marshall_defines ( Element svproject ) { NodeList definesList = svproject . getElementsByTagName ( ""<STR_LIT>"" ) ; Element defines = null ; if ( definesList . getLength ( ) > <NUM_LIT:0> ) { defines = ( Element ) definesList . item ( <NUM_LIT:0> ) ; } else { defines = fDocument . createElement ( ""<STR_LIT>"" ) ; svproject . appendChild ( defines ) ; } NodeList defineList = defines . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int i = <NUM_LIT:0> ; i < defineList . getLength ( ) ; i ++ ) { defines . removeChild ( ( Element ) defineList . item ( i ) ) ; } for ( Tuple < String , String > def : fGlobalDefines ) { Element def_e = fDocument . createElement ( ""<STR_LIT>"" ) ; def_e . setAttribute ( ""<STR_LIT:key>"" , def . first ( ) ) ; def_e . setAttribute ( ""<STR_LIT>"" , def . second ( ) ) ; defines . appendChild ( def_e ) ; } } private void marshall_source_collections ( Element svproject , List < SVDBSourceCollection > source_collections ) { NodeList collectionsList = svproject . getElementsByTagName ( ""<STR_LIT>"" ) ; Element paths = null ; if ( collectionsList . getLength ( ) > <NUM_LIT:0> ) { paths = ( Element ) collectionsList . item ( <NUM_LIT:0> ) ; } else { paths = fDocument . createElement ( ""<STR_LIT>"" ) ; svproject . appendChild ( paths ) ; } NodeList sourceCollections = paths . getElementsByTagName ( ""<STR_LIT>"" ) ; for ( int i = <NUM_LIT:0> ; i < sourceCollections . getLength ( ) ; i ++ ) { paths . removeChild ( ( Element ) sourceCollections . item ( i ) ) ; } for ( SVDBSourceCollection c : source_collections ) { Element path = fDocument . createElement ( ""<STR_LIT>"" ) ; path . setAttribute ( ""<STR_LIT>"" , c . getBaseLocation ( ) ) ; path . setAttribute ( ""<STR_LIT>"" , ( c . getDefaultIncExcl ( ) ) ? ""<STR_LIT:true>"" : ""<STR_LIT:false>"" ) ; if ( ! c . getDefaultIncExcl ( ) ) { for ( String inc : c . getIncludes ( ) ) { Element inc_e = fDocument . createElement ( ""<STR_LIT>"" ) ; inc_e . setAttribute ( ""<STR_LIT>"" , inc ) ; path . appendChild ( inc_e ) ; } for ( String excl : c . getExcludes ( ) ) { Element excl_e = fDocument . createElement ( ""<STR_LIT>"" ) ; excl_e . setAttribute ( ""<STR_LIT>"" , excl ) ; path . appendChild ( excl_e ) ; } } paths . appendChild ( path ) ; } } public List < SVDBPath > getIncludePaths ( ) { return fIncludePaths ; } public List < SVDBPath > getLibraryPaths ( ) { return fLibraryPaths ; } public List < SVDBPath > getBuildPaths ( ) { return fBuildPaths ; } public List < SVDBPath > getPluginPaths ( ) { return fPluginPaths ; } public List < SVDBPath > getArgFilePaths ( ) { return fArgFilePaths ; } public void addArgFilePath ( String path ) { SVDBPath arg_path = new SVDBPath ( path ) ; if ( ! fArgFilePaths . contains ( arg_path ) ) { fArgFilePaths . add ( arg_path ) ; } } public List < Tuple < String , String > > getGlobalDefines ( ) { return fGlobalDefines ; } public void addGlobalDefine ( String key , String val ) { synchronized ( fGlobalDefines ) { boolean found = false ; for ( int i = <NUM_LIT:0> ; i < fGlobalDefines . size ( ) ; i ++ ) { if ( fGlobalDefines . get ( i ) . first ( ) . equals ( key ) ) { fGlobalDefines . set ( i , new Tuple < String , String > ( key , val ) ) ; found = true ; break ; } } if ( ! found ) { fGlobalDefines . add ( new Tuple < String , String > ( key , val ) ) ; } } } public List < SVDBSourceCollection > getSourceCollections ( ) { return fSourceCollections ; } public List < SVDBPath > getProjectRefs ( ) { return fProjectReferences ; } public void addProjectRef ( String ref ) { SVDBPath p = new SVDBPath ( ref ) ; fProjectReferences . add ( p ) ; } public void toStream ( OutputStream out ) { SAXTransformerFactory tf = ( SAXTransformerFactory ) SAXTransformerFactory . newInstance ( ) ; try { marshall ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { DOMSource ds = new DOMSource ( fDocument ) ; StreamResult sr = new StreamResult ( out ) ; tf . setAttribute ( ""<STR_LIT>"" , new Integer ( <NUM_LIT:2> ) ) ; TransformerHandler th = tf . newTransformerHandler ( ) ; Properties format = new Properties ( ) ; format . put ( OutputKeys . METHOD , ""<STR_LIT>"" ) ; format . put ( OutputKeys . ENCODING , ""<STR_LIT:UTF-8>"" ) ; format . put ( OutputKeys . INDENT , ""<STR_LIT:yes>"" ) ; th . getTransformer ( ) . setOutputProperties ( format ) ; th . setResult ( sr ) ; th . getTransformer ( ) . transform ( ds , sr ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public SVProjectFileWrapper duplicate ( ) { SVProjectFileWrapper ret = new SVProjectFileWrapper ( ) ; ret . init ('}]",)fDocument = this.fDocument; ret.fGlobalDefines = this.fGlobalDefines; ret.fIncludePaths = this.fIncludePaths; ret.fLibraryPaths = this.fLibraryPaths; ret.fBuildPaths = this.fBuildPaths; ret.fPluginPaths = this.fPluginPaths; ret.fArgFilePaths = this.fArgFilePaths; ret.fSourceCollections = this.fSourceCollections; ret.fProjectReferences = this.fProjectReferences; return ret; } },0.0002476913512016367
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ti . util ; import org . jruby . ast . Node ; public class ClosestSpanningNodeLocator extends NodeLocator { private ClosestSpanningNodeLocator ( ) { } private static ClosestSpanningNodeLocator staticInstance = new ClosestSpanningNodeLocator ( ) ; public static ClosestSpanningNodeLocator Instance ( ) { return staticInstance ; } private int offset ; private INodeAcceptor acceptor ; private Node locatedNode ; public Node findClosestSpanner ( Node rootNode , int offset , INodeAcceptor acceptor ) { if ( rootNode == null ) return null ; locatedNode = null ; this . offset = offset ; this . acceptor = acceptor ; rootNode . accept ( this ) ; return locatedNode ; } public Object handleNode ( Node iVisited ) { boolean nodeSpansOffset = nodeSpansOffset ( iVisited , offset ) ; boolean nodeSpansMoreCloselyThanCurrent = ( locatedNode == null ) || ( calculateSpanLength ( iVisited ) <= calculateSpanLength ( locatedNode ) ) ; if ( nodeSpansOffset && nodeSpansMoreCloselyThanCurrent && acceptor . doesAccept ( iVisited ) ) { locatedNode'}]","= iVisited ; } return null ; } private boolean nodeSpansOffset ( Node node, int offset ) { return ( node. getStartOffset ( ) <= offset ) && ( offset <= node. getEndOffset ( ) ) ; } private int calculateSpanLength ( Node node ) { return node. getEndOffset ( ) - node. getStartOffset ( ) ; } }",4.375017070355701e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . packager ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . nio . charset . Charset ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarOutputStream ; import java . util . zip . ZipEntry ; import javax . tools . Diagnostic ; import javax . tools . DiagnosticCollector ; import javax . tools . JavaCompiler ; import javax . tools . JavaCompiler . CompilationTask ; import javax . tools . JavaFileObject ; import javax . tools . StandardJavaFileManager ; import javax . tools . ToolProvider ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . batch . ResourceRepository ; import com . asakusafw . compiler . batch . ResourceRepository . Cursor ; import com . asakusafw . compiler . common . FileRepository ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . compiler . flow . Location ; import com . asakusafw . compiler . flow . Packager ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . utils . java . model . syntax . CompilationUnit ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . util . Filer ; public class FilePackager extends FlowCompilingEnvironment . Initialized implements Packager { static final Logger LOG = LoggerFactory . getLogger ( FilePackager . class ) ; private static final Charset CHARSET = Charset . forName ( ""<STR_LIT:UTF-8>"" ) ; private static final String SOURCE_DIRECTORY = ""<STR_LIT:src>"" ; private static final String CLASS_DIRECTORY = ""<STR_LIT>"" ; private final File sourceDirectory ; private final File classDirectory ; private final Filer sourceFiler ; private final Filer resourceFiler ; private final List < ? extends ResourceRepository > fragmentRepositories ; public FilePackager ( File workingDirectory , List < ? extends ResourceRepository > fragmentRepositories ) { Precondition . checkMustNotBeNull ( workingDirectory , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( fragmentRepositories , ""<STR_LIT>"" ) ; this . fragmentRepositories = fragmentRepositories ; this . sourceDirectory = new File ( workingDirectory , SOURCE_DIRECTORY ) ; this . classDirectory = new File ( workingDirectory , CLASS_DIRECTORY ) ; this . sourceFiler = new Filer ( sourceDirectory , CHARSET'}]","); this.resourceFiler = new Filer(resourceDirectory, CHARSET); } @Override public void pack ( DiagnosticCollector diagnostics, CompilationUnit compilationUnit ) throws IOException { if ( diagnostics. getErrorCount ( ) > 0 ) { // TODO: diagnostics -> error message throw new RuntimeException ( diagnostics. getErrorMessages ( ) ) ; } // TODO: compilation unit -> java class file List <? extends JavaFileObject > files = new ArrayList < > ( ) ; files. add ( sourceFiler. create ( compilationUnit. getName ( ), compilationUnit. getSyntaxTree ( ) ) ) ; for ( ResourceRepository repository : fragmentRepositories ) { Cursor cursor = repository. openCursor ( ) ; while ( cursor. hasNext ( ) ) { files. add ( resourceFiler. create ( cursor. next ( ). getName ( ), cursor. next ( ). getContent ( ) ) ) ; } cursor. close ( ) ; } // TODO: files -> jar file JarOutputStream jar = new JarOutputStream ( new FileOutputStream ( new File ( classDirectory, compilationUnit. getName ( ) + "".jar"" ) ) ) ; for ( JavaFileObject file : files ) { jar. putNextEntry ( new JarEntry ( file. getName ( ) ) )",0.00037459435564895485
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . util . LinkedList ; import java . util . Map ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . TextUtilities ; import org . eclipse . jface . text . TypedPosition ; import org . eclipse . jface . text . formatter . ContextBasedFormattingStrategy ; import org . eclipse . jface . text . formatter . FormattingContextProperties ; import org . eclipse . jface . text . formatter . IFormattingContext ; import org . eclipse . text . edits . MalformedTreeException ; import org . eclipse . text . edits . TextEdit ; import org . rubypeople . rdt . core . formatter . CodeFormatter ; import org . rubypeople'}]",".rdt.core.FormatterConstants;public class RubyFormatter extends ContextBasedFormattingStrategy { private static final int TAB_STOPS = 8; private static final String NEWLINE = System.getProperty(""line.separator"");private CodeFormatter codeFormatter;private IDocument document;private int tabSize;public RubyFormatter(int tabSize) { this.tabSize = tabSize; } @Override public void configure(Map properties) { super.configure(properties); if (properties.containsKey(FormattingContextProperties.TAB_SIZE)) { tabSize = (Integer) properties.get(FormattingContextProperties.TAB_SIZE); } } @Override public void configure(IDocument document, int tabSize) { super.configure(document, tabSize); this.document = document; this.tabSize = tabSize; } @Override public TextEdit format(IDocument document, int offset, int length) throws BadLocationException, MalformedTreeException { if (document == null || document.getChar(offset) == '\n') { return null; } // TODO: support for multi-line formatting if (offset + length > document.getLength()) { length = document.getLength() - offset; } // TODO: support for folding IFormattingContext context = new FormattingContext(document, offset, length); if (codeFormatter == null) { codeFormatter = new Code",0.00034050066749929237
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . utils ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . ISVDBNamedItem ; import net . sf . sveditor . core . db . ISVDBScopeItem ; import net . sf . sveditor . core . db . SVDBPreProcCond ; public class SVDBItemPrint { public static void printItem ( ISVDBItemBase item ) { printItem ( <NUM_LIT:0> , item ) ; } private static void printItem ( int indent , ISVDBItemBase item ) { for ( int i = <NUM_LIT:0> ; i < indent ; i ++ ) { System . out'}]",".println ( ""  "" ) ; } if ( item instanceof ISVDBNamedItem ) { printItemName ( item ) ; } else if ( item instanceof ISVDBScopeItem ) { printItemScope ( item ) ; } else if ( item instanceof SVDBPreProcCond ) { printItemCond ( item ) ; } else { System. out. println ( ""<STR_LIT> "" + item. getClass ( ). getName ( ) + ""<STR_LIT>"" ) ; } } //... (rest of the method)",0.00015311051606480003
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . windgate . core . process . ProcessProfile ; import com . asakusafw . windgate . core . process . ProcessProvider ; import com . asakusafw . windgate . core . resource . ResourceProfile ; import com . asakusafw . windgate . core . session . SessionProfile ; public class GateProfile { static final WindGateLogger WGLOG = new WindGateCoreLogger ( GateProfile . class ) ; static final Logger LOG = LoggerFactory . getLogger ( GateProfile . class ) ; private final String name ; private final CoreProfile core ; private final SessionProfile session ; private final List < ProcessProfile > processes ; private final List < ResourceProfile > resources ; public GateProfile ( String name , CoreProfile core , SessionProfile session , Collection < ? extends ProcessProfile > processes , Collection < ? extends ResourceProfile > resources ) { if ( core == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( session == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( processes == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( resources == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . name = name ; this . core = core ; this . session = session ; this . processes = Collections . unmodifiableList ( new ArrayList < ProcessProfile > ( processes ) ) ; this . resources = Collections . unmodifiableList ( new ArrayList < ResourceProfile > ( resources ) ) ; } public String getName ( ) { return name ; } public CoreProfile getCore ( ) { return core ; } public SessionProfile getSession ( ) { return session ; } public List < ProcessProfile > getProcesses ( ) { return processes ; } public List < ResourceProfile >'}]",getResources() { return resources; },3.252453629446527e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . basic ; import java . io . IOException ;'}]",import java.util.zip.ZipEntry;,2.553287932007391e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs . job ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; import org . oddjob . framework . SimpleJob ; import org . oddjob . state . JobState ; import org . oddjob . state . State ; import org . oddjob . state . StateEvent ; import org . oddjob . state . StateListener ; import org . oddjob . state . StateMemory ; import org . oddjob . util . OddjobConfigException ; public class DependsJob extends SimpleJob implements Stoppable , StateListener { private static final long serialVersionUID = <NUM_LIT> ; private transient Stateful job ; private transient volatile StateEvent event ; public DependsJob ( ) { logger ( ) . warn ( ""<STR_LIT>"" ) ; } @ ArooaAttribute synchronized public void setJob ( Stateful node ) { this . job = node ; } synchronized public Stateful getJob ( ) { return this . job ; } protected int execute ( ) throws Throwable { if ( job == null ) { throw new OddjobConfigException ( ""<STR_LIT>"" ) ; } try { job . addStateListener ( this ) ; while ( ! stop ) { State state = event . getState ( ) ; logger ( ) . debug ( ""<STR_LIT>"" + state + ""<STR_LIT:]>"" ) ; long sleep = <NUM_LIT:10> ; if ( state == JobState . READY ) { if ( job instanceof Runnable ) { StateMemory remember = new StateMemory ( ) ; remember . run ( ( Runnable ) job ) ; if ( remember . getJobState ( ) . isComplete ( ) ) { return <NUM_LIT:0> ; } else if ('}]","remember.getJobState().isFailed()) { throw new OddjobConfigException(""<STR_LIT>""); } } sleep = 5000L; } else if (state == JobState.RUNNING) { sleep = 1000L; } else if (state == JobState.FAILED) { throw new OddjobConfigException(""<STR_LIT>""); } Thread.sleep(sleep); } finally { job.removeStateListener(this); } } catch (InterruptedException e) { logger().warn(""<STR_LIT>"", e); } return 1; } @Override public void stateChanged(StateEvent event) { this.event = event; } @Override public void stop() { this.stop = true; } }",0.0002122679985424615
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . docs . html ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import net . sf . sveditor . core . docs . DocGenConfig ; import net . sf . sveditor . core . docs . DocTopicType ; public class HTMLUtils { static final String STR_DOCTYPE = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; static String genHTMLHeadStart ( String relPathToHTML , String title ) { String result = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + title + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + relPathToHTML + ""<STR_LIT>"" + ""<STR_LIT>"" + relPathToHTML + ""<STR_LIT>"" + ""<STR_LIT>"" + relPathToHTML + ""<STR_LIT>"" + ""<STR_LIT>"" + relPathToHTML + ""<STR_LIT>"" + ""<STR_LIT>"" ; return result ; } static String genBodyBegin ( String bodyClass ) { String result = ""<STR_LIT>"" + bodyClass + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; return result ; } static String genFooter ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genBodyHTMLEnd ( ) { String result = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; return result ; } static String genContentBegin ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genContentEnd ( ) { return genDivEnd ( ) ; } static String genCTopicBegin ( String topicID ) { String result = ""<STR_LIT>"" + topicID + ""<STR_LIT:>>"" ; return result ; } static String genCTopicEnd ( ) { return genDivEnd ( ) ; } static String genCTitle ( String name ) { String result = ""<STR_LIT>"" + name + ""<STR_LIT>"" + name + ""<STR_LIT>"" ; return result ; } static String genCBodyBegin ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genCBodyEnd ( ) { return genDivEnd ( ) ; } static String genSummaryBegin ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genSummaryEnd ( ) { return genDivEnd ( ) ; } static String genSTitle ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genSBorderBegin ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genSBorderEnd ( ) { return genDivEnd ( ) ; } static String genSTableBegin ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genSTableEnd ( ) { return genTableEnd ( ) ; } static String genDivEnd ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genTableEnd ( ) { String result = ""<STR_LIT>"" ; return result ; } static String genCSSClassForTopic ( String topicName ) { String c = ""<STR_LIT:C>"" ; if ( topicName == null || topicName . length ( ) < <NUM_LIT:1> ) { return ""<STR_LIT>"" ; } c += capitalize ( topicName ) ; return c ; } static String capitalize ( String in ) { String out = ""<STR_LIT>"" ; out = out + in . substring ( <NUM_LIT:0> , <NUM_LIT:1> ) . toUpperCase ( ) ; out = out + in . substring ( <NUM_LIT:1> ) . toLowerCase ( ) ; return out ; } static String genCSSClassForTopicInSummary ( String topicName ) { String c = ""<STR_LIT:S>"" ; if ( topicName == null'}]","|| topicName.length() < <NUM_LIT:1> ) { return ""<STR_LIT>"" ; } c += capitalize(topicName) ; return c ; } static String genCSSClassForTopicInTable ( String topicName ) { String c = ""<STR_LIT:T>"" ; if ( topicName == null || topicName.length() < <NUM_LIT:1> ) { return ""<STR_LIT>"" ; } c += capitalize(topicName) ; return c ; } }",0.00016460023974183109
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . temporary ; import java . io . IOException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . windgate . core . resource . DrainDriver ; public class ModelOutputDrainDriver < T > implements DrainDriver < T > { static final Logger LOG = LoggerFactory . getLogger ( ModelOutputDrainDriver . class ) ;'}]",private final ModelOutput<T> modelOutput;,2.8202349142627043e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . menu ; import net . ggtools . grand . ui . actions . ClearFiltersAction ; import net . ggtools . grand . ui . actions . EditGraphPropertiesAction ; import net . ggtools . grand . ui . actions . ExportGraphAction ; import net . ggtools . grand . ui . actions . FilterConnectedToNodeAction ; import net . ggtools . grand . ui . actions . FilterFromNodeAction ; import net . ggtools . grand . ui . actions . FilterIsolatedNodesAction ; import net . ggtools . grand . ui . actions . FilterMissingNodesAction ; import net . ggtools . grand . ui . actions . FilterSelectedNodesAction ; import net . ggtools . grand . ui . actions . FilterToNodeAction ; import net . ggtools . grand . ui . actions . ReloadGraphAction ; import net . ggtools . grand . ui . graph . GraphControlerProvider ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; public class GraphMenu extends MenuManager { public GraphMenu ( final GraphControlerProvider controlerProvider ) { super ( ""<STR_LIT>"" ) ; add ( new ReloadGraphAction ( controlerProvider ) ) ; add ( new EditGraphPropertiesAction ( controlerProvider ) ) ; add ( new ExportGraphAction ( controlerProvider ) ) ; add ( new Separator ( ""<STR_LIT>"" ) ) ; add ('}]",new ClearFiltersAction(controlerProvider));,2.968495211829682e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . vaadin . teemu . clara ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . teemu . clara . binder . annotation . EventHandler ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; public class ClaraIntegrationTest { private InputStream xml ; private Controller controller ; private AttributeInterceptor firstInterceptor ; private AttributeInterceptor secondInterceptor ; public static class Controller { private boolean clicked ; @ EventHandler ( ""<STR_LIT>"" ) public void clicked ( Button . ClickEvent event ) { clicked = true ; } } @ Before public void setUp ( ) { xml = getXml ( ""<STR_LIT>"" ) ; controller = new Controller ( ) ; firstInterceptor = getInterceptor ( ) ; secondInterceptor = getSecondInterceptor ( ) ; } @ Test public void testCreateMethod_usingAllParametersWithTwoInterceptors_interceptorsAndControllerCalled ( ) { Component layout = Clara . create ( xml , controller , firstInterceptor , secondInterceptor ) ; Button button200px = ( Button ) Clara . findComponentById ( layout , ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , button200px . getCaption ( ) ) ; assertFalse ( controller . clicked ) ; button200px . click ( ) ; assertTrue ( controller . clicked'}]",) ; } private InputStream getXml ( ) { return null ; } private AttributeInterceptor getInterceptor ( ) { return null ; } private AttributeInterceptor getSecondInterceptor ( ) { return null ; } },7.185063025062714e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import java . lang . reflect . InvocationTargetException ; import java . util . Map ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IWorkspaceRunnable ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . ProgressMonitorDialog ; import org . eclipse . jface . preference . IPreferencePageContainer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . dialogs . PropertyPage ; import org . eclipse . ui . preferences . IWorkbenchPreferenceContainer ; import org . rubypeople . rdt . core . ILoadpathEntry ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . corext . util . BusyIndicatorRunnableContext ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . actions . WorkbenchRunnableAdapter ; import org . rubypeople . rdt . internal . ui . dialogs . StatusUtil ; import org . rubypeople . rdt . internal . ui . util . ExceptionHandler ; import org . rubypeople . rdt . internal . ui . wizards . IStatusChangeListener ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . BuildPathsBlock ; public class BuildPathsPropertyPage extends PropertyPage implements IStatusChangeListener { public static final String PROP_ID = ""<STR_LIT>"" ; private static final String PAGE_SETTINGS = ""<STR_LIT>"" ; private static final String INDEX = ""<STR_LIT>"" ; public static final Object DATA_ADD_ENTRY = ""<STR_LIT>"" ; public static final Object DATA_REVEAL_ENTRY = ""<STR_LIT>"" ; public static final Object DATA_REVEAL_ATTRIBUTE_KEY = ""<STR_LIT>"" ; public static final Object DATA_BLOCK = ""<STR_LIT>"" ; private BuildPathsBlock fBuildPathsBlock ; private boolean fBlockOnApply = false ; protected Control createContents ( Composite parent ) { noDefaultAndApplyButton ( ) ; IProject project = getProject ( ) ; Control result ; if ( project == null || ! isRubyProject ( project ) ) { result = createWithoutRuby ( parent ) ; } else if ( ! project . isOpen ( ) ) { result = createForClosedProject ( parent ) ; } else { result = createWithRuby ( parent , project ) ; } Dialog . applyDialogFont ( result ) ; return result ; } public void createControl ( Composite parent ) { super . createControl ( parent ) ; } private IDialogSettings getSettings ( ) { IDialogSettings javaSettings = RubyPlugin . getDefault ( ) . getDialogSettings ( ) ; IDialogSettings pageSettings = javaSettings . getSection ( PAGE_SETTINGS ) ; if ( pageSettings == null ) { pageSettings = javaSettings . addNewSection ( PAGE_SETTINGS ) ; pageSettings . put ( INDEX , <NUM_LIT:3> ) ; } return pageSettings ; } public void setVisible ( boolean visible ) { if ( fBuildPathsBlock != null ) { if ( ! visible ) { if ( fBuildPathsBlock . hasChangesInDialog ( ) ) { String title = PreferencesMessages . BuildPathsPropertyPage_unsavedchanges_title ; String message = PreferencesMessages . BuildPathsPropertyPage_unsavedchanges_message ; String [ ] buttonLabels = new String [ ] { PreferencesMessages . BuildPathsPropertyPage_unsavedchanges_button_save , PreferencesMessages . BuildPathsPropertyPage_unsavedchanges_button_discard , PreferencesMessages . BuildPathsPropertyPage_unsavedchanges_button_ignore } ; MessageDialog dialog = new MessageDialog ( getShell ( ) , title , null , message , MessageDialog . QUESTION , buttonLabels , <NUM_LIT:0> ) ; int res = dialog . open ( ) ; if ( res == <NUM_LIT:0> ) { performOk ( ) ; } else if ( res == <NUM_LIT:1> ) { fBuildPathsBlock . init ( RubyCore . create ( getProject ( ) ) , null , null ) ; } else { } } } else { if ( ! fBuildPathsBlock . hasChangesInDialog ( ) && fBuildPathsBlock . hasChangesInLoadpathFile ( ) ) { fBuildPathsBlock . init ( RubyCore . create ( getProject ( ) ) , null , null ) ; } } } super . setVisible ( visible ) ; } private Control createWithRuby ( Composite parent , IProject project ) { IWorkbenchPreferenceContainer pageContainer = null ; IPreferencePageContainer container = getContainer ( ) ; if ( container instanceof IWorkbenchPreferenceContainer ) { pageContainer = ( IWorkbenchPreferenceContainer ) container ; } fBuildPathsBlock = new BuildPathsBlock ( new BusyIndicatorRunnableContext ( ) , this , getSettings ( ) . getInt ( INDEX ) , false , pageContainer ) ; fBuildPathsBlock . init ( RubyCore . create ( project ) , null , null ) ; return fBuildPathsBlock . createControl ( parent ) ; } private Control createWithoutRuby ( Composite parent ) { Label label = new Label ( parent , SWT . LEFT ) ; label . setText ( PreferencesMessages . BuildPathsPropertyPage_no_java_project_message ) ; fBuildPathsBlock = null ; setValid ( true ) ; return label ; } private Control createForClosedProject ( Composite parent ) { Label label = new Label ( parent , SWT . LEFT ) ; label . setText ( PreferencesMessages . BuildPathsPropertyPage_closed_project_message ) ; fBuildPathsBlock = null ; setValid ( true ) ; return label ; } private IProject getProject ( ) { IAdaptable adaptable = getElement ( ) ; if ( adaptable != null ) { IRubyElement elem = ( IRubyElement ) adaptable . getAdapter ( IRubyElement . class ) ; if ( elem instanceof IRubyProject ) { return ( ( IRubyProject ) elem ) . getProject ( ) ; } } return null ; } private boolean isRubyProject ( IProject proj ) { try { return proj . hasNature ( RubyCore . NATURE_ID ) ; } catch ( CoreException e ) { RubyPlugin . log ( e ) ; } return false ; } public boolean performOk ( ) { if ( fBuildPathsBlock != null ) { getSettings ( ) . put ( INDEX , fBuildPathsBlock . getPageIndex ( ) ) ; if ( fBuildPathsBlock . hasChangesInDialog ( ) ) { IWorkspaceRunnable runnable = new IWorkspaceRunnable ( ) { public void run ( IProgressMonitor'}]","monitor) throws CoreException { fBuildPathsBlock. saveChanges ( ) ; } }; WorkbenchRunnableAdapter. run ( new BusyIndicatorRunnableContext ( ), runnable ) ; } else { return true ; } return false ; } public void statusChanged ( IStatus status ) { if ( status. getSeverity ( ) == IStatus. ERROR ) { fBlockOnApply = true ; } else { fBlockOnApply = false ; } } }",0.0001775482961955158
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fruit ; import java . io . Serializable ; import org . oddjob . arooa . convert . Convertlet ; import org . oddjob . arooa . convert . ConvertletException ; import org . oddjob . arooa . convert . ConversionProvider ; import org . oddjob . arooa . convert . ConversionRegistry ; import fruit . Colour ; import fruit . ColourType ; import fruit . ColourType . Colours ; public'}]","class ColourConvertlet implements Convertlet<Colour, Serializable>, ConversionProvider<Colour, Serializable> { @Override public Serializable convert(Colour input) throws ConvertletException { if (input.getType() == ColourType.RED) { return Colours.RED; } else if (input.getType() == ColourType.GREEN) { return Colours.GREEN; } else if (input.getType() == ColourType.BLUE) { return Colours.BLUE; } else { throw new ConvertletException(""Unsupported colour type: "" + input.getType()); } } @Override public ConversionRegistry<Colour, Serializable> getConversionRegistry() { // implementation } }",0.00017715805714721072
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamefield ; import org . rubypeople . rdt . refactoring . core . IRefactoringContext ; import org . rubypeople . rdt . refactoring . core . IValidator ; import org . rubypeople . rdt . refactoring . core . RubyRefactoring ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentWithIncluding ; import org . rubypeople . rdt . refactoring . ui . NewNameListener ; import org . rubypeople . rdt . refactoring . ui . pages . OccurenceReplaceSelectionPage ; import org . rubypeople . rdt . refactoring . ui . pages . RenameFieldPage ; import org . rubypeople . rdt . refactoring . util . NameValidator ; public class RenameFieldRefactoring extends RubyRefactoring { private static final class LocalVarNameValidator implements IValidator { public boolean isValid ( String test ) { return NameValidator . isValidLocalVariableName ( test ) ; } } public static final String NAME = Messages . RenameFieldRefactoring_Name ; private RenameFieldConfig config ; private RenameFieldConditionChecker checker ; private FieldRenamer renamer ; private NewNameListener nameListener ; private RenameFieldPage pageOne ; private OccurenceReplaceSelectionPage page ; public RenameFieldRefactoring ( IRefactoringContext selectionProvider ) { super ( NAME , selectionProvider ) ; config ='}]","new RenameFieldConfig(); checker = new RenameFieldConditionChecker(config); renamer = new FieldRenamer(config, checker); nameListener = new NewNameListener(renamer, checker); pageOne = new RenameFieldPage(this, selectionProvider, nameListener); page = new OccurenceReplaceSelectionPage(this, selectionProvider); }",0.00010451991694260177
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . flow . testing . model . KeyConflict ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class KeyConflictInput implements ModelInput < KeyConflict > { private final RecordParser parser ; public KeyConflictInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . parser = parser ; } @ Override public boolean readTo ( KeyConflict model ) throws IOException { if ( parser . next ( ) == false ) { return false ; } parser . fill ( model .'}]","keyConflictId, model. conflictId, model. conflictType, model. conflictValue ) ; return true ; } @ Override public boolean readTo ( KeyConflict model, long limit ) throws IOException { if ( parser. next ( ) == false ) { return false ; } parser. fill ( model. keyConflictId, model. conflictId, model. conflictType, model. conflictValue ) ; return true ; } }",0.00012857431704662656
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . lang ; public interface ModelVisitor { public void visit ( ScalarModel model ) ; public void visit ('}]",CompositeModel model ) ; },2.4782684993918488e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . bulkloader ; import java . io . IOException ; import java . sql . Connection ; import java . sql . SQLException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . testdriver . core . AbstractExporterRetriever ; import com . asakusafw . testdriver . core . DataModelDefinition ; import com . asakusafw . testdriver . core . DataModelSource ; import com . asakusafw . testdriver . core . ExporterRetriever ; import com . asakusafw . vocabulary . bulkloader . BulkLoadExporterDescription ; import com . asakusafw . vocabulary . bulkloader . BulkLoadExporterDescription . DuplicateRecordCheck ; public class BulkLoadExporterRetriever extends AbstractExporterRetriever < BulkLoadExporterDescription > { static final Logger LOG = LoggerFactory . getLogger ( BulkLoadExporterRetriever . class ) ; @ Override public void truncate ( BulkLoadExporterDescription description ) throws IOException { Configuration conf = Configuration . load ( description . getTargetName ( ) ) ; truncate ( conf , description . getTableName ( ) ) ; if ( description . getDuplicateRecordCheck ( ) != null ) { truncate ( conf , description . getDuplicateRecordCheck ( ) . getTableName ( ) ) ; } } private void truncate ( Configuration conf , String tableName ) throws IOException { assert conf != null ; assert tableName != null ; LOG . info ( ""<STR_LIT>"" , tableName ) ; Util . truncate ( conf , tableName ) ; } @ Override public < V > ModelOutput < V > createOutput ( DataModelDefinition < V > definition , BulkLoadExporterDescription description ) throws IOException { Configuration conf = Configuration . load ( description . getTargetName ( ) ) ; TableInfo < V > info = buildTableInfo ( definition , description ) ; LOG . info ( ""<STR_LIT>"" , info . getTableName ( ) ) ; LOG . debug ( ""<STR_LIT>"" , info ) ; Connection conn = conf . open ( ) ; boolean green = false ; try { ModelOutput < V > output = new TableOutput < V > ( info , conn'}]",", conf.getMapperClass(), conf.getReducerClass()); green = true; try { output.write(definition); } finally { output.close(); } finally { conn.close(); } if (green) { LOG.info(MessageFormat.format(""<STR_LIT>"", info.getTableName())); } return output; } private <V> TableInfo<V> buildTableInfo(DataModelDefinition<V> definition, BulkLoadExporterDescription description) throws IOException { Configuration conf = Configuration.load(description.getTargetName()); TableInfo<V> info = new TableInfo<>(definition, conf.getTableName(), conf.getSchema(), conf.getColumns(), conf.getTypes()); info.setPrimaryKey(definition.getPrimaryKey()); return info; } }",0.0002056200738499249
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . parser ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBMarker ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . parser . SVParseException ; import net . sf . sveditor . core . tests . SVCoreTestsPlugin ; import net . sf . sveditor . core . tests . SVDBTestUtils ; public class TestParserSVStdExamples extends TestCase { public void test_7_2_0_struct_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT:f>"" , ""<STR_LIT>"" } ) ; } public void test_7_2_0_struct_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT:f>"" , ""<STR_LIT>"" } ) ; } public void test_7_2_1_struct_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void test_7_2_1_struct_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT>"" } ) ; } public void test_7_2_2_struct_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void test_7_3_0_union_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void test_13_5_3_tf_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void test_13_5_3_tf_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" , ""<STR_LIT:n>"" } ) ; } public void test_13_5_4_tf_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" } ) ; } public void test_16_3_0_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:c>"" } ) ; } public void test_16_3_0_assert_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_3_0_assert_3 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_2_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_2_assert_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_2_assert_3 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_3_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_3_assert_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_4_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_4_assert_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_4_5_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT>"" } ) ; } public void test_16_6_0_assert_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_8_0_sequence_1 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_8_0_sequence_2 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_8_0_sequence_3 ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; runTest ( ""<STR_LIT>"" , ""<STR_LIT>"" , new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_8_0_sequence_4 ( ) throws SVParseException { SVCorePlugin . getDefault ('}]","runTest(""<STR_LIT>"", ""<STR_LIT>"", new String[] {""<STR_LIT:m>""}); } public void test_16_8_0_sequence_5 ( ) throws SVParseException { SVCorePlugin. getDefault ( ). enableDebug ( false ) ; runTest ( ""<STR_LIT>"", ""<STR_LIT>"", new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_9_0_choice_1 ( ) throws SVParseException { SVCorePlugin. getDefault ( ). enableDebug ( false ) ; runTest ( ""<STR_LIT>"", ""<STR_LIT>"", new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_9_0_choice_2 ( ) throws SVParseException { SVCorePlugin. getDefault ( ). enableDebug ( false ) ; runTest ( ""<STR_LIT>"", ""<STR_LIT>"", new String [ ] { ""<STR_LIT:m>"" } ) ; } public void test_16_10_0_choice_1 ( ) throws SVParseException { SVCorePlugin. getDefault ( ). enableDebug ( false ) ; runTest ( ""<STR_L",0.00043224864091737065
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . model ; import java . util . ArrayList ; import java . util . List ; import org . oddjob . OJConstants ; import org . oddjob . Oddjob ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . logging . ConsoleArchiver ; import org . oddjob . logging . LogArchiver ; import org . oddjob . logging . cache . LocalConsoleArchiver ; import org . oddjob . logging . log4j . Log4jArchiver ; import org . oddjob . monitor .'}]",Model; public class LogArchiverModel extends Model { private List<LogArchiver> archivers = new ArrayList<>(); private LogArchiver selectedArchiver; public LogArchiverModel() { super(OJConstants.LOG_ARCHIVER); } public void addArchiver(LogArchiver archiver) { archivers.add(archiver); } public void setSelectedArchiver(LogArchiver archiver) { selectedArchiver = archiver; } public LogArchiver getSelectedArchiver() { return selectedArchiver; } public List<LogArchiver> getArchivers() { return archivers; } },0.0001696096621526992
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index . plugin_lib ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . db . index . ISVDBIndexFactory ; import net . sf . sveditor . core . db . index . SVDBIndexConfig ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCache ; public class SVDBPluginLibIndexFactory implements ISVDBIndexFactory { public static final String TYPE = ""<STR_LIT>"" ; public ISVDBIndex createSVDBIndex ( String project , String base_location , ISVDBIndexCache cache , SVDBIndexConfig config ) {'}]","SVCorePlugin plugin = SVCorePlugin.getPlugin(project); ISVDBIndex index = plugin.createIndex(base_location, cache, config); return index;",5.7414358686513884e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . resource . StringConverter ; import org . eclipse . jface . text . TextAttribute ; import org . eclipse . jface . text . rules . ITokenScanner ; import org . eclipse . jface . text . rules . Token ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Display ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . text . IAbstractManagedScanner ; import org . rubypeople . rdt . ui . text . IColorManager ; import org . rubypeople . rdt . ui . text . IColorManagerExtension ; public abstract class AbstractRubyTokenScanner implements ITokenScanner , IAbstractManagedScanner { private String [ ] fPropertyNamesColor ; private String [ ] fPropertyNamesBgColor ; private String [ ] fPropertyNamesBold ; private String [ ] fPropertyNamesBGEnabled ; private String [ ] fPropertyNamesItalic ; private String [ ] fPropertyNamesStrikethrough ; private String [ ] fPropertyNamesUnderline ; private IColorManager fColorManager ; private IPreferenceStore fPreferenceStore ; private boolean fNeedsLazyColorLoading ; private Map fTokenMap = new HashMap ( ) ; public AbstractRubyTokenScanner ( IColorManager manager , IPreferenceStore store ) { super ( ) ; fColorManager = manager ; fPreferenceStore = store ; } protected IPreferenceStore getPreferenceStore ( ) { return fPreferenceStore ; } abstract protected String [ ] getTokenProperties ( ) ; public final void initialize ( ) { fPropertyNamesColor = getTokenProperties ( ) ; int length = fPropertyNamesColor . length ; fPropertyNamesBgColor = new String [ length ] ; fPropertyNamesBGEnabled = new String [ length ] ; fPropertyNamesBold = new String [ length ] ; fPropertyNamesItalic = new String [ length ] ; fPropertyNamesStrikethrough = new String [ length ] ; fPropertyNamesUnderline = new String [ length ] ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { fPropertyNamesBgColor [ i ] = getBGKey ( fPropertyNamesColor [ i ] ) ; fPropertyNamesBold [ i ] = getBoldKey ( fPropertyNamesColor [ i ] ) ; fPropertyNamesBGEnabled [ i ] = getBGEnabledKey ( fPropertyNamesColor [ i ] ) ; fPropertyNamesItalic [ i ] = getItalicKey ( fPropertyNamesColor [ i ] ) ; fPropertyNamesStrikethrough [ i ] = getStrikethroughKey ( fPropertyNamesColor [ i ] ) ; fPropertyNamesUnderline [ i ] = getUnderlineKey ( fPropertyNamesColor [ i ] ) ; } fNeedsLazyColorLoading = Display . getCurrent ( ) == null ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { if ( fNeedsLazyColorLoading ) addTokenWithProxyAttribute ( fPropertyNamesColor [ i ] , fPropertyNamesBgColor [ i ] , fPropertyNamesBGEnabled [ i ] , fPropertyNamesBold [ i ] , fPropertyNamesItalic [ i ] , fPropertyNamesStrikethrough [ i ] , fPropertyNamesUnderline [ i ] ) ; else addToken ( fPropertyNamesColor [ i ] , fPropertyNamesBgColor [ i ] , fPropertyNamesBGEnabled [ i ] , fPropertyNamesBold [ i ] , fPropertyNamesItalic [ i ] , fPropertyNamesStrikethrough [ i ] , fPropertyNamesUnderline [ i ] ) ; } } protected String getBoldKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_BOLD_SUFFIX ; } protected String getBGKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_BG_SUFFIX ; } protected String getBGEnabledKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_BG_ENABLED_SUFFIX ; } protected String getItalicKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_ITALIC_SUFFIX ; } protected String getStrikethroughKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_STRIKETHROUGH_SUFFIX ; } protected String getUnderlineKey ( String colorKey ) { return colorKey + PreferenceConstants . EDITOR_UNDERLINE_SUFFIX ; } private void addTokenWithProxyAttribute ( String colorKey , String bgColorKey , String bgEnabledKey , String boldKey , String italicKey , String strikethroughKey , String underlineKey ) { fTokenMap . put ( colorKey , new Token ( createTextAttribute ( null , null , bgEnabledKey , boldKey , italicKey , strikethroughKey , underlineKey ) ) ) ; } private void resolveProxyAttributes ( ) { if ( fNeedsLazyColorLoading && Display . getCurrent ( ) != null ) { for ( int i = <NUM_LIT:0> ; i < fPropertyNamesColor . length ; i ++ ) { addToken ( fPropertyNamesColor [ i ] , fPropertyNamesBgColor [ i ] , fPropertyNamesBGEnabled [ i ] , fPropertyNamesBold [ i ] , fPropertyNamesItalic [ i ] , fPropertyNamesStrikethrough [ i ] , fPropertyNamesUnderline [ i ] ) ; } fNeedsLazyColorLoading = false ; } } private void addToken ( String colorKey , String bgColorKey , String bgEnabledKey , String boldKey , String italicKey , String strikethroughKey , String underlineKey ) { bindColor ( colorKey ) ; bindColor ( bgColorKey ) ; if ( ! fNeedsLazyColorLoading ) fTokenMap . put ( colorKey , new Token ( createTextAttribute ( colorKey , bgColorKey , bgEnabledKey , boldKey , italicKey , strikethroughKey , underlineKey ) ) ) ; else { Token token = ( ( Token ) fTokenMap . get ( colorKey ) ) ; if ( token != null ) token . setData ( createTextAttribute ( colorKey , bgColorKey , bgEnabledKey , boldKey , italicKey , strikethroughKey , underlineKey ) ) ; } } private void bindColor ( String colorKey ) { if ( fColorManager != null && colorKey != null && fColorManager . getColor ( colorKey ) == null ) { RGB rgb = PreferenceConverter . getColor ( fPreferenceStore , colorKey ) ; if ( rgb == PreferenceConverter . COLOR_DEFAULT_DEFAULT && ! colorKey . endsWith ( PreferenceConstants . EDITOR_BG_SUFFIX ) ) return ; if ( fColorManager instanceof IColorManagerExtension ) { IColorManagerExtension ext = ( IColorManagerExtension ) fColorManager ; ext . unbindColor ( colorKey ) ; ext . bindColor ( colorKey , rgb ) ; } } } public Token getToken ( String key ) { if ( fNeedsLazyColorLoading ) resolveProxyAttributes ( ) ; return ( Token ) fTokenMap . get ( key ) ; } private TextAttribute createTextAttribute ( String colorKey , String bgColorKey , String bgEnabledKey , String boldKey , String italicKey , String strikethroughKey , String underlineKey ) { Color color = null ; if ( colorKey != null ) color = fColorManager . getColor ( colorKey ) ; boolean useBG = fPreferenceStore . getBoolean ( bgEnabledKey ) ; Color bgColor = null ; if ( bgColorKey != null && useBG ) bgColor = fColorManager . getColor ( bgColorKey ) ; int style = fPreferenceStore . getBoolean ( boldKey ) ? SWT . BOLD : SWT . NORMAL ; if ( fPreferenceStore . getBoolean ( italicKey ) ) style |= SWT . ITALIC ; if ( fPreferenceStore . getBoolean ( strikethroughKey ) ) style |= TextAttribute . STRIKETHROUGH ; if ( fPreferenceStore . getBoolean ( underlineKey ) ) style |= TextAttribute . UNDERLINE ; return new TextAttribute ( color , bgColor , style ) ; } public boolean affectsBehavior ( PropertyChangeEvent event ) { return indexOf ( event . getProperty ( ) ) >= <NUM_LIT:0> ; } public void adaptToPreferenceChange ( PropertyChangeEvent event ) { String p = event . getProperty ( ) ; int index = indexOf ( p ) ; Token token = getToken ( fPropertyNamesColor [ index ] ) ; if ( fPropertyNamesColor [ index ] . equals ( p ) ) adaptToColorChange ( token , event ) ; if ( fPropertyNamesBgColor [ index ] . equals ( p ) || fPropertyNamesBGEnabled [ index ] . equals ( p ) ) adaptToBgColorChange ( token , event ) ; else if ( fPropertyNamesBold [ index ] . equals ( p ) ) adaptToStyleChange ( token , event , SWT . BOLD ) ; else if ( fPropertyNamesItalic [ index ] . equals ( p ) ) adaptToStyleChange ( token , event , SWT . ITALIC ) ; else if ( fPropertyNamesStrikethrough [ index ] . equals ( p ) ) adaptToStyleChange ( token , event , TextAttribute . STRIKETHROUGH ) ; else if ( fPropertyNamesUnderline [ index ] . equals ( p ) ) adaptToStyleChange ( token , event , TextAttribute . UNDERLINE ) ; } private void adaptToStyleChange ( Token token , PropertyChangeEvent event , int styleAttribute ) { boolean eventValue = false ; Object value = event . getNewValue ( ) ; if ( value instanceof Boolean ) eventValue = ( ( Boolean ) value ) . booleanValue ( ) ; else if ( IPreferenceStore . TRUE . equals ( value ) ) eventValue = true ; Object data = token . getData ( ) ; if ( data instanceof TextAttribute ) { TextAttribute oldAttr = ( TextAttribute ) data ; boolean activeValue = ( oldAttr . getStyle ( ) & styleAttribute ) == styleAttribute ; if ( activeValue != eventValue ) token . setData ( new TextAttribute ( oldAttr . getForeground ( ) , oldAttr . getBackground ( ) , eventValue ? oldAttr . getStyle ( ) | styleAttribute : oldAttr . getStyle ( ) & ~ styleAttribute ) ) ; } } private void adaptToColorChange ( Token token , PropertyChangeEvent event ) { adaptToSomeColorChange ( token , event , true ) ; } private void adaptToBgColorChange ( Token token , PropertyChangeEvent'}]","event ) { adaptToSomeColorChange ( token, event, false ) ; } private void adaptToSomeColorChange ( Token token, PropertyChangeEvent event, boolean isColorChange ) { Color newColor = null ; Object value = event. getNewValue ( ) ; if ( value instanceof Color ) newColor = ( Color ) value ; else if ( value instanceof RGB ) newColor = new Color ( Display. getCurrent ( ), ( RGB ) value ) ; if ( newColor!= null ) { Color oldColor = null ; Object data = token. getData ( ) ; if ( data instanceof TextAttribute ) { TextAttribute oldAttr = ( TextAttribute ) data ; oldColor = oldAttr. getForeground ( ) ; } if ( newColor!= null &&! newColor. equals ( oldColor ) ) { Color oldBGColor = null ; if ( isColorChange ) { RGB oldRGB = PreferenceConverter. getColor ( fPreferenceStore, event. getProperty ( ) ) ; if ( oldRGB!= PreferenceConverter. COLOR_DEFAULT_DEFAULT ) oldBGColor = new Color ( Display. getCurrent ( ), oldRGB ) ; } TextAttribute newAttr = new TextAttribute ( newColor, oldBGColor, token. getStyle ( ) ) ; token.",0.00046591206054021956
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . scanner ; import java . util . List ; import net . sf . sveditor . core . Tuple ; public interface ISVPreProcScannerObserver { void init ( ISVScanner scanner ) ; void enter_file ( String'}]",filePath ) ; void enter_line ( int lineNumber ) ; void exit_line ( ) ; void exit_file ( ) ; void enter_block ( int lineNumber ) ; void exit_block ( ) ; void error ( String message ) ; void warning ( String message ) ; void info ( String message ) ; void end_of_file ( ) ; void setTuple ( Tuple tuple ) ; void setList ( List <?> list ) ; },0.00011877938013058788
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . batch ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; import java . text . MessageFormat ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . vocabulary . batch . Batch ; import com . asakusafw . vocabulary . batch . BatchDescription ; public final class BatchDriver { static final Logger LOG = LoggerFactory . getLogger ( BatchDriver . class ) ; private Class < ? extends BatchDescription > description ; private BatchClass batchClass ; private List < String > diagnostics ; private BatchDriver ( Class < ? extends BatchDescription > description ) { Precondition . checkMustNotBeNull ( description , ""<STR_LIT:description>"" ) ; this . description = description ; this . diagnostics = Lists . create ( ) ; } public static BatchDriver analyze ( Class < ? extends BatchDescription > description ) { Precondition . checkMustNotBeNull ( description , ""<STR_LIT:description>"" ) ; BatchDriver analyzer = new BatchDriver ( description ) ; analyzer . analyze ( ) ; return analyzer ; } public BatchClass getBatchClass ( ) { return batchClass ; } public Class < ? extends BatchDescription > getDescription ( ) { return this . description ; } public List < String > getDiagnostics ( ) { return diagnostics ; } private void analyze ( ) { Batch config = findConfig ( ) ; BatchDescription instance = describe ( ) ;'}]","batchClass = new BatchClass(config, instance); } private Batch findConfig() { try { Constructor<Batch> constructor = description.getConstructor(String.class, String.class, String.class); Object[] params = { ""config"", ""config"", ""config"" }; return constructor.newInstance(params); } catch (Exception e) { if (Modifier.isPublic(description.getModifiers())) { throw new RuntimeException(MessageFormat.format(""<STR_LIT> unable to find configuration constructor in {0}"", description.getName()), e); } else { return null; } } } private BatchDescription describe() { try { Constructor<BatchDescription> constructor = description.getConstructor(); return constructor.newInstance(); } catch (Exception e) { if (Modifier.isPublic(description.getModifiers())) { throw new RuntimeException(MessageFormat.format(""<STR_LIT> unable to find constructor in {0}"", description.getName()), e); } else { return null; } } } }",0.0002519459975484027
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net .'}]",.sf.sveditor.core.db.DBException; import net.sf.sveditor.core.db.DBResult; public class DBPreparedStatement extends DBStatement { //... },5.435781411593707e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . bootstrap ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . HashMap ; import java . util . Map ; import com . asakusafw . yaess . core . ExecutionContext ; import com . asakusafw . yaess . core . ExecutionScript ; import com . asakusafw . yaess . core . ExecutionScriptHandler ; public interface ExecutionTracker { String KEY_CLASS = ""<STR_LIT>"" ; String KEY_ID = ""<STR_LIT>"" ; void add ( Id id , Record record ) throws IOException , InterruptedException ; public class Record { public final ExecutionContext context ; public final ExecutionScript script ; public final ExecutionScriptHandler < ? > handler ; public Record ( ExecutionContext context , ExecutionScript script , ExecutionScriptHandler < ? > handler ) { this . context = context ; this . script = script ; this . handler = handler ; } @ Override public String toString ( ) { return MessageFormat . format ( ""<STR_LIT>"" , context . getFlowId ( ) , context . getPhase ( ) , script == null ? handler . getHandlerId ( ) : script . getId ( ) ) ; } } public class Id { private static final Map < String , Id > CACHE = new HashMap < String , Id > ( ) ; private final String token ; private Id ( String token ) { this . token = token ; } public static Id get ( String token ) { synchronized ( CACHE ) { Id cached = CACHE . get ( token'}]","); if ( cached == null ) { cached = new Id(token); CACHE.put(token, cached); } return cached; } public String getToken() { return token; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass()!= obj.getClass()) return false; Id other = (Id) obj; return token.equals(other.token); } @Override public int hashCode() { return token.hashCode(); } }",0.00014385493099755673
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . flow ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . lang . reflect . Field ; import java . util . List ; import java . util . Set ; import javax . lang . model . element . Element ; import org . junit . Test ; import com . asakusafw . compiler . operator . Callback ; import com . asakusafw . compiler . operator . OperatorCompilerException ; import com . asakusafw . compiler . operator . OperatorCompilerTestRoot ; import com . asakusafw . compiler . operator . model . MockFoo ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . utils . graph . Graph ; import com . asakusafw . vocabulary . flow . FlowPart ; import com . asakusafw . vocabulary . flow . Source ; import com . asakusafw . vocabulary . flow . graph . FlowGraph ; import com . asakusafw . vocabulary . flow . graph . FlowPartDescription ; import com . asakusafw . vocabulary . flow . testing . MockIn ; import com . asakusafw . vocabulary . flow . testing . MockOut ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; public class FlowClassEmitterTest extends OperatorCompilerTestRoot { @ Test public void simple ( ) throws Exception { add ( ""<STR_LIT>"" ) ; add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new Collector ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < MockHoge > in = MockIn . of ( MockHoge . class , ""<STR_LIT>"" ) ; MockOut < MockHoge > out = MockOut . of ( MockHoge . class , ""<STR_LIT>"" ) ; Object operator = invoke ( factory , ""<STR_LIT>"" , in ) ; assertStored ( loader , ""<STR_LIT:OK>"" ) ; Source < MockHoge > flowOut = output ( MockHoge . class , operator , ""<STR_LIT>"" ) ; out . add ( flowOut ) ; FlowPartDescription desc = ( FlowPartDescription ) flowOut . toOutputPort ( ) . getOwner ( ) . getDescription ( ) ; assertThat ( desc . getInputPorts ( ) . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( desc . getInputPorts ( ) . get ( <NUM_LIT:0> ) . getName ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( desc . getInputPorts ( ) . get ( <NUM_LIT:0> ) . getDataType ( ) , is ( ( Object ) MockHoge . class ) ) ; assertThat ( desc . getOutputPorts ( ) . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( desc . getOutputPorts ( ) . get ( <NUM_LIT:0> ) . getName ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( desc . getOutputPorts ( ) . get ( <NUM_LIT:0>'}]",").getDataType(), is((Object) MockHoge.class)); } public void add(Class<?> clazz) throws Exception { Field field = clazz.getDeclaredField(""field""); field.setAccessible(true); field.set(null, new Object()); } public void invoke(Object factory, String methodName, MockIn<?> in) throws Exception { return factory.getClass().getMethod(methodName, in.getClass()).invoke(factory, in); } public <T> T create(ClassLoader loader, String className) throws Exception { return (T) loader.loadClass(className).newInstance(); } public void assertStored(ClassLoader loader, String className) throws Exception { Set<Class<?>> classes = loader.getDefinedClasses(); boolean found = false; for (Class<?> clazz : classes) { if (clazz.getName().equals(className)) { found = true; break; } } assertThat(found, is(true)); } public <T> MockOut<T> output(Class<T> clazz, Object operator, String methodName) throws Exception { return new MockOut<>(clazz, operator.getClass().getMethod(methodName, clazz).invoke(operator)); } }",0.000314536482384032
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . io . File ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import junit . framework . TestCase ; import org . oddjob . OurDirs ;'}]",import java.lang.reflect.Method;,2.378991162819383e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . wizards ; import java . util . ArrayList ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Path ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . DirectoryDialog ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . model . WorkbenchContentProvider ; import org . eclipse . ui . model . WorkbenchLabelProvider ; import org . rubypeople . rdt . internal . ui . IUIConstants ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . TypedViewerFilter ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . EditVariableEntryDialog ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . MultipleFolderSelectionDialog ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . NewVariableEntryDialog ; public final class BuildPathDialogAccess { private BuildPathDialogAccess ( ) { } public static IPath [ ] chooseSourceFolderEntries ( Shell shell , IPath initialSelection , IPath [ ] usedEntries ) { if ( usedEntries == null ) { throw new IllegalArgumentException ( ) ; } String title = NewWizardMessages . BuildPathDialogAccess_ExistingSourceFolderDialog_new_title ; String message = NewWizardMessages . BuildPathDialogAccess_ExistingSourceFolderDialog_new_description ; return internalChooseFolderEntry ( shell , initialSelection , usedEntries , title , message ) ; } private static IPath [ ] internalChooseFolderEntry ( Shell shell , IPath initialSelection , IPath [ ] usedEntries , String title , String message ) { Class [ ] acceptedClasses = new Class [ ] { IProject . class , IFolder . class } ; ArrayList usedContainers = new ArrayList ( usedEntries . length ) ; IWorkspaceRoot root = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; for ( int i = <NUM_LIT:0> ; i < usedEntries . length ; i ++ ) { IResource resource = root . findMember ( usedEntries [ i ] ) ; if ( resource instanceof IContainer ) { usedContainers . add ( resource ) ; } } IResource focus = initialSelection != null ? root . findMember ( initialSelection ) : null ; Object [ ] used = usedContainers . toArray ( ) ; MultipleFolderSelectionDialog dialog = new MultipleFolderSelectionDialog ( shell , new WorkbenchLabelProvider ( ) , new WorkbenchContentProvider ( ) ) ; dialog . setExisting ( used ) ; dialog . setTitle ( title ) ; dialog . setMessage ( message ) ; dialog . setHelpAvailable ( false ) ; dialog . addFilter ( new TypedViewerFilter ( acceptedClasses , used ) ) ; dialog . setInput ( root ) ; dialog . setInitialFocus ( focus ) ; if ( dialog . open ( ) == Window . OK ) { Object [ ] elements = dialog . getResult ( ) ; IPath [ ] res = new IPath ['}]","elements.length]; for (int i = 0; i < elements.length; i++) { IResource resource = root.findMember((IPath) elements[i]); res[i] = resource.getFullPath(); } return res; } public static IPath chooseSourceFolderEntry(Shell shell, IPath initialSelection, IPath usedEntry) { if (usedEntry == null) { throw new IllegalArgumentException(); } String title = NewWizardMessages.BuildPathDialogAccess_ExistingSourceFolderDialog_new_title; String message = NewWizardMessages.BuildPathDialogAccess_ExistingSourceFolderDialog_new_description; return internalChooseFolderEntry(shell, initialSelection, new IPath[] { usedEntry }, title, message); } public static IPath chooseSourceFolderEntry(Shell shell, IPath initialSelection) { return chooseSourceFolderEntry(shell, initialSelection, null); } }",0.0002593865921525344
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . search ; import org . eclipse . core . runtime . IPath ; import org . rubypeople . rdt . core . IRubyElement ; public interface IRubySearchScope { int SOURCES = <NUM_LIT:1> ; int APPLICATION_LIBRARIES = <NUM_LIT:2> ; int SYSTEM_LIBRARIES = <NUM_LIT:4> ; int REFERENCED_PROJECTS = <NUM_LIT:8> ; IPath [ ]'}]",getPaths(IRubyElement element) throws java.lang.IllegalStateException;,3.513881347865205e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api . plus . person . impl ; import org . springframework . social . google . api . impl . AbstractGoogleApiOperations ; import org . springframework . social . google . api . plus . person . ContactQueryBuilder ; import org . springframework . social . google . api . plus . person . PeoplePage ; import org . springframework . social . google . api . plus . person . Person ; import org . springframework . social . google . api . plus . person . PersonOperations ; import org . springframework . social . google . api . plus . person . PersonQueryBuilder ; import org . springframework . web . client . RestTemplate ; public class PersonTemplate extends AbstractGoogleApiOperations implements PersonOperations { static final String PEOPLE_SEARCH_URL = ""<STR_LIT>"" ; static final String PEOPLE_URL = PEOPLE_SEARCH_URL + \'<CHAR_LIT:/>\' ; private static final String ACTIVITIES_URL = ""<STR_LIT>"" ; private static final String PLUSONERS = ""<STR_LIT>"" ; private static final String RESHARERS = ""<STR_LIT>"" ; static final String FEED_PREFIX = ""<STR_LIT>"" ; static final String CONTACTS_FEED = FEED_PREFIX + ""<STR_LIT>"" ; public PersonTemplate ( RestTemplate restTemplate , boolean isAuthorized ) { super ( restTemplate , isAuthorized ) ; }'}]",protected String getPeopleUrl() { return PEOPLE_URL; },3.5415255057591915e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> import java . io . * ; import org . kxml2 . io . * ; import org . xmlpull . v1 . * ; public class EventList { public static void main ( String [ ] args ) throws IOException , XmlPullParserException { for ( int i = <NUM_LIT:0> ; i < <NUM_LIT:2> ; i ++ ) { XmlPullParser xr = new KXmlParser ( ) ; xr . setInput ( new FileReader ( args [ <NUM_LIT:0> ] ) ) ; System . out . println ( ""<STR_LIT>"" ) ; System . out . println ( ""<STR_LIT>"" + ( i == <NUM_LIT:0> ? ""<STR_LIT>"" : ""<STR_LIT>"" ) + ""<STR_LIT>"" ) ; System . out . println ( ""<STR_LIT>"" ) ; do { if'}]","xr. next () == XmlPullParser. END_TAG && xr. getName (). equals ( ""item"" ) ) { break ; } else if ( xr. next () == XmlPullParser. START_TAG && xr. getName (). equals ( ""item"" ) ) { System. out. println ( ""<STR_LIT>"" + i + ""<STR_LIT>"" ) ; } } } }",0.00011818435871782971
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . loiane . model ; public class Tag { private int id ; private String value ; public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getValue ( ) { return value ; }'}]",public void setValue(String value) { this.value = value; },3.350700921355227e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . model . syntax ; public enum ImportKind { SINGLE_TYPE ( Target . TYPE , Range . SINGLE ) , TYPE_ON_DEMAND ( Target . TYPE , Range . ON_DEMAND ) , SINGLE_STATIC ( Target . MEMBER , Range . SINGLE ) , STATIC_ON_DEMAND ( Target . MEMBER , Range . ON_DEMAND ) , ; private Target target ; private Range range ; private ImportKind ( Target target , Range range ) { assert target != null ; assert range != null ; this . target = target ; this . range = range ; } public Target getTarget ( ) { return target ; }'}]",public Range getRange ( ) { return range ; },3.0799939042845023e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . srcgen ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . indent . ISVIndenter ; import net . sf . sveditor . core . indent . SVIndentScanner ; import net . sf . sveditor . core . scanner . SVCharacter ; import net . sf . sveditor . core . scanutils . StringTextScanner ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; public class NewInterfaceGenerator { public void generate ( ISVDBIndexIterator index_it , final IFile file_path , String interfacename , IProgressMonitor monitor ) { String subst_filename = ""<STR_LIT>"" ; if ( monitor == null ) { monitor = new NullProgressMonitor ( ) ; } monitor . beginTask ( ""<STR_LIT>"" , <NUM_LIT:100> ) ; subst_filename = SVCharacter . toSVIdentifier ( file_path . getName ( ) ) ; String template = ""<STR_LIT>"" + ""<STR_LIT>"" + file_path . getName ( ) + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + subst_filename + ""<STR_LIT:n>"" + ""<STR_LIT>"" + subst_filename + ""<STR_LIT:n>"" + ""<STR_LIT:n>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" + interfacename + ""<STR_LIT:n>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" + interfacename ; monitor . worked ( <NUM_LIT> ) ; template += ""<STR_LIT>"" ; monitor . worked ( <NUM_LIT> ) ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT:n>"" + ""<STR_LIT>"" + subst_filename + ""<STR_LIT>"" ; monitor . subTask ( ""<STR_LIT>"" ) ; SVIndentScanner scanner = new SVIndentScanner ( new StringTextScanner ( new StringBuilder ( template ) ) ) ; ISVIndenter indenter = SVCorePlugin . getDefault'}]",().getIndentManager().createIndenter(scanner); monitor.worked(<NUM_LIT>); indenter.setIndentationLevel(0); monitor.worked(<NUM_LIT>); monitor.done(); } },2.966979086655293e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . concurrent . Callable ; import junit . framework . TestCase ; public class CallableProxyGeneratorTest extends TestCase { public interface MyInterface { } public static class MyJob implements Callable < Integer > , MyInterface { @ Override public Integer call ( ) throws Exception { return <NUM_LIT:0> ; } } public void testAProxyImplementsAllInterfaces ( ) { MyJob callable = new MyJob ( ) ; Object'}]",proxy = new CallableProxyGenerator ( ). createProxy ( callable ); proxy.getClass ( ). getInterfaces ( ) ; } },4.774663683090872e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . model . util ; import java . util . ArrayList ; import java . util . List ; import com . asakusafw . utils . java . model . syntax . Annotation ; import com . asakusafw . utils . java . model . syntax . AnnotationElement ; import com . asakusafw . utils . java . model . syntax . Attribute ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Modifier ; import com . asakusafw . utils . java . model . syntax . ModifierKind ; import com . asakusafw . utils . java . model . syntax . NamedType ; import com . asakusafw . utils . java . model . syntax . Type ; public class AttributeBuilder { private final ModelFactory f ; private final List < Attribute > attributes ; public AttributeBuilder ( ModelFactory factory ) { if ( factory == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . f = factory ; this . attributes = new ArrayList < Attribute > ( ) ; } public AttributeBuilder copy ( ) { AttributeBuilder copy = new AttributeBuilder ( f ) ; copy . attributes . addAll ( attributes ) ; return copy ; } public List < Attribute > toAttributes ( ) { return new ArrayList < Attribute > ( attributes ) ; } public List < Modifier > toModifiers ( ) { List < Modifier > results = new ArrayList < Modifier > ( ) ; for ( Attribute attribute : toAttributes ( ) ) { if ( attribute instanceof Modifier ) { results . add ( ( Modifier ) attribute ) ; } } return results ; } public List < Annotation > toAnnotations ( ) { List < Annotation > results = new ArrayList < Annotation > ( ) ; for ( Attribute attribute : toAttributes ( ) ) { if ( attribute instanceof Annotation ) { results . add ( ( Annotation ) attribute ) ; } } return results ; } public AttributeBuilder Public ( ) { return modifier ( ModifierKind . PUBLIC ) ; } public AttributeBuilder Protected ( ) { return modifier ( ModifierKind . PROTECTED ) ; } public AttributeBuilder Private ( ) { return modifier ( ModifierKind . PRIVATE ) ; } public AttributeBuilder'}]",Final() { return modifier(ModifierKind.FINAL); } public AttributeBuilder Static() { return modifier(ModifierKind.STATIC); } public AttributeBuilder Volatile() { return modifier(ModifierKind.VOLATILE); } public AttributeBuilder Synchronized() { return modifier(ModifierKind.SYNCHRONIZED); } public AttributeBuilder Native() { return modifier(ModifierKind.NATIVE); } public AttributeBuilder Strictfp() { return modifier(ModifierKind.STRICTFP); } public AttributeBuilder Transient() { return modifier(ModifierKind.TRANSIENT); } public AttributeBuilder InnerClasses() { return modifier(ModifierKind.INNER_CLASSES); } public AttributeBuilder Enum() { return modifier(ModifierKind.ENUM); } public AttributeBuilder Synthetic() { return modifier(ModifierKind.SYNTHETIC); } public AttributeBuilder Bridge() { return modifier(ModifierKind.BRIDGE); } public AttributeBuilder Varargs() { return modifier(ModifierKind.VARARGS); } public AttributeBuilder Synthetickind() { return modifier(ModifierKind.SYNTHETICKIND); } public AttributeBuilder Syntheticconstraint() { return modifier(ModifierKind.SYNTHETICCONSTRAINT); } public AttributeBuilder Syntheticrestriction() { return modifier(ModifierKind.SYNTH,0.00036581554406888464
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . flow ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . io . NullWritable ; import org . apache . hadoop . mapreduce . Counter ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import com . asakusafw . runtime . core . Result ; public class ResultOutput < T > implements Result < T > { static final Log LOG = LogFactory . getLog ( ResultOutput . class ) ; private final TaskAttemptContext context ; private final RecordWriter < Object , Object > writer ; private final List < Counter > counters ; private long records ; @ SuppressWarnings ( { ""<STR_LIT:rawtypes>"" } ) public ResultOutput ( TaskAttemptContext context , RecordWriter writer ) throws IOException , InterruptedException { this ( context , writer , Collections . < Counter > emptyList ( ) ) ; } @ SuppressWarnings ( { ""<STR_LIT:rawtypes>"" , ""<STR_LIT:unchecked>"" } ) public ResultOutput ( TaskAttemptContext context , RecordWriter writer , List < Counter > counters ) throws IOException , InterruptedException { if ( context'}]","== null ) { throw new IllegalArgumentException ( ""context must not be null"" ) ; } if ( writer == null ) { throw new IllegalArgumentException ( ""writer must not be null"" ) ; } this.context = context; this.writer = writer; this.counters = Collections.unmodifiableList(counters); } @Override public void close() throws IOException, InterruptedException { if (context!= null) { context.taskAttemptFinished(true); } writer.close(); } @Override public void setCounter(String name, long value) { if (counters!= null) { Counter counter = new Counter(name, value); if (!counters.contains(counter)) { counters.add(counter); } } } @Override public void setCounter(Counter counter) { if (counters!= null) { if (!counters.contains(counter)) { counters.add(counter); } } } @Override public void setCounterValue(String name, long value) { if (counters!= null) { Counter counter = new Counter(name, value); if (!counters.contains(counter)) { counters.add(counter); } } } @Override public void setRecord(T record) { records++; } @Override public void setRecord(T record, long size) { records += size; } @Override public void setRecord(T record, long",0.00034628123578100354
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . generateaccessors ; import org . jruby . ast . DefnNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . NodeProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . offsetprovider . AfterLastMethodInClassOffsetProvider ; import org . rubypeople . rdt . refactoring . offsetprovider . BeforeFirstMethodInClassOffsetProvider ; import org . rubypeople . rdt . refactoring . offsetprovider . OffsetProvider ; public class AccessorOffsetProvider extends OffsetProvider { private ClassNodeWrapper classNode ; private int type ; private String document ; public AccessorOffsetProvider ( ClassNodeWrapper classNode , int type , String document ) { super ( document ) ; this . document = document ; this . classNode = classNode ; this . type = type ; } @ Override public Node getInsertAfterNode ( ) { if ( NodeProvider . hasChildNode ( classNode . getFirstPartialClassNode ( )'}]",) { return classNode.getFirstPartialClassNode(); } else { return classNode.getFirstPartialClassNode().getBody(); } },5.135459588493755e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . core . gems ; public'}]",class Gem extends Object { },2.3726984378853468e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . java . emitter ; import java . io . IOException ; import com . asakusafw . dmdl . java . Configuration ; import com . asakusafw . dmdl . java . spi . JavaDataModelDriver ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; public class JavaModelClassGenerator { private final DmdlSemantics semantics ; private final Configuration config ; private final JavaDataModelDriver driver ; public JavaModelClassGenerator ( DmdlSemantics semantics , Configuration config , JavaDataModelDriver driver ) { if ( semantics == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( config == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( driver == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . semantics = semantics ; this . config = config ; this . driver = driver ; } public void emit ( ModelDeclaration model ) throws IOException { if ( model == null ) {'}]","throw new IllegalArgumentException(""<STR_LIT>"");}driver.emit(semantics.toJavaModel(model, config));}",4.6633744860236416e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . frontend . elements ; import java . awt . Component ; import javax . swing . JPanel ; public'}]","class Button extends JPanel { private String text; private String actionCommand; public Button(String text, String actionCommand) { this.text = text; this.actionCommand = actionCommand; } public Button(String text) { this(text, null); } }",7.836906403370459e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . bulkloader ; import java . util . List ; public abstract class DbImporterDescription extends BulkLoadImporterDescription { @ Override public final Mode getMode ( ) { return Mode . PRIMARY ; } @ Override public String getTableName ( ) { return AttributeHelper . getTableName ( getModelType ( ) ) ; } @ Override public List < String > getColumnNames ( ) { return AttributeHelper . getColumnNames ('}]",", getModelType() ); } public abstract String getModelType(); }",3.3404824060541193e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . lang . openjdk6 ; import java . util . Collection ; import com . google . common . collect . ImmutableList ; import com . sun . tools . hat . internal . lang . CollectionModel ; import com . sun . tools . hat . internal . lang . Models ; import com . sun . tools . hat . internal . model . JavaObject ; import com . sun . tools . hat . internal . model . JavaThing ; class JavaLinkedList extends CollectionModel { private final ImmutableList < JavaThing > items ; private JavaLinkedList ( ImmutableList < JavaThing > items ) { this . items = items ; } public static JavaLinkedList make ( JavaObject'}]","... thing ) { return new JavaLinkedList ( ImmutableList. of ( thing ) ) ; } public static JavaLinkedList make ( Collection <? extends JavaThing > things ) { return new JavaLinkedList ( ImmutableList. copyOf ( things ) ) ; } @ Override public boolean isEmpty ( ) { return items. isEmpty ( ) ; } @ Override public int size ( ) { return items. size ( ) ; } @ Override public JavaThing get ( int index ) { return items. get ( index ) ; } @ Override public JavaLinkedList subList ( int start, int end ) { return new JavaLinkedList ( items. subList ( start, end ) ) ; } @ Override public String toString ( ) { return items. toString ( ) ; } @ Override public int hashCode ( ) { return items. hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null || getClass ( )!= obj. getClass ( ) ) return false ; JavaLinkedList other = ( JavaLinkedList ) obj ; return items. equals ( other. items ) ; } }",0.00030536120152830216
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . ConditionalExpression ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class ConditionalExpressionImpl extends ModelRoot implements ConditionalExpression { private Expression condition ; private Expression thenExpression ; private Expression elseExpression ; @ Override public Expression getCondition ( ) { return this . condition ; } public void setCondition ( Expression condition ) { Util . notNull ( condition'}]",", ""condition"" ) ; this. condition = condition ; } @ Override public Expression getThenExpression ( ) { return this. thenExpression ; } public void setThenExpression ( Expression thenExpression ) { Util. notNull ( thenExpression, ""thenExpression"" ) ; this. thenExpression = thenExpression ; } @ Override public Expression getElseExpression ( ) { return this. elseExpression ; } public void setElseExpression ( Expression elseExpression ) { Util. notNull ( elseExpression, ""elseExpression"" ) ; this. elseExpression = elseExpression ; } @ Override public < T > T accept ( Visitor < T > visitor ) { return visitor. visit ( this ) ; } }",0.00019435623095278708
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package hudson . jbpm . model ; import hudson . jbpm . PluginImpl ; import java . io . IOException ; import javax . servlet . ServletException ; import org . jbpm . taskmgmt . exe . TaskInstance ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; public class Form { private final TaskInstance taskInstance ; public Form ( TaskInstance taskInstance ) { super ( ) ; this . taskInstance = taskInstance ; } public TaskInstance getTaskInstance ( ) { return taskInstance ; } public void handle ( StaplerRequest request , StaplerResponse response ) throws ServletException , IOException { }'}]","public void doIndex(StaplerRequest request, StaplerResponse response) throws ServletException, IOException { }",4.433049701788973e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate ; import java . io . File ; import java . nio . charset . Charset ; import com . asakusafw . dmdl . model . AstLiteral ; public class Configuration { private String jdbcDriver ; private String jdbcUrl ; private String jdbcUser ; private String jdbcPassword ; private String databaseName ; private File output ; private ModelMatcher matcher ; private Charset encoding ; private String sidColumn ; private String timestampColumn ; private String deleteFlagColumn ; private AstLiteral deleteFlagValue ; public String getJdbcDriver ( ) { return jdbcDriver ; } public void setJdbcDriver ( String jdbcDriver ) { this . jdbcDriver = jdbcDriver ; } public String getJdbcUrl ( ) { return jdbcUrl ; } public void setJdbcUrl ( String jdbcUrl ) { this . jdbcUrl = jdbcUrl ; } public String getJdbcUser ( ) { return jdbcUser ; } public void setJdbcUser ( String jdbcUser ) { this . jdbcUser = jdbcUser ; } public String getJdbcPassword ( ) { return jdbcPassword ; } public void setJdbcPassword ( String jdbcPassword ) { this . jdbcPassword = jdbcPassword ; } public String getDatabaseName ( ) { return databaseName ; } public void setDatabaseName ( String databaseName ) { this . databaseName = databaseName ; } public File getOutput ( ) { return output ; } public void setOutput ( File output ) { this . output = output ; } public ModelMatcher getMatcher ( ) { return matcher ; } public void setMatcher ( ModelMatcher matcher ) { this . matcher = matcher ; } public Charset getEncoding ( ) { return encoding ; } public void setEncoding ( Charset encoding ) { this . encoding = encoding ; }'}]",public String getSidColumn() { return sidColumn; },3.777325817469809e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . view ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . Arrays ; import org . junit . Test ; import com . asakusafw . dmdl . thundergate . model . Aggregator ; import com . asakusafw . dmdl . thundergate . view . model . CreateView ; import com . asakusafw . dmdl . thundergate . view . model . From ; import com . asakusafw . dmdl . thundergate . view . model . Join ; import com . asakusafw . dmdl . thundergate . view . model . Name ; import com . asakusafw . dmdl . thundergate . view . model . On ; import com . asakusafw . dmdl . thundergate . view . model . Select ; public class ViewParserTest { @ Test public void parseJoin ( ) throws Exception { ViewDefinition def = def ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; CreateView model = ViewParser . parse ( def ) ; assertThat ( model , is ( new CreateView ( n ( ""<STR_LIT:test>"" ) , Arrays . asList ( new Select [ ] { new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , } ) , new From ( n ( ""<STR_LIT>"" ) , null , new Join ( n ( ""<STR_LIT>"" ) , null , Arrays . asList ( new On ( n ( ""<STR_LIT>"" ) , n ( ""<STR_LIT>"" ) ) ) ) ) , Arrays . < Name > asList ( ) ) ) ) ; } @ Test public void parseJoin_withAlias ( ) throws Exception { ViewDefinition def = def ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; CreateView model = ViewParser . parse ( def ) ; assertThat ( model , is ( new CreateView ( n ( ""<STR_LIT:test>"" ) , Arrays . asList ( new Select [ ] { new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , } ) , new From ( n ( ""<STR_LIT>"" ) , ""<STR_LIT:a>"" , new Join ( n ( ""<STR_LIT>"" ) , ""<STR_LIT:b>"" , Arrays . asList ( new On ( n ( ""<STR_LIT>"" ) , n ( ""<STR_LIT>"" ) ) ) ) ) , Arrays . < Name > asList ( ) ) ) ) ; } @ Test public void parseSummarize ( ) throws Exception { ViewDefinition def = def ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; CreateView model = ViewParser . parse ( def ) ; assertThat ( model , is ( new CreateView ( n ( ""<STR_LIT:test>"" ) , Arrays . asList ( new Select [ ] { new Select ( n ( ""<STR_LIT>"" ) , Aggregator . IDENT , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . COUNT , n ( ""<STR_LIT:count>"" ) ) , new Select ( n ( ""<STR_LIT>"" ) , Aggregator . MAX , n ( ""<STR_LIT>"" ) ) , new Select ( n ( ""<STR_LIT>"" )'}]","), new From ( n ( ""<STR_LIT>"" ), null, new Join ( n ( ""<STR_LIT>"" ), null, Arrays. asList ( new On ( n ( ""<STR_LIT>"" ), n ( ""<STR_LIT>"" ) ) ) ) ), Arrays. < Name > asList ( n ( ""<STR_LIT>"" ), n ( ""<STR_LIT:count>"" ) ) ) ) ) ; } @Test public void parseSummarize_withAlias ( ) throws Exception { ViewDefinition def = def ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; CreateView model = ViewParser. parse ( def ) ; assertThat ( model, is ( new CreateView ( n ( ""<STR_LIT:test>"" ), Arrays. asList ( new Select [ ] { new Select ( n ( ""<STR_LIT>"" ), Aggregator. IDENT, n ( ""<STR_LIT>"" ) ), new Select ( n ( ""<STR_LIT>"" ), Aggregator. COUNT, n",0.00038677178917260324
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . parser ; public class SVParsers { private ISVParser fSVParser ; private ParserSVDBFileFactory fSVDBFileFactory ; private SVClassDeclParser fClassParser ; private SVCovergroupParser fCovergroupParser ; private SVParameterDeclParser fParamDeclParser ; private SVParameterPortListParser fParamPortParser ; private SVDataTypeParser fDataTypeParser ; private SVTaskFunctionParser fFunctionParser ; private SVTaskFunctionPortListParser fTFPortListParser ; private SVTaskFuncBodyParser fTFBodyParser ; private SVBlockItemDeclParser fBlockItemDeclParser ; private SVParameterValueAssignmentParser fParamValueAssignParser ; private SVBehavioralBlockParser fBehavioralBlockParser ; private SVModIfcProgDeclParser fModIfcProgParser ; private SVPortListParser fPortListParser ; private SVGenerateBlockParser fGenBlockParser ; private SVClockingBlockParser fClkBlockParser ; private SVSpecifyBlockParser fSpecifyBlockParser ; private SVImpExpStmtParser fImportParser ; private SVExprParser fExprParser ; private SVGateInstantiationParser fGateInstanceParser ; private SVAssertionParser fAssertionParser ; private SVModIfcBodyItemParser fModIfcBodyItemParser ; private SVConstraintParser fConstraintParser ; private SVAttributeParser fAttrParser ; private SVPropertyExprParser fPropertyExprParser ; private SVSequenceParser fSequenceParser ; private SVPropertyParser fPropertyParser ; private SVConfigParser fConfigParser ; public SVParsers ( ) { } public SVParsers ( ISVParser parser ) { fSVParser = parser ; } public void init ( ParserSVDBFileFactory sv_parser ) { fSVDBFileFactory = sv_parser ; init ( ( ISVParser ) sv_parser ) ; } public void init ( ISVParser parser ) { fSVParser = parser ; fClassParser = new SVClassDeclParser ( fSVParser ) ; fParamDeclParser = new SVParameterDeclParser ( fSVParser ) ; fParamPortParser = new SVParameterPortListParser ( fSVParser ) ; fDataTypeParser = new SVDataTypeParser ( fSVParser ) ; fFunctionParser = new SVTaskFunctionParser ( fSVParser ) ; fTFPortListParser = new SVTaskFunctionPortListParser ( fSVParser ) ; fTFBodyParser = new SVTaskFuncBodyParser ( fSVParser ) ; fBlockItemDeclParser = new SVBlockItemDeclParser ( fSVParser ) ; fParamValueAssignParser = new SVParameterValueAssignmentParser ( fSVParser ) ; fBehavioralBlockParser = new SVBehavioralBlockParser ( fSVParser ) ; fModIfcProgParser = new SVModIfcProgDeclParser ( fSVParser ) ; fPortListParser = new SVPortListParser ( fSVParser ) ; fGenBlockParser = new SVGenerateBlockParser ( fSVParser ) ; fClkBlockParser = new SVClockingBlockParser ( fSVParser ) ; fSpecifyBlockParser = new SVSpecifyBlockParser ( fSVParser ) ; fImportParser = new SVImpExpStmtParser ( fSVParser ) ; fExprParser = new SVExprParser ( fSVParser ) ; fGateInstanceParser = new SVGateInstantiationParser ( fSVParser ) ; fAssertionParser = new SVAssertionParser ( fSVParser ) ; fCovergroupParser = new SVCovergroupParser ( fSVParser ) ; fModIfcBodyItemParser = new SVModIfcBodyItemParser ( fSVParser ) ; fConstraintParser = new SVConstraintParser ( fSVParser ) ; fAttrParser = new SVAttributeParser ( fSVParser ) ; fPropertyExprParser = new SVPropertyExprParser ( fSVParser ) ; fSequenceParser = new SVSequenceParser ( fSVParser ) ; fPropertyParser = new SVPropertyParser ( fSVParser ) ; fConfigParser = new SVConfigParser ( fSVParser ) ; } public ParserSVDBFileFactory SVParser ( ) { return fSVDBFileFactory ; } public final SVClassDeclParser classParser ( ) { return fClassParser ; } public SVParameterDeclParser paramDeclParser ( ) {'}]",return fParamDeclParser;,3.5724906450523235e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core ; import java . text . MessageFormat ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class WindGateLogger { private final Logger internal ; private final MessageFormat format = new MessageFormat ( ""<STR_LIT>"" ) ; private final String componentName ; public WindGateLogger ( Class < ? > target , String componentName ) { if ( target == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( componentName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . componentName = componentName ; this . internal = LoggerFactory . getLogger ( target ) ; } public void info ( String'}]","message, Object... args ) { internal. info ( format. format ( message, args ) ) ; } public void debug ( String message, Object... args ) { internal. debug ( format. format ( message, args ) ) ; } public void warn ( String message, Object... args ) { internal. warn ( format. format ( message, args ) ) ; } public void error ( String message, Object... args ) { internal. error ( format. format ( message, args ) ) ; } }",0.00014832111571916464
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow . graph ; import java . util . List ; public interface FlowElementDescription extends FlowElementAttributeProvider { FlowElementKind getKind ( ) ; String getName ( ) ; void setName ( String newName ) ; List < FlowElementPortDescription > getInputPorts ( ) ; List <'}]",FlowElementPortDescription > getOutputPorts ( ) ; },3.168129267469796e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . workingsets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IResourceChangeEvent ; import org . eclipse . core . resources . IResourceChangeListener ; import org . eclipse . core . resources . IResourceDelta ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . IWorkingSetManager ; import org . eclipse . ui . IWorkingSetUpdater ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . ElementChangedEvent ; import org . rubypeople . rdt . core . IElementChangedListener ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyElementDelta ; import org . rubypeople . rdt . core . IRubyModel ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; public class OthersWorkingSetUpdater implements IWorkingSetUpdater { public static final String ID = ""<STR_LIT>"" ; private IWorkingSet fWorkingSet ; private WorkingSetModel fWorkingSetModel ; private class ResourceChangeListener implements IResourceChangeListener { public void resourceChanged ( IResourceChangeEvent event ) { if ( fWorkingSet == null ) return ; IResourceDelta delta = event . getDelta ( ) ; IResourceDelta [ ] affectedChildren = delta . getAffectedChildren ( IResourceDelta . ADDED | IResourceDelta . REMOVED , IResource . PROJECT ) ; if ( affectedChildren . length > <NUM_LIT:0> ) { updateElements ( ) ; } else { affectedChildren = delta . getAffectedChildren ( IResourceDelta . CHANGED , IResource . PROJECT ) ; for ( int i = <NUM_LIT:0> ; i < affectedChildren . length ; i ++ ) { IResourceDelta projectDelta = affectedChildren [ i ] ; if ( ( projectDelta . getFlags ( ) & IResourceDelta . DESCRIPTION ) != <NUM_LIT:0> ) { updateElements ( ) ; return ; } } } } } private IResourceChangeListener fResourceChangeListener ; private class WorkingSetListener implements IPropertyChangeListener { public void propertyChange ( PropertyChangeEvent event ) { if ( IWorkingSetManager . CHANGE_WORKING_SET_CONTENT_CHANGE . equals ( event . getProperty ( ) ) ) { IWorkingSet changedWorkingSet = ( IWorkingSet ) event . getNewValue ( ) ; if ( changedWorkingSet != fWorkingSet && fWorkingSetModel . isActiveWorkingSet ( changedWorkingSet ) ) { updateElements ( ) ; } } } } private IPropertyChangeListener fWorkingSetListener ; private class RubyElementChangeListener implements IElementChangedListener { public void elementChanged ( ElementChangedEvent event ) { if ( fWorkingSet == null ) return ; processRubyDelta ( new ArrayList ( Arrays . asList ( fWorkingSet . getElements ( ) ) ) , event . getDelta ( ) ) ; } private void processRubyDelta ( List elements , IRubyElementDelta delta ) { IRubyElement jElement = delta . getElement ( ) ; int type = jElement . getElementType ( ) ; if ( type == IRubyElement . RUBY_PROJECT ) { int index = elements . indexOf ( jElement ) ; int kind = delta . getKind ( ) ; int flags = delta . getFlags ( ) ; if ( kind == IRubyElementDelta . CHANGED ) { if ( index != - <NUM_LIT:1> && ( flags & IRubyElementDelta . F_CLOSED ) != <NUM_LIT:0> ) { elements . set ( index , ( ( IRubyProject ) jElement ) . getProject ( ) ) ; fWorkingSet . setElements ( ( IAdaptable [ ] ) elements . toArray ( new IAdaptable [ elements . size ( ) ] ) ) ; } else if ( ( flags & IRubyElementDelta . F_OPENED ) != <NUM_LIT:0> ) { index = elements . indexOf ( ( ( IRubyProject ) jElement ) . getProject ( ) ) ; if ( index != - <NUM_LIT:1> ) { elements . set ( index , jElement ) ; fWorkingSet . setElements ( ( IAdaptable [ ] ) elements . toArray ( new IAdaptable [ elements . size ( ) ] ) ) ; } } } return ; } IRubyElementDelta [ ] children = delta . getAffectedChildren ( ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; i ++ ) { processRubyDelta ( elements , children [ i ] ) ; } } } private IElementChangedListener fRubyElementChangeListener ; public void add ( IWorkingSet workingSet ) { Assert . isTrue ( fWorkingSet == null && fWorkingSetModel != null ) ; fWorkingSet = workingSet ; } public boolean remove ( IWorkingSet workingSet ) { Assert . isTrue ( fWorkingSet == workingSet ) ; fWorkingSet = null ; return true ; } public boolean contains ( IWorkingSet workingSet ) { return fWorkingSet == workingSet ; } public void init ( WorkingSetModel model ) { fWorkingSetModel = model ; fResourceChangeListener = new ResourceChangeListener ( ) ; ResourcesPlugin . getWorkspace ( ) . addResourceChangeListener ( fResourceChangeListener , IResourceChangeEvent . POST_CHANGE ) ; fWorkingSetListener = new WorkingSetListener ( ) ;'}]","fWorkingSet. addPropertyChangeListener ( IWorkingSetManager. CHANGE_WORKING_SET_CONTENT_CHANGE, fWorkingSetListener ) ; fRubyElementChangeListener = new RubyElementChangeListener ( ) ; RubyCore. getInstance ( ). addElementChangedListener ( fRubyElementChangeListener ) ; } public void dispose ( ) { if ( fWorkingSet!= null ) { fWorkingSet. removePropertyChangeListener ( IWorkingSetManager. CHANGE_WORKING_SET_CONTENT_CHANGE, fWorkingSetListener ) ; fWorkingSet = null ; } if ( fWorkingSetModel!= null ) { fWorkingSetModel = null ; ResourcesPlugin. getWorkspace ( ). removeResourceChangeListener ( fResourceChangeListener ) ; RubyCore. getInstance ( ). removeElementChangedListener ( fRubyElementChangeListener ) ; } } public void updateElements ( ) { if ( fWorkingSet == null ) return ; fWorkingSet. setElements ( ( IAdaptable [ ] ) fWorkingSetModel. getElements ( ). toArray ( new IAdaptable [ fWorkingSetModel. getElements ( ). size ( ) ] ) ) ; } private void processRubyDelta ( List elements, IRubyElementDelta delta ) { //... } }",0.00039911327385204395
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . expr . eval ; import java . math . BigInteger ; import net . sf . sveditor . core . db . expr . SVDBBinaryExpr ; import net . sf . sveditor . core . db . expr . SVDBExpr ; import net . sf . sveditor . core . db . expr . SVDBIdentifierExpr ; import net . sf . sveditor . core . db . expr . SVDBLiteralExpr ; public class SVIntegerExprEvaluator { private IValueProvider fValueProvider ; public SVIntegerExprEvaluator ( IValueProvider provider ) { fValueProvider = provider ; } public BigInteger evaluate ( SVDBExpr expr ) throws Exception { switch ( expr . getType ( ) ) { case LiteralExpr : { SVDBLiteralExpr literal = ( SVDBLiteralExpr ) expr ; return parse_literal ( literal ) ; } case BinaryExpr : { SVDBBinaryExpr binary = ( SVDBBinaryExpr ) expr ; return evaluate_binary ( evaluate ( binary . getLhs ( ) ) , binary . getOp ( ) , evaluate ( binary . getRhs ( ) ) ) ; } case IdentifierExpr : { SVDBIdentifierExpr id = ( SVDBIdentifierExpr ) expr ; if ( fValueProvider != null ) { return'}]","fValueProvider.getValue(id.getName()); } else { throw new Exception(""Identifier '"" + id.getName() + ""' is not bound to a value provider""); } } default: { throw new Exception(""Unsupported expression type: "" + expr.getType()); } } private BigInteger evaluate_binary(BigInteger lhs, String op, BigInteger rhs) throws Exception { switch (op) { case ""+"": return lhs.add(rhs); case ""-"": return lhs.subtract(rhs); case ""*"": return lhs.multiply(rhs); case ""/"": if (rhs.equals(BigInteger.ZERO)) { throw new Exception(""Division by zero""); } return lhs.divide(rhs); default: throw new Exception(""Unsupported operator: "" + op); } } private BigInteger parse_literal(SVDBLiteralExpr literal) throws Exception { return new BigInteger(literal.getValue()); } }",0.0002165305541161543
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . builder ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . SubMonitor ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . jruby . lexer . yacc . SyntaxException ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . compiler . BuildContext ; import org . rubypeople . rdt . core . compiler . CompilationParticipant ; import org . rubypeople . rdt . internal . core . parser . InOrderVisitor ; import org . rubypeople . rdt . internal . core . parser . RubyParser ; import org . rubypeople . rdt . internal . core . util . ASTUtil ; import com . aptana . rdt . AptanaRDTPlugin ; import com . aptana . rdt . core . gems . Gem ; public class GemLoadpathAdder extends CompilationParticipant { private IRubyProject project ; @ Override public int aboutToBuild ( IRubyProject project ) { this . project = project ; return super . aboutToBuild ( project ) ; } @ Override public void buildStarting ( BuildContext [ ] files , boolean isBatch , IProgressMonitor monitor ) { SubMonitor sub = SubMonitor . convert ( monitor'}]",", ""Adding gems to load path..."", files.length); Set<Gem> gems = project.getGems(); for (Gem gem : gems) { sub.worked(1); if (sub.isCanceled()) { return; } } sub.done(); } @Override public void buildFinished ( BuildContext [ ] files, boolean isBatch, IProgressMonitor monitor ) { } @Override public void buildStarted ( BuildContext [ ] files, boolean isBatch, IProgressMonitor monitor ) { } }",0.00014649782012580455
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . vaadin . teemu . clara . util ; import java . lang . reflect . Method ; import java . util . HashSet ; import java . util . Set ; import com . vaadin . ui . Component ; public class ReflectionUtils { private ReflectionUtils ( ) { throw new AssertionError ( ) ; } public static Set < Method > getMethodsByNameAndParamCount ( Class < ? > clazz , String methodName , int numberOfParams ) { Set < Method > methods = new HashSet < Method > ( ) ; for ( Method method : clazz . getMethods ( ) ) { if ( method . getName ( ) . equals ( methodName ) && method'}]",.getParameterCount() == numberOfParams) { methods.add(method); } return methods; } },4.10950818685594e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import java . util . List ; import com . asakusafw . utils . java . model . syntax . ArrayInitializer ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class ArrayInitializerImpl extends ModelRoot implements ArrayInitializer { private List < ? extends Expression >'}]","elements; private final ModelKind kind; public ArrayInitializerImpl(ModelKind kind, List<? extends Expression> elements) { this.kind = kind; this.elements = elements; } @Override public <T> T accept(Visitor<T> visitor) { return visitor.visit(this); } @Override public ModelKind kind() { return kind; } @Override public List<? extends Expression> elements() { return elements; } }",0.0001245989422709912
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . find ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . sparql . engine . binding . Binding ; import com . hp . hpl . jena . sparql . engine . iterator . QueryIter ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; import com . hp . hpl . jena . util . iterator . NiceIterator ; import de . fuberlin . wiwiss . d2rq . algebra .'}]","QueryResult;public class FindQueryIterator extends NiceIterator<Binding> { private final QueryIter iter;public FindQueryIterator(QueryResult result) { super(new ExtendedIterator<Binding>(new QueryIter(result))); this.iter = (QueryIter) super.iterator(); } @Overridepublic void remove() { throw new UnsupportedOperationException(""remove()""); } @Overridepublic boolean hasNext() { return iter.hasNext(); } @Overridepublic Binding next() { return iter.next(); } @Overridepublic void close() { iter.close(); } }",5.5708287667535e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . generateaccessors ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . BlockNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . editprovider . InsertEditProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . AttrAccessorNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . VisibilityNodeWrapper ; import org . rubypeople . rdt . refactoring . offsetprovider . IOffsetProvider ; public class GeneratedAccessor extends InsertEditProvider { public static final int TYPE_SIMPLE_ACCESSOR = <NUM_LIT:1> ; public static final int TYPE_METHOD_ACCESSOR = <NUM_LIT:2> ; public static final int DEFAULT_TYPE = TYPE_SIMPLE_ACCESSOR ; public String definitionName ; private int type ; private String attrName ; private ClassNodeWrapper classNode ; public GeneratedAccessor ( String definitionName , String instVarName , int type , ClassNodeWrapper classNode ) { super ( true ) ; this . definitionName = definitionName ; this . attrName = instVarName ; this . type = type ; this . classNode = classNode ; } public boolean isWriter ( ) { return definitionName . equals ( AttrAccessorNodeWrapper . ATTR_WRITER ) ; } public boolean isReader ( ) { return definitionName . equals ( AttrAccessorNodeWrapper . ATTR_READER ) ; } public'}]","Node createNode ( NodeFactory factory ) { return factory. createClassDefinition ( classNode, definitionName, type, attrName ) ; }",5.8733742589699775e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . index ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . io . UTFDataFormatException ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . compiler . util . HashtableOfIntValues ; import org . rubypeople . rdt . internal . compiler . util . HashtableOfObject ; import org . rubypeople . rdt . internal . compiler . util . SimpleLookupTable ; import org . rubypeople . rdt . internal . compiler . util . SimpleSet ; import org . rubypeople . rdt . internal . compiler . util . SimpleSetOfCharArray ; import org . rubypeople . rdt . internal . core . util . CharOperation ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . core . util . SimpleWordSet ; import org . rubypeople . rdt . internal . core . util . Util ; public class DiskIndex { File indexFile ; private int headerInfoOffset ; private int numberOfChunks ; private int sizeOfLastChunk ; private int [ ] chunkOffsets ; private int documentReferenceSize ; private int startOfCategoryTables ; private HashtableOfIntValues categoryOffsets , categoryEnds ; private int cacheUserCount ; private String [ ] [ ] cachedChunks ; private HashtableOfObject categoryTables ; private char [ ] cachedCategoryName ; private static final int DEFAULT_BUFFER_SIZE = <NUM_LIT> ; private static int BUFFER_READ_SIZE = DEFAULT_BUFFER_SIZE ; private static final int BUFFER_WRITE_SIZE = DEFAULT_BUFFER_SIZE ; private byte [ ] streamBuffer ; private int bufferIndex , bufferEnd ; private int streamEnd ; char separator = Index . DEFAULT_SEPARATOR ; public static final String SIGNATURE = ""<STR_LIT>"" ; private static final char [ ] SIGNATURE_CHARS = SIGNATURE . toCharArray ( ) ; public static boolean DEBUG = false ; private static final int RE_INDEXED = - <NUM_LIT:1> ; private static final int DELETED = - <NUM_LIT:2> ; private static final int CHUNK_SIZE = <NUM_LIT:100> ; private static final SimpleSetOfCharArray INTERNED_CATEGORY_NAMES = new SimpleSetOfCharArray ( <NUM_LIT:20> ) ; static class IntList { int size ; int [ ] elements ; IntList ( int [ ] elements ) { this . elements = elements ; this . size = elements . length ; } void add ( int newElement ) { if ( this . size == this . elements . length ) { int newSize = this . size * <NUM_LIT:3> ; if ( newSize < <NUM_LIT:7> ) newSize = <NUM_LIT:7> ; System . arraycopy ( this . elements , <NUM_LIT:0> , this . elements = new int [ newSize ] , <NUM_LIT:0> , this . size ) ; } this . elements [ this . size ++ ] = newElement ; } int [ ] asArray ( ) { int [ ] result = new int [ this . size ] ; System . arraycopy ( this . elements , <NUM_LIT:0> , result , <NUM_LIT:0> , this . size ) ; return result ; } } DiskIndex ( String fileName ) { if ( fileName == null ) throw new java . lang . IllegalArgumentException ( ) ; this . indexFile = new File ( fileName ) ; this . headerInfoOffset = - <NUM_LIT:1> ; this . numberOfChunks = - <NUM_LIT:1> ; this . sizeOfLastChunk = - <NUM_LIT:1> ; this . chunkOffsets = null ; this . documentReferenceSize = - <NUM_LIT:1> ; this . cacheUserCount = - <NUM_LIT:1> ; this . cachedChunks = null ; this . categoryTables = null ; this . cachedCategoryName = null ; this . categoryOffsets = null ; this . categoryEnds = null ; } SimpleSet addDocumentNames ( String substring , MemoryIndex memoryIndex ) throws IOException { String [ ] docNames = readAllDocumentNames ( ) ; SimpleSet results = new SimpleSet ( docNames . length ) ; if ( substring == null ) { if ( memoryIndex == null ) { for ( int i = <NUM_LIT:0> , l = docNames . length ; i < l ; i ++ ) results . add ( docNames [ i ] ) ; } else { SimpleLookupTable docsToRefs = memoryIndex . docsToReferences ; for ( int i = <NUM_LIT:0> , l = docNames . length ; i < l ; i ++ ) { String docName = docNames [ i ] ; if ( ! docsToRefs . containsKey ( docName ) ) results . add ( docName ) ; } } } else { if ( memoryIndex == null ) { for ( int i = <NUM_LIT:0> , l = docNames . length ; i < l ; i ++ ) if ( docNames [ i ] . startsWith ( substring , <NUM_LIT:0> ) ) results . add ( docNames [ i ] ) ; } else { SimpleLookupTable docsToRefs = memoryIndex . docsToReferences ; for ( int i = <NUM_LIT:0> , l = docNames . length ; i < l ; i ++ ) { String docName = docNames [ i ] ; if ( docName . startsWith ( substring , <NUM_LIT:0> ) && ! docsToRefs . containsKey ( docName ) ) results . add ( docName ) ; } } } return results ; } private HashtableOfObject addQueryResult ( HashtableOfObject results , char [ ] word , HashtableOfObject wordsToDocNumbers , MemoryIndex memoryIndex ) throws IOException { if ( results == null ) results = new HashtableOfObject ( <NUM_LIT> ) ; EntryResult result = ( EntryResult ) results . get ( word ) ; if ( memoryIndex == null ) { if ( result == null ) results . put ( word , new EntryResult ( word , wordsToDocNumbers ) ) ; else result . addDocumentTable ( wordsToDocNumbers ) ; } else { SimpleLookupTable docsToRefs = memoryIndex . docsToReferences ; if ( result == null ) result = new EntryResult ( word , null ) ; int [ ] docNumbers = readDocumentNumbers ( wordsToDocNumbers . get ( word ) ) ; for ( int i = <NUM_LIT:0> , l = docNumbers . length ; i < l ; i ++ ) { String docName = readDocumentName ( docNumbers [ i ] ) ; if ( ! docsToRefs . containsKey ( docName ) ) result . addDocumentName ( docName ) ; } if ( ! result . isEmpty ( ) ) results . put ( word , result ) ; } return results ; } HashtableOfObject addQueryResults ( char [ ] [ ] categories , char [ ] key , int matchRule , MemoryIndex memoryIndex ) throws IOException { if ( this . categoryOffsets == null ) return null ; HashtableOfObject results = null ; if ( key == null ) { for ( int i = <NUM_LIT:0> , l = categories . length ; i < l ; i ++ ) { HashtableOfObject wordsToDocNumbers = readCategoryTable ( categories [ i ] , true ) ; if ( wordsToDocNumbers != null ) { char [ ] [ ] words = wordsToDocNumbers . keyTable ; if ( results == null ) results = new HashtableOfObject ( wordsToDocNumbers . elementSize ) ; for ( int j = <NUM_LIT:0> , m = words . length ; j < m ; j ++ ) if ( words [ j ] != null ) results = addQueryResult ( results , words [ j ] , wordsToDocNumbers , memoryIndex ) ; } } if ( results != null && this . cachedChunks == null ) cacheDocumentNames ( ) ; } else { switch ( matchRule ) { case SearchPattern . R_EXACT_MATCH | SearchPattern . R_CASE_SENSITIVE : for ( int i = <NUM_LIT:0> , l = categories . length ; i < l ; i ++ ) { HashtableOfObject wordsToDocNumbers = readCategoryTable ( categories [ i ] , false ) ; if ( wordsToDocNumbers != null && wordsToDocNumbers . containsKey ( key ) ) results = addQueryResult ( results , key , wordsToDocNumbers , memoryIndex ) ; } break ; case SearchPattern . R_PREFIX_MATCH | SearchPattern . R_CASE_SENSITIVE : for ( int i = <NUM_LIT:0> , l = categories . length ; i < l ; i ++ ) { HashtableOfObject wordsToDocNumbers = readCategoryTable ( categories [ i ] , false ) ; if ( wordsToDocNumbers != null ) { char [ ] [ ] words = wordsToDocNumbers . keyTable ; for ( int j = <NUM_LIT:0> , m = words . length ; j < m ; j ++ ) { char [ ] word = words [ j ] ; if ( word != null && key [ <NUM_LIT:0> ] == word [ <NUM_LIT:0> ] && CharOperation . prefixEquals ( key , word ) ) results = addQueryResult ( results , word , wordsToDocNumbers , memoryIndex ) ; } } } break ; default : for ( int i = <NUM_LIT:0> , l = categories . length ; i < l ; i ++ ) { HashtableOfObject wordsToDocNumbers = readCategoryTable ( categories [ i ] , false ) ; if ( wordsToDocNumbers != null ) { char [ ] [ ] words = wordsToDocNumbers . keyTable ; for ( int j = <NUM_LIT:0> , m = words . length ; j < m ; j ++ ) { char [ ] word = words [ j ] ; if ( word != null && Index . isMatch ( key , word , matchRule ) ) results = addQueryResult ( results , word , wordsToDocNumbers , memoryIndex ) ; } } } } } if ( results == null ) return null ; return results ; } private void cacheDocumentNames ( ) throws IOException { this . cachedChunks = new String [ this . numberOfChunks ] [ ] ; FileInputStream stream = new FileInputStream ( this . indexFile ) ; try { if ( this . numberOfChunks > <NUM_LIT:5> ) BUFFER_READ_SIZE <<= <NUM_LIT:1> ; int offset = this . chunkOffsets [ <NUM_LIT:0> ] ; stream . skip ( offset ) ; this . streamBuffer = new byte [ BUFFER_READ_SIZE ] ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , this . streamBuffer . length ) ; for ( int i = <NUM_LIT:0> ; i < this . numberOfChunks ; i ++ ) { int size = i == this . numberOfChunks - <NUM_LIT:1> ? this . sizeOfLastChunk : CHUNK_SIZE ; readChunk ( this . cachedChunks [ i ] = new String [ size ] , stream , <NUM_LIT:0> , size ) ; } } catch ( IOException e ) { this . cachedChunks = null ; throw e ; } finally { stream . close ( ) ; this . streamBuffer = null ; BUFFER_READ_SIZE = DEFAULT_BUFFER_SIZE ; } } private String [ ] computeDocumentNames ( String [ ] onDiskNames , int [ ] positions , SimpleLookupTable indexedDocuments , MemoryIndex memoryIndex ) { int onDiskLength = onDiskNames . length ; Object [ ] docNames = memoryIndex . docsToReferences . keyTable ; Object [ ] referenceTables = memoryIndex . docsToReferences . valueTable ; if ( onDiskLength == <NUM_LIT:0> ) { for ( int i = <NUM_LIT:0> , l = referenceTables . length ; i < l ; i ++ ) if ( referenceTables [ i ] != null ) indexedDocuments . put ( docNames [ i ] , null ) ; String [ ] newDocNames = new String [ indexedDocuments . elementSize ] ; int count = <NUM_LIT:0> ; Object [ ] added = indexedDocuments . keyTable ; for ( int i = <NUM_LIT:0> , l = added . length ; i < l ; i ++ ) if ( added [ i ] != null ) newDocNames [ count ++ ] = ( String ) added [ i ] ; Util . sort ( newDocNames ) ; for ( int i = <NUM_LIT:0> , l = newDocNames . length ; i < l ; i ++ ) indexedDocuments . put ( newDocNames [ i ] , new Integer ( i ) ) ; return newDocNames ; } for ( int i = <NUM_LIT:0> ; i < onDiskLength ; i ++ ) positions [ i ] = i ; int numDeletedDocNames = <NUM_LIT:0> ; int numReindexedDocNames = <NUM_LIT:0> ; nextPath : for ( int i = <NUM_LIT:0> , l = docNames . length ; i < l ; i ++ ) { String docName = ( String ) docNames [ i ] ; if ( docName != null ) { for ( int j = <NUM_LIT:0> ; j < onDiskLength ; j ++ ) { if ( docName . equals ( onDiskNames [ j ] ) ) { if ( referenceTables [ i ] == null ) { positions [ j ] = DELETED ; numDeletedDocNames ++ ; } else { positions [ j ] = RE_INDEXED ; numReindexedDocNames ++ ; } continue nextPath ; } } if ( referenceTables [ i ] != null ) indexedDocuments . put ( docName , null ) ; } } String [ ] newDocNames = onDiskNames ; if ( numDeletedDocNames > <NUM_LIT:0> || indexedDocuments . elementSize > <NUM_LIT:0> ) { newDocNames = new String [ onDiskLength + indexedDocuments . elementSize - numDeletedDocNames ] ; int count = <NUM_LIT:0> ; for ( int i = <NUM_LIT:0> ; i < onDiskLength ; i ++ ) if ( positions [ i ] >= RE_INDEXED ) newDocNames [ count ++ ] = onDiskNames [ i ] ; Object [ ] added = indexedDocuments . keyTable ; for ( int i = <NUM_LIT:0> , l = added . length ; i < l ; i ++ ) if ( added [ i ] != null ) newDocNames [ count ++ ] = ( String ) added [ i ] ; Util . sort ( newDocNames ) ; for ( int i = <NUM_LIT:0> , l = newDocNames . length ; i < l ; i ++ ) if ( indexedDocuments . containsKey ( newDocNames [ i ] ) ) indexedDocuments . put ( newDocNames [ i ] , new Integer ( i ) ) ; } int count = - <NUM_LIT:1> ; for ( int i = <NUM_LIT:0> ; i < onDiskLength ; ) { switch ( positions [ i ] ) { case DELETED : i ++ ; break ; case RE_INDEXED : String newName = newDocNames [ ++ count ] ; if ( newName . equals ( onDiskNames [ i ] ) ) { indexedDocuments . put ( newName , new Integer ( count ) ) ; i ++ ; } break ; default : if ( newDocNames [ ++ count ] . equals ( onDiskNames [ i ] ) ) positions [ i ++ ] = count ; } } return newDocNames ; } private void copyQueryResults ( HashtableOfObject categoryToWords , int newPosition ) { char [ ] [ ] categoryNames = categoryToWords . keyTable ; Object [ ] wordSets = categoryToWords . valueTable ; for ( int i = <NUM_LIT:0> , l = categoryNames . length ; i < l ; i ++ ) { char [ ] categoryName = categoryNames [ i ] ; if ( categoryName != null ) { SimpleWordSet wordSet = ( SimpleWordSet ) wordSets [ i ] ; HashtableOfObject wordsToDocs = ( HashtableOfObject ) this . categoryTables . get ( categoryName ) ; if ( wordsToDocs == null ) this . categoryTables . put ( categoryName , wordsToDocs = new HashtableOfObject ( wordSet . elementSize ) ) ; char [ ] [ ] words = wordSet . words ; for ( int j = <NUM_LIT:0> , m = words . length ; j < m ; j ++ ) { char [ ] word = words [ j ] ; if ( word != null ) { Object o = wordsToDocs . get ( word ) ; if ( o == null ) { wordsToDocs . put ( word , new int [ ] { newPosition } ) ; } else if ( o instanceof IntList ) { ( ( IntList ) o ) . add ( newPosition ) ; } else { IntList list = new IntList ( ( int [ ] ) o ) ; list . add ( newPosition ) ; wordsToDocs . put ( word , list ) ; } } } } } } void initialize ( boolean reuseExistingFile ) throws IOException { if ( this . indexFile . exists ( ) ) { if ( reuseExistingFile ) { FileInputStream stream = new FileInputStream ( this . indexFile ) ; this . streamBuffer = new byte [ BUFFER_READ_SIZE ] ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , <NUM_LIT> ) ; try { char [ ] signature = readStreamChars ( stream ) ; if ( ! CharOperation . equals ( signature , SIGNATURE_CHARS ) ) { throw new IOException ( Messages . exception_wrongFormat ) ; } this . headerInfoOffset = readStreamInt ( stream ) ; if ( this . headerInfoOffset > <NUM_LIT:0> ) { stream . skip ( this . headerInfoOffset - this . bufferEnd ) ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , this . streamBuffer . length ) ; readHeaderInfo ( stream ) ; } } finally { stream . close ( ) ; } return ; } if ( ! this . indexFile . delete ( ) ) { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; throw new IOException ( ""<STR_LIT>"" + this . indexFile ) ; } } if ( this . indexFile . createNewFile ( ) ) { FileOutputStream stream = new FileOutputStream ( this . indexFile , false ) ; try { this . streamBuffer = new byte [ BUFFER_READ_SIZE ] ; this . bufferIndex = <NUM_LIT:0> ; writeStreamChars ( stream , SIGNATURE_CHARS ) ; writeStreamInt ( stream , - <NUM_LIT:1> ) ; if ( this . bufferIndex > <NUM_LIT:0> ) { stream . write ( this . streamBuffer , <NUM_LIT:0> , this . bufferIndex ) ; this . bufferIndex = <NUM_LIT:0> ; } } finally { stream . close ( ) ; } } else { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; throw new IOException ( ""<STR_LIT>"" + this . indexFile ) ; } } private void initializeFrom ( DiskIndex diskIndex , File newIndexFile ) throws IOException { if ( newIndexFile . exists ( ) && ! newIndexFile . delete ( ) ) { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; } else if ( ! newIndexFile . createNewFile ( ) ) { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; throw new IOException ( ""<STR_LIT>"" + this . indexFile ) ; } int size = diskIndex . categoryOffsets == null ? <NUM_LIT:8> : diskIndex . categoryOffsets . elementSize ; this . categoryOffsets = new HashtableOfIntValues ( size ) ; this . categoryEnds = new HashtableOfIntValues ( size ) ; this . categoryTables = new HashtableOfObject ( size ) ; this . separator = diskIndex . separator ; } private void mergeCategories ( DiskIndex onDisk , int [ ] positions , FileOutputStream stream ) throws IOException { char [ ] [ ] oldNames = onDisk . categoryOffsets . keyTable ; for ( int i = <NUM_LIT:0> , l = oldNames . length ; i < l ; i ++ ) { char [ ] oldName = oldNames [ i ] ; if ( oldName != null && ! this . categoryTables . containsKey ( oldName ) ) this . categoryTables . put ( oldName , null ) ; } char [ ] [ ] categoryNames = this . categoryTables . keyTable ; for ( int i = <NUM_LIT:0> , l = categoryNames . length ; i < l ; i ++ ) if ( categoryNames [ i ] != null ) mergeCategory ( categoryNames [ i ] , onDisk , positions , stream ) ; this . categoryTables = null ; } private void mergeCategory ( char [ ] categoryName , DiskIndex onDisk , int [ ] positions , FileOutputStream stream ) throws IOException { HashtableOfObject wordsToDocs = ( HashtableOfObject ) this . categoryTables . get ( categoryName ) ; if ( wordsToDocs == null ) wordsToDocs = new HashtableOfObject ( <NUM_LIT:3> ) ; HashtableOfObject oldWordsToDocs = onDisk . readCategoryTable ( categoryName , true ) ; if ( oldWordsToDocs != null ) { char [ ] [ ] oldWords = oldWordsToDocs . keyTable ; Object [ ] oldArrayOffsets = oldWordsToDocs . valueTable ; nextWord : for ( int i = <NUM_LIT:0> , l = oldWords . length ; i < l ; i ++ ) { char [ ] oldWord = oldWords [ i ] ; if ( oldWord != null ) { int [ ] oldDocNumbers = ( int [ ] ) oldArrayOffsets [ i ] ; int length = oldDocNumbers . length ; int [ ] mappedNumbers = new int [ length ] ; int count = <NUM_LIT:0> ; for ( int j = <NUM_LIT:0> ; j < length ; j ++ ) { int pos = positions [ oldDocNumbers [ j ] ] ; if ( pos > RE_INDEXED ) mappedNumbers [ count ++ ] = pos ; } if ( count < length ) { if ( count == <NUM_LIT:0> ) continue nextWord ; System . arraycopy ( mappedNumbers , <NUM_LIT:0> , mappedNumbers = new int [ count ] , <NUM_LIT:0> , count ) ; } Object o = wordsToDocs . get ( oldWord ) ; if ( o == null ) { wordsToDocs . put ( oldWord , mappedNumbers ) ; } else { IntList list = null ; if ( o instanceof IntList ) { list = ( IntList ) o ; } else { list = new IntList ( ( int [ ] ) o ) ; wordsToDocs . put ( oldWord , list ) ; } for ( int j = <NUM_LIT:0> ; j < count ; j ++ ) list . add ( mappedNumbers [ j ] ) ; } } } onDisk . categoryTables . put ( categoryName , null ) ; } writeCategoryTable ( categoryName , wordsToDocs , stream ) ; } DiskIndex mergeWith ( MemoryIndex memoryIndex ) throws IOException { String [ ] docNames = readAllDocumentNames ( ) ; int previousLength = docNames . length ; int [ ] positions = new int [ previousLength ] ; SimpleLookupTable indexedDocuments = new SimpleLookupTable ( <NUM_LIT:3> ) ; docNames = computeDocumentNames ( docNames , positions , indexedDocuments , memoryIndex ) ; if ( docNames . length == <NUM_LIT:0> ) { if ( previousLength == <NUM_LIT:0> ) return this ; DiskIndex newDiskIndex = new DiskIndex ( this . indexFile . getPath ( ) ) ; newDiskIndex . initialize ( false ) ; return newDiskIndex ; } DiskIndex newDiskIndex = new DiskIndex ( this . indexFile . getPath ( ) + ""<STR_LIT>"" ) ; try { newDiskIndex . initializeFrom ( this , newDiskIndex . indexFile ) ; FileOutputStream stream = new FileOutputStream ( newDiskIndex . indexFile , false ) ; int offsetToHeader = - <NUM_LIT:1> ; try { newDiskIndex . writeAllDocumentNames ( docNames , stream ) ; docNames = null ; if ( indexedDocuments . elementSize > <NUM_LIT:0> ) { Object [ ] names = indexedDocuments . keyTable ; Object [ ] integerPositions = indexedDocuments . valueTable ; for ( int i = <NUM_LIT:0> , l = names . length ; i < l ; i ++ ) if ( names [ i ] != null ) newDiskIndex . copyQueryResults ( ( HashtableOfObject ) memoryIndex . docsToReferences . get ( names [ i ] ) , ( ( Integer ) integerPositions [ i ] ) . intValue ( ) ) ; } indexedDocuments = null ; if ( previousLength == <NUM_LIT:0> ) newDiskIndex . writeCategories ( stream ) ; else newDiskIndex . mergeCategories ( this , positions , stream ) ; offsetToHeader = newDiskIndex . streamEnd ; newDiskIndex . writeHeaderInfo ( stream ) ; positions = null ; } finally { stream . close ( ) ; this . streamBuffer = null ; } newDiskIndex . writeOffsetToHeader ( offsetToHeader ) ; if ( this . indexFile . exists ( ) && ! this . indexFile . delete ( ) ) { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; throw new IOException ( ""<STR_LIT>"" + this . indexFile ) ; } if ( ! newDiskIndex . indexFile . renameTo ( this . indexFile ) ) { if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + this . indexFile ) ; throw new IOException ( ""<STR_LIT>"" + this . indexFile ) ; } } catch ( IOException e ) { if ( newDiskIndex . indexFile . exists ( ) && ! newDiskIndex . indexFile . delete ( ) ) if ( DEBUG ) System . out . println ( ""<STR_LIT>"" + newDiskIndex . indexFile ) ; throw e ; } newDiskIndex . indexFile = this . indexFile ; return newDiskIndex ; } private synchronized String [ ] readAllDocumentNames ( ) throws IOException { if ( this . numberOfChunks <= <NUM_LIT:0> ) return CharOperation . NO_STRINGS ; FileInputStream stream = new FileInputStream ( this . indexFile ) ; try { int offset = this . chunkOffsets [ <NUM_LIT:0> ] ; stream . skip ( offset ) ; this . streamBuffer = new byte [ BUFFER_READ_SIZE ] ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , this . streamBuffer . length ) ; int lastIndex = this . numberOfChunks - <NUM_LIT:1> ; String [ ] docNames = new String [ lastIndex * CHUNK_SIZE + sizeOfLastChunk ] ; for ( int i = <NUM_LIT:0> ; i < this . numberOfChunks ; i ++ ) readChunk ( docNames , stream , i * CHUNK_SIZE , i < lastIndex ? CHUNK_SIZE : sizeOfLastChunk ) ; return docNames ; } finally { stream . close ( ) ; this . streamBuffer = null ; } } private synchronized HashtableOfObject readCategoryTable ( char [ ] categoryName , boolean readDocNumbers ) throws IOException { int offset = this . categoryOffsets . get ( categoryName ) ; if ( offset == HashtableOfIntValues . NO_VALUE ) { return null ; } if ( this . categoryTables == null ) { this . categoryTables = new HashtableOfObject ( <NUM_LIT:3> ) ; } else { HashtableOfObject cachedTable = ( HashtableOfObject ) this . categoryTables . get ( categoryName ) ; if ( cachedTable != null ) { if ( readDocNumbers ) { Object [ ] arrayOffsets = cachedTable . valueTable ; for ( int i = <NUM_LIT:0> , l = arrayOffsets . length ; i < l ; i ++ ) if ( arrayOffsets [ i ] instanceof Integer ) arrayOffsets [ i ] = readDocumentNumbers ( arrayOffsets [ i ] ) ; } return cachedTable ; } } FileInputStream stream = new FileInputStream ( this . indexFile ) ; HashtableOfObject categoryTable = null ; char [ ] [ ] matchingWords = null ; int count = <NUM_LIT:0> ; int firstOffset = - <NUM_LIT:1> ; this . streamBuffer = new byte [ BUFFER_READ_SIZE ] ; try { stream . skip ( offset ) ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , this . streamBuffer . length ) ; int size = readStreamInt ( stream ) ; try { if ( size < <NUM_LIT:0> ) { System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ""<STR_LIT>"" + this . indexFile ) ; System . err . println ( ""<STR_LIT>"" + offset ) ; System . err . println ( ""<STR_LIT>"" + size ) ; System . err . println ( ""<STR_LIT>"" ) ; } categoryTable = new HashtableOfObject ( size ) ; } catch ( OutOfMemoryError oom ) { oom . printStackTrace ( ) ; System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ""<STR_LIT>"" + this . indexFile ) ; System . err . println ( ""<STR_LIT>"" + offset ) ; System . err . println ( ""<STR_LIT>"" + size ) ; System . err . println ( ""<STR_LIT>"" ) ; throw oom ; } int largeArraySize = <NUM_LIT> ; for ( int i = <NUM_LIT:0> ; i < size ; i ++ ) { char [ ] word = readStreamChars ( stream ) ; int arrayOffset = readStreamInt ( stream ) ; if ( arrayOffset <= <NUM_LIT:0> ) { categoryTable . put ( word , new int [ ] { - arrayOffset } ) ; } else if ( arrayOffset < largeArraySize ) { categoryTable . put ( word , readStreamDocumentArray ( stream , arrayOffset ) ) ; } else { arrayOffset = readStreamInt ( stream ) ; if ( readDocNumbers ) { if ( matchingWords == null ) matchingWords = new char [ size ] [ ] ; if ( count == <NUM_LIT:0> ) firstOffset = arrayOffset ; matchingWords [ count ++ ] = word ; } categoryTable . put ( word , new Integer ( arrayOffset ) ) ; } } this . categoryTables . put ( INTERNED_CATEGORY_NAMES . get ( categoryName ) , categoryTable ) ; this . cachedCategoryName = categoryTable . elementSize < <NUM_LIT> ? categoryName : null ; } catch ( IOException ioe ) { this . streamBuffer = null ; throw ioe ; } finally { stream . close ( ) ; } if ( matchingWords != null && count > <NUM_LIT:0> ) { stream = new FileInputStream ( this . indexFile ) ; try { stream . skip ( firstOffset ) ; this . bufferIndex = <NUM_LIT:0> ; this . bufferEnd = stream . read ( this . streamBuffer , <NUM_LIT:0> , this . streamBuffer . length ) ; for ( int i = <NUM_LIT:0> ; i < count ; i ++ ) { categoryTable . put ( matchingWords [ i ] , readStreamDocumentArray ( stream , readStreamInt ( stream ) ) ) ; } } catch ( IOException ioe ) { this . streamBuffer = null ; throw ioe ; } finally { stream . close ( ) ; } } this . streamBuffer = null ; return categoryTable ; } private void readChunk ( String [ ] docNames , FileInputStream stream , int index , int size ) throws IOException { String current = new String ( readStreamChars ( stream ) ) ; docNames [ index ++ ] = current ; for ( int i = <NUM_LIT:1> ; i < size ; i ++ ) { if ( stream != null && this . bufferIndex + <NUM_LIT:2> >= this . bufferEnd ) readStreamBuffer ( stream ) ; int start = streamBuffer [ this . bufferIndex ++ ] & <NUM_LIT> ; int end = streamBuffer [ this . bufferIndex ++ ] & <NUM_LIT> ; String next = new String ( readStreamChars ( stream ) ) ; if ( start > <NUM_LIT:0> ) { if ( end > <NUM_LIT:0> ) { int length = current . length ( ) ; next = current . substring ( <NUM_LIT:0> , start ) + next + current . substring ( length - end , length ) ; } else { next = current . substring ( <NUM_LIT:0> , start ) + next ; } } else if ( end > <NUM_LIT:0> ) { int length = current . length ( ) ; next = next + current . substring ( length - end , length ) ; } docNames [ index ++ ] = next ; current = next ; } } synchronized String readDocumentName ( int docNumber ) throws IOException { if ( this . cachedChunks == null ) this . cachedChunks = new String [ this . numberOfChunks ] [ ] ; int chunkNumber = docNumber / CHUNK_SIZE ; String [ ] chunk = this . cachedChunks [ chunkNumber ] ; if ( chunk == null ) { boolean isLastChunk = chunkNumber == this . numberOfChunks - <NUM_LIT:1> ; int start = this . chunkOffsets [ chunkNumber ] ; int numberOfBytes = ( isLastChunk ? this . startOfCategoryTables : this . chunkOffsets [ chunkNumber + <NUM_LIT:1> ] ) - start ; if ( numberOfBytes < <NUM_LIT:0> ) throw new IllegalArgumentException ( ) ; this . streamBuffer = new byte [ numberOfBytes ] ; this . bufferIndex = <NUM_LIT:0> ; FileInputStream file = new FileInputStream ( this . indexFile ) ; try { file . skip ( start ) ; if ( file . read ( this . streamBuffer , <NUM_LIT:0> , numberOfBytes ) != numberOfBytes ) throw new IOException ( ) ; } catch ( IOException ioe ) { this . streamBuffer = null ; throw ioe ; } finally { file . close ( ) ; } int numberOfNames = isLastChunk ? this . sizeOfLastChunk : CHUNK_SIZE ; chunk = new String [ numberOfNames ] ; try { readChunk ( chunk , null , <NUM_LIT:0> , numberOfNames ) ; } catch ( IOException ioe ) { this . streamBuffer = null ; throw ioe ; } this . cachedChunks [ chunkNumber ] = chunk ; } this . streamBuffer = null ; return chunk [ docNumber - ( chunkNumber * CHUNK_SIZE ) ] ; } synchronized int [ ] readDocumentNumbers ( Object arrayOffset ) throws IOException { if ( arrayOffset instanceof int [ ] ) return ( int [ ] ) arrayOffset ; FileInputStream stream = new FileInputStream ( this . indexFile'}]",} finally { stream. close ( ) ; } return ( int [ ] ) arrayOffset ; } private synchronized int readHeaderInfo ( FileInputStream stream ) throws IOException { int size = readStreamInt ( stream ) ; this. headerInfoOffset = readStreamInt ( stream ) ; this. numberOfChunks = readStreamInt ( stream ) ; this. chunkOffsets = new int [ this. numberOfChunks + <NUM_LIT:1> ] ; this. sizeOfLastChunk = readStreamInt ( stream ) ; this. documentReferenceSize = readStreamInt ( stream ) ; this. startOfCategoryTables = readStreamInt ( stream ) ; this. categoryOffsets = new HashtableOfIntValues ( this. categoryEnds = new HashtableOfIntValues ( this. categoryTables = new HashtableOfObject ( this. cacheUserCount = readStreamInt ( stream ) ) ) ) ; this. categoryTables = null ; return size ; } private void readOffsetToHeader ( FileInputStream stream ) throws IOException { this. streamEnd = readStreamInt ( stream ) ; } private synchronized void readStreamBuffer ( FileInputStream stream ) throws IOException { if ( this. bufferIndex + <NUM_LIT:2> >= this. bufferEnd ) { this. bufferEnd =,0.0008413866118886195
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . ArrayList ; import java . util . List ; public class SVDBModportSimplePortsDecl extends SVDBModportPortsDecl { public enum PortDir { input , output , inout } ; public PortDir fPortDir ; public List < SVDBModportSimplePort > fPortList ; public SVDBModportSimplePortsDecl ( ) { super'}]",(); fPortList = new ArrayList<>(); } public SVDBModportSimplePortsDecl ( List<SVDBModportSimplePort> portList ) { super(); fPortList = portList; } },6.827126617610227e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api . plus . person . impl ; import java . io . IOException ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpRequest ; import org . springframework . http . client . ClientHttpRequestExecution ; import org . springframework . http . client . ClientHttpRequestInterceptor ; import org . springframework . http . client . ClientHttpResponse ; import org . springframework . social . support . HttpRequestDecorator ; class OAuth2Draft10RequestInterceptor implements ClientHttpRequestInterceptor { private static final String AUTHORIZATION = ""<STR_LIT>"" ; @ Override public'}]","ClientHttpResponse intercept ( HttpRequest request, byte [ ] bytes, ClientHttpRequestExecution execution ) throws IOException { String token = getAccessToken ( ) ; HttpHeaders headers = request. getHeaders ( ) ; headers. set ( ""Authorization"", token ) ; return execution. execute ( request, bytes, headers ) ; } }",9.479886053632348e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . windgate . jdbc . driver ; import java . util . Map ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstAttributeElement ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics .'}]","DmdlSemanticsFactory; public class DmdlDriver implements DmdlSemantics { private final DmdlSemanticsFactory factory ; public DmdlDriver ( DmdlSemanticsFactory factory ) { this. factory = factory ; } @ Override public Map < String, AstAttribute > getAttributes ( ) { return factory. createAttributes ( ) ; } @ Override public Map < String, AstAttributeElement > getElements ( ) { return factory. createElements ( ) ; } }",0.00013851237411707847
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . source ; import java . io . BufferedReader ; import java . io . StringReader ; public class StringSource implements Source { private final String source ;'}]",public StringSource(String source) { this.source = source; } @Override public BufferedReader getReader() { return new BufferedReader(new StringReader(source)); } },5.5435139841741235e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . debug . core . model ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . model . IThread ; import org . eclipse'}]",.debug.core.model.IScope; public class Thread implements IThread { private IScope scope; private String name; private int status; private DebugException exception; // getters and setters },2.2920269092843263e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Path ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IRubyModelStatus ; import org . rubypeople . rdt . core . RubyConventions ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . dialogs . StatusInfo ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . DialogField ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IDialogFieldListener ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IListAdapter ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . LayoutUtil ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . ListDialogField ; import org . rubypeople . rdt . ui . viewsupport . ImageDescriptorRegistry ; import org . rubypeople . rdt . ui . wizards . NewElementWizardPage ; public class SetFilterWizardPage extends NewElementWizardPage { private static final String PAGE_NAME = ""<STR_LIT>"" ; private ListDialogField fInclusionPatternList ; private ListDialogField fExclusionPatternList ; private CPListElement fCurrElement ; private IProject fCurrProject ; private IContainer fCurrSourceFolder ; private static final int IDX_ADD = <NUM_LIT:0> ; private static final int IDX_ADD_MULTIPLE = <NUM_LIT:1> ; private static final int IDX_EDIT = <NUM_LIT:2> ; private static final int IDX_REMOVE = <NUM_LIT:4> ; private final ArrayList fExistingEntries ; public SetFilterWizardPage ( CPListElement entryToEdit , ArrayList existingEntries ) { super ( PAGE_NAME ) ; fExistingEntries = existingEntries ; setTitle ( NewWizardMessages . ExclusionInclusionDialog_title ) ; setDescription ( NewWizardMessages . ExclusionInclusionDialog_description2 ) ; fCurrElement = entryToEdit ; fCurrProject = entryToEdit . getRubyProject ( ) . getProject ( ) ; IWorkspaceRoot root = fCurrProject . getWorkspace ( ) . getRoot ( ) ; IResource res = root . findMember ( entryToEdit . getPath ( ) ) ; if ( res instanceof IContainer ) { fCurrSourceFolder = ( IContainer ) res ; } String excLabel = NewWizardMessages . ExclusionInclusionDialog_exclusion_pattern_label ; ImageDescriptor excDescriptor = RubyPluginImages . DESC_OBJS_EXCLUSION_FILTER_ATTRIB ; String [ ] excButtonLabels = new String [ ] { NewWizardMessages . ExclusionInclusionDialog_exclusion_pattern_add , NewWizardMessages . ExclusionInclusionDialog_exclusion_pattern_add_multiple , NewWizardMessages . ExclusionInclusionDialog_exclusion_pattern_edit , null , NewWizardMessages . ExclusionInclusionDialog_exclusion_pattern_remove } ; String incLabel = NewWizardMessages . ExclusionInclusionDialog_inclusion_pattern_label ; ImageDescriptor incDescriptor = RubyPluginImages . DESC_OBJS_INCLUSION_FILTER_ATTRIB ; String [ ] incButtonLabels = new String [ ] { NewWizardMessages . ExclusionInclusionDialog_inclusion_pattern_add , NewWizardMessages . ExclusionInclusionDialog_inclusion_pattern_add_multiple , NewWizardMessages . ExclusionInclusionDialog_inclusion_pattern_edit , null , NewWizardMessages . ExclusionInclusionDialog_inclusion_pattern_remove } ; fExclusionPatternList = createListContents ( entryToEdit , CPListElement . EXCLUSION , excLabel , excDescriptor , excButtonLabels ) ; fInclusionPatternList = createListContents ( entryToEdit , CPListElement . INCLUSION , incLabel , incDescriptor , incButtonLabels ) ; } public void createControl ( Composite parent ) { Composite inner = new Composite ( parent , SWT . NONE ) ; inner . setFont ( parent . getFont ( ) ) ; GridLayout layout = new GridLayout ( ) ; layout . marginHeight = <NUM_LIT:0> ; layout . marginWidth = <NUM_LIT:0> ; layout . numColumns = <NUM_LIT:2> ; inner . setLayout ( layout ) ; inner . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; fInclusionPatternList . doFillIntoGrid ( inner , <NUM_LIT:3> ) ; LayoutUtil . setHorizontalSpan ( fInclusionPatternList . getLabelControl ( null ) , <NUM_LIT:2> ) ; LayoutUtil . setHorizontalGrabbing ( fInclusionPatternList . getListControl ( null ) ) ; fExclusionPatternList . doFillIntoGrid ( inner , <NUM_LIT:3> ) ; LayoutUtil . setHorizontalSpan ( fExclusionPatternList . getLabelControl ( null ) , <NUM_LIT:2> ) ; LayoutUtil . setHorizontalGrabbing ( fExclusionPatternList . getListControl ( null ) ) ; setControl ( inner ) ; Dialog . applyDialogFont ( inner ) ; } private static class ExclusionInclusionLabelProvider extends LabelProvider { private Image fElementImage ; public ExclusionInclusionLabelProvider ( ImageDescriptor descriptor ) { ImageDescriptorRegistry registry = RubyPlugin . getImageDescriptorRegistry ( ) ; fElementImage = registry . get ( descriptor ) ; } public Image getImage ( Object element ) { return fElementImage ; } public String getText ( Object element ) { return ( String ) element ; } } private ListDialogField createListContents ( CPListElement entryToEdit , String key , String label , ImageDescriptor descriptor , String [ ] buttonLabels ) { ExclusionPatternAdapter adapter = new ExclusionPatternAdapter ( ) ; ListDialogField patternList = new ListDialogField ( adapter , buttonLabels , new ExclusionInclusionLabelProvider ( descriptor ) ) ; patternList . setDialogFieldListener ( adapter ) ; patternList . setLabelText ( label ) ; patternList . enableButton ( IDX_EDIT , false ) ; IPath [ ] pattern = ( IPath [ ] ) entryToEdit . getAttribute ( key'}]","); if ( pattern!= null && pattern.length > 0 ) { patternList. setElements ( pattern ) ; } return patternList ; } private class ExclusionPatternAdapter implements IDialogFieldListener { private ListDialogField fPatternList ; public ExclusionPatternAdapter ( ) { } @Override public void dialogFieldChanged ( IDialogField field ) { if ( field == fPatternList ) { String [ ] patterns = fPatternList. getSelectedValues ( ) ; IPath [ ] pathPatterns = new IPath [ patterns. length ] ; for ( int i = 0 ; i < patterns. length ; i ++ ) { pathPatterns [ i ] = new Path ( patterns [ i ] ) ; } fCurrElement. setAttribute ( CPListElement. EXCLUSION, pathPatterns ) ; } } @Override public void selectionChanged ( IDialogField field ) { } @Override public void booleanChanged ( IDialogField field ) { } @Override public void valueChanged ( IDialogField field ) { } @Override public void controlChanged ( IDialogField field ) { } }",0.00037140568894708086
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . logging ; public interface ConsoleArchiver { public void addConsoleListener ( LogListener l , Object component , long last'}]",timestamp);,1.9187465181975786e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ExportTempTest02 ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class ExportTempTest02ModelInput implements ModelInput < ExportTempTest02 > { private final RecordParser parser ; public ExportTempTest02ModelInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ) ; } this . parser = parser ; } @ Override public boolean readTo ( ExportTempTest02 model ) throws IOException { if ( parser . next ( ) == false ) {'}]","return false; } model.setTest02(parser.getInt(""test02"")); return true; } @Override public boolean readFrom(ExportTempTest02 model) throws IOException { if (parser.next() == false) { return false; } model.setTest02(parser.getInt(""test02"")); return true; } @Override public boolean readTo(ExportTempTest02 model, int limit) throws IOException { if (parser.next(limit) == false) { return false; } model.setTest02(parser.getInt(""test02"")); return true; } @Override public boolean readFrom(ExportTempTest02 model, int limit) throws IOException { if (parser.next(limit) == false) { return false; } model.setTest02(parser.getInt(""test02"")); return true; } }",0.00021194894793291275
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . api ; import java . util . HashMap ; import java . util . Map ; import net . bioclipse . core . domain . IStringMatrix ; import net . bioclipse . rdf . business . RDFManager ; public abstract class Algorithm { private static RDFManager rdf = new RDFManager ( ) ; public static Map < String , String > getProperties ( String ontologyServer , String feature ) {'}]","Map<String, String> properties = new HashMap<>(); // Create a new HashMap to store properties",4.096614892621133e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . workingsets ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IStorage ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . ui . IWorkingSet ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . internal . ui . packageview . LoadPathContainer ; public class WorkingSetFilter extends ViewerFilter { private IWorkingSet fWorkingSet = null ; private IAdaptable [ ] fCachedWorkingSet = null ; public IWorkingSet getWorkingSet ( ) { return fWorkingSet ; } public void setWorkingSet ( IWorkingSet workingSet ) { fWorkingSet = workingSet ; } public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( fWorkingSet == null || ( fWorkingSet . isAggregateWorkingSet ( ) && fWorkingSet . getElements ( ) . length == <NUM_LIT:0> ) ) return true ; if ( element instanceof IRubyElement ) return isEnclosing ( ( IRubyElement ) element ) ; if ( element instanceof IResource ) return isEnclosing ( ( ( IResource ) element ) . getFullPath ( ) ) ; if ( element instanceof LoadPathContainer ) { return isEnclosing ( ( LoadPathContainer ) element ) ; } if ( element instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) element ; IRubyElement je = ( IRubyElement ) adaptable . getAdapter ( IRubyElement . class ) ; if ( je != null ) return isEnclosing ( je ) ; IResource resource = ( IResource ) adaptable . getAdapter ( IResource . class ) ; if ( resource != null ) return isEnclosing ( resource . getFullPath ( ) ) ; } return true ; } private boolean isEnclosing ( LoadPathContainer container ) { Object [ ] roots = container . getSourceFolderRoots ( ) ; if ( roots . length > <NUM_LIT:0> ) return isEnclosing ( ( ISourceFolderRoot ) roots [ <NUM_LIT:0> ] ) ; return false ; } public Object [ ] filter ( Viewer viewer , Object parent , Object [ ] elements ) { Object [ ] result = null ; if ( fWorkingSet != null ) fCachedWorkingSet = fWorkingSet . getElements ( ) ; try { result = super . filter ( viewer , parent , elements ) ; } finally { fCachedWorkingSet = null ; } return result ; } private boolean isEnclosing ( IPath elementPath ) { if ( elementPath == null ) return false ; IAdaptable [ ] cachedWorkingSet = fCachedWorkingSet ; if ( cachedWorkingSet == null ) cachedWorkingSet'}]",= fWorkingSet.getElements(); for (IAdaptable adaptable : cachedWorkingSet) { IPath path = (IPath) adaptable.getAdapter(IPath.class); if (path!= null && path.isPrefixOf(elementPath)) { return true; } } return false; } private boolean isEnclosing ( IRubyElement element ) { return isEnclosing ( element. getFullPath ( ) ) ; } },0.00014243243636393198
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import java . util . Date ; public class MockStateChanger implements StateChanger < ParentState > { public void setState ( ParentState state ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; }'}]",@Override public void setState(ParentState state) { // implementation here },3.492833725059416e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . content_assist ; import net . sf . sveditor . core . content_assist . AbstractCompletionProcessor ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; public class TestCompletionProcessor extends AbstractCompletionProcessor { private SVDBFile fSVDBFile ; private ISVDBIndexIterator fIndexIterator ; public TestCompletionProcessor ( LogHandle log , SVDBFile file , ISVDBIndexIterator iterator ) { fSVDBFile = file ; fIndexIterator = iterator ; fLog = LogFactory . getLogHandle ( log . getName ( ) + ""<STR_LIT>"" ) ; } public TestCompletionProcessor ( String'}]","logName ) { this ( LogFactory. getLogHandle ( logName ), null, null ) ; } }",1.8278519502668903e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob ; import org . oddjob . state . StateEvent ; import org . oddjob . state . StateListener ;'}]",public class MyListener implements StateListener { @Override public void stateChanged(StateEvent event) { // do something } },4.5815653411445624e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . text ; import net . sf . sveditor . ui . editor . SVEditor ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITextViewer ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . information . IInformationProvider ; import org . eclipse . jface . text . information . IInformationProviderExtension ; import org . eclipse . ui . IEditorPart ; public class SVEditorFileProvider implements IInformationProvider , IInformationProviderExtension { private SVEditor fEditor ; public SVEditorFileProvider ( IEditorPart editor ) { if ( editor instanceof SVEditor ) fEditor = ( SVEditor ) editor ; } public SVEditorFileProvider ( IEditorPart editor , boolean useCodeResolve ) { this ( editor ) ; } public String getInformation ( ITextViewer textViewer , IRegion subject ) { return getInformation2 ( textViewer , subject ) . toString ( ) ; } public Object getInformation2 ( ITextViewer textViewer , IRegion subject ) { if'}]","(fEditor == null ||!fEditor.isInputValid()) return null;IRegion region = fEditor.computeRegion(subject.getOffset(), subject.getLength());if (region!= null && region.getLength() > 0) return fEditor.getAdapter(IFile.class);return null; } public void dispose ( ) { fEditor = null ; } }",0.00010721480075732276
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . gems ; import java . io . * ; import java . util . HashMap ; import java . util . Iterator ; public class XMLWriter extends PrintWriter { protected int tab ; protected static final String XML_VERSION = ""<STR_LIT>"" ; public XMLWriter ( OutputStream output ) throws UnsupportedEncodingException { super ( new OutputStreamWriter ( output , ""<STR_LIT>"" ) ) ; tab = <NUM_LIT:0> ; println ( XML_VERSION ) ; } public void endTag ( String name ) { tab -- ; printTag ( \'<CHAR_LIT:/>\' + name , null ) ; } public void printSimpleTag ( String name , Object value ) { if ( value != null ) { printTag ( name , null , true , false ) ; print ( getEscaped ( String . valueOf ( value ) ) ) ; printTag ( \'<CHAR_LIT:/>\' + name , null , false , true ) ; } } public void printTabulation ( ) { for ( int i = <NUM_LIT:0> ; i < tab ; i ++ ) super . print ( \'<STR_LIT:\\t>\' ) ; } public void printTag ( String name , HashMap < String , Object > parameters ) { printTag ( name , parameters , true , true ) ; } public void printTag ( String name , HashMap < String , Object > parameters , boolean shouldTab , boolean newLine ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( ""<STR_LIT:<>"" ) ; sb . append ( name ) ; if ( parameters != null ) for ( Iterator < String > it = parameters . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { sb . append ( ""<STR_LIT:U+0020>"" ) ;'}]","sb. append ( it. next ( ) ) ; sb. append ( ""<STR_LIT:U+003D>"" ) ; sb. append ( getEscaped ( String. valueOf ( parameters. get ( it. next ( ) ) ) ) ) ; } sb. append ( ""<STR_LIT:/>"" ) ; if ( shouldTab ) printTabulation ( ) ; if ( newLine ) println ( sb. toString ( ) ) ; else print ( sb. toString ( ) ) ; } public void startTag ( String name ) { tab ++ ; printTag ( name, null ) ; } public String getEscaped ( String value ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < value. length ( ) ; i ++ ) { char c = value. charAt ( i ) ; if ( c == '<' ) { sb. append ( ""<STR_LIT:&lt;>"" ) ; } else if ( c == '>' ) { sb. append ( ""<STR_LIT:&gt;>"" ) ; } else if ( c == '&' ) { sb. append ( ""<STR_LIT:&amp;>"" ) ; } else if ( c == '""' ) { sb. append ( ""<",0.0003635530713774325
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index ; import java . util . List ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItem ; public interface ISVDBChangeListener { void'}]","itemAdded(SVDBItem item, SVDBFile file);",3.2478595538185196e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . io ; import java . io . IOException ; import com . asakusafw . compiler . operator . model . MockJoined ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class MockJoinedOutput implements ModelOutput < MockJoined > {'}]",private final RecordEmitter emitter; public MockJoinedOutput(RecordEmitter emitter) { this.emitter = emitter; } @Override public void emit(MockJoined model) throws IOException { // implementation } @Override public void close() throws IOException { // implementation } },3.036585148839531e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . TempImportTarget1 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class TempImportTarget1ModelOutput implements ModelOutput < TempImportTarget1 > { private final RecordEmitter emitter ; public TempImportTarget1ModelOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( TempImportTarget1 model ) throws IOException { emitter . emit ( model . getTempSidOption ( ) ) ; emitter . emit ( model . getSidOption ( ) ) ; emitter . emit ( model . getVersionNoOption ( ) ) ; emitter . emit ( model . getTextdata1Option ( ) ) ; emitter . emit ( model . getIntdata1Option ( ) ) ; emitter . emit ( model .'}]",getIntdata2Option() ); } @Override public Class< TempImportTarget1 > getModelClass() { return TempImportTarget1.class; } },5.653604917240059e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . templates ; import java . util . ArrayList ; import java . util . List ; public class TemplateParameter { private TemplateParameterType fType ; private String fName ; private String fDefault ; private String fValue ; private String fExtFrom ; private List < String > fValues ; public TemplateParameter ( TemplateParameterType type , String name , String dflt , String ext_from ) { fType = type ; fName = name ; fDefault = dflt ; fValue = dflt ; fExtFrom = ext_from ; fValues = new ArrayList < String > ( ) ; } public TemplateParameterType getType ( ) { return fType ; }'}]",public String getName() { return fName; } public String getDefault() { return fDefault; } public String getValue() { return fValue; } public String getExtFrom() { return fExtFrom; } public List<String> getValues() { return fValues; } public void setValue(String value) { fValue = value; },0.00010278700819388244
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdata . generator . excel ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . junit . Test ; public class MainTest extends ExcelTesterRoot { @ Test public void simple ( ) throws Exception { File output = folder . newFolder ( ""<STR_LIT>"" ) ; File source = folder . newFolder ( ""<STR_LIT:source>"" ) ; deploy ( ""<STR_LIT>"" , source ) ; List < String > args = new ArrayList < String > ( ) ; Collections . addAll ( args , ""<STR_LIT>"" , output . getAbsolutePath ( ) ) ; Collections . addAll ( args , ""<STR_LIT>"" , source . getAbsolutePath ( ) ) ; Collections . addAll ( args , ""<STR_LIT>"" , WorkbookFormat . DATA . name ( ) ) ; int exit = Main . start ( args . toArray ( new String [ args . size ( ) ] ) ) ; assertThat ( exit , is ( <NUM_LIT:0> ) ) ; HSSFWorkbook book = open ( output , ""<STR_LIT>"" ) ; assertThat ( cell ( book . getSheetAt ( <NUM_LIT:0> ) , <NUM_LIT:0> , <NUM_LIT:0> ) , is ( ""<STR_LIT:value>"" ) ) ; } @ Test public void less ( ) { List < String > args = new ArrayList < String > ( ) ; Collections . addAll ( args ) ; int exit = Main . start ( args . toArray ( new String [ args . size ( ) ] ) ) ; assertThat ( exit , not ( <NUM_LIT:0> ) ) ; } @ Test public void invalid_dmdl ( ) throws Exception { File output = folder . newFolder ( ""<STR_LIT>"" ) ; File source = folder . newFolder ( ""<STR_LIT:source>"" ) ; deploy ( ""<STR_LIT>"" , source ) ; List < String > args = new ArrayList < String > ( ) ; Collections . addAll ( args , ""<STR_LIT>"" , output . getAbsolutePath ( ) ) ; Collections . addAll ( args , ""<STR_LIT>"" , source . getAbsolutePath ( ) ) ; Collections . addAll ( args , ""<STR_LIT>"" , WorkbookFormat . DATA . name ( ) ) ; int exit = Main . start ( args . toArray ( new String [ args . size ( ) ] ) ) ; assertThat ( exit , is ( <NUM_LIT:1> ) ) ; } @ Test public void'}]","invalid_dmdl_with_option ( ) throws Exception { File output = folder. newFolder ( ""<STR_LIT>"" ) ; File source = folder. newFolder ( ""<STR_LIT:source>"" ) ; deploy ( ""<STR_LIT>"", source ) ; List < String > args = new ArrayList < String > ( ) ; Collections. addAll ( args, ""<STR_LIT>"", output. getAbsolutePath ( ) ) ; Collections. addAll ( args, ""<STR_LIT>"", source. getAbsolutePath ( ) ) ; Collections. addAll ( args, ""<STR_LIT>"", WorkbookFormat. DATA. name ( ) ) ; Collections. addAll ( args, ""<STR_LIT>"", ""<STR_LIT:option>"" ) ; int exit = Main. start ( args. toArray ( new String [ args. size ( ) ] ) ) ; assertThat ( exit, is ( <NUM_LIT:1> ) ) ; }",0.0002895320555862249
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . search ; import org . eclipse . core . resources . IResource ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . internal . core . RubyElement ; public class SearchMatch { public static final int A_ACCURATE = <NUM_LIT:0> ; public static final int A_INACCURATE = <NUM_LIT:1> ; private Object element ; private int length ; private int offset ; private int accuracy ; private SearchParticipant participant ; private IResource resource ; private boolean insideDocComment = false ; private final static int ALL_GENERIC_FLAVORS = SearchPattern . R_FULL_MATCH | SearchPattern . R_EQUIVALENT_MATCH | SearchPattern . R_ERASURE_MATCH ; private int rule = ALL_GENERIC_FLAVORS ; private boolean raw = false ; private boolean implicit = false ; public SearchMatch ( IRubyElement element , int accuracy , int offset , int length , SearchParticipant participant , IResource resource ) { this . element = element ; this . offset = offset ; this . length = length ; this . accuracy = accuracy & A_INACCURATE ; if ( accuracy > A_INACCURATE ) { int genericFlavors = accuracy & ALL_GENERIC_FLAVORS ; if ( genericFlavors > <NUM_LIT:0> ) { this . rule &= ~ ALL_GENERIC_FLAVORS ; } this . rule |= accuracy & ~ A_INACCURATE ; } this . participant = participant ; this . resource = resource ; } public final int getAccuracy ( ) { return this . accuracy ; } public final Object getElement ( ) { return this . element ; } public final int getLength ( ) { return this . length ; } public final int getOffset ( ) { return this . offset ; } public final SearchParticipant getParticipant ( ) { return this . participant ; } public final IResource getResource ( ) { return this . resource ; } public final int getRule ( ) { return this . rule ; } public final boolean isEquivalent ( ) { return isErasure ( ) && ( this . rule & SearchPattern . R_EQUIVALENT_MATCH ) != <NUM_LIT:0> ; } public final boolean isErasure ( ) { return ( this . rule & SearchPattern . R_ERASURE_MATCH ) != <NUM_LIT:0> ; } public final boolean isExact ( ) { return isEquivalent ( ) && ( this . rule & SearchPattern . R_FULL_MATCH ) != <NUM_LIT:0> ; } public final boolean isImplicit ( ) { return this . implicit ; } public final boolean isRaw ( ) { return this . raw ; } public final boolean isInsideDocComment ( ) { return this . insideDocComment ; } public final void setAccuracy ( int accuracy ) { this . accuracy = accuracy ; } public final void setElement ( Object element ) { this . element = element ; } public final void setInsideDocComment ( boolean insideDoc ) { this . insideDocComment = insideDoc ; } public final void setImplicit ( boolean implicit ) { this . implicit = implicit ; } public final void setLength ( int length ) { this . length = length ; } public final void setOffset ( int offset ) { this . offset = offset ; } public final void setParticipant ( SearchParticipant participant ) { this . participant = participant ; } public final void setResource ( IResource resource ) { this . resource = resource ; } public final void setRule ( int rule ) { this . rule = rule ; } public final void setRaw ( boolean raw ) { this . raw = raw ; } public String toString ( ) { StringBuffer buffer = new'}]","StringBuffer (""SearchMatch [element="" + element + "", offset="" + offset + "", length="" + length + "", accuracy="" + accuracy + "", participant="" + participant + "", resource="" + resource + "", rule="" + rule + "", raw="" + raw + "", implicit="" + implicit + "", insideDocComment="" + insideDocComment + ""]""); return buffer.toString(); } }",0.00012995229317042117
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . sql ; import de . fuberlin . wiwiss . d2rq . D2RQTestSuite ; public class MySQLDatatypeTest extends DatatypeTestBase { public void setUp ( ) throws Exception { initDB ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:root>"" , null , D2RQTestSuite . DIRECTORY + ""<STR_LIT>"" , null ) ; } public void testSerial ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:1>"" , ""<STR_LIT:2>"" , ""<STR_LIT>"" } ) ; } public void testBit_4 ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void testBit ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" } ) ; } public void testTinyInt ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void testTinyInt1 ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:false>"" , ""<STR_LIT:true>"" , ""<STR_LIT:true>"" } ) ; } public void testTinyIntUnsigned ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" } ) ; } public void testSmallInt ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void testSmallIntUnsigned ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" } ) ; } public void testMediumInt ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public void testMediumIntUnsigned ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType'}]","( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"", ""<STR_LIT:1>"", ""<STR_LIT>"" } ) ; } public void testInt ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"", ""<STR_LIT:1>"", ""<STR_LIT>"", ""<STR_LIT>"" } ) ; } public void testIntUnsigned ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"", ""<STR_LIT:1>"", ""<STR_LIT>"" } ) ; } public void testBigInt ( ) { createMapping ( ""<STR_LIT>"" ) ; assertMappedType ( ""<STR_LIT>"" ) ; assertValues ( new String [ ] { ""<STR_LIT:0>"", ""<STR_LIT:1>"", ""<STR_LIT>"", ""<STR_LIT>"" } ) ; } public void testBigIntUnsigned ( ) { createMapping ( ""<STR_LIT>"" ) ; assert",0.0003724060691805198
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . display ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . text . ITextOperationTarget ; import org . eclipse . ui . texteditor . IUpdate ; public class DisplayViewAction extends Action implements IUpdate { private int fOperationCode = - <NUM_LIT:1> ; private ITextOperationTarget'}]","fTarget;private DisplayViewAction() {}public DisplayViewAction(ITextOperationTarget target, int operationCode) { super(); fTarget = target; fOperationCode = operationCode; }public void update(IUpdate update) { setEnabled(update!= null && fTarget!= null && fTarget.getAdapter(IAdaptable.class)!= null && fOperationCode!= -1); }public ITextOperationTarget getTarget() { return fTarget; }public int getOperationCode() { return fOperationCode; }public void setOperationCode(int operationCode) { fOperationCode = operationCode; } }",0.0001734585183447436
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . nodewrapper ; import org . jruby . ast . AttrAssignNode ; import org . jruby . ast . CallNode ; import org . jruby . ast . ConstNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . jruby . ast . VCallNode ; import org . jruby . ast . types . INameNode ; import org . jruby . lexer . yacc . ISourcePosition ; import org . rubypeople . rdt . refactoring . util . NodeUtil ; public class MethodCallNodeWrapper implements INodeWrapper { static final Class [ ] METHOD_CALL_NODE_CLASSES = { CallNode . class , VCallNode . class , FCallNode . class , AttrAssignNode . class } ; public static final int INVALID_TYPE = - <NUM_LIT:1> ; public static final int CALL_NODE = <NUM_LIT:1> ; public static final int V_CALL_NODE = <NUM_LIT:2> ; public static final int F_CALL_NODE = <NUM_LIT:3> ; private int nodeType ; private Node wrappedNode ; private Node receiverNode ; private Node argsNode ; private String name ; public MethodCallNodeWrapper ( Node node ) { this . wrappedNode = node ; if ( NodeUtil . nodeAssignableFrom ( node , CallNode . class ) ) { CallNode callNode = ( CallNode ) node ; nodeType = CALL_NODE ; receiverNode = callNode . getReceiverNode ( ) ; argsNode = callNode . getArgsNode ( ) ; name = callNode . getName ( ) ; } else if ( NodeUtil . nodeAssignableFrom ( node , AttrAssignNode . class ) ) { AttrAssignNode callNode = ( AttrAssignNode ) node ; nodeType = CALL_NODE ; receiverNode = callNode . getReceiverNode ( ) ; argsNode = callNode . getArgsNode ( ) ; name = callNode . getName ( ) ; } else if ( NodeUtil . nodeAssignableFrom ( node , VCallNode . class ) ) { nodeType = V_CALL_NODE ; name = ( ('}]","INameNode) node).getName(); } else if (NodeUtil.nodeAssignableFrom(node, FCallNode.class)) { FCallNode callNode = (FCallNode) node; nodeType = F_CALL_NODE; receiverNode = callNode.getReceiverNode(); argsNode = callNode.getArgsNode(); name = callNode.getName(); } else { nodeType = INVALID_TYPE; } } public int getType() { return nodeType; } public Node getWrappedNode() { return wrappedNode; } public Node getReceiverNode() { return receiverNode; } public Node getArgsNode() { return argsNode; } public String getName() { return name; } }",0.0001991824505970674
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . action ; import org . rubypeople . rdt . refactoring . core'}]",";.Action; import org.eclipse.jdt.core.ICompilationUnit; import org.eclipse.jdt.core.IJavaElement; import org.eclipse.jdt.core.IType; import org.eclipse.jdt.core.dom.AST; import org.eclipse.jdt.core.dom.ASTParser; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.CompilationUnit; import org.eclipse.jdt.core.dom.MethodInvocation; import org.eclipse.jdt.core.dom.SimpleName; import org.eclipse.jdt.core.dom.Type; import org.eclipse.jface.text.IDocument; import org.eclipse.jface.text.ITextViewer; import org.eclipse.ui.IElementVisitor; import org.eclipse.ui.IElementVisitorAdapter; public class ExtractMethodAction extends RefactoringAction { public ExtractMethodAction ( ) { super ( ""Extract Method"" ) ; } @Override public void run ( IAction action ) { super. run ( action ) ; ICompilationUnit unit = getCompilationUnit ( ) ; IJavaElement element = getSelectedElement ( ) ; if ( element instanceof IType ) { IType type = ( IType ) element ; String source = type. getCompilationUnit ( ). getBuffer ( ). getContents ( ) ; ASTParser parser = ASTParser. newParser ( AST. J",0.0003376112948045438
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . beanbus ; import java . util . ArrayList ; import java . util . List ; import java . util . Stack ; public class StageSupport implements StageNotifier { private List < StageListener > batchListeners = new ArrayList < StageListener > ( ) ; private final StageNotifier source ; private final Stack <'}]",StageListener> listenerStack = new Stack<StageListener>();public StageSupport(StageNotifier source) { this.source = source; } public void addListener(StageListener listener) { listenerStack.push(listener); batchListeners.add(listener); } public void removeListener(StageListener listener) { listenerStack.remove(listener); batchListeners.remove(listener); } public void notify(StageEvent event) { for (StageListener listener : listenerStack.elements()) { listener.notify(event); } } },0.000135081886377863
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . values . properties ; import junit . framework . TestCase ; public class EnvVarPropertyLookupTest extends TestCase { public void testLookup ( ) { EnvVarPropertyLookup test = new EnvVarPropertyLookup ( ""<STR_LIT>"" ) ; String path = test . lookup ( ""<STR_LIT>"" ) ; assertNotNull ( path ) ; path = test . lookup ( ""<STR_LIT>"" ) ;'}]","assertEquals ( System. getProperty ( ""<STR_LIT>"" ), path ); } }",3.7182931957829144e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org .'}]",rubypeople.rdt.internal.ui.text.TextDocument;,2.9723670979167115e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . template . contentassist ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . BadPositionCategoryException ; import org . eclipse . jface . text . DocumentEvent ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IInformationControlCreator ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITextViewer ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . contentassist . ICompletionProposal ; import org . eclipse . jface . text . contentassist . ICompletionProposalExtension2 ; import org . eclipse . jface . text . contentassist . ICompletionProposalExtension3 ; import org . eclipse . jface . text . contentassist . ICompletionProposalExtension4 ; import org . eclipse . jface . text . contentassist . IContextInformation ; import org . eclipse . jface . text . link . ILinkedModeListener ; import org . eclipse . jface . text . link . InclusivePositionUpdater ; import org . eclipse . jface . text . link . LinkedModeModel ; import org . eclipse . jface . text . link . LinkedModeUI ; import org . eclipse . jface . text . link . LinkedPosition ; import org . eclipse . jface . text . link . LinkedPositionGroup ; import org . eclipse . jface . text . link . ProposalPosition ; import org . eclipse . jface . text . templates . DocumentTemplateContext ; import org . eclipse . jface . text . templates . GlobalTemplateVariables ; import org . eclipse . jface . text . templates . Template ; import org . eclipse . jface . text . templates . TemplateBuffer ; import org . eclipse . jface . text . templates . TemplateContext ; import org . eclipse . jface . text . templates . TemplateException ; import org . eclipse . jface . text . templates . TemplateVariable ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . texteditor . link . EditorLinkedModeUI ; import org . rubypeople . rdt . internal . corext . template . ruby . RubyScriptContext ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rubyeditor . EditorHighlightingSynchronizer ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . internal . ui . util . ExceptionHandler ; import org . rubypeople . rdt . ui . text . ruby . IRubyCompletionProposal ; public class TemplateProposal implements IRubyCompletionProposal , ICompletionProposalExtension2 , ICompletionProposalExtension3 , ICompletionProposalExtension4 { private final Template fTemplate ; private final TemplateContext fContext ; private final Image fImage ; private IRegion fRegion ; private int fRelevance ; private IRegion fSelectedRegion ; private String fDisplayString ; public TemplateProposal ( Template template , TemplateContext context , IRegion region , Image image ) { Assert . isNotNull ( template ) ; Assert . isNotNull ( context ) ; Assert . isNotNull ( region ) ; fTemplate = template ; fContext = context ; fImage = image ; fRegion = region ; fDisplayString = null ; fRelevance = computeRelevance ( ) ; } private int computeRelevance ( ) { final int R_DEFAULT = <NUM_LIT:0> ; final int R_INTERESTING = <NUM_LIT:5> ; final int R_CASE = <NUM_LIT:10> ; final int R_NON_RESTRICTED = <NUM_LIT:3> ; final int R_EXACT_NAME = <NUM_LIT:4> ; final int R_INLINE_TAG = <NUM_LIT:31> ; int base = R_DEFAULT + R_INTERESTING + R_NON_RESTRICTED ; try { if ( fContext instanceof DocumentTemplateContext ) { DocumentTemplateContext templateContext = ( DocumentTemplateContext ) fContext ; IDocument document = templateContext . getDocument ( ) ; String content = document . get ( fRegion . getOffset ( ) , fRegion . getLength ( ) ) ; if ( fTemplate . getName ( ) . startsWith ( content ) ) base += R_CASE ; if ( fTemplate . getName ( ) . equalsIgnoreCase ( content ) ) base += R_EXACT_NAME ; } } catch ( BadLocationException e ) { } final int TEMPLATE_RELEVANCE = <NUM_LIT:1> ; return base * <NUM_LIT:16> + TEMPLATE_RELEVANCE ; } public final void apply ( IDocument document ) { } public void apply ( ITextViewer viewer , char trigger , int stateMask , int offset ) { try { fContext . setReadOnly ( false ) ; TemplateBuffer templateBuffer ; try { templateBuffer = fContext . evaluate ( fTemplate ) ; } catch ( TemplateException e1 ) { fSelectedRegion = fRegion ; return ; } int start = getReplaceOffset ( ) ; int end = getReplaceEndOffset ( ) ; end = Math . max ( end , offset ) ; IDocument document = viewer . getDocument ( ) ; String templateString = templateBuffer . getString ( ) ; document . replace ( start , end - start , templateString ) ; LinkedModeModel model = new LinkedModeModel ( ) ; TemplateVariable [ ] variables = templateBuffer . getVariables ( ) ; MultiVariableGuess guess = fContext instanceof RubyScriptContext ? ( ( RubyScriptContext ) fContext ) . getMultiVariableGuess ( ) : null ; boolean hasPositions = false ;'}]","for ( TemplateVariable variable : variables ) { if ( variable instanceof IRubyCompletionProposal ) { IRubyCompletionProposal proposal = ( IRubyCompletionProposal ) variable ; model. addPosition ( new ProposalPosition ( offset, proposal. getDisplayString ( ), proposal. getDisplayString ( ), proposal. getRelevance ( ) ) ) ; hasPositions = true ; } } if ( hasPositions ) { viewer. setDocument ( document ) ; LinkedPositionUpdater updater = new InclusivePositionUpdater ( viewer, new InclusivePositionUpdater. PositionUpdater ( ) { @ Override public void updatePosition ( Position position, int offset, int length ) { position. setOffset ( offset ) ; position. setLength ( length ) ; } } ) ; LinkedPositionGroup group = new LinkedPositionGroup ( ) ; group. addPosition ( new LinkedPosition ( offset, fDisplayString, fDisplayString, fRelevance ) ) ; for ( TemplateVariable variable : variables ) { if ( variable instanceof IRubyCompletionProposal ) { IRubyCompletionProposal proposal = ( IRubyCompletionProposal ) variable ; group. addPosition ( new LinkedPosition ( offset, proposal. getDisplayString ( ), proposal. getDisplayString ( ), proposal. getRelevance ( )",0.00041261682126715734
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . internal . ui . search . RubySearchScopeFactory ;'}]",import org.eclipse.jface.action.Action;,2.605652221539442e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . dom ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . Region ; import org . jruby . ast . Node ; import org . rubypeople . rdt . internal . core . parser . InOrderVisitor ; public class SelectionAnalyzer extends InOrderVisitor { private Selection fSelection ; private boolean fTraverseSelectedNode ; private Node fLastCoveringNode ; private List < Node > fSelectedNodes ; public SelectionAnalyzer ( Selection selection , boolean traverseSelectedNode ) { Assert . isNotNull ( selection ) ; fSelection = selection ; fTraverseSelectedNode = traverseSelectedNode ; } public boolean hasSelectedNodes ( ) { return fSelectedNodes != null && ! fSelectedNodes . isEmpty ( ) ; } public Node [ ] getSelectedNodes ( ) { if ( fSelectedNodes == null || fSelectedNodes . isEmpty ( ) ) return new Node [ <NUM_LIT:0> ] ; return ( Node [ ] ) fSelectedNodes . toArray ( new Node [ fSelectedNodes . size ( ) ] ) ; } public Node getFirstSelectedNode ( ) { if ( fSelectedNodes == null || fSelectedNodes'}]",.isEmpty() ) { return null; } return fSelectedNodes.get(0); } @Override public void visit(Node node) { super.visit(node); if (fTraverseSelectedNode && node == fSelection.getSelectedNode()) { fLastCoveringNode = node; } } @Override public void visitChildren(Node node) { super.visitChildren(node); if (fLastCoveringNode == node) { fLastCoveringNode = null; } } @Override public void visitEnd(Node node) { super.visitEnd(node); if (fSelection.isSelected(node)) { if (fSelectedNodes == null) { fSelectedNodes = new ArrayList<>(); } fSelectedNodes.add(node); } } },0.00019778662371156116
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import org . eclipse . jface . text . Assert ; import org . eclipse . jface . text . link . ILinkedModeListener ; import org . eclipse . jface . text . link . LinkedModeModel ; public class EditorHighlightingSynchronizer implements ILinkedModeListener { private final RubyEditor fEditor ; private final boolean fWasOccurrencesOn ; public EditorHighlightingSynchronizer ( RubyEditor editor ) { Assert . isLegal ( editor != null ) ; fEditor = editor ; fWasOccurrencesOn = fEditor . isMarkingOccurrences ( ) ; if ( fWasOccurrencesOn && ! isEditorDisposed ( ) ) fEditor . uninstallOccurrencesFinder ( ) ; } public void left ('}]","void ) { } public void left ( String oldString, String newString ) { fEditor. setHighlighting ( newString ) ; if ( fWasOccurrencesOn &&! isEditorDisposed ( ) ) { fEditor. uninstallOccurrencesFinder ( ) ; fEditor. installOccurrencesFinder ( newString ) ; } } public void left ( String oldString, String newString, int offset, int length ) { left ( oldString, newString ) ; } public void right ( String oldString, String newString ) { fEditor. setHighlighting ( newString ) ; if ( fWasOccurrencesOn &&! isEditorDisposed ( ) ) { fEditor. uninstallOccurrencesFinder ( ) ; fEditor. installOccurrencesFinder ( newString ) ; } } public void right ( String oldString, String newString, int offset, int length ) { right ( oldString, newString ) ; } public void cancel ( ) { fEditor. setHighlighting ( null ) ; if ( fWasOccurrencesOn &&! isEditorDisposed ( ) ) { fEditor. uninstallOccurrencesFinder ( ) ; fEditor. installOccurrencesFinder ( fEditor. getHighlighting ( ) ) ; } } private boolean isEditorDisposed ( ) { return fEditor. is",0.00035142852120477447
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import java . io . IOException ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . core . index . EntryResult ; import org . rubypeople . rdt . internal . core . index . Index ; import org . rubypeople . rdt . internal . core . search . indexing . IIndexConstants ; import org . rubypeople . rdt . internal . core . util . CharOperation ; public class SuperTypeReferencePattern extends RubySearchPattern implements IIndexConstants { public char [ ] superQualification ; public char [ ] superSimpleName ; public char superClassOrInterface ; public char typeSuffix ; public char [ ] pkgName ; public char [ ] simpleName ; public char [ ] enclosingTypeName ; public char classOrInterface ; public int modifiers ; protected int superRefKind ; public static final int ALL_SUPER_TYPES = <NUM_LIT:0> ; public static final int ONLY_SUPER_INTERFACES = <NUM_LIT:1> ; public static final int ONLY_SUPER_CLASSES = <NUM_LIT:2> ; protected static char [ ] [ ] CATEGORIES = { SUPER_REF } ; public static char [ ] createIndexKey ( int modifiers , char [ ] packageName , char [ ] typeName , char [ ] [ ] enclosingTypeNames , char classOrInterface , char [ ] superTypeName , char superClassOrInterface ) { if ( superTypeName == null ) superTypeName = OBJECT ; char [ ] superSimpleName = CharOperation . lastSegment ( superTypeName , ""<STR_LIT>"" ) ; char [ ] superQualification = null ; if ( ! CharOperation . equals ( superSimpleName , superTypeName ) ) { int length = superTypeName . length - superSimpleName . length - <NUM_LIT:1> ; superQualification = new char [ length - <NUM_LIT:1> ] ; System . arraycopy ( superTypeName , <NUM_LIT:0> , superQualification , <NUM_LIT:0> , length - <NUM_LIT:1> ) ; } char [ ] superTypeSourceName = CharOperation . lastSegment ( superSimpleName , ""<STR_LIT>"" ) ; if ( ! CharOperation . equals ( superSimpleName , superTypeSourceName ) ) { int start = superQualification == null ? <NUM_LIT:0> : superQualification . length + <NUM_LIT:1> ; int prefixLength = superSimpleName . length - superTypeSourceName . length ; char [ ] mangledQualification = new char [ start + prefixLength ] ; if ( superQualification != null ) { System . arraycopy ( superQualification , <NUM_LIT:0> , mangledQualification , <NUM_LIT:0> , start - <NUM_LIT:1> ) ; mangledQualification [ start - <NUM_LIT:1> ] = \'<CHAR_LIT:.>\' ; } System . arraycopy ( superSimpleName , <NUM_LIT:0> , mangledQualification , start , prefixLength ) ; superQualification = mangledQualification ; superSimpleName = superTypeSourceName ; } char [ ] simpleName = CharOperation . lastSegment ( typeName , ""<STR_LIT>"" ) ; char [ ] enclosingTypeName = CharOperation . concatWith ( enclosingTypeNames , ""<STR_LIT>"" ) ; if ( superQualification != null && CharOperation . equals ( superQualification , packageName ) ) packageName = ONE_ZERO ; int superLength = superSimpleName == null ? <NUM_LIT:0> : superSimpleName . length ; int superQLength = superQualification == null ? <NUM_LIT:0> : superQualification . length ; int simpleLength = simpleName == null ? <NUM_LIT:0> : simpleName . length ; int enclosingLength = enclosingTypeName == null ? <NUM_LIT:0> : enclosingTypeName . length ; int packageLength = packageName == null ? <NUM_LIT:0> : packageName . length ; char [ ] result = new char [ superLength + superQLength + simpleLength + enclosingLength + packageLength + <NUM_LIT:8> ] ; int pos = <NUM_LIT:0> ; if ( superLength > <NUM_LIT:0> ) { System . arraycopy ( superSimpleName , <NUM_LIT:0> , result , pos , superLength ) ; pos += superLength ; } result [ pos ++ ] = SEPARATOR ; if ( superQLength > <NUM_LIT:0> ) { System . arraycopy ( superQualification , <NUM_LIT:0> , result , pos , superQLength ) ; pos += superQLength ; } result [ pos ++ ] = SEPARATOR ; if ( simpleLength > <NUM_LIT:0> ) { System . arraycopy ( simpleName , <NUM_LIT:0> , result , pos , simpleLength ) ; pos += simpleLength ; } result [ pos ++ ] = SEPARATOR ; if ( enclosingLength > <NUM_LIT:0> ) { System . arraycopy ( enclosingTypeName , <NUM_LIT:0> , result , pos , enclosingLength ) ; pos += enclosingLength ; } result [ pos ++ ] = SEPARATOR ; if ( packageLength > <NUM_LIT:0> ) { System . arraycopy ( packageName , <NUM_LIT:0> , result , pos , packageLength ) ; pos += packageLength ; } result [ pos ++ ] = SEPARATOR ; result [ pos ++ ] = superClassOrInterface ; result [ pos ++ ] = classOrInterface ; result [ pos ] = ( char ) modifiers ; return result ; } public SuperTypeReferencePattern ( char [ ] superQualification , char [ ] superSimpleName , int superRefKind , int matchRule ) { this ( matchRule ) ; this . superQualification = isCaseSensitive ( ) ? superQualification : CharOperation . toLowerCase ( superQualification ) ; this . superSimpleName = ( isCaseSensitive ( ) || isCamelCase ( ) ) ? superSimpleName : CharOperation . toLowerCase ( superSimpleName ) ; ( ( InternalSearchPattern ) this ) . mustResolve = superQualification != null ; this . superRefKind = superRefKind ; } public SuperTypeReferencePattern ( char [ ] superQualification , char [ ] superSimpleName , int superRefKind , char typeSuffix , int matchRule ) { this ( superQualification , superSimpleName , superRefKind , matchRule ) ; this . typeSuffix = typeSuffix ; ( ( InternalSearchPattern ) this ) . mustResolve = superQualification != null || typeSuffix != IIndexConstants . TYPE_SUFFIX ; } SuperTypeReferencePattern ( int matchRule ) { super ( SUPER_REF_PATTERN , matchRule ) ; } public void decodeIndexKey ( char [ ] key ) { int slash = CharOperation . indexOf ( SEPARATOR , key , <NUM_LIT:0> ) ;'}]","superSimpleName = CharOperation.lastSegment(CharOperation.substring(key, <NUM_LIT:0>, slash), ""<STR_LIT>"");",7.821202683872798e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBSequenceRepetitionExpr extends SVDBExpr { public String fRepType ;'}]","public SVDBSequenceRepetitionExpr(String fRepType, SVDBExpr fExpr) { super(); this.fRepType = fRepType; this.fExpr = fExpr; }",6.3236339770433e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . visualizer ; import java . util . Collections ; import java . util . Set ; import java . util . UUID ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . vocabulary . flow . graph . FlowElement ; public class VisualFlowPart implements VisualNode { private final UUID id = UUID . randomUUID ( ) ; private final FlowElement element ; private final Set < VisualNode > nodes ; public VisualFlowPart ( FlowElement element , Set < ? extends VisualNode > nodes ) { Precondition . checkMustNotBeNull ( element , ""<STR_LIT>"" ) ; Precondition . checkMustNotBeNull ( nodes , ""<STR_LIT>"" ) ; this . element = element ; this . nodes = Sets . from ( nodes ) ; } @ Override public Kind getKind ( ) { return Kind . FLOW_PART ; } @ Override public UUID getId ( ) { return id ; } public FlowElement getElement ( ) { return element ; } public Set < VisualNode > getNodes ( ) { return Collections . unmodifiableSet ( nodes ) ; }'}]",public Set<? extends VisualNode> getChildren() { return Collections.unmodifiableSet(nodes); },4.254593234306673e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core ; import java . io . IOException ; import java . util . Map ; public class MockCommandScriptHandler extends ExecutionScriptHandlerBase implements CommandScriptHandler { @ Override protected void'}]","doConfigure(Map<String, Object> options) throws IOException, InterruptedException { }",3.555978595426805e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Writable ; import com . asakusafw . compiler . operator . io . MockHogeInput ; import com . asakusafw . compiler . operator . io . MockHogeOutput ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . value . IntOption ; @ DataModelKind ( ""<STR_LIT>"" ) @ ModelInputLocation ( MockHogeInput . class ) @ ModelOutputLocation ( MockHogeOutput . class ) public class MockHoge implements DataModel < MockHoge > , MockProjection , Writable { private final IntOption value = new IntOption ( ) ; @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void reset ( ) { this . value . setNull ( ) ; } @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void copyFrom ( MockHoge other ) { this . value . copyFrom ( other . value ) ; } @ Override public int getValue ( ) { return this . value . get ( ) ; } @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setValue ( int value0 ) { this . value'}]",".set(value0); } @Override @SuppressWarnings(""<STR_LIT:deprecation>"") public void readFields(DataInput in) throws IOException { this.value.readFields(in); } @Override @SuppressWarnings(""<STR_LIT:deprecation>"") public void write(DataOutput out) throws IOException { this.value.write(out); } }",0.00010514729386720558
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import junit . framework . TestCase ; public class IsContineableTest extends TestCase { public void testAllStates ( ) { IsContinueable test = new IsContinueable ( ) ; assertTrue'}]",( test.isContinueable() ); } public class IsContinueable { public boolean isContinueable ( ) { return true; } },4.989929752357826e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import org . eclipse . core . resources . IResourceStatus ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyModelStatus ; import org . rubypeople . rdt . core . IRubyModelStatusConstants ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . core . util . Messages ; public class RubyModelStatus extends Status implements IRubyModelStatus , IRubyModelStatusConstants , IResourceStatus { protected IRubyElement [ ] elements = new IRubyElement [ <NUM_LIT:0> ] ; protected IPath path ; protected String string ; protected final static IStatus [ ] NO_CHILDREN = new IStatus [ ] { } ; protected IStatus [ ] children = NO_CHILDREN ; public static final IRubyModelStatus VERIFIED_OK = new RubyModelStatus ( OK , OK , Messages . bind ( Messages . status_OK ) ) ; public RubyModelStatus ( ) { super ( ERROR , RubyCore . PLUGIN_ID , <NUM_LIT:0> , ""<STR_LIT>"" , null ) ; } public RubyModelStatus ( int code ) { super ( ERROR , RubyCore . PLUGIN_ID , code , ""<STR_LIT>"" , null ) ; this . elements = RubyElement . NO_ELEMENTS ; } public RubyModelStatus ( int code , IRubyElement [ ] elements ) { super ( ERROR , RubyCore . PLUGIN_ID , code , ""<STR_LIT>"" , null ) ; this . elements = elements ; this . path = null ; } public RubyModelStatus ( int code , String string ) { this ( ERROR , code , string ) ; } public RubyModelStatus ( int severity , int code , String string ) { super ( severity , RubyCore . PLUGIN_ID , code , ""<STR_LIT>"" , null ) ; this . elements = RubyElement . NO_ELEMENTS ; this . path = null ; this . string = string ; } public RubyModelStatus ( int code , Throwable throwable ) { super ( ERROR , RubyCore . PLUGIN_ID , code , ""<STR_LIT>"" , throwable ) ; this . elements = RubyElement . NO_ELEMENTS ; } public RubyModelStatus ( int code , IPath path ) { super ( ERROR , RubyCore . PLUGIN_ID , code , ""<STR_LIT>"" , null ) ; this . elements = RubyElement . NO_ELEMENTS ; this . path = path ; } public RubyModelStatus ( int code , IRubyElement element ) { this ( code , new IRubyElement [ ] { element } ) ; } public RubyModelStatus ( int code , IRubyElement element , String string ) { this ( code , new IRubyElement [ ] { element } ) ; this . string = string ; } public RubyModelStatus ( int code , IRubyElement element , IPath path ) { this ( code , new IRubyElement [ ] { element } ) ; this . path = path ; } public RubyModelStatus ( int code , IRubyElement element , IPath path , String string ) { this ( code , new IRubyElement [ ] { element } ) ; this . path = path ; this . string = string ; } public RubyModelStatus ( CoreException coreException ) { super ( ERROR , RubyCore . PLUGIN_ID , CORE_EXCEPTION , ""<STR_LIT>"" , coreException ) ; elements = RubyElement . NO_ELEMENTS ; } protected int getBits ( ) { int severity = <NUM_LIT:1> << ( getCode ( ) % <NUM_LIT:100> / <NUM_LIT> ) ; int category = <NUM_LIT:1> << ( ( getCode ( ) / <NUM_LIT:100> ) + <NUM_LIT:3> ) ; return severity | category ; } public IStatus [ ] getChildren ( ) { return children ; } public IRubyElement [ ] getElements ( ) { return elements ; } public String getMessage ( ) { Throwable exception = getException ( ) ; if ( exception == null ) { switch ( getCode ( ) ) { case CORE_EXCEPTION : return Messages . bind ( Messages . status_coreException ) ; case BUILDER_INITIALIZATION_ERROR : return Messages . bind ( Messages . build_initializationError ) ; case BUILDER_SERIALIZATION_ERROR : return Messages . bind ( Messages . build_serializationError ) ; case DEVICE_PATH : return Messages . bind ( Messages . status_cannotUseDeviceOnPath , getPath ( ) . toString ( ) ) ; case DOM_EXCEPTION : return Messages . bind ( Messages . status_JDOMError ) ; case ELEMENT_DOES_NOT_EXIST : return Messages . bind ( Messages . element_doesNotExist , ( ( RubyElement ) elements [ <NUM_LIT:0> ] ) . toStringWithAncestors ( ) ) ; case ELEMENT_NOT_ON_CLASSPATH : return Messages . bind ( Messages . element_notOnClasspath , ( ( RubyElement ) elements [ <NUM_LIT:0> ] ) . toStringWithAncestors ( ) ) ; case EVALUATION_ERROR : return Messages . bind ( Messages . status_evaluationError , string ) ; case INDEX_OUT_OF_BOUNDS : return Messages . bind ( Messages . status_indexOutOfBounds ) ; case INVALID_CONTENTS : return Messages . bind ( Messages . status_invalidContents ) ; case INVALID_DESTINATION : return Messages . bind ( Messages . status_invalidDestination , ( ( RubyElement ) elements [ <NUM_LIT:0> ] ) . toStringWithAncestors ( ) ) ; case INVALID_ELEMENT_TYPES : StringBuffer buff = new StringBuffer ( Messages . bind ( Messages . operation_notSupported ) ) ; for ( int i = <NUM_LIT:0> ; i < elements . length ; i ++ ) { if ( i > <NUM_LIT:0> ) { buff . append ( ""<STR_LIT:U+002CU+0020>"" ) ; } buff . append ( ( ( RubyElement ) elements [ i ] ) . toStringWithAncestors ( ) ) ; } return buff . toString ( ) ; case INVALID_NAME : return Messages . bind ( Messages . status_invalidName , string ) ; case INVALID_PACKAGE : return Messages . bind ( Messages . status_invalidPackage , string ) ; case INVALID_PATH : if ( string != null ) { return string ; } return Messages . bind ( Messages . status_invalidPath , getPath ( ) == null ? ""<STR_LIT:null>"" : getPath ( ) . toString ( ) ) ; case INVALID_PROJECT : return Messages . bind ( Messages . status_invalidProject , string ) ; case INVALID_RESOURCE : return Messages . bind ( Messages . status_invalidResource , string ) ; case INVALID_RESOURCE_TYPE : return Messages . bind ( Messages . status_invalidResourceType , string ) ; case INVALID_SIBLING : if ( string != null ) { return Messages . bind ( Messages . status_invalidSibling , string ) ; } return Messages . bind ( Messages . status_invalidSibling , ( ( RubyElement ) elements [ <NUM_LIT:0> ] ) . toStringWithAncestors ( ) ) ; case IO_EXCEPTION : return Messages . bind ( Messages . status_IOException ) ; case NAME_COLLISION : if ( string != null ) { return string ; } return Messages . bind ( Messages . status_nameCollision , ""<STR_LIT>"" ) ; case NO_ELEMENTS_TO_PROCESS : return Messages . bind ( Messages . operation_needElements ) ; case NULL_NAME : return Messages . bind ( Messages . operation_needName ) ; case NULL_PATH : return Messages . bind ( Messages . operation_needPath ) ; case NULL_STRING : return Messages . bind ( Messages . operation_needString ) ; case PATH_OUTSIDE_PROJECT : return Messages . bind ( Messages . operation_pathOutsideProject , string , ( ( RubyElement ) elements [ <NUM_LIT:0> ] ) . toStringWithAncestors ( ) ) ; case READ_ONLY : IRubyElement element = elements [ <NUM_LIT:0> ] ; String name = element . getElementName ( ) ; return Messages . bind ( Messages . status_readOnly , name ) ; case RELATIVE_PATH : return Messages . bind ( Messages . operation_needAbsolutePath , getPath ( ) . toString ( ) ) ; case TARGET_EXCEPTION : return Messages . bind ( Messages . status_targetException ) ; case UPDATE_CONFLICT : return Messages . bind ( Messages . status_updateConflict ) ; case NO_LOCAL_CONTENTS : return Messages . bind ( Messages . status_noLocalContents , getPath ( ) . toString ( ) ) ; case CP_VARIABLE_PATH_UNBOUND : IRubyProject javaProject = ( IRubyProject ) elements [ <NUM_LIT:0> ] ; return'}]","Messages.bind(Messages.statusCPVariablePathUnbound, javaProject.toStringWithAncestors());",7.181680565611943e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . util ; import junit . framework . Test ; import junit . framework . TestSuite ; public class TS_CoreUtil { public static'}]",TestSuite suite = new TestSuite();,2.7027856653015703e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . indent ; import java . util . ArrayList ; import java . util . List ; public class SVIndentExprToken extends SVIndentToken { protected List < SVIndentToken > fExprElems ; public SVIndentExprToken ( String leading_ws ) { super ( SVIndentTokenType . Expression , leading_ws ) ; fExprElems = new ArrayList < SVIndentToken > ( ) ; } public List < SVIndentToken > getExprElems ( ) { return fExprElems ; } public void addExprElem ( SVIndentToken elem ) { fExprElems . add ( elem ) ; } @ Override public String getImage ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <NUM_LIT:0> ; i < fExprElems . size ( ) ; i ++ ) { SVIndentToken tok = fExprElems . get ( i ) ; if'}]","(i > 0) { sb.append("" ""); } sb.append(tok.getImage()); } return sb.toString(); } }",4.870231663880755e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . map ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import com . hp . hpl . jena . rdf . model . Literal ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . rdf . model . Statement ; import com . hp . hpl . jena . shared . PrefixMapping ; import com . hp . hpl . jena . shared . impl . PrefixMappingImpl ; import com . hp . hpl . jena . vocabulary . RDF ; import com . hp . hpl . jena . vocabulary . RDFS ; import de . fuberlin . wiwiss . d2rq . D2RQException ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . algebra . Relation ; import de . fuberlin . wiwiss . d2rq . algebra . TripleRelation ; import de . fuberlin . wiwiss . d2rq . sql . types . DataType ; import de . fuberlin . wiwiss . d2rq . vocab . D2RQ ; public class Mapping { private static final Log log = LogFactory . getLog ( Mapping . class ) ; private final Model model = ModelFactory . createDefaultModel ( ) ; private final Model vocabularyModel = ModelFactory . createDefaultModel ( ) ; private Resource mappingResource ; private final Map < Resource , Database > databases = new HashMap < Resource , Database > ( ) ; private Configuration configuration = new Configuration ( ) ; private final Map < Resource , ClassMap > classMaps = new HashMap < Resource , ClassMap > ( ) ; private final Map < Resource , TranslationTable > translationTables = new HashMap < Resource , TranslationTable > ( ) ; private final Map < Resource , DownloadMap > downloadMaps = new HashMap < Resource , DownloadMap > ( ) ; private final PrefixMapping prefixes = new PrefixMappingImpl ( ) ; private Collection < TripleRelation > compiledPropertyBridges ; public Mapping ( ) { this ( null ) ; } public Mapping ( String mappingURI ) { if ( mappingURI == null ) { this . mappingResource = this . model . createResource ( ) ; } else { this . mappingResource = this . model . createResource ( mappingURI ) ; } } public Resource resource ( ) { return this . mappingResource ; } public Model getVocabularyModel ( ) { return vocabularyModel ; } public void validate ( ) throws D2RQException { if ( this . databases . isEmpty ( ) ) { throw new D2RQException ( ""<STR_LIT>"" , D2RQException . MAPPING_NO_DATABASE ) ; } for ( Database db : databases . values ( ) ) { db'}]",".validate(); } } public void addDatabase ( Database database ) { this. databases. put ( database. resource ( ), database ) ; } public void addClassMap ( Resource subject, ClassMap classMap ) { this. classMaps. put ( subject, classMap ) ; } public void addTranslationTable ( Resource subject, TranslationTable translationTable ) { this. translationTables. put ( subject, translationTable ) ; } public void addDownloadMap ( Resource subject, DownloadMap downloadMap ) { this. downloadMaps. put ( subject, downloadMap ) ; } public void setPrefixes ( PrefixMapping prefixes ) { this. prefixes = prefixes ; } public PrefixMapping getPrefixes ( ) { return this. prefixes ; } public void setConfiguration ( Configuration configuration ) { this. configuration = configuration ; } public Configuration getConfiguration ( ) { return this. configuration ; } public void setCompiledPropertyBridges ( Collection < TripleRelation > compiledPropertyBridges ) { this. compiledPropertyBridges = compiledPropertyBridges ; } public Collection < TripleRelation > getCompiledPropertyBridges ( ) { return this. compiledPropertyBridges ; } }",0.00035726254684467296
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . Viewer ; public abstract class RubySearchContentProvider implements IStructuredContentProvider { protected final Object [ ] EMPTY_ARR = new Object [ <NUM_LIT:0> ] ; protected RubySearchResult fResult ; private RubySearchResultPage fPage ; RubySearchContentProvider ( RubySearchResultPage page ) { fPage = page ; } public void inputChanged ( Viewer viewer , Object'}]","[] input ) { fResult = ( RubySearchResult ) input ; } public void dispose ( ) { } public Object [ ] getElements ( Object element ) { return EMPTY_ARR ; } public void updateElement ( Object element, Object elementData ) { } }",8.362225997157528e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import com . asakusafw . utils . java . internal . model . util . LiteralAnalyzer ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class SimpleNameImpl extends ModelRoot implements SimpleName { private static final Set < String > RESERVED ; static { Set < String > set = new HashSet < String > ( ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:default>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:boolean>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:double>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:int>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:class>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:long>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT:float>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; set . add ( ""<STR_LIT>"" ) ; RESERVED = Collections . unmodifiableSet ( set ) ; } private String token ; @ Override public String getToken ( ) { return this . token ; } public void setToken ( String token ) { Util . notNull ( token , ""<STR_LIT>"" ) ; if ( token . isEmpty ( ) ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( Character . isJavaIdentifierStart ( token . charAt ( <NUM_LIT:0> ) ) == false ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , LiteralAnalyzer . stringLiteralOf ( token ) ) ) ; } for ( int i = <NUM_LIT:1> ,'}]","n = token. length ( ) ; i < n ; i ++ ) { if ( Character. isJavaIdentifierPart ( token. charAt ( i ) ) == false ) { throw new IllegalArgumentException ( MessageFormat. format ( ""<STR_LIT>"", LiteralAnalyzer. stringLiteralOf ( token ) ) ) ; } } this. token = token ; } @ Override public < T > T accept ( Visitor < T > visitor ) { return visitor. visitSimpleName ( this ) ; } }",0.00016298259649604323
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . server ; import javax . management . MBeanException ; import javax . management . ReflectionException ; import junit . framework . TestCase ; public class ServerAllOperationsHandlerTest extends TestCase { interface Fruit { String getColour ( ) ; } class MyFruit implements Fruit {'}]","private String colour; public String getColour() { return colour; } } public void testGetColour() throws MBeanException, ReflectionException { MyFruit fruit = new MyFruit(); fruit.colour = ""red""; assertEquals(""red"", fruit.getColour()); } }",8.719676803467241e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . search ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . index . SVDBDeclCacheItem ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import org . eclipse . core'}]",.resources.ResourceBundle;import org.eclipse.core.runtime.Platform;import org.eclipse.core.runtime.preferences.IConfigurationElement;import org.eclipse.core.runtime.preferences.IConfigurationFactory;import org.eclipse.core.runtime.preferences.IScopeContext;import org.eclipse.core.runtime.preferences.IPreferenceStore;import org.eclipse.core.runtime.preferences.IConfiguration;import org.osgi.framework.BundleContext;public class SVDBSearchEngine { private static final LogHandle log = LogFactory.,0.0001249190606364983
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . batch ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . Collection ; import org . junit . Test ; import com . asakusafw . compiler . batch . batch . Abstract ; import com . asakusafw . compiler . batch . batch . DescribeFailBatch ; import com . asakusafw . compiler . batch . batch . InstantiateFailBatch ; import com . asakusafw . compiler . batch . batch . JobFlow1 ; import com . asakusafw . compiler . batch . batch . NoEmptyParameterConstructor ; import com . asakusafw . compiler . batch . batch . NotAnnotated ; import com . asakusafw . compiler . batch . batch . SimpleBatch ; import com . asakusafw . compiler . batch . batch . TopLevel ; import com . asakusafw . vocabulary . batch . JobFlowWorkDescription ; import com . asakusafw . vocabulary . batch . Work ; public class BatchDriverTest { @'}]","Test public void testSimpleBatch() { SimpleBatch batch = new SimpleBatch(); JobFlowWorkDescription description = new JobFlowWorkDescription(batch); Assert.assertThat(description.getJobFlow(), is(instanceOf(JobFlow1.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(NotAnnotated.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(TopLevel.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(NoEmptyParameterConstructor.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(SimpleBatch.class))); } @Test public void testDescribeFailBatch() { DescribeFailBatch batch = new DescribeFailBatch(); JobFlowWorkDescription description = new JobFlowWorkDescription(batch); Assert.assertThat(description.getJobFlow(), is(instanceOf(JobFlow1.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(NotAnnotated.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(TopLevel.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(NoEmptyParameterConstructor.class))); Assert.assertThat(description.getJobFlow(), is(instanceOf(DescribeFailBatch.class))); } @Test(expected=Exception.class) public void testInstantiateFailBatch() { InstantiateFailBatch batch = new InstantiateFailBatch(); JobFlowWorkDescription description = new JobFlowWork",0.00034755032129499264
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . operator . model . MockFoo ; import com . asakusafw . compiler . testing . TemporaryOutputDescription ; import com . asakusafw . vocabulary . external . ExporterDescription ; public class MockFooExporterDescription extends TemporaryOutputDescription { @ Override public Class < ?'}]","> getOutputClass ( ) { return MockFoo. class ; } @ Override public ExporterDescription getExporter ( ) { return new ExporterDescription ( ""MockFoo"", ""MockFoo"" ) ; } }",7.373851302210593e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . util ; import java . text . MessageFormat ; public class Messages { public static String format ( String message , Object object ) { return MessageFormat . format ( message , new Object [ ] { object } ) ; }'}]","public static String format(String message, Object... objects) { return MessageFormat.format(message, objects); }",4.2330905922973915e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . pullup ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . BlockNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . editprovider . InsertEditProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; import org . rubypeople . rdt . refactoring . offsetprovider . ConstructorOffsetProvider ; import org . rubypeople . rdt . refactoring . offsetprovider . IOffsetProvider ; import org . rubypeople . rdt . refactoring . offsetprovider . MethodOffsetProvider ; public class UpPulledMethods extends InsertEditProvider { private Collection < MethodNodeWrapper > methodNodes ; private boolean constructors ; private ClassNodeWrapper classNode ; public UpPulledMethods ( Collection < MethodNodeWrapper > methodNodes , ClassNodeWrapper classNode , boolean constructors ) { super ( true ) ; this . methodNodes = methodNodes ; this . constructors = constructors ; this . classNode = classNode ; } @ Override protected BlockNode getInsertNode ( int offset , String document ) { boolean needsNewLineAtEndOfBlock = lastEditInGroup && ! isNextLineEmpty ( offset , document ) ; return NodeFactory . createBlockNode ( needsNewLineAtEndOfBlock , getMethodNodes ( methodNodes ) ) ; } private Node [ ] getMethodNodes ( Collection < MethodNodeWrapper > nodeCollection ) { Collection < Node >'}]",nodeList = new ArrayList <> ( ) ; for ( MethodNodeWrapper method : nodeCollection ) { if ( method. isConstructor ( ) == constructors ) { nodeList. add ( method. getNode ( ) ) ; } } return nodeList. toArray ( new Node [ nodeList. size ( ) ] ) ; } },0.00010408507629893155
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . views . diagram ; import org . eclipse . draw2d . AbstractRouter ; public interface IDiagLabelProviderConfig { boolean getIncludePrivateClassFields ( ) ; boolean getIncludePublicClassFields ( ) ;'}]",boolean getIncludeMethods ( );,2.373624754006805e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import java . io . IOException ; import java . net . URI ; public interface DataModelSourceProvider { < T > DataModelSource open ( DataModelDefinition'}]",< T > DataModelSource open ( DataModelDefinition < T > definition ) throws IOException ; },4.1572917525672465e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . jdbc ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import com . asakusafw . windgate . core . vocabulary . DataModelJdbcSupport ; public class JdbcScript < T > { private final String name ; private final DataModelJdbcSupport < ? super T > support ; private final String tableName ; private final List < String > columnNames ; private final String condition ; public JdbcScript ( String name , DataModelJdbcSupport < ? super T > support , String tableName , List < String > columnNames , String condition ) { if ( name == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( support == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( tableName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( columnNames == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( condition != null && isEmpty ( condition ) ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . name'}]",= name; this.support = support; this.tableName = tableName; this.columnNames = Collections.unmodifiableList(columnNames); this.condition = condition; } private static boolean isEmpty(String str) { return str == null || str.trim().isEmpty(); } },8.555199611738577e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . scanutils ; import net . sf . sveditor . core . scanner . SVCharacter ; public abstract class AbstractTextScanner implements ITextScanner { protected StringBuilder fTmpBuffer ; protected StringBuilder fCaptureBuffer ; protected boolean fCaptureEnabled ; protected int fLineno ; protected int fLinepos ; protected int fLastCh ; protected boolean fScanFwd ; public AbstractTextScanner ( ) { fTmpBuffer = new StringBuilder ( ) ; fCaptureBuffer = new StringBuilder ( ) ; fCaptureEnabled = false ; fScanFwd = true ; fLastCh = - <NUM_LIT:1> ; fLineno = <NUM_LIT:1> ; fLinepos = <NUM_LIT:0> ; } public void init ( ) { fCaptureEnabled = false ; } public boolean getScanFwd ( ) { return fScanFwd ; } public void setScanFwd ( boolean scanFwd ) { fScanFwd = scanFwd ; } public int skipWhite ( int ch ) { while ( Character . isWhitespace ( ch ) || ch == \'<STR_LIT:\\\\>\' ) { int tmp = get_ch ( ) ; if ( ch == \'<STR_LIT:\\\\>\' && ( tmp != \'<STR_LIT>\' && tmp != \'<STR_LIT:\\n>\' ) ) { unget_ch ( tmp ) ; return ch ; } ch = tmp ; } return ch ; } public String readIdentifier ( int ci ) { fTmpBuffer . setLength ( <NUM_LIT:0> ) ; if ( fScanFwd ) { if ( ! SVCharacter . isSVIdentifierStart ( ci ) ) { unget_ch ( ci ) ; return null ; } boolean in_ref = false ; int last_ci = ci ; fTmpBuffer . append ( ( char ) ci ) ; while ( ( ci = get_ch ( ) ) != - <NUM_LIT:1> && ( SVCharacter . isSVIdentifierPart ( ci ) || ci == \'<CHAR_LIT::>\' || ( last_ci == \'<CHAR_LIT>\' && ci == \'<CHAR_LIT>\' ) || ( in_ref && ci == \'<CHAR_LIT:}>\' ) ) ) { if ( ci == \'<CHAR_LIT::>\' ) { int c2 = get_ch ( ) ; if ( c2 == \'<CHAR_LIT::>\' ) { fTmpBuffer . append ( ""<STR_LIT>"" ) ; } else { unget_ch ( c2 ) ; break ; } } else { fTmpBuffer . append ( ( char ) ci ) ; } in_ref |= ( ci == \'<CHAR_LIT>\' && last_ci == \'<CHAR_LIT>\' ) ; in_ref &= ! ( in_ref && ci == \'<CHAR_LIT:}>\' ) ; last_ci = ci ; } unget_ch ( ci ) ; while ( fTmpBuffer . length ( ) > <NUM_LIT:0> && fTmpBuffer . charAt ( fTmpBuffer . length ( ) - <NUM_LIT:1> ) == \'<CHAR_LIT::>\' ) { unget_ch ( \'<CHAR_LIT::>\' ) ; fTmpBuffer . setLength ( fTmpBuffer . length ( ) - <NUM_LIT:1> ) ; } } else { if ( ! SVCharacter . isSVIdentifierPart ( ci ) ) { unget_ch ( ci ) ; return null ; } fTmpBuffer . append ( ( char ) ci ) ; while ( ( ci = get_ch ( ) ) != - <NUM_LIT:1> && ( SVCharacter . isSVIdentifierPart ( ci ) || ci == \'<CHAR_LIT::>\' ) ) { fTmpBuffer . append ( ( char ) ci ) ; } unget_ch ( ci ) ; } return ( fTmpBuffer . length ( ) > <NUM_LIT:0> ) ? fTmpBuffer . toString ( ) : null ; } public String readPreProcIdentifier ( int ci ) { fTmpBuffer . setLength ( <NUM_LIT:0> ) ; if ( ! SVCharacter . isSVIdentifierStart ( ci ) ) { unget_ch ( ci ) ; return null ; } fTmpBuffer . append ( ( char ) ci ) ; while ( ( ci = get_ch ( ) ) != - <NUM_LIT:1> && SVCharacter . isSVIdentifierPart ( ci ) ) { fTmpBuffer . append ( ( char ) ci ) ; } unget_ch ( ci ) ; return ( fTmpBuffer . length ( ) > <NUM_LIT:0> ) ? fTmpBuffer . toString ( ) : null ; } public String readString ( int ch ) { fTmpBuffer . setLength ( <NUM_LIT:0> ) ; int last_ch = - <NUM_LIT:1> ; if ( ch != \'<CHAR_LIT:"">\' ) { return null ; } ch = get_ch ( ) ; while ( ( ( ch != \'<CHAR_LIT:"">\' && ch != \'<STR_LIT:\\n>\' ) || last_ch == \'<STR_LIT:\\\\>\' ) && ch != - <NUM_LIT:1> ) { if ( last_ch == \'<STR_LIT:\\\\>\' && ch == \'<CHAR_LIT:"">\' ) { if ( fTmpBuffer . charAt ( fTmpBuffer . length ( ) - <NUM_LIT:1> ) == \'<STR_LIT:\\\\>\' ) { fTmpBuffer . setCharAt ( fTmpBuffer . length ( ) - <NUM_LIT:1> , \'<CHAR_LIT:"">\' ) ; } } else if ( last_ch == \'<STR_LIT:\\\\>\' && ch == \'<STR_LIT:\\n>\' ) { if'}]",(fTmpBuffer.length() > <NUM_LIT:0> && fTmpBuffer.charAt(fTmpBuffer.length() - <NUM_LIT:1>) == '<CHAR_LIT:\\>' ) { fTmpBuffer.setLength(fTmpBuffer.length() - <NUM_LIT:1>); } } fTmpBuffer.append((char) ch); last_ch = ch; ch = get_ch(); } unget_ch(ch); return (fTmpBuffer.length() > <NUM_LIT:0>? fTmpBuffer.toString() : null); } public int get_ch() { return fScanFwd? read() : read_last(); } public void unget_ch(int ch) { if (fScanFwd) { if (ch!= -<NUM_LIT:1>) { push_back(ch); } } else { if (ch!= -<NUM_LIT:1>) { push_back_last(ch); } } } public void push_back(int ch) { fLinepos--; fLastCh = ch; } public void push_back_last(int ch) { fLastCh = ch; } public int read_last() { if (fLastCh!= -<NUM_LIT:1>) { return fLastCh; } return fLineno ==,0.00039898918082343434
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . scheduling ; import java . util . concurrent . CancellationException ; import java . util . concurrent . Exchanger ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import junit . framework . TestCase ; public class JavaExecutorAssumptionsTest extends TestCase { class SimpleRunnable implements Runnable { boolean ran ; public void run ( ) { ran = true ; } } public void testCancelBeforeRun ( ) throws InterruptedException { ScheduledExecutorService executor = new ScheduledThreadPoolExecutor ( <NUM_LIT:1> ) ; SimpleRunnable runnable = new SimpleRunnable ( ) ; ScheduledFuture < ? > future = executor . schedule ( runnable , <NUM_LIT:1000> , TimeUnit . HOURS ) ; Thread . sleep ( <NUM_LIT:1> ) ; assertTrue ( future . getDelay ( TimeUnit . MILLISECONDS ) < ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT:1000> ) ) ; assertEquals ( false , future . isCancelled ( ) ) ; assertEquals ( false , future . isDone ( ) ) ; future . cancel ( true ) ; assertEquals ( true , future . isCancelled ( ) ) ; assertEquals ( true , future . isDone ( ) ) ; assertEquals ( false , runnable . ran ) ; executor . shutdown ( ) ; } public void testRunBeforeCancel ( ) throws InterruptedException , ExecutionException { ScheduledExecutorService executor = new ScheduledThreadPoolExecutor ( <NUM_LIT:1> ) ; SimpleRunnable runnable = new SimpleRunnable ( ) ; Future < ? > future = executor . schedule ( runnable , <NUM_LIT:0> , TimeUnit . HOURS ) ; future . get ( ) ; assertEquals ( true , runnable . ran ) ; assertEquals ( false , future . isCancelled ( ) ) ; assertEquals ( true , future . isDone ( ) ) ; future . cancel ( true ) ; assertEquals ( false , future . isCancelled ( ) ) ; executor . shutdown ( ) ; } class RunUntilInerrupted implements Runnable { Exchanger < Void > exchange = new Exchanger < Void > ( ) ; boolean ran ; boolean interrupted ; public synchronized void run ( ) { ran = true ; try { exchange . exchange ( null ) ; wait ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } try {'}]",Thread.currentThread().interrupt(); } finally { exchange.exchange(null); } } },4.2492452102047537e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core . process ; import java . io . IOException ; import com . asakusafw . windgate . core . BaseProvider ; import com . asakusafw . windgate . core . ProcessScript ; import'}]",java. util. Properties;,8.789538756337431e-08
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . util ; import java . util . Comparator ; import org . eclipse . core . runtime . Assert ; public class TwoArrayQuickSorter { private Comparator fComparator ; public static final class StringComparator implements Comparator < String > { private boolean fIgnoreCase ; StringComparator ( boolean ignoreCase ) { fIgnoreCase = ignoreCase ; } public int compare ( String left , String right ) { return fIgnoreCase ? left . compareToIgnoreCase ( right ) : left . compareTo ( right ) ; } } public TwoArrayQuickSorter ( boolean ignoreCase ) { fComparator = new StringComparator ( ignoreCase ) ; } public TwoArrayQuickSorter ( Comparator < ? extends Object > comparator ) { fComparator = comparator ; } public void sort ( Object [ ] keys , Object [ ] values ) { if ( ( keys == null ) || ( values == null ) ) { Assert . isTrue ( false , ""<STR_LIT>"" ) ; return ; } if ( keys . length <= <NUM_LIT:1> ) return ; internalSort ( keys , values , <NUM_LIT:0> , keys . length - <NUM_LIT:1> ) ; } private void internalSort ( Object [ ] keys , Object [ ] values , int left , int right ) { int original_left = left ; int original_right = right ; Object mid = keys [ ( left + right ) / <NUM_LIT:2>'}]","] ; int new_pos = partition ( keys, values, left, right, fComparator ) ; if ( left!= new_pos ) internalSort ( keys, values, left, new_pos - <NUM_LIT:1> ) ; if ( new_pos!= right ) internalSort ( keys, values, new_pos + <NUM_LIT:1>, right ) ; } private int partition ( Object [ ] keys, Object [ ] values, int left, int right, Comparator <? extends Object > comparator ) { int i = left ; int j = right ; Object pivot = keys [ ( left + right ) / <NUM_LIT:2> ] ; while ( i <= j ) { while ( comparator. compare ( keys [ i ], pivot ) < 0 ) i ++ ; while ( comparator. compare ( pivot, keys [ j ] ) < 0 ) j -- ; if ( i <= j ) { Object temp = keys [ i ] ; keys [ i ] = keys [ j ] ; keys [ j ] = temp ; Object temp2 = values [ i ] ; values [ i ] = values [ j ] ; values [ j ] = temp2 ; i ++ ; j -- ; } } return i ; } }",1.3137033301389873e-06
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . model ; import java . util . concurrent . Executor ;'}]",import java.util.concurrent.Executors;,2.4305237086154117e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . describe ; import java . util . Map ; import java . util . TreeMap ; import org . oddjob . arooa . ArooaAnnotations ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . deploy . ArooaAnnotation ; import org . oddjob . arooa . reflect . ArooaClass ; import org . oddjob . arooa . reflect . BeanOverview ; import org . oddjob . arooa . reflect . PropertyAccessor ; public class AccessorDescriber implements Describer { private final ArooaSession session ; public AccessorDescriber ( ArooaSession session ) { if ( session == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } this . session = session ; } @ Override public Map < String , String > describe ( Object bean ) { PropertyAccessor accessor = session . getTools ( ) . getPropertyAccessor ( ) ; ArooaClass'}]","class = accessor.getClass(bean); BeanOverview overview = ArooaAnnotations.getOverview(bean); Map<String, String> map = new TreeMap<>(); map.put(""class"", class.getName()); map.put(""overview"", overview.toString()); // Add the overview to the map return map; } }",8.954268987219244e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . lang . jruby12 ; import com . sun . tools . hat . internal . lang . Model ; import com . sun . tools . hat . internal . lang . ModelFactory ; import com . sun . tools . hat . internal . lang . ModelFactoryFactory ; import com . sun . tools . hat . internal . lang . Models ; import com . sun . tools . hat . internal . lang . jruby . JRubyArray ; import com . sun . tools . hat . internal . lang . jruby . JRubyString ; import com . sun . tools . hat . internal . lang . openjdk6 . JavaHash ; import com . sun . tools . hat . internal . model . JavaClass ; import com . sun . tools . hat . internal . model . JavaObject ; import com . sun . tools . hat . internal . model . JavaThing ; import com . sun . tools . hat . internal . model . Snapshot ; public class JRuby12 implements ModelFactory { public enum Factory implements ModelFactoryFactory { INSTANCE ; @ Override public boolean isSupported ( Snapshot snapshot ) { JavaClass constants = snapshot . findClass ( ""<STR_LIT>"" ) ; return Models . checkStaticString ( constants , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } @ Override public ModelFactory newFactory ( Snapshot snapshot ) { return isSupported ( snapshot ) ? new JRuby12 ( snapshot ) : null ; } } private final JavaClass constantsClass ; private final JavaClass stringClass ; private'}]","final JavaClass arrayClass;private final JavaHash constants;public JRuby12(Snapshot snapshot) {constantsClass = snapshot.findClass(""<STR_LIT>"");stringClass = snapshot.findClass(""java/lang/String"");arrayClass = snapshot.findClass(""[Ljava/lang/String;"");constants = new JavaHash(snapshot, ""Constants"", snapshot.findClass(""<STR_LIT>""));}",0.00011853410429695647
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . source ; import java . util . List ; import com . pogofish . jadt . util'}]",.JadtNode;public class JadtParser { public static List<JadtNode> parse(String source) { // implementation } public static class JadtNode { // implementation } },6.0682629578560644e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io ; import static com . asakusafw . runtime . io . TsvConstants . * ; import java . io . IOException ; import java . io . Writer ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . charset . Charset ; import java . nio . charset . CharsetDecoder ; import java . nio . charset . CoderResult ; import java . nio . charset . CodingErrorAction ; import java . text . MessageFormat ; import org . apache . hadoop . io . Text ; import com . asakusafw . runtime . value . BooleanOption ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DateUtil ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . DoubleOption ; import com . asakusafw . runtime . value . FloatOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . ShortOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . runtime . value . ValueOption ; public class TsvEmitter implements RecordEmitter { private static final Charset TEXT_ENCODE = Charset . forName ( ""<STR_LIT:UTF-8>"" ) ; private static final int BUFFER_SIZE = <NUM_LIT> ; private final Writer writer ; private final CharsetDecoder decoder ; private final StringBuilder lineBuffer ; private final char [ ] writeBuffer ; private boolean headOfLine ; private final CharBuffer decodeBuffer ; public TsvEmitter ( Writer writer ) throws IOException { if ( writer == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . writer = writer ; this . decoder = TEXT_ENCODE . newDecoder ( ) . onMalformedInput ( CodingErrorAction . REPORT ) . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; this . lineBuffer = new StringBuilder ( ) ; this . writeBuffer = new char [ BUFFER_SIZE ] ; this . headOfLine = true ; this . decodeBuffer = CharBuffer . wrap ( writeBuffer ) ; } @ Override public void endRecord ( ) throws IOException { flushLineBuffer ( ) ; writer . write ( RECORD_SEPARATOR ) ; headOfLine = true ; } private void flushLineBuffer ( ) throws IOException { int rest = lineBuffer . length ( ) ; int cursor = <NUM_LIT:0> ; while ( rest > <NUM_LIT:0> ) { int chunkSize = Math . min ( rest , writeBuffer . length ) ; lineBuffer . getChars ( cursor , cursor + chunkSize , writeBuffer , <NUM_LIT:0> ) ; writer . write ( writeBuffer , <NUM_LIT:0> , chunkSize ) ; rest -= chunkSize ; cursor += chunkSize ; } lineBuffer . setLength ( <NUM_LIT:0> ) ; } private void startCell ( ) { if ( headOfLine == false ) { lineBuffer . append ( CELL_SEPARATOR ) ; } headOfLine = false ; } @ Override public void emit ( BooleanOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ? BOOLEAN_TRUE : BOOLEAN_FALSE ) ; } @ Override public void emit ( ByteOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( ShortOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( IntOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( LongOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( FloatOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( DoubleOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( DecimalOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } lineBuffer . append ( option . get ( ) ) ; } @ Override public void emit ( StringOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } Text text = option . get ( ) ; if ( text . getLength ( ) == <NUM_LIT:0> ) { return ; } byte [ ] bytes = text . getBytes ( ) ; ByteBuffer source = ByteBuffer . wrap ( bytes , <NUM_LIT:0> , text . getLength ( ) ) ; decoder . reset ( ) ; decodeBuffer . clear ( ) ; while ( true ) { CoderResult result = decoder . decode ( source , decodeBuffer , true ) ; if ( result . isError ( ) ) { throw new RecordFormatException ( MessageFormat . format ( ""<STR_LIT>"" , result ) ) ; } if ( result . isUnderflow ( ) ) { consumeDecoded ( ) ; break ; } if ( result . isOverflow ( ) ) { consumeDecoded ( ) ; } } while ( true ) { CoderResult result = decoder . flush ( decodeBuffer ) ; if ( result . isError ( ) ) { throw new RecordFormatException ( MessageFormat . format ( ""<STR_LIT>"" , result ) ) ; } if ( result . isUnderflow ( ) ) { consumeDecoded ( ) ; break ; } if ( result . isOverflow ( ) ) { consumeDecoded ( ) ; } } } private void consumeDecoded ( ) { decodeBuffer . flip ( ) ; if ( decodeBuffer . hasRemaining ( ) ) { char [ ] array = decodeBuffer . array ( ) ; for ( int i = decodeBuffer . position ( ) , n = decodeBuffer . limit ( ) ; i < n ; i ++ ) { char c = array [ i ] ; if ( c == \'<STR_LIT:\\t>\' ) { lineBuffer . append ( ESCAPE_CHAR ) ; lineBuffer . append ( ESCAPE_HT ) ; } else if ( c == \'<STR_LIT:\\n>\' ) { lineBuffer . append ( ESCAPE_CHAR ) ; lineBuffer . append ('}]","ESCAPE_LF); } else if (c == '<STR_LIT:\r>' ) { lineBuffer. append ( ESCAPE_CHAR ) ; lineBuffer. append ( ESCAPE_CR ) ; } else { lineBuffer. append ( c ) ; } decodeBuffer. position ( decodeBuffer. position ( ) + 1 ) ; } } private boolean emitNull ( ValueOption option ) { return option == null || option. get ( ) == null ; } @ Override public void emit ( DateOption option ) throws IOException { startCell ( ) ; if ( emitNull ( option ) ) { return ; } Text text = option. get ( ) ; if ( text. getLength ( ) == <NUM_LIT:0> ) { return ; } byte [ ] bytes = text. getBytes ( ) ; ByteBuffer source = ByteBuffer. wrap ( bytes, <NUM_LIT:0>, text. getLength ( ) ) ; decoder. reset ( ) ; decodeBuffer. clear ( ) ; while ( true ) { CoderResult result = decoder. decode ( source, decodeBuffer, true ) ; if ( result. isError ( ) ) { throw new RecordFormatException ( MessageFormat. format ( ""<STR_LIT>"", result ) ) ; }",0.00042125586037473987
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renamemodule . conditionchecker ; import'}]",java.lang.reflect.Method;,2.300662112078364e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . d2rq_sdb ; import junit . framework . Test ; import'}]",org.junit.runner.JUnitCore;,2.4054866140212758e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver ; import com . asakusafw . compiler . flow . Location ; import com . asakusafw . runtime . stage . StageConstants ; final class FlowPartDriverUtils { private FlowPartDriverUtils ( ) { } public static Location createInputLocation ( TestDriverContext driverContext , String name ) { Location location = Location . fromPath ( driverContext . getClusterWorkDir ( ) , \'<CHAR_LIT:/>\' ) . append ( StageConstants . EXPR_EXECUTION_ID ) . append ( ""<STR_LIT>"" ) . append ( normalize ( name ) ) ; return location ; } public static Location createOutputLocation ( TestDriverContext driverContext , String name ) { Location location = Location . fromPath ( driverContext . getClusterWorkDir ( ) , \'<CHAR_LIT:/>\' ) . append ( StageConstants . EXPR_EXECUTION_ID ) . append ( ""<STR_LIT>"" ) . append ( normalize ( name ) ) . asPrefix ( ) ; return location ; } public static Location createWorkingLocation ( TestDriverContext driverContext ) { Location location = Location . fromPath ( driverContext . getClusterWorkDir ( ) , \'<CHAR_LIT:/>\' ) . append ( StageConstants . EXPR_EXECUTION_ID ) . append ( ""<STR_LIT>"" ) ; return location ; } private static String normalize ( String name ) { StringBuilder buf = new StringBuilder ( ) ;'}]",for ( char c : name. toCharArray ( ) ) { if ( Character. isLetterOrDigit ( c ) ) { buf. append ( c ) ; } else { buf. append ( '_' ) ; } } return buf. toString ( ) ; },8.638800138767975e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . dnd ; import org . eclipse . swt . dnd . DND ; import org . eclipse . swt . dnd . DragSourceAdapter ; import org . eclipse . swt . dnd . DragSourceEvent ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . util . TransferDragSourceListener ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . ui . views . navigator . LocalSelectionTransfer ;'}]",public class DragSourceListener extends DragSourceAdapter { @Override public void dragStart ( DragSourceEvent event ) { Assert. isNotNull ( LocalSelectionTransfer. getSelection ( ) ) ; } @Override public void dragFinished ( DragSourceEvent event ) { LocalSelectionTransfer. clearSelection ( ) ; } },9.682241625078958e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index ; import java . lang . ref . Reference ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . SVFileUtils ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCache ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCacheFactory ; import net . sf . sveditor . core . db . index . cache . InMemoryIndexCache ; import net . sf . sveditor . core . db . index . plugin_lib . SVDBPluginLibIndexFactory ; import net . sf . sveditor . core . log . ILogLevel ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IExtensionRegistry ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . SubProgressMonitor ; public class SVDBIndexRegistry implements ILogLevel { public static final String GLOBAL_PROJECT = ""<STR_LIT>"" ; private SVDBIndexCollectionMgr fIndexCollectionMgr ; private SVDBIndexCollection fGlobalIndexMgr ; private List < Reference < ISVDBIndex > > fIndexList ; private ISVDBIndexCacheFactory fCacheFactory ; private boolean fAutoRebuildEn ; private LogHandle fLog ; public SVDBIndexRegistry ( ) { this ( false ) ; } public SVDBIndexRegistry ( boolean standalone_test_mode ) { fIndexList = new ArrayList < Reference < ISVDBIndex > > ( ) ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; fAutoRebuildEn = true ; fIndexCollectionMgr = new SVDBIndexCollectionMgr ( ) ; } public void setEnableAutoRebuild ( boolean en ) { fAutoRebuildEn = en ; clearStaleIndexes ( ) ; for ( Reference < ISVDBIndex > i : fIndexList ) { if ( i . get ( ) != null ) { i . get ( ) . setEnableAutoRebuild ( fAutoRebuildEn ) ; } } } public SVDBIndexCollectionMgr getIndexCollectionMgr ( ) { return fIndexCollectionMgr ; } public void init ( ISVDBIndexCacheFactory cache_factory ) { fCacheFactory = cache_factory ; fIndexList . clear ( ) ; fGlobalIndexMgr = getGlobalIndexMgr ( ) ; } public void test_init ( ISVDBIndexCacheFactory cache_factory ) { fCacheFactory = cache_factory ; fIndexList . clear ( ) ; } public List < ISVDBIndex > getAllProjectLists ( ) { List < ISVDBIndex > ret = new ArrayList < ISVDBIndex > ( ) ; synchronized ( fIndexList ) { for ( Reference < ISVDBIndex > i : fIndexList ) { if ( i . get ( ) != null ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public List < ISVDBIndex > getProjectIndexList ( String project ) { List < ISVDBIndex > ret = new ArrayList < ISVDBIndex > ( ) ; clearStaleIndexes ( ) ; synchronized ( fIndexList ) { for ( Reference < ISVDBIndex > i : fIndexList ) { if ( i . get ( ) != null && i . get ( ) . getProject ( ) . equals ( project ) ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public List < ISVDBIndex > getIndexList ( ) { List < ISVDBIndex > ret = new ArrayList < ISVDBIndex > ( ) ; clearStaleIndexes ( ) ; synchronized ( fIndexList ) { for ( Reference < ISVDBIndex > i : fIndexList ) { if ( i . get ( ) != null ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public void disposeIndex ( ISVDBIndex index ) { fLog . debug ( LEVEL_MID , ""<STR_LIT>"" + index . getBaseLocation ( ) + ""<STR_LIT>"" + index . getConfig ( ) ) ; synchronized ( fIndexList ) { fIndexList . remove ( index ) ; } index . dispose ( ) ; } public SVDBIndexCollection getGlobalIndexMgr ( ) { if ( fGlobalIndexMgr == null ) { fGlobalIndexMgr = new SVDBIndexCollection ( fIndexCollectionMgr , GLOBAL_PROJECT ) ; ISVDBIndex index = findCreateIndex ( new NullProgressMonitor ( ) , SVDBIndexRegistry . GLOBAL_PROJECT , SVCorePlugin . SV_BUILTIN_LIBRARY , SVDBPluginLibIndexFactory . TYPE , null ) ; if ( index != null ) { fGlobalIndexMgr . addPluginLibrary ( index ) ; } } return fGlobalIndexMgr ; } public ISVDBIndex findCreateIndex ( IProgressMonitor monitor , String project , String base_location , String type , SVDBIndexConfig config ) { ISVDBIndex ret = null ; base_location = SVFileUtils . normalize ( base_location ) ; fLog . debug ( ""<STR_LIT>"" + base_location + ""<STR_LIT>"" + type ) ; synchronized ( fIndexList ) { for ( Reference < ISVDBIndex > i : fIndexList ) { ISVDBIndex index = i . get ( ) ; if ( index != null && index . getProject ( ) . equals ( project ) && index . getBaseLocation ( ) . equals ( base_location ) && index . getTypeID ( ) . equals ( type ) ) { ret = index ; break ; } } } if ( ret != null ) { if ( ! SVDBIndexConfig . equals ( config , ret . getConfig ( ) ) ) { fLog . debug ( LEVEL_MID , ""<STR_LIT>"" + ret . getBaseLocation ( ) + ""<STR_LIT>"" ) ; disposeIndex ( ret ) ; ret = null ; } } if ( ret == null ) { fLog . debug ( ""<STR_LIT>"" ) ; ISVDBIndexFactory factory = findFactory ( type ) ; ISVDBIndexCache cache = null ; if ( type . equals ( SVDBShadowIndexFactory . TYPE ) ) { cache = new InMemoryIndexCache ( ) ; } else { cache = fCacheFactory . createIndexCache ( project , base_location ) ; } ret = factory . createSVDBIndex ( project , base_location , cache , config ) ; ret . setEnableAutoRebuild ( fAutoRebuildEn ) ; SubProgressMonitor m = new SubProgressMonitor ( monitor , <NUM_LIT:1> ) ; ret . init ( m ) ; synchronized ( fIndexList ) { fIndexList . add ( new WeakReference < ISVDBIndex > ( ret ) ) ; } } else { fLog . debug ( ""<STR_LIT>"" ) ; } return ret ; } public ISVDBIndex findCreateIndex ( String project , String base_location , String type , ISVDBIndexFactory factory , SVDBIndexConfig config ) { return findCreateIndex ( new NullProgressMonitor ( ) , project , base_location , type , factory , config ) ; } public ISVDBIndex findCreateIndex ( IProgressMonitor monitor , String project , String base_location , String type , ISVDBIndexFactory factory , SVDBIndexConfig config ) { ISVDBIndex ret = null ; fLog . debug ( ""<STR_LIT>"" + base_location + ""<STR_LIT>"" + type ) ; synchronized ( fIndexList ) { for ( Reference < ISVDBIndex > i : fIndexList ) { ISVDBIndex index = i . get ( ) ; if ( index != null && index . getProject ( ) . equals ( project ) && index . getBaseLocation ( ) . equals ( base_location ) && index . getTypeID ( ) . equals ( type ) ) { ret = index ; break ; } } } if ( ret == null ) { fLog . debug ( ""<STR_LIT>"" ) ; ISVDBIndexCache cache = fCacheFactory . createIndexCache ( project , base_location ) ;'}]","factory. createSVDBIndex ( project, base_location, cache, config ) ; ret. setEnableAutoRebuild ( fAutoRebuildEn ) ; SubProgressMonitor m = new SubProgressMonitor ( monitor, 1 ) ; ret. init ( m ) ; synchronized ( fIndexList ) { fIndexList. add ( new WeakReference < ISVDBIndex > ( ret ) ) ; } } return ret ; } }",0.0001810763504187246
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . flow . testing . model . ExJoined2 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class ExJoined2Output implements ModelOutput < ExJoined2 > { private final RecordEmitter emitter ; public ExJoined2Output ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( ExJoined2 model ) throws IOException { emitter . emit ( model . getSid1Option ( ) ) ;'}]",emitter.emit(model.getSid2Option()); } @Override public void close() throws IOException { emitter.close(); } },4.9593699345353164e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . stage ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . compiler . flow . JobflowCompilerTestRoot ; import com . asakusafw . compiler . flow . example . MultipleUpdateStage ; import com . asakusafw . compiler . flow . example . NoShuffleStage ; import com . asakusafw . compiler . flow . example . SimpleShuffleStage ; import com . asakusafw . compiler . flow . plan . StageBlock ; import com . asakusafw . compiler . flow . plan . StageGraph ; import com . asakusafw . compiler . flow . stage . StageModel . Factor ; import com . asakusafw . compiler . flow . stage . StageModel . Fragment ; import com . asakusafw . compiler . flow . stage . StageModel . MapUnit ; import com . asakusafw . compiler . flow . stage . StageModel . ReduceUnit ; import com . asakusafw . compiler . flow . testing . operator . ExOperator ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription ; public class StageAnalyzerTest extends JobflowCompilerTestRoot { @ Test public void mapOnly ( ) { StageGraph graph = jfToStageGraph ( NoShuffleStage . class ) ; assertThat ( graph . getStages ( ) . size ( ) , is ( <NUM_LIT:1> ) ) ; StageBlock target = graph . getStages ( ) . get ( <NUM_LIT:0> ) ; StageAnalyzer analyzer = new StageAnalyzer ( environment ) ; StageModel analyzed = analyzer . analyze ( target , null ) ; assertThat ( analyzed . getMapUnits ( ) . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( analyzed . getReduceUnits ( ) . size ( ) , is ( <NUM_LIT:0> ) ) ; MapUnit map = analyzed . getMapUnits ( ) . get ( <NUM_LIT:0> ) ; assertThat ( map . getFragments'}]","(), is ( hasItem ( Fragment. FACTORY ) ) ) ; }",4.416349145952086e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . general ; import org . apache . commons . beanutils . DynaBean ; import org . oddjob . jmx . client . Destroyable ; import org . oddjob . script .'}]","Scriptable; public class OddJobDynaBean extends DynaBean implements Destroyable, Scriptable { }",4.2600494366015015e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renameclass ; import org . jruby . ast . ClassNode ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . ui . INewNameReceiver ; public class RenameClassConfig implements INewNameReceiver , IRefactoringConfig { private IDocumentProvider documentWithIncludingProvider ; private final int offset ; private ClassNode selectedNode ; private String newName ; private String modulePrefix ; private IDocumentProvider docProvider ; private String fOldName ; public RenameClassConfig ( IDocumentProvider'}]","documentWithIncludingProvider, ClassNode selectedNode, int offset, String modulePrefix ) { this. documentWithIncludingProvider = documentWithIncludingProvider ; this. selectedNode = selectedNode ; this. offset = offset ; this. modulePrefix = modulePrefix ; this. docProvider = documentWithIncludingProvider ; this. fOldName = selectedNode. getName ( ) ; }",0.0001153861333807497
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . stage ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . util . List ; import org . apache . hadoop . io . RawComparator ; import org . apache . hadoop . io . Writable ; import org . junit . Test ; import com . asakusafw . compiler . flow . JobflowCompilerTestRoot ; import com . asakusafw . compiler . flow . example . CoGroupStage ; import com . asakusafw . compiler . flow . plan . StageBlock ; import com . asakusafw . compiler . flow . plan . StageGraph ; import com . asakusafw . compiler . flow . stage . ShuffleModel . Segment ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Ex2 ; import com . asakusafw . runtime . flow . SegmentedWritable ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . vocabulary . flow . FlowDescription ; public class ShuffleSortComparatorEmitterTest extends JobflowCompilerTestRoot { @ Test public void simple ( ) throws Exception { ShuffleModel analyzed = shuffle ( CoGroupStage . class ) ; ShuffleSortComparatorEmitter emitter = new ShuffleSortComparatorEmitter ( environment ) ; Name key = emitKey ( analyzed ) ; Name name = emitter . emit ( analyzed , key ) ; ClassLoader loader = start ( ) ; @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) RawComparator < Writable > cmp = ( RawComparator < Writable > ) create ( loader , name ) ; SegmentedWritable k1 = ( SegmentedWritable ) create ( loader , key ) ; SegmentedWritable k2 = ( SegmentedWritable ) create ( loader , key ) ; List < Segment > segments = analyzed . getSegments ( ) ; assertThat ( segments . size ( ) , is ( <NUM_LIT:2> ) ) ; Segment seg1 = segments . get ( <NUM_LIT:0> ) ; Segment seg2 = segments . get ( <NUM_LIT:1> ) ; assertThat ( seg1 . getTerms ( ) . size ( ) , is ( <NUM_LIT:2> ) ) ; assertThat ( seg2 . getTerms ( ) . size ( ) , is ( <NUM_LIT:2> ) ) ; Ex1 ex1 = new Ex1 ( ) ; ex1 . setSid ( <NUM_LIT:10> ) ; ex1 . setValue ( <NUM_LIT:100> ) ;'}]","assertThat(cmp.compare(k1, k2), is(0));",4.455943210869799e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import org .'}]",rubypeople.rdt.internal.ui.preferences.PreferenceManager;,2.932117499854956e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . model ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . PARAMETER } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented'}]",public @interface VocabularyModelParameter;,2.5097575538954837e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemType ;'}]",public class SVDBStatement extends SVDBStatement { public static SVDBStatement create(SVDBItemType itemType) { return new SVDBStatement(itemType); } },5.648804033071045e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . text . ruby ; import java . util . Comparator ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . jface . text . contentassist . ICompletionProposal ; public abstract class AbstractProposalSorter implements Comparator { protected AbstractProposalSorter ( ) { } public void beginSorting ('}]","IConfigurationElement[] elements, ICompletionProposal[] proposals) { } @Override public int compare(Object o1, Object o2) { return 0; } }",5.939354608556283e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . editor ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . scanner . SVCharacter ; import net . sf . sveditor . core . scanner . SVKeywords ; import org . eclipse . jface . text . TextAttribute ; import org . eclipse . jface . text . rules . EndOfLineRule ; import org . eclipse . jface . text . rules . IRule ; import org . eclipse . jface . text . rules . IToken ; import org . eclipse . jface . text . rules . IWordDetector ; import org . eclipse . jface . text . rules . MultiLineRule ; import org . eclipse . jface . text . rules . RuleBasedScanner ; import org . eclipse . jface . text . rules . SingleLineRule ; import org . eclipse . jface . text . rules . Token ; import org . eclipse . jface . text . rules . WordRule ; public class SVCodeScanner extends RuleBasedScanner { public SVCodeScanner ( ) { updateRules ( ) ; } public void updateRules ( ) { IToken keyword = new Token ( new TextAttribute ( SVEditorColors . getColor ( SVEditorColors . KEYWORD ) , null , SVEditorColors . getStyle ( SVEditorColors . KEYWORD ) ) ) ; final IToken str = new Token ( new TextAttribute ( SVEditorColors . getColor ( SVEditorColors . STRING ) , null , SVEditorColors . getStyle ( SVEditorColors . STRING ) ) ) ; final IToken slc = new Token ( new TextAttribute ( SVEditorColors . getColor ( SVEditorColors . SINGLE_LINE_COMMENT ) , null , SVEditorColors . getStyle ( SVEditorColors . SINGLE_LINE_COMMENT ) ) ) ; final IToken mlc = new Token ( new TextAttribute ( SVEditorColors . getColor ( SVEditorColors . MULTI_LINE_COMMENT ) , null , SVEditorColors . getStyle ( SVEditorColors . MULTI_LINE_COMMENT ) ) ) ; IToken default_t = new Token ( new TextAttribute ( SVEditorColors . getColor ( SVEditorColors . DEFAULT ) , null , SVEditorColors . getStyle ( SVEditorColors . DEFAULT ) ) ) ; setDefaultReturnToken ( default_t ) ; List < IRule > rules = new ArrayList < IRule > ( ) ; rules . add ( new EndOfLineRule ( ""<STR_LIT>"" , slc ) ) ; rules . add ( new MultiLineRule ( ""<STR_LIT>"" , ""<STR_LIT>"" , mlc , ( char ) <NUM_LIT:0> , true ) ) ; rules . add ( new SingleLineRule ( ""<STR_LIT:\\"">"" , ""<STR_LIT:\\"">"" , str , \'<STR_LIT:\\\\>\' ) ) ; WordRule wordRule = new WordRule ( new IWordDetector ( ) { public boolean isWordPart ( char c ) { return SVCharacter . isSVIdentifierPart ( c ) ; } public boolean isWordStart ( char c ) { return SVCharacter . isSVIdentifierStart ( c ) ; } } , default_t ) ; for ( String kw : SVKeywords . getKeywords ( ) ) { String kw_p = kw ; if ( kw . endsWith ( ""<STR_LIT:*>"" ) ) { kw_p = kw . substring ( <NUM_LIT:0> , kw . length ( ) - <NUM_LIT:1> ) ; } wordRule . addWord ('}]",kw_p); } rules.add(wordRule); setRules(rules); } },4.928451651810374e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; final class Messages { private static final String BUNDLE_NAME = ""<STR_LIT>"" ;'}]",private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle. getBundle ( BUNDLE_NAME ) ;,3.807660786387112e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . browsing ; import'}]",javax.swing.JComponent;,2.315951127004265e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocBlock ; public class AcceptableJavadocBlockParserTest { @ Test'}]","public void testIrDocBlock() { IrDocBlock block = new IrDocBlock(""/** @author sample */""); assertNotNull(block); assertEquals(""sample"", block.getAuthor()); }",6.169752791627001e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Future ; import javax . inject . Inject ; import org . oddjob . FailedToStopException ; import org . oddjob . Stoppable ; import org . oddjob . arooa . deploy . annotations . ArooaComponent ; import org . oddjob . state . IsStoppable ; import org . oddjob . state . ParentState ; abstract public class SimultaneousStructural extends StructuralJob < Runnable > implements Stoppable { private static final long serialVersionUID = <NUM_LIT> ; private volatile transient ExecutorService executorService ; private volatile transient List < Future < ? > > jobThreads ; @ Inject public void setExecutorService ( ExecutorService executorService ) { this . executorService = executorService ; } @ ArooaComponent public void setJobs ( int index , Runnable child ) { logger ( ) . debug ( ""<STR_LIT>"" + child + ""<STR_LIT>"" + index + ""<STR_LIT:]>"" ) ; if ( child == null ) { childHelper . removeChildAt ( index ) ; } else { childHelper . insertChild ( index , child ) ; } } protected void execute ( ) throws InterruptedException { if ( executorService == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } ExecutionWatcher executionWatcher = new ExecutionWatcher ( new Runnable ( ) { public void run ( ) { SimultaneousStructural . super . startChildStateReflector ( ) ; } } ) ;'}]",executorService.execute(executionWatcher);,2.9631962910310245e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . io ; import java . io . File ; import java . util . Arrays ; import java . util . SortedSet ; import java . util . TreeSet ; public class Files { public static File [ ] expand ( File [ ] files ) { SortedSet < File > results = new TreeSet < File > ( ) ; for ( int i = <NUM_LIT:0> ; i < files . length ; ++ i ) { results . addAll ( Arrays . asList ( new WildcardSpec ( files [ i ] ) . findFiles ( ) ) ) ; } return ( File [ ] ) results . toArray ('}]",(new File[files.length + results.size()]); } },3.350144050719462e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . expr ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import junit . framework . TestCase ; import de . fuberlin . wiwiss . d2rq . algebra . AliasMap ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . algebra . ColumnRenamerMap ; import de . fuberlin . wiwiss . d2rq . algebra . RelationName ; import de . fuberlin . wiwiss . d2rq . algebra . AliasMap . Alias ; public class SQLExpressionTest extends TestCase { public void testCreate ( ) { Expression e = SQLExpression . create ( ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , e . toString ( ) ) ; assertFalse ( e . isTrue ( ) ) ; assertFalse ( e . isFalse ( ) ) ; } public void testFindsColumns ( ) { Expression e = SQLExpression . create ( ""<STR_LIT>"" ) ; Set < Attribute > expectedColumns = new HashSet < Attribute > ( Arrays . asList ( new Attribute [ ] { new Attribute ( null , ""<STR_LIT>"" , ""<STR_LIT>"" ) , new Attribute ( null , ""<STR_LIT>"" , ""<STR_LIT>"" ) , new Attribute ( null , ""<STR_LIT>"" , ""<STR_LIT>"" ) , new Attribute ( null , ""<STR_LIT>"" , ""<STR_LIT>"" ) } ) ) ; assertEquals ( expectedColumns , e . attributes ( ) ) ; } public void testToString ( ) { Expression e = SQLExpression . create ( ""<STR_LIT>"" ) ; assertEquals ( ""<STR_LIT>"" , e . toString ( ) ) ; } public void testTwoExpressionsAreEqual ( ) { assertEquals ( SQLExpression . create ( ""<STR_LIT>"" ) , SQLExpression . create ( ""<STR_LIT>"" ) ) ; assertEquals ( SQLExpression . create ( ""<STR_LIT>"" ) . hashCode ( ) , SQLExpression . create ( ""<STR_LIT>"" ) . hashCode ( ) ) ; } public void testTwoExpressionsAreNotEqual ( ) { assertFalse ( SQLExpression . create ( ""<STR_LIT>"" ) . equals ( SQLExpression . create ('}]","""<STR_LIT>"" ) ; } public void testExpressionIsSerializable ( ) { Expression e = SQLExpression. create ( ""<STR_LIT>"" ) ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos. writeObject ( e ) ; oos. flush ( ) ; oos. close ( ) ; } catch ( IOException e1 ) { fail ( ""Serialization failed"" ) ; } } public void testAttributes ( ) { Expression e = SQLExpression. create ( ""<STR_LIT>"" ) ; Map < RelationName, Set < Attribute >> expectedAttributes = new HashMap < RelationName, Set < Attribute >> ( ) ; expectedAttributes. put ( new RelationName ( ""<STR_LIT>"" ), new HashSet < Attribute > ( Arrays. asList ( new Attribute [ ] { new Attribute ( null, ""<STR_LIT>"", ""<STR_LIT>"" ), new Attribute ( null, ""<STR_LIT>"", ""<STR_LIT>"" ) } ) ) ; assertEquals ( expectedAttributes, e. attributes ( ) ) ; } public void testAttributesForMultipleColumns ( ) { Expression e = SQLExpression. create ( ""<STR_LIT>"" ) ; Map < RelationName, Set <",0.0003653790728848502
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; @ JobFlow ( name = ""<STR_LIT>"" ) public class WithAbstractImportInput extends FlowDescription { private In < MockHoge > in ; private Out < MockHoge > out ; public WithAbstractImportInput ( @ Import ( name = ""<STR_LIT>""'}]",") In<MockHoge> in) { this.in = in; } public WithAbstractImportInput (@Export(name = ""<STR_LIT>"") Out<MockHoge> out) { this.out = out; } }",7.473947328595732e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . windgate . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . windgate . testing . model . Pair ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class PairOutput implements ModelOutput < Pair > { private final RecordEmitter emitter ; public PairOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( Pair model ) throws IOException {'}]","emitter.write(model.getKey(), model.getValue());",2.8981704351380188e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . argfile . editor . actions ; import java . util . ResourceBundle ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . ui . argfile . editor . SVArgFileEditor ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text .'}]","IDocumentChangeListener;public class OpenArgFileAction extends SVArgFileEditorAction { private static final LogHandle LOG = LogFactory. getLogger ( OpenArgFileAction. class ) ; public OpenArgFileAction ( ResourceBundle bundle ) { super ( bundle ) ; } @Override public void run ( ) { IDocument document = getEditor ( ). getDocument ( ) ; if ( document!= null &&! document. getLength ( ) == 0 ) { document. addDocumentListener ( new DocumentListener ( ) { @Override public void documentAboutToBeChanged ( IDocument document ) { LOG. info ( ""Document changed"" ) ; } @Override public void documentChanged ( IDocument document ) { LOG. info ( ""Document changed"" ) ; } } ) ; } } }",0.00022108507532016318
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . prefs ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . bioclipse . opentox . Activator ; import net . bioclipse . opentox . OpenToxConstants ; import net . bioclipse . ui . prefs . IPreferenceConstants ; import org . apache . log4j . Logger ; import org . eclipse . core . runtime . preferences . ConfigurationScope ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; import org . eclipse . ui . PlatformUI ; import org . eclipse . swt . layout . FormLayout ; import org . eclipse . swt . layout . FormData ; import org . eclipse . swt . layout . FormAttachment ; import org . osgi . service . prefs . BackingStoreException ; import org . osgi . service . prefs . Preferences ; public class ServicesPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { private static final Logger logger = Logger . getLogger ( ServicesPreferencePage . class . toString ( ) ) ; private static Preferences preferences = ConfigurationScope . INSTANCE . getNode ( OpenToxConstants . PLUGIN_ID ) ; private List < String [ ] > appList ; private TableViewer checkboxTableViewer ; public ServicesPreferencePage ( ) { super ( ) ; } class ApplicationsLabelProvider extends LabelProvider implements ITableLabelProvider { public Image getColumnImage ( Object element , int columnIndex ) { return null ; } public String getColumnText ( Object element , int index ) { if ( ! ( element instanceof String [ ] ) ) return ""<STR_LIT>"" ; String [ ] retList = ( String [ ] ) element ; if ( index == <NUM_LIT:0> ) { if ( retList . length > <NUM_LIT:0> ) return retList [ <NUM_LIT:0> ] ; else return ""<STR_LIT>"" ; } else if ( index == <NUM_LIT:1> ) { if ( retList . length > <NUM_LIT:1> ) return retList [ <NUM_LIT:1> ] ; else return ""<STR_LIT>"" ; } else if ( index == <NUM_LIT:2> ) { if ( retList . length > <NUM_LIT:2> ) return retList [ <NUM_LIT:2> ] ; else return ""<STR_LIT>"" ; } else return ""<STR_LIT>"" ; } } class ApplicationsContentProvider implements IStructuredContentProvider { @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) public Object [ ] getElements ( Object inputElement ) { if ( inputElement instanceof ArrayList ) { ArrayList retList = ( ArrayList ) inputElement ; return retList . toArray ( ) ; } return new Object [ <NUM_LIT:0> ] ; } public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } } public Control createContents ( Composite parent ) { Composite container = new Composite ( parent , SWT . NULL ) ; setSize ( new Point ( <NUM_LIT> , <NUM_LIT> ) ) ; container . setSize ( <NUM_LIT> , <NUM_LIT> ) ; container . setLayout ( new FormLayout ( ) ) ; checkboxTableViewer = new TableViewer ( container , SWT . BORDER | SWT . SINGLE ) ; checkboxTableViewer . setContentProvider ( new ApplicationsContentProvider ( ) ) ; checkboxTableViewer . setLabelProvider ( new ApplicationsLabelProvider ( ) ) ; final Table table = checkboxTableViewer . getTable ( ) ; FormData formData = new FormData ( <NUM_LIT> , <NUM_LIT> ) ; formData . left = new FormAttachment ( <NUM_LIT:0> , <NUM_LIT:11> ) ; formData . top = new FormAttachment ( <NUM_LIT:0> , <NUM_LIT:10> ) ; table . setLayoutData ( formData ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( true ) ; TableColumn tableColumn = new TableColumn ( table , SWT . LEFT ) ; tableColumn . setText ( ""<STR_LIT:Name>"" ) ; tableColumn . setWidth ( <NUM_LIT:100> ) ; TableColumn tableColumn2 = new TableColumn ( table , SWT . LEFT ) ; tableColumn2 . setText ( ""<STR_LIT>"" ) ; tableColumn2 . setWidth ( <NUM_LIT> ) ; TableColumn tableColumn3 = new TableColumn ( table , SWT . LEFT ) ; tableColumn3 . setText ( ""<STR_LIT>"" ) ; tableColumn3 . setWidth ( <NUM_LIT> ) ; appList = getPreferencesFromStore ( ) ; checkboxTableViewer . setInput ( appList ) ; final Button addButton = new Button ( container , SWT . NONE ) ; formData . right = new FormAttachment ( <NUM_LIT:100> , - <NUM_LIT> ) ; FormData formData_1 = new FormData ( ) ; formData_1 . right = new FormAttachment ( <NUM_LIT:100> , - <NUM_LIT:9> ) ; formData_1 . left = new FormAttachment ( table , <NUM_LIT:6> ) ; addButton . setLayoutData ( formData_1 ) ; addButton . setText ( ""<STR_LIT>"" ) ; addButton . addMouseListener ( new MouseAdapter ( ) { public void mouseUp ( MouseEvent e ) { ServicesEditDialog dlg = new ServicesEditDialog ( getShell ( ) ) ; dlg . open ( ) ; String [ ] ret = dlg . getServiceInfo ( ) ; if ( ret . length == <NUM_LIT:3> ) { appList . add ( ret ) ; checkboxTableViewer . refresh ( ) ; } } } ) ; final Button editButton = new Button ( container , SWT . NONE ) ; FormData formData_2 = new FormData ( ) ; formData_2 . top = new FormAttachment ( table , <NUM_LIT:0> , SWT . TOP ) ; formData_2 . left = new FormAttachment ( table , <NUM_LIT:6> ) ; formData_2 . right = new FormAttachment ( <NUM_LIT:100> , - <NUM_LIT:9> ) ; editButton . setLayoutData ( formData_2 ) ; editButton . setText ( ""<STR_LIT>"" ) ; editButton . addMouseListener ( new MouseAdapter ( ) { public void mouseUp ( MouseEvent e ) { ISelection sel = checkboxTableViewer . getSelection ( ) ; if ( ! ( sel instanceof IStructuredSelection ) ) { logger . debug ( ""<STR_LIT>"" ) ; showMessage ( ""<STR_LIT>"" ) ; return ; } IStructuredSelection ssel = ( IStructuredSelection ) sel ; Object obj = ssel . getFirstElement ( ) ; if ( ! ( obj instanceof String [ ] ) ) { logger . debug ( ""<STR_LIT>"" ) ; showMessage ( ""<STR_LIT>"" ) ; return ; } String [ ] chosen = ( String [ ] ) obj ; if ( chosen . length < <NUM_LIT:3> ) { String [ ] temp = { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ; for ( int i = <NUM_LIT:0> ; i < chosen . length ; i ++ ) temp [ i ] = chosen [ i ] ; chosen = temp ; } ServicesEditDialog dlg = new ServicesEditDialog ( getShell ( ) , chosen [ <NUM_LIT:0> ] , chosen [ <NUM_LIT:1> ] , chosen [ <NUM_LIT:2> ] ) ; dlg . open ( ) ; String [ ] ret = dlg . getServiceInfo ( ) ; if ( dlg . getReturnCode ( ) == <NUM_LIT:0> ) { if ( ret . length == <NUM_LIT:3> ) { chosen [ <NUM_LIT:0> ] = ret [ <NUM_LIT:0> ] ; chosen [ <NUM_LIT:1> ] = ret [ <NUM_LIT:1> ] ; chosen [ <NUM_LIT:2> ] = ret [ <NUM_LIT:2> ] ; checkboxTableViewer . refresh ( ) ; } else { logger . debug ( ""<STR_LIT>"" ) ; showMessage ( ""<STR_LIT>"" ) ; } } } } ) ; final Button removeButton = new Button ( container , SWT . NONE ) ; formData_1 . top = new FormAttachment ( removeButton , <NUM_LIT:6> ) ; FormData formData_3 = new FormData ( ) ; formData_3 . right = new FormAttachment ( <NUM_LIT:100> , - <NUM_LIT:9> ) ; formData_3 . left = new FormAttachment ( table , <NUM_LIT:6> ) ; formData_3 . top = new FormAttachment ( <NUM_LIT:0> , <NUM_LIT> ) ; removeButton . setLayoutData ( formData_3 ) ; removeButton . setText ( ""<STR_LIT>"" ) ; removeButton . addMouseListener ( new MouseAdapter ( ) { public void mouseUp ( MouseEvent e ) { if ( checkboxTableViewer . getSelection ( ) instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) checkboxTableViewer . getSelection ( ) ; Object [ ] objSelection = selection . toArray ( ) ; for ( int i = <NUM_LIT:0> ; i < objSelection . length ; i ++ ) { if ( objSelection [ i ] instanceof String [ ] ) { String [ ] row = ( String [ ] ) objSelection [ i ] ; if ( appList . contains ( row ) ) { appList . remove ( row ) ; } } } checkboxTableViewer . refresh ( ) ; } } } ) ; if ( table . getItemCount ( ) > <NUM_LIT:0> ) table . setSelection ( <NUM_LIT:0> ) ; container . pack ( ) ; parent . pack ( ) ; return container ; } public void init ( IWorkbench workbench ) { setPreferenceStore ( Activator . getDefault ( ) . getPreferenceStore ( ) ) ; } public boolean performOk ( ) { String value'}]","= getPreferenceStore().getValue(OpenToxConstants.SERVICES); return true; } public void showStatusMessage(String message) { MessageDialog.openInformation(getShell(), ""<STR_LIT>"", message); } public List<String[]> getPreferencesFromStore() { List<String[]> ret = new ArrayList<String[]>(); String[] preferences = preferences.getString(OpenToxConstants.SERVICES, """").split(""<DELIMITER>""); for (String preference : preferences) { String[] preferenceArray = preference.split(""<DELIMITER>""); if (preferenceArray.length == <NUM_LIT:3>) { ret.add(preferenceArray); } } return ret; } public void setPreferencesToStore(List<String[]> appList) { String[] preferences = new String[appList.size()]; int i = 0; for (String[] app : appList) { preferences[i++] = app[<NUM_LIT:0>] + ""<DELIMITER>"" + app[<NUM_LIT:1>] + ""<DELIMITER>"" + app[<NUM_LIT:2>]; } preferences.put(OpenToxConstants.SERVICES, preferences); } }",0.0004351418179582468
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . stage ; import java . io . IOException ; import java . net . URL ; import java . net . URLClassLoader ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . LinkedList ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . util . GenericOptionsParser ; import org . apache . hadoop . util . Tool ; import org . apache . hadoop . util . ToolRunner ; public final class ToolLauncher { public static final int JOB_SUCCEEDED = <NUM_LIT:0> ; public static final int JOB_FAILED = <NUM_LIT:1> ; public static final int LAUNCH_ERROR = - <NUM_LIT:2> ; public static final int CLIENT_ERROR = - <NUM_LIT:1> ; public static void main ( String ... args ) { if ( args == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LinkedList < String > arguments = new LinkedList < String > ( ) ; Collections . addAll ( arguments , args ) ; int result = main ( arguments ) ; System . exit ( result ) ; } private static int main ( LinkedList < String > args ) { assert args != null ; if ( args . isEmpty ( ) ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } String main = args . removeFirst ( ) ; Tool tool ; try { URL [ ] libraries = parseLibraries ( args ) ; ClassLoader loader = createLoader ( libraries ) ; tool = newTool ( main , loader ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return LAUNCH_ERROR ; } try { return ToolRunner . run ( tool ,'}]","args)!= null? ToolRunner.TERMINATE_EXITCODE : ToolRunner.RUN_EXITCODE; } finally { tool = null; } } private static URL[] parseLibraries(LinkedList<String> args) { assert args!= null; LinkedList<URL> libraries = new LinkedList<URL>(); while (!args.isEmpty()) { String arg = args.removeFirst(); if (arg.startsWith(""-libjars,"")) { String library = arg.substring(9); try { libraries.add(new URL(library)); } catch (Exception e) { e.printStackTrace(); } } else if (arg.startsWith(""-libjars"")) { String library = arg.substring(7); try { libraries.add(new URL(library)); } catch (Exception e) { e.printStackTrace(); } } else if (arg.startsWith(""-lib"")) { String library = arg.substring(4); try { libraries.add(new URL(library)); } catch (Exception e) { e.printStackTrace(); } } } return libraries.toArray(new URL[libraries.size()]); } private static ClassLoader createLoader(URL[] libraries) { URLClassLoader loader = new URLClassLoader(libraries); return loader; } private static Tool newTool(String main, ClassLoader loader) { try { Class<?> clazz = Class.forName(main, true, loader); Tool tool = (Tool",1.2928233596652866e-06
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . lmax . disruptor ; import com . lmax . disruptor . support . StubEntry ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import static org . junit . Assert . assertEquals ; public class BatchConsumerSequenceTrackingCallbackTest { private final CountDownLatch callbackLatch = new CountDownLatch ( <NUM_LIT:1> ) ; private final CountDownLatch onEndOfBatchLatch = new CountDownLatch ( <NUM_LIT:1> ) ; @ Test public void shouldReportProgressByUpdatingSequenceViaCallback ( ) throws Exception { final RingBuffer < StubEntry > ringBuffer = new RingBuffer < StubEntry > ( StubEntry . ENTRY_FACTORY , <NUM_LIT:16> ) ; final ConsumerBarrier < StubEntry > consumerBarrier = ringBuffer . createConsumerBarrier ( ) ; final SequenceTrackingHandler < StubEntry > handler = new TestSequenceTrackingHandler ( ) ; final BatchConsumer < StubEntry > batchConsumer = new BatchConsumer < StubEntry > ( consumerBarrier , handler ) ; final ProducerBarrier < StubEntry > producerBarrier = ringBuffer . createProducerBarrier ( batchConsumer ) ; Thread thread = new Thread ( batchConsumer ) ; thread . setDaemon ( true ) ; thread . start ( ) ; assertEquals ( - <NUM_LIT:1L> , batchConsumer . getSequence ( ) ) ; producerBarrier . commit ( producerBarrier . nextEntry ( ) ) ; callbackLatch . await ( ) ; assertEquals ( <NUM_LIT> , batchConsumer . getSequence ( ) ) ; onEndOfBatchLatch . countDown ( ) ; assertEquals ( <NUM_LIT> , batchConsumer . getSequence ( ) ) ; batchConsumer . halt ( ) ; thread . join ( ) ; } private class TestSequenceTrackingHandler implements SequenceTrackingHandler < StubEntry > { private BatchConsumer . SequenceTrackerCallback sequenceTrackerCallback ;'}]","@Override public void onSequenceUpdated(Sequence sequence) { callbackLatch.countDown(); } @Override public void onEndOfBatch() { onEndOfBatchLatch.countDown(); } @Override public void onException(Exception ex) { } @Override public void onEvent(StubEntry event, long sequence, boolean endOfBatch) { sequenceTrackerCallback.onEvent(event, sequence, endOfBatch); } @Override public void onStart() { } @Override public void onStop() { } @Override public void onSequenceReset() { } }",0.00016275440382807277
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . pref ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . preference . PathEditor ; import org'}]",".eclipse.jface.preference.PreferencePage; import org.eclipse.swt.widgets.Shell; public class PathPreferencePage extends PreferencePage { private PathEditor editor; public PathPreferencePage ( ) { super ( ); setPreferenceStore ( getPreferenceStore ( ) ); } @Override public void init ( Dialog shell ) { super. init ( shell ); editor = new PathEditor ( getPreferenceStore ( ) ); setControl ( editor. getControl ( ) ); } @Override public boolean performOk ( ) { String path = editor. getPath ( ) ; // Add this line to save the path if ( path!= null &&! path. trim ( ). isEmpty ( ) ) { getPreferenceStore ( ). setValue ( ""path"", path ) ; } return true ; } }",0.00021146125060449525
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . swing ; import java . awt . Component ; import java . awt . Container ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicReference ; import javax . swing . JCheckBox ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JPasswordField ; import javax . swing . JTextField ; import org . oddjob . arooa . design . screem . FileSelectionOptions ; import org . oddjob . arooa . design . view . DialogueHelper ; import org . oddjob . arooa . design . view . FileSelectionWidget ; import org . oddjob . arooa . design . view . Looks ; import org . oddjob . input . InputHandler ; import org . oddjob . input . InputMedium ; import org . oddjob . input . InputRequest ; public class SwingInputHandler implements InputHandler { private Component parent ; public SwingInputHandler ( Component owner ) { this . parent = owner ; } @ Override public Properties handleInput ( InputRequest [ ] requests ) { InputDialogue form = new InputDialogue ( ) ; List < AtomicReference < String > > refs = new ArrayList < AtomicReference < String > > ( ) ; final List < Callable < Boolean > > validations = new ArrayList < Callable < Boolean > > ( ) ; Properties properties = new Properties ( ) ; for ( InputRequest request : requests ) { AtomicReference < String > ref = new AtomicReference < String > ( ) ; refs . add ( ref ) ; FieldBuilder medium = new FieldBuilder ( ref ) ; request . render ( medium ) ; FormWriter formWriter = medium . getFormWriter ( ) ; form . accept ( formWriter ) ; validations . add ( medium . getValidator ( ) ) ; } DialogManager dialogManager = new DialogManager ( ) ; dialogManager . showDialog ( form . getForm ( ) , new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { for ( Callable < Boolean > validator : validations ) { if ( validator == null ) { continue ; } if ( ! validator . call ( ) ) { return Boolean . FALSE ; } } return Boolean . TRUE ; } } ) ; if ( dialogManager . isChosen ( ) ) { int i = <NUM_LIT:0> ; for ( AtomicReference < String > ref : refs ) { String property = requests [ i ++ ] . getProperty ( ) ; if ( property == null ) { continue ; } if ( ref . get ( ) == null ) { continue ; } properties . setProperty ( property , ref . get ( ) ) ; } return properties ; } else { return null ; } } class InputDialogue { private final JPanel form = new JPanel ( ) ; private int row ; public InputDialogue ( ) { form . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . weightx = <NUM_LIT:1.0> ; c . weighty = <NUM_LIT:0.0> ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . insets = new Insets ( Looks . DETAIL_FORM_BORDER , Looks . DETAIL_FORM_BORDER , Looks . DETAIL_FORM_BORDER , Looks . DETAIL_FORM_BORDER ) ; c . gridx = <NUM_LIT:0> ; c . gridy = <NUM_LIT:0> ; } public void accept ( FormWriter formWriter ) { row = formWriter . writeTo ( form , row ) ; } public JPanel getForm ( ) { return form ; } } interface FormWriter { public int writeTo ( Container container , int row ) ; } class FieldBuilder implements InputMedium { private final AtomicReference < String > reference ; private FormWriter formWriter ; private Callable < Boolean > validator ; public FieldBuilder ( AtomicReference < String > reference ) { this . reference = reference ; } @ Override public void confirm ( String message , Boolean defaultValue ) { final JLabel label = new JLabel ( formatLabelText ( message ) ) ; final JCheckBox toggle = new JCheckBox ( ) ; if ( defaultValue != null ) { toggle . setSelected ( defaultValue . booleanValue ( ) ) ; } formWriter = new FormWriter ( ) { @ Override public int writeTo ( Container container , int row ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . weightx = <NUM_LIT> ; c . weighty = <NUM_LIT:0.0> ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . gridx = <NUM_LIT:0> ; c . gridy = row ; c . insets = new Insets ( <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:20> ) ; container . add ( label , c ) ; c . weightx = <NUM_LIT:1.0> ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . WEST ; c . gridx = <NUM_LIT:1> ; c . gridwidth = GridBagConstraints . REMAINDER ; c . insets = new Insets ( <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> ) ; container . add ( toggle , c ) ; return row + <NUM_LIT:1> ; } } ; validator = new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { reference . set ( new Boolean ( toggle . isSelected ( ) ) . toString ( ) ) ; return true ; } } ; } @ Override public void password ( String prompt ) { final JLabel label = new JLabel ( formatLabelText ( prompt ) ) ; final JPasswordField text = new JPasswordField ( Looks . TEXT_FIELD_SIZE ) ; formWriter = new FormWriter ( ) { @ Override public int writeTo ( Container container , int row ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . weightx = <NUM_LIT> ; c . weighty = <NUM_LIT:0.0> ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . gridx = <NUM_LIT:0> ; c . gridy = row ; c . insets = new Insets ( <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:20> ) ; container . add ( label , c ) ; c . weightx = <NUM_LIT:1.0> ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . WEST ; c . gridx = <NUM_LIT:1> ; c . gridwidth = GridBagConstraints . REMAINDER ; c . insets = new Insets ( <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> ) ; container . add ( text , c ) ; return row + <NUM_LIT:1> ; } } ; validator = new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { reference . set ( new String ( text . getPassword ( ) ) ) ; return true ; } } ; } @ Override public void prompt ( String prompt , String defaultValue ) { final JLabel label = new JLabel ( formatLabelText ( prompt ) ) ; final JTextField text = new JTextField ( Looks . TEXT_FIELD_SIZE ) ; text . setText ( defaultValue ) ; reference . set ( defaultValue ) ; formWriter = new FormWriter ( ) { @ Override public int writeTo ( Container container , int row ) {'}]","int row = super.writeTo(container, row); return row + 1; } @Override public void text ( String prompt ) { final JLabel label = new JLabel (formatLabelText(prompt)); final JTextField text = new JTextField(Looks.TEXT_FIELD_SIZE); formWriter = new FormWriter() { @Override public int writeTo(Container container, int row) { GridBagConstraints c = new GridBagConstraints(); c.weightx = 1.0; c.weighty = 0.0; c.fill = GridBagConstraints.HORIZONTAL; c.anchor = GridBagConstraints.NORTHWEST; c.gridx = 0; c.gridy = row; c.insets = new Insets(Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER); container.add(label, c); c.weightx = 1.0; c.fill = GridBagConstraints.HORIZONTAL; c.anchor = GridBagConstraints.WEST; c.gridx = 1; c.gridwidth = GridBagConstraints.REMAINDER; c.insets = new Insets(Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER, Looks.DETAIL_FORM_BORDER); container.add(text, c); return row + 1; } }; validator = new Callable<Boolean>() { @Override public Boolean call",0.00042388733866885627
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . part . ISetSelectionTarget ; import org . rubypeople . rdt . core . ILoadpathEntry ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . corext . buildpath . LoadpathModifier ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . CPListElement ; public class AddSelectedLibraryToBuildpathAction extends Action implements ISelectionChangedListener { private final IWorkbenchSite fSite ; private IFile [ ] fSelectedElements ; public AddSelectedLibraryToBuildpathAction ( IWorkbenchSite site ) { super ( NewWizardMessages . NewSourceContainerWorkbookPage_ToolBar_AddSelLibToCP_label , RubyPluginImages . DESC_OBJS_EXTJAR ) ; setToolTipText ( NewWizardMessages . NewSourceContainerWorkbookPage_ToolBar_AddSelLibToCP_tooltip ) ; fSite = site ; fSelectedElements = null ; } public void run ( ) { try { final IFile [ ] files = fSelectedElements ; if ( files == null ) { return ; } final IRunnableWithProgress runnable = new IRunnableWithProgress ( ) { public void run ( IProgressMonitor monitor ) throws InvocationTargetException , InterruptedException { try { IRubyProject project = RubyCore . create ( files [ <NUM_LIT:0> ] . getProject ( ) ) ; List result = addLibraryEntries ( files , project , monitor ) ; selectAndReveal ( new StructuredSelection ( result ) ) ; } catch ( CoreException e ) { throw new InvocationTargetException ( e ) ; } } } ; PlatformUI . getWorkbench ( ) . getProgressService ( ) . run ( true , false , runnable ) ; } catch ( final InvocationTargetException e ) { if ( e . getCause ( ) instanceof CoreException ) { showExceptionDialog ( ( CoreException ) e . getCause ( ) ) ; } else { RubyPlugin . log ( e ) ; } } catch ( final InterruptedException e ) { } } private List addLibraryEntries ( IFile [ ] resources , IRubyProject project , IProgressMonitor monitor ) throws CoreException { List addedEntries = new ArrayList ( ) ; try { monitor . beginTask ( NewWizardMessages . LoadpathModifier_Monitor_AddToBuildpath , <NUM_LIT:4> ) ; for ( int i = <NUM_LIT:0> ; i < resources . length ; i ++ ) { IResource res = resources [ i ] ; addedEntries . add ( new CPListElement ( project , ILoadpathEntry . CPE_LIBRARY , res . getFullPath ( ) , res ) ) ; } monitor . worked ( <NUM_LIT:1> ) ; List existingEntries = LoadpathModifier . getExistingEntries ( project ) ; LoadpathModifier . setNewEntry ( existingEntries , addedEntries , project , new SubProgressMonitor ( monitor , <NUM_LIT:1> ) ) ; LoadpathModifier . commitLoadPath ( existingEntries , project , new SubProgressMonitor ( monitor , <NUM_LIT:1> ) ) ; List result = new ArrayList ( addedEntries . size ( ) ) ; for ( int i = <NUM_LIT:0> ; i < resources . length ; i ++ ) { IResource res = resources [ i ] ; IRubyElement elem = project . getSourceFolderRoot ( res ) ; if ( elem != null ) { result . add ( elem ) ; } } monitor . worked ( <NUM_LIT:1> ) ; return result ; } finally { monitor . done ( ) ; } } public void selectionChanged ( final SelectionChangedEvent event ) { final ISelection selection = event . getSelection ( ) ; if ( selection instanceof IStructuredSelection ) { setEnabled ( canHandle ( ( IStructuredSelection ) selection ) ) ; } else { setEnabled ( canHandle ( StructuredSelection . EMPTY ) ) ; } } private boolean canHandle ( IStructuredSelection elements ) { fSelectedElements = getSelectedResources ( elements ) ; return fSelectedElements != null ; } private IFile [ ] getSelectedResources ( IStructuredSelection elements ) { if ( elements . size ( ) == <NUM_LIT:0> ) return null ; ArrayList res = new ArrayList ( ) ; for ( Iterator iter = elements . iterator ( ) ; iter . hasNext ( ) ; ) { Object element = iter . next ( ) ; if ( element instanceof IFile ) { IFile file = ( IFile ) element ; IRubyProject project = RubyCore . create ( file . getProject ( ) ) ; if ( project == null ) return null ; return null ; } else { return null ; } } return ( IFile [ ] ) res . toArray ( new IFile [ res . size ( ) ] ) ; } private void showExceptionDialog ( CoreException exception ) { showError ( exception , fSite . getShell ( ) , NewWizardMessages . AddSelectedLibraryToBuildpathAction_ErrorTitle , exception . getMessage ( ) ) ; } private void showError ( CoreException e , Shell shell , String'}]","title, String message) { MessageDialog.openError(shell, title, message); } }",6.421970288107e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . operation . IRunnableContext ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . forms . events . HyperlinkAdapter ; import org . eclipse . ui . forms . events . HyperlinkEvent ; import org . eclipse . ui . forms . widgets . FormText ; import org . eclipse . ui . forms . widgets . FormToolkit ; import org . eclipse . ui . forms . widgets . TableWrapData ; import org . eclipse . ui . forms . widgets . TableWrapLayout ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . buildpath . ILoadpathInformationProvider ; import org . rubypeople . rdt . internal . corext . buildpath . IPackageExplorerActionListener ; import org . rubypeople . rdt . internal . corext . buildpath . PackageExplorerActionEvent ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . preferences . ScrolledPageContent ; import org . rubypeople . rdt . internal . ui . util . ExceptionHandler ; import org . rubypeople . rdt . internal . ui . util . PixelConverter ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . DialogPackageExplorerActionGroup . DialogExplorerActionContext ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . LoadpathModifierQueries . ICreateFolderQuery ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . LoadpathModifierQueries . IInclusionExclusionQuery ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . LoadpathModifierQueries . ILinkToQuery ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . LoadpathModifierQueries . IRemoveLinkedFolderQuery ; public final class HintTextGroup implements ILoadpathInformationProvider , IPackageExplorerActionListener { private final static int [ ] ACTION_ORDER = { ILoadpathInformationProvider . CREATE_FOLDER , ILoadpathInformationProvider . CREATE_LINK , ILoadpathInformationProvider . EDIT_FILTERS , ILoadpathInformationProvider . EXCLUDE , ILoadpathInformationProvider . INCLUDE , ILoadpathInformationProvider . UNEXCLUDE , ILoadpathInformationProvider . UNINCLUDE , ILoadpathInformationProvider . CREATE_OUTPUT , ILoadpathInformationProvider . ADD_SEL_SF_TO_BP , ILoadpathInformationProvider . REMOVE_FROM_BP , ILoadpathInformationProvider . ADD_SEL_LIB_TO_BP , ILoadpathInformationProvider . ADD_LIB_TO_BP , ILoadpathInformationProvider . ADD_JAR_TO_BP } ; private Composite fTopComposite ; private DialogPackageExplorerActionGroup fActionGroup ; private DialogPackageExplorer fPackageExplorer ; private IRunnableContext fRunnableContext ; private IRubyProject fCurrJProject ; private List fNewFolders ; private HashMap fImageMap ; private final NewSourceContainerWorkbookPage fPage ; public HintTextGroup ( DialogPackageExplorer packageExplorer , IRunnableContext runnableContext , NewSourceContainerWorkbookPage page ) { fPackageExplorer = packageExplorer ; fRunnableContext = runnableContext ; fPage = page ; fCurrJProject = null ; fNewFolders = new ArrayList ( ) ; fImageMap = new HashMap ( ) ; } public Composite createControl ( Composite parent ) { fTopComposite = new Composite ( parent , SWT . NONE ) ; fTopComposite . setFont ( parent . getFont ( ) ) ; GridData gridData = new GridData ( GridData . FILL_BOTH ) ; PixelConverter converter = new PixelConverter ( parent ) ; gridData . heightHint = converter . convertHeightInCharsToPixels ( <NUM_LIT:12> ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . marginWidth = <NUM_LIT:0> ; gridLayout . marginHeight = <NUM_LIT:0> ; fTopComposite . setLayout ( gridLayout ) ; fTopComposite . setLayoutData ( gridData ) ; fTopComposite . setData ( null ) ; fTopComposite . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { Collection collection = fImageMap . values ( ) ; Iterator iterator = collection . iterator ( ) ; while ( iterator . hasNext ( ) ) { Image image = ( Image ) iterator . next ( ) ; image . dispose ( ) ; } } } ) ; return fTopComposite ; } private Shell getShell ( ) { return RubyPlugin . getActiveWorkbenchShell ( ) ; } public void setRubyProject ( IRubyProject jProject ) { fCurrJProject = jProject ; } public void setActionGroup ( DialogPackageExplorerActionGroup actionGroup ) { fActionGroup = actionGroup ; } private FormText createFormText ( Composite parent , String text ) { FormToolkit toolkit = new FormToolkit ( getShell ( ) . getDisplay ( ) ) ; try { FormText formText = toolkit . createFormText ( parent , true ) ; formText . setFont ( parent . getFont ( ) ) ; try { formText . setText ( text , true , false ) ; } catch ( IllegalArgumentException e ) { formText . setText ( e . getMessage ( ) , false , false ) ; RubyPlugin . log ( e ) ; } formText . marginHeight = <NUM_LIT:2> ; formText . marginWidth = <NUM_LIT:0> ; formText . setBackground ( null ) ; formText . setLayoutData ( new TableWrapData ( TableWrapData . FILL_GRAB ) ) ; return formText ; } finally { toolkit . dispose ( ) ; } } private void createLabel ( Composite parent , String text , final LoadpathModifierAction action , final IRunnableContext context ) { FormText formText = createFormText ( parent , text ) ; Image image = ( Image ) fImageMap . get ( action . getId ( ) ) ; if ( image == null ) { image = action . getImageDescriptor ( ) . createImage ( ) ; fImageMap . put ( action . getId ( ) , image ) ; } formText . setImage ( ""<STR_LIT>"" , image ) ; formText . addHyperlinkListener ( new HyperlinkAdapter ( ) { public void linkActivated ( HyperlinkEvent e ) { try { context . run ( false , false , action . getOperation ( ) ) ; } catch ( InvocationTargetException err ) { ExceptionHandler . handle ( err , getShell ( ) , Messages . format ( NewWizardMessages . HintTextGroup_Exception_Title , action . getName ( ) ) , err . getMessage ( ) ) ; } catch ( InterruptedException err ) { } } } ) ; } public IStructuredSelection getSelection ( ) { return fPackageExplorer . getSelection ( ) ; } public void setSelection ( List elements ) { fPackageExplorer . setSelection ( elements ) ; } public IRubyProject getRubyProject ( ) { return fCurrJProject ; } public void handleResult ( List resultElements , CoreException exception , int actionType ) { if ( exception != null ) { ExceptionHandler . handle ( exception , getShell ( ) , Messages . format ( NewWizardMessages . HintTextGroup_Exception_Title_refresh , fActionGroup . getAction ( actionType ) . getName ( ) ) , exception . getLocalizedMessage ( ) ) ; return ; } switch ( actionType ) { case CREATE_FOLDER : handleFolderCreation ( resultElements ) ; break ; case CREATE_LINK : handleFolderCreation ( resultElements ) ; break ; case EDIT_FILTERS : defaultHandle ( resultElements , false ) ; break ; case ADD_SEL_SF_TO_BP : case ADD_SEL_LIB_TO_BP : case ADD_JAR_TO_BP : case ADD_LIB_TO_BP : handleAddToCP ( resultElements ) ; break ; case REMOVE_FROM_BP : handleRemoveFromBP ( resultElements , false ) ; break ; case INCLUDE : defaultHandle ( resultElements , true ) ; break ; case EXCLUDE : defaultHandle ( resultElements , false ) ; break ; case UNINCLUDE : defaultHandle ( resultElements , false ) ; break ; case UNEXCLUDE : defaultHandle ( resultElements , true ) ; break ; case RESET : defaultHandle ( resultElements , false ) ; break ; case RESET_ALL : handleResetAll ( ) ; break ; default : break ; } } private void defaultHandle ( List result , boolean forceRebuild ) { try { fPackageExplorer . setSelection ( result ) ; if ( forceRebuild ) { fActionGroup . refresh ( new DialogExplorerActionContext ( result , fCurrJProject ) ) ; } } catch ( RubyModelException e ) { ExceptionHandler . handle ( e , getShell ( ) , NewWizardMessages . HintTextGroup_Exception_Title_refresh , e . getLocalizedMessage ( ) ) ; } } private void handleFolderCreation ( List result ) { if ( result . size ( ) == <NUM_LIT:1> ) { fNewFolders . add ( result . get ( <NUM_LIT:0> ) ) ; fPackageExplorer . setSelection ( result ) ; } } private void handleAddToCP ( List result ) { try { if ( containsRubyProject ( result ) ) { fPackageExplorer . setSelection ( result ) ; fActionGroup . refresh ( new DialogExplorerActionContext ( result , fCurrJProject ) ) ; } else fPackageExplorer . setSelection ( result ) ; } catch ( RubyModelException e ) { ExceptionHandler . handle ( e , getShell ( ) , NewWizardMessages . HintTextGroup_Exception_Title_refresh , e . getLocalizedMessage ( ) ) ; } } private void handleRemoveFromBP ( List result , boolean forceRebuild ) { fPackageExplorer . setSelection ( result ) ; try { if ( forceRebuild || containsRubyProject ( result ) ) { fActionGroup . refresh ( new DialogExplorerActionContext ( result , fCurrJProject ) ) ; } } catch ( RubyModelException e ) { ExceptionHandler . handle ( e , getShell ( ) , NewWizardMessages . HintTextGroup_Exception_Title_refresh , e . getLocalizedMessage ( ) ) ; } } private void handleResetAll ( ) { List list = new ArrayList ( ) ; list . add ( fCurrJProject ) ; setSelection ( list ) ; } private boolean containsRubyProject ( List elements ) { for ( int i = <NUM_LIT:0> ; i < elements . size ( ) ; i ++ ) { if ( elements . get ( i ) instanceof IRubyProject ) return true ; } return false ; } public IInclusionExclusionQuery getInclusionExclusionQuery ( ) { return LoadpathModifierQueries . getDefaultInclusionExclusionQuery ( getShell ( ) ) ; } public ILinkToQuery getLinkFolderQuery ( ) throws RubyModelException { return LoadpathModifierQueries . getDefaultLinkQuery'}]","(getShell(), fCurrJProject); } public ICreateFolderQuery getCreateFolderQuery() throws RubyModelException { return LoadpathModifierQueries.getDefaultCreateFolderQuery(getShell(), fCurrJProject); } public IRemoveLinkedFolderQuery getRemoveLinkedFolderQuery() throws RubyModelException { return LoadpathModifierQueries.getDefaultRemoveLinkedFolderQuery(getShell(), fCurrJProject); } }",0.00018559695963839628
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core ; import java . io . IOException ; import java . text . MessageFormat ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class BaseProfile < S extends BaseProfile < S , T > , T extends BaseProvider < S > > { static final WindGateLogger WGLOG = new WindGateCoreLogger ( BaseProfile . class ) ; static final Logger LOG = LoggerFactory . getLogger ( BaseProfile . class ) ; public static final char QUALIFIER = \'<CHAR_LIT:.>\' ; public abstract Class < ? extends T > getProviderClass ( ) ; public abstract ProfileContext getContext ( ) ; @ Deprecated public ClassLoader getClassLoader ( ) { return getContext ( ) . getClassLoader ( ) ; } protected abstract S getThis ( ) ; protected static < T extends BaseProvider < ? > > Class < ? extends T > loadProviderClass ( String className , ProfileContext context , Class < T > providerInterface ) { if ( className == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( context == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( providerInterface == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , className ) ; Class < ? > loaded ; try { loaded = context . getClassLoader ('}]","). loadClass ( className ) ; } catch ( ClassNotFoundException e ) { LOG. debug ( MessageFormat. format ( ""<STR_LIT>"", className, e. getClass ( ). getName ( ) ), e ) ; loaded = Class. forName ( className ) ; } if (! providerInterface. isAssignableFrom ( loaded ) ) { throw new ClassCastException ( MessageFormat. format ( ""<STR_LIT>"", className, providerInterface. getName ( ) ) ) ; } return loaded ; } }",0.00015433213178581514
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import org . oddjob . arooa . design . DesignFactory ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignProperty ; import org . oddjob . arooa . design . SimpleDesignProperty ; import org . oddjob . arooa . design . SimpleTextAttribute ; import org . oddjob . arooa . design . screem . BorderedGroup ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa'}]",".util.design.DesignUtil;public class PropertyEditor extends BorderedGroup { private DesignInstance design; public PropertyEditor(DesignInstance design) { super(new Form(design)); this.design = design; } public DesignProperty createProperty(String name, Class<?> type) { return DesignUtil.createProperty(design, name, type); } public DesignProperty createProperty(String name, String description, Class<?> type) { return new SimpleDesignProperty(new SimpleTextAttribute(name, description), createProperty(name, type)); } }",0.00015087964309018115
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . core . context ; public class InconsistentApplicationException extends IllegalStateException { private static final long serialVersionUID = <NUM_LIT> ; public InconsistentApplicationException'}]","(String message) { super(message); } public InconsistentApplicationException(Throwable cause) { super(cause); } public InconsistentApplicationException(String message, Throwable cause) { super(message, cause); } }",6.736959105345039e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . entity . family ; import fi . koku . settings . KoKuPropertiesUtil ;'}]",import javax.jdo.annotations.Extension;,2.540889528950381e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import org . eclipse . core . runtime . IProgressMonitor ; import org . jruby'}]",".runtime.InputOutput; public class RubyTextEditor extends TextEditor { @Override public void doOpen ( IEditorInput editorInput, boolean restore ) throws CoreException { super. doOpen ( editorInput, restore ) ; } }",7.389298335595976e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . jsr269 . bridge ; import java . util . Set ; import javax . annotation . processing . AbstractProcessor ; import javax . annotation . processing . RoundEnvironment ; import javax . annotation . processing . SupportedAnnotationTypes ; import javax . annotation . processing . SupportedSourceVersion ; import javax . lang . model . SourceVersion ; import javax'}]",".lang.model.element.TypeElement;public class JSR269BridgeProcessor extends AbstractProcessor { @Override public Set<String> getSupportedAnnotationTypes() { return Set.of(""com.asakusafw.utils.java.jsr269.annotation.Bridge""); } @Override public Set<SupportedSourceVersion> getSupportedSourceVersions() { return Set.of(SourceVersion.RELEASE_8); } @Override public boolean process(Set<? super javax.annotation.processing.ProcessingEnvironment> annotations, RoundEnvironment roundEnv) { // implementation } }",0.0001474078707139542
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage ; import java . lang . reflect . InvocationTargetException ; import java . util . List ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . buildpath . ILoadpathInformationProvider ; import org . rubypeople . rdt . internal . corext . buildpath . LoadpathModifier ; public abstract class LoadpathModifierOperation extends LoadpathModifier implements IRunnableWithProgress { protected ILoadpathInformationProvider fInformationProvider ; protected CoreException fException ; private int fType ; private String fName ; public LoadpathModifierOperation ( ILoadpathModifierListener listener , ILoadpathInformationProvider informationProvider , String name , int type ) { super ( listener ) ; fInformationProvider = informationProvider ; fException = null ; fName = name ; fType = type ; } protected void handleResult ( List result , IProgressMonitor monitor ) throws InvocationTargetException { if ( monitor == null || fException == null ) fInformationProvider . handleResult ( result , fException , fType ) ; else throw new InvocationTargetException ( fException ) ; fException = null ; } public abstract void run ( IProgressMonitor monitor ) throws InvocationTargetException , InterruptedException ; public String getId ( ) {'}]",return fName;,2.561173118327426e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . scheduling ; import junit . framework . TestCase ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignParser ; import org . oddjob . arooa . design . view . ViewMainHelper ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . StateConditions ; public'}]","class OddjobDescriptorFactoryTest extends TestCase { public void testCreate() throws ArooaParseException { OddjobDescriptorFactory factory = new OddjobDescriptorFactory(); DesignInstance instance = new DesignParser(Helper.getDefaultParser()).parse(Helper.getDefaultInput()); ArooaDescriptor descriptor = factory.createDescriptor(instance, StandardArooaSession.createDefaultSession()); StateConditions conditions = factory.createConditions(descriptor); ViewMainHelper.verifyConditions(conditions); } }",4.855990202405664e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . elements ; import org . oddjob . arooa . design . DesignFactory ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignProperty ; import org . oddjob . arooa . design . DesignValueBase ; import org . oddjob . arooa . design . SimpleDesignProperty ; import org . oddjob . arooa . design . SimpleTextAttribute ; import org . oddjob . arooa . design . screem . BorderedGroup ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design'}]",". screem. Group;public class DesignScreenElement extends DesignValueBase { public static final String NAME = ""name""; public static final String DESCRIPTION = ""description""; public static final String SCREEN = ""screen""; public static final String GROUP = ""group""; public static final String BORDER = ""border""; public static final String FORM = ""form""; public static final String GROUPS = ""groups""; public static final String FORMS = ""forms""; public static final String PROPERTY = ""property""; public static final String VALUE = ""value""; public static final String PROPERTY_NAME = ""property.name""; public static final String PROPERTY_DESCRIPTION = ""property.description""; public static final String PROPERTY_SCREEN = ""property.screen""; public static final String PROPERTY_GROUP = ""property.group""; public static final String PROPERTY_BORDER = ""property.border""; public static final String PROPERTY_FORM = ""property.form""; public static final String PROPERTY_GROUPS = ""property.groups""; public static final String PROPERTY_FORMS = ""property.forms""; public static final String PROPERTY_VALUE = ""property.value""; public static final String PROPERTY_PROPERTY_NAME = ""property.property.name""; public static final String PROPERTY_PROPERTY_DESCRIPTION = ""property.property.description""; public static final String PROPERTY_PROPERTY_SCREEN = ""property.property.screen""; public static final String PROPERTY_PROPERTY_GROUP = """,0.0003449254973591517
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . bulkloader . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . bulkloader . testing . model . MockErrorModel ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class MockErrorModelInput implements ModelInput < MockErrorModel > { private final RecordParser parser ; public MockErrorModelInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . parser = parser ; } @ Override public boolean readTo ( MockErrorModel model ) throws IOException { if ( parser . next ( ) == false ) { return false ; } parser . fill ( model . getAOption ( ) ) ; parser'}]",.fill(model.getBOption()); return true;}@Overridepublic MockErrorModel read() throws IOException {MockErrorModel model = new MockErrorModel();if (parser.next() == false) {return model;}parser.fill(model.getAOption());parser.fill(model.getBOption());return model;}@Overridepublic void close() throws IOException {parser.close();}},0.000107396459082303
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> import java . awt . BorderLayout ; import java . awt . EventQueue ; import javax . swing . JFrame ; import javax . swing . JPanel ; import javax . swing . border . Border ; import javax . swing . border . EmptyBorder ; import javax . swing . text . JTextComponent ; import javax . swing . BoxLayout ; import javax . swing . JTextArea ; import java . awt . datatransfer . DataFlavor ; import java . awt . dnd . DnDConstants ; import java . awt . dnd . DropTarget ; import java . awt . dnd . DropTargetDropEvent ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . BufferedReader ; import java . io . File ; import java . util . Arrays ; import java . util . List ; import net . miginfocom . swing . MigLayout ; import javax . swing . BorderFactory ; import javax . swing . ImageIcon ; import javax . swing . JOptionPane ; import javax . swing . JScrollPane ; import javax . swing . JLabel ; import javax . swing . JButton ; import javax . swing . ScrollPaneConstants ; import java . awt . FlowLayout ; import java . awt . GridLayout ; public class MultiUploader extends JFrame { private JPanel contentPane ; private Upload upload ; private JTextArea linkBox ; private JTextArea pathBox ; private MultiUploaderThread mut ; private JButton btnUpload ; private int total_uploads = <NUM_LIT:0> ; private int current_upload = <NUM_LIT:0> ; private JTextArea deletionBox ; public MultiUploader ( ) { setTitle ( ""<STR_LIT>"" ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; setBounds ( <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> , <NUM_LIT> ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( <NUM_LIT:5> , <NUM_LIT:5> , <NUM_LIT:5> , <NUM_LIT:5> ) ) ; contentPane . setLayout ( new BorderLayout ( <NUM_LIT:0> , <NUM_LIT:0> ) ) ; setContentPane ( contentPane ) ; ImageIcon ii2 = new ImageIcon ( this . getClass ( ) . getResource ( ""<STR_LIT>"" ) ) ; this . setIconImage ( ii2 . getImage ( ) ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new MigLayout ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; JScrollPane scrollPane = new JScrollPane ( ) ; scrollPane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS ) ; scrollPane . setBorder ( BorderFactory . createTitledBorder ( ""<STR_LIT>"" ) ) ; panel . add ( scrollPane , ""<STR_LIT>"" ) ; pathBox = new JTextArea ( ) ; pathBox . setEditable ( false ) ; scrollPane . setViewportView'}]","(pathBox); linkBox = new JTextArea(); linkBox.setEditable(false); scrollPane.setViewportView(linkBox); JButton btnNewButton = new JButton(""<STR_LIT>""); btnNewButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent arg0) { // add action here } }); panel.add(btnNewButton, ""cell 0 1""); btnUpload = new JButton(""<STR_LIT>""); btnUpload.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent arg0) { // add action here } }); panel.add(btnUpload, ""cell 1 1""); deletionBox = new JTextArea(); deletionBox.setEditable(false); panel.add(deletionBox, ""cell 2 1""); mut = new MultiUploaderThread(this); mut.start(); } }",0.0002275823156125816
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . scanutils ; import net . sf . sveditor . core . scanutils . AbstractTextScanner ; import net . sf . sveditor . core . scanutils . IBIDITextScanner ; import net . sf . sveditor . core . scanutils . ScanLocation ; import net . sf . sveditor . ui . editor . SVDocumentPartitions ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . BadPartitioningException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentExtension3 ; import org . eclipse . jface . text . ITypedRegion ; public class SVDocumentTextScanner extends AbstractTextScanner implements IBIDITextScanner { private IDocument fDoc ; private int fIdx ; private int fOffset ; private int fLimit ; private String fName ; private int fUngetCh ; private boolean fSkipComments ; public SVDocumentTextScanner ( IDocument doc , String name , int offset , boolean scan_fwd , boolean skip_comments ) { fDoc = doc ; fName = name ;'}]","fIdx = 0; fOffset = offset; fLimit = doc.getLength(); fSkipComments = skip_comments; } public SVDocumentTextScanner ( IDocument doc, String name, int offset, int limit, boolean scan_fwd, boolean skip_comments ) { this ( doc, name, offset, skip_comments ); fLimit = limit; } @Override public ScanLocation scanForward () throws BadLocationException, BadPartitioningException { if (fIdx >= fLimit) { return null; } //... } @Override public ScanLocation scanBackward () throws BadLocationException, BadPartitioningException { if (fIdx <= 0) { return null; } //... } @Override public ScanLocation scanForward ( ITypedRegion region ) throws BadLocationException, BadPartitioningException { //... } @Override public ScanLocation scanBackward ( ITypedRegion region ) throws BadLocationException, BadPartitioningException { //... } @Override public void ungetChar ( int ch ) { fUngetCh = ch; } @Override public int ungetChar () { return fUngetCh; } @Override public void setDocument ( IDocument doc ) { fDoc = doc; } @Override public IDocument getDocument () { return",0.0003498068334438474
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . prefs ; import org . eclipse . jface . preference . FieldEditorPreferencePage ; import org . eclipse . jface . preference . IntegerFieldEditor ; import org'}]",".eclipse.jface.preference.PreferencePage; import org.eclipse.ui.IWorkbench; public class IntegerPreferencePage extends FieldEditorPreferencePage { public IntegerPreferencePage () { super ( GRIFFIN_PLUGIN_ID ) ; } @Override protected void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( INTEGER_PREFERENCE, ""Integer Preference"", getFieldEditorPreference ( ) ) ) ; } }",0.00011450707426825766
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package edsdk ; import com . sun . jna . NativeLong ; import com . sun . jna . Structure ; public class EdsUsersetData extends Structure { public NativeLong valid ; public NativeLong dataSize ; public byte [ ] szCaption = new byte [ ( <NUM_LIT:32> ) ] ; public byte [ ] data = new byte [ ( <NUM_LIT:1> ) ] ; public EdsUsersetData ( ) { super ( ) ; initFieldOrder ( ) ; } protected void initFieldOrder ( ) { setFieldOrder ( new java . lang . String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:data>"" } ) ; } public EdsUsersetData ( NativeLong valid , NativeLong dataSize , byte szCaption [ ] , byte data [ ] ) { super ( ) ; this . valid = valid ; this . dataSize = dataSize ; if ( szCaption . length != this . szCaption . length ) throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; this . szCaption = szCaption ; if ( data . length != this . data'}]",".length ) throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; this. data = data ; } }",4.539481602202981e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . sql . Connection ; import org . oddjob . Stoppable ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . deploy . annotations . ArooaHidden ; import org . oddjob . arooa . life . ArooaSessionAware ; import org . oddjob . arooa . types . IdentifiableValueType ; import org . oddjob . arooa . types . ValueType ; import org . oddjob . beanbus . BadBeanException ; import org . oddjob . beanbus . BadBeanFilter ; import org . oddjob . beanbus . CrashBusException ; import org . oddjob . beanbus . SimpleBus ; import org . oddjob . io . BufferType ; import org . oddjob . io . FileType ; public class SQLJob implements Runnable , Serializable , ArooaSessionAware , Stoppable { private static final long serialVersionUID = <NUM_LIT> ; public enum DelimiterType { NORMAL , ROW , } public enum OnError { CONTINUE , STOP , ABORT ; } private transient ScriptParser parser ; private transient BadSQLHandler errorHandler ; private transient ParameterisedExecutor executor ; private String name ; private transient SQLResultsProcessor results ; private transient ArooaSession session ; public SQLJob ( ) { completeConstruction ( ) ; } private void completeConstruction ( ) { executor = new ParameterisedExecutor ( ) ; parser = new ScriptParser ( ) ; errorHandler = new BadSQLHandler ( ) ; } @ Override @ ArooaHidden public void setArooaSession ( ArooaSession session ) { this . session = session ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void run ( ) { if ( results == null ) { executor . setResultProcessor ( new SQLResultsProcessor ( ) { @ Override public void accept ( Object bean ) throws BadBeanException , CrashBusException { } } ) ; } else { executor . setResultProcessor ( results ) ; } parser . setArooaSession ( session ) ; executor . setArooaSession ( session ) ; BadBeanFilter < String > errorFilter = new BadBeanFilter < String > ( ) ; errorFilter . setBadBeanHandler ( errorHandler ) ; parser . setTo ( errorFilter ) ; errorFilter . setTo ( executor ) ; SimpleBus < String > bus = new SimpleBus < String > ( ) ; bus . setDriver ( parser ) ; bus . run ( ) ; } @ Override public void stop ( ) { parser . stop ( ) ; executor . stop ( ) ; } public SQLResultsProcessor getResults ( ) { return results ; } public void setResults ( SQLResultsProcessor results ) { this . results = results ; } public void setInput ( InputStream sql ) { parser . setInput ( sql ) ; } public void setExpandProperties ( boolean expandProperties ) { this . parser . setExpandProperties ( expandProperties ) ; } public boolean getExpandProperties ( ) { return this . parser . isExpandProperties ( ) ; } public void setEncoding ( String encoding ) { this . parser . setEncoding ( encoding ) ; } public String getEncoding ( ) { return this . parser . getEncoding ( ) ; } public void setDelimiter ( String delimiter ) { this . parser . setDelimiter ( delimiter ) ; } public String getDelimiter ( ) { return this . parser . getDelimiter ( ) ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . parser . setDelimiterType ( delimiterType ) ; } public DelimiterType getDelimiterType ( ) { return this . parser . getDelimiterType ( ) ; } public void setKeepFormat ( boolean keepformat ) { this . parser . setKeepFormat ( keepformat ) ; } public boolean isKeepFormat ( ) { return this . parser . isKeepFormat ( ) ; } public void setConnection ( Connection connection ) { executor . setConnection ( connection ) ; } public void setAutocommit ( boolean autocommit ) { executor . setAutocommit ( autocommit ) ; } public boolean isAutocommit ( ) { return executor . isAutocommit ( ) ; } public ValueType getParameters ( int index ) { return executor . getParameters ( index ) ; }'}]",public void setOnError(OnError onError) { this.errorHandler.setOnError(onError); },1.993826493362435e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . compiler . operator . io . MockKeyValue1Input ; import com . asakusafw . compiler . operator . io . MockKeyValue1Output ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . StringOption ; @ DataModelKind ( ""<STR_LIT>"" ) @ ModelInputLocation ( MockKeyValue1Input . class ) @ ModelOutputLocation ( MockKeyValue1Output . class ) public class MockKeyValue1 implements DataModel < MockKeyValue1 > , MockKey , MockProjection , Writable { private final StringOption key = new StringOption ('}]",") ; private final IntOption value = new IntOption ( ) ; public StringOption getKey ( ) { return key ; } public IntOption getValue ( ) { return value ; } @ Override public void readFields ( DataInput in ) throws IOException { key. readFields ( in ) ; value. readFields ( in ) ; } @ Override public void write ( DataOutput out ) throws IOException { key. write ( out ) ; value. write ( out ) ; } @ Override public String toString ( ) { return ""<STR_LIT>"" + key + ""<STR_LIT>"" + value ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( key == null )? 0 : key. hashCode ( ) ) ; result = prime * result + ( ( value == null )? 0 : value. hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( )!= obj. getClass ( ) ) { return false ; } MockKeyValue1 other = ( MockKeyValue1 ) obj ; if ( key == null ) { if ( other",0.0003575303779108588
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . text . ruby ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . Image ; import org . rubypeople . rdt . core . CompletionProposal ; import org . rubypeople . rdt . core . CompletionRequestor ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . compiler . IProblem ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . ruby . AbstractRubyCompletionProposal ; import org . rubypeople . rdt . internal . ui . text . ruby . CompletionProposalLabelProvider ; import org . rubypeople . rdt . internal . ui . text . ruby . FillArgsAndBlockProposal ; import org . rubypeople . rdt . internal . ui . text . ruby . FillMethodArgumentsProposal ; import org . rubypeople . rdt . internal . ui . text . ruby . ProposalInfo ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyCompletionProposal ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyContentAssistInvocationContext ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . viewsupport . ImageDescriptorRegistry ; public class CompletionProposalCollector extends CompletionRequestor { private static final boolean DEBUG = ""<STR_LIT:true>"" . equalsIgnoreCase ( Platform . getDebugOption ( ""<STR_LIT>"" ) ) ; private final CompletionProposalLabelProvider fLabelProvider = new CompletionProposalLabelProvider ( ) ; private final ImageDescriptorRegistry fRegistry = RubyPlugin . getImageDescriptorRegistry ( ) ; protected final static char [ ] VAR_TRIGGER = new char [ ] { \'<STR_LIT:\\t>\' , \'<CHAR_LIT:U+0020>\' , \'<CHAR_LIT:=>\' , \'<CHAR_LIT:;>\' , \'<CHAR_LIT:.>\' } ; private final List fRubyProposals = new ArrayList ( ) ; private final List fKeywords = new ArrayList ( ) ; private final Set fSuggestedMethodNames = new HashSet ( ) ; private final IRubyScript fRubyScript ; private final IRubyProject fRubyProject ; private int fUserReplacementLength ; private IProblem fLastProblem ; private long fStartTime ; private long fUITime ; private RubyContentAssistInvocationContext context ; public CompletionProposalCollector ( RubyContentAssistInvocationContext context ) { this ( context . getProject ( ) , context . getRubyScript ( ) ) ; this . context = context ; } private CompletionProposalCollector ( IRubyProject project , IRubyScript cu ) { fRubyProject = project ; fRubyScript = cu ; fUserReplacementLength = - <NUM_LIT:1> ; } public final IRubyCompletionProposal [ ] getRubyCompletionProposals ( ) { return ( IRubyCompletionProposal [ ] ) fRubyProposals . toArray ( new IRubyCompletionProposal [ fRubyProposals . size ( ) ] ) ; } public final IRubyCompletionProposal [ ] getKeywordCompletionProposals ( ) { return ( IRubyCompletionProposal [ ] ) fKeywords . toArray ( new RubyCompletionProposal [ fKeywords . size ( ) ] ) ; } @ Override public void accept ( CompletionProposal proposal ) { if ( proposal == null ) return ; long start = DEBUG ? System . currentTimeMillis ( ) : <NUM_LIT:0> ; try { if ( isFiltered ( proposal ) ) return ; if ( proposal . getKind ( ) == CompletionProposal . POTENTIAL_METHOD_DECLARATION ) { } else { IRubyCompletionProposal rubyProposal = createRubyCompletionProposal ( proposal ) ; if ( rubyProposal != null ) { fRubyProposals . add ( rubyProposal ) ; if ( proposal . getKind ( ) == CompletionProposal . KEYWORD ) fKeywords . add ( rubyProposal ) ; } } } catch ( IllegalArgumentException e ) { RubyPlugin . log ( new Status ( IStatus . ERROR , RubyPlugin . getPluginId ( ) , IStatus . OK , ""<STR_LIT>"" + String . valueOf ( proposal . getCompletion ( ) ) , e ) ) ; } if ( DEBUG ) fUITime += System . currentTimeMillis ( ) - start ; } protected int computeRelevance ( CompletionProposal proposal ) { final int baseRelevance = proposal . getRelevance ( ) * <NUM_LIT:16> ; switch ( proposal . getKind ( ) ) { case CompletionProposal . KEYWORD : return baseRelevance + <NUM_LIT:2> ; case CompletionProposal . TYPE_REF : return baseRelevance + <NUM_LIT:3> ; case CompletionProposal . METHOD_REF : case CompletionProposal . METHOD_NAME_REFERENCE : case CompletionProposal . METHOD_DECLARATION : return baseRelevance + <NUM_LIT:4> ; case CompletionProposal . POTENTIAL_METHOD_DECLARATION : return baseRelevance + <NUM_LIT:4> ; case CompletionProposal . CONSTANT_REF : case CompletionProposal . CLASS_VARIABLE_REF : case CompletionProposal . INSTANCE_VARIABLE_REF : return baseRelevance + <NUM_LIT:5> ; case CompletionProposal . LOCAL_VARIABLE_REF : case CompletionProposal . VARIABLE_DECLARATION : return baseRelevance + <NUM_LIT:6> ; default : return baseRelevance ; } } protected boolean isFiltered ( CompletionProposal proposal ) { if ( isIgnored ( proposal . getKind ( ) ) ) return true ; return false ; } protected IRubyCompletionProposal createRubyCompletionProposal ( CompletionProposal proposal ) { switch ( proposal . getKind ( ) ) { case CompletionProposal . METHOD_REF : IRubyCompletionProposal proposal2 = createMethodReferenceProposal ( proposal ) ; if ( fSuggestedMethodNames . contains ( proposal2 . getDisplayString ( ) ) ) return null ; fSuggestedMethodNames . add ( proposal2 . getDisplayString ( ) ) ; return proposal2 ; } return createProposal ( proposal ) ; } private IRubyCompletionProposal createMethodReferenceProposal ( CompletionProposal methodProposal ) { boolean fillArgs = RubyPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CODEASSIST_FILL_ARGUMENT_NAMES ) ; if ( fillArgs ) { boolean fillBlockArgs = RubyPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CODEASSIST_FILL_METHOD_BLOCK_ARGUMENTS ) ; String completion = String . valueOf ( methodProposal . getCompletion ( ) ) ; if ( ( completion . length ( ) == <NUM_LIT:0> ) || ( ( completion . length ( ) == <NUM_LIT:1> ) && completion . charAt ( <NUM_LIT:0> ) == \'<CHAR_LIT:)>\' ) || methodProposal . getParameterNames ( )'}]","().length == <NUM_LIT:0> || fillBlockArgs ) { return new FillArgsAndBlockProposal ( methodProposal ) ; } return new FillMethodArgumentsProposal ( methodProposal ) ; } private IRubyCompletionProposal createProposal ( CompletionProposal proposal ) { return new RubyCompletionProposal ( proposal, fLabelProvider, fRegistry ) ; } private boolean isIgnored ( int kind ) { return kind == CompletionProposal. CLASS_VARIABLE_REF ; }",0.0001717436179084202
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . lang . reflect . Type ; import java . util . Arrays ; import java . util . List ; import java . util . Set ; import org . junit . Test ; import com . asakusafw . utils . graph . Graph ; import com . asakusafw . vocabulary . flow . Source ; import com . asakusafw . vocabulary . flow . graph . FlowElement ; import com . asakusafw . vocabulary . flow . graph . FlowElementOutput ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription . Declaration ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription . Parameter ; import com . asakusafw . vocabulary . flow . testing . MockIn ; import com . asakusafw . vocabulary . flow . testing . MockOut ; import com . asakusafw . vocabulary . operator . Branch ; import com . asakusafw . vocabulary . operator . CoGroup ; import com . asakusafw . vocabulary . operator . Convert ; import com . asakusafw . vocabulary . operator . Fold ; import com . asakusafw . vocabulary . operator . GroupSort ; import com . asakusafw . vocabulary . operator . Logging ; import com . asakusafw . vocabulary . operator . MasterBranch ; import com . asakusafw . vocabulary . operator . MasterCheck ; import com . asakusafw . vocabulary . operator . MasterJoin ; import com . asakusafw . vocabulary . operator . MasterJoinUpdate ; import com . asakusafw . vocabulary . operator . Split ; import com . asakusafw . vocabulary . operator . Summarize ; import com . asakusafw . vocabulary . operator . Update ; public class OperatorCompilerTest extends OperatorCompilerTestRoot { @ Test public void types ( ) { start ( new Callback ( ) { @ Override protected void test ( ) { OperatorCompiler compiler = new OperatorCompiler ( ) ; compiler . init ( env . getProcessingEnvironment ( ) ) ; Set < String > supported = compiler . getSupportedAnnotationTypes ( ) ; assertThat ( supported , hasItem ( Branch . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( CoGroup . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Convert . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Fold . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( GroupSort . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Logging . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( MasterBranch . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( MasterCheck . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( MasterJoin . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( MasterJoinUpdate . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Split . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Summarize . class . getName ( ) ) ) ; assertThat ( supported , hasItem ( Update . class . getName ( ) ) ) ; } } ) ; } @ Test public void simple_Factory ( ) { add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new MockOperatorProcessor ( ) ) ; Object factory = create ( loader , ""<STR_LIT>"" ) ; MockIn < String > in = new MockIn < String > ( String . class , ""<STR_LIT>"" ) ; Object example = invoke ( factory , ""<STR_LIT>"" , in , <NUM_LIT:5> ) ; Source < CharSequence > op = output ( CharSequence . class , example , ""<STR_LIT>"" ) ; MockOut < CharSequence > out = new MockOut < CharSequence > ( CharSequence . class , ""<STR_LIT>"" ) ; out . add ( op ) ; FlowElementOutput port = op . toOutputPort ( ) ; FlowElement element = port . getOwner ( ) ; OperatorDescription desc = ( OperatorDescription ) element . getDescription ( ) ; List < Parameter > params = desc . getParameters ( ) ; assertThat ( params . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( params . get ( <NUM_LIT:0>'}]",").name(), is(""<STR_LIT>"")); } @Test public void simple_Factory_with_Parameters ( ) { add ( ""<STR_LIT>"" ) ; ClassLoader loader = start ( new MockOperatorProcessor ( ) ) ; Object factory = create ( loader, ""<STR_LIT>"" ) ; MockIn < String > in = new MockIn < String > ( String. class, ""<STR_LIT>"" ) ; Object example = invoke ( factory, ""<STR_LIT>"", in, <NUM_LIT:5> ) ; Source < CharSequence > op = output ( CharSequence. class, example, ""<STR_LIT>"" ) ; MockOut < CharSequence > out = new MockOut < CharSequence > ( CharSequence. class, ""<STR_LIT>"" ) ; out. add ( op ) ; FlowElementOutput port = op. toOutputPort ( ) ; FlowElement element = port. getOwner ( ) ; OperatorDescription desc = ( OperatorDescription ) element. getDescription ( ) ; List < Parameter > params = desc. getParameters ( ) ; assertThat ( params. size ( ), is ( <NUM_LIT:2> ) ) ; assertThat ( params. get ( <NUM_LIT:0> ). name ( ), is ( ""<",0.0003813151381332462
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . srcgen ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . ISVDBNamedItem ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBModIfcClassParam ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . search . SVDBFindByName ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclItem ; import net . sf . sveditor . core . indent . ISVIndenter ; import net . sf . sveditor . core . indent . SVIndentScanner ; import net . sf . sveditor . core . scanner . SVCharacter ; import net . sf . sveditor . core . scanutils . StringTextScanner ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; public class NewClassGenerator { public void generate ( ISVDBIndexIterator index_it , final IFile file_path , String clsname , String superclass , boolean implement_new , IProgressMonitor monitor ) { String subst_filename = ""<STR_LIT>"" ; if ( monitor == null ) { monitor = new NullProgressMonitor ( ) ; } monitor . beginTask ( ""<STR_LIT>"" , <NUM_LIT:100> ) ; subst_filename = SVCharacter . toSVIdentifier ( file_path . getName ( ) ) ; String template = ""<STR_LIT>"" + ""<STR_LIT>"" + file_path . getName ( ) + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + subst_filename + ""<STR_LIT:n>"" + ""<STR_LIT>"" + subst_filename + ""<STR_LIT:n>"" + ""<STR_LIT:n>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" + clsname + ""<STR_LIT:n>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" ; template += ""<STR_LIT>"" + clsname ; SVDBClassDecl superclass_decl = null ; if ( superclass != null && ! superclass . trim ( ) . equals ( ""<STR_LIT>"" ) ) { monitor . subTask ( ""<STR_LIT>"" ) ; template += ""<STR_LIT>"" + superclass ; if ( index_it != null ) { SVDBFindByName finder = new SVDBFindByName ( index_it ) ; List < ISVDBItemBase > result = finder . find ( superclass , SVDBItemType . ClassDecl ) ; if ( result . size ( ) > <NUM_LIT:0> && result . get ( <NUM_LIT:0> ) . getType ( ) == SVDBItemType . ClassDecl ) { superclass_decl = ( SVDBClassDecl ) result . get ( <NUM_LIT:0> ) ; } } } monitor . worked ( <NUM_LIT> ) ; if ( superclass_decl != null ) { if ( superclass_decl . getParameters ( ) != null && superclass_decl . getParameters ( ) . size ( ) > <NUM_LIT:0> ) { template += ""<STR_LIT>"" ; List < SVDBModIfcClassParam > params = superclass_decl . getParameters ( ) ; for ( int i = <NUM_LIT:0> ; i < params . size ( ) ; i ++ ) { template += params . get ( i ) . getName ( ) ; if ( i + <NUM_LIT:1> < params . size ( ) ) { template += ""<STR_LIT:U+002CU+0020>"" ; } } template += ""<STR_LIT:)>"" ; } } template += ""<STR_LIT>"" ; if ( implement_new ) { monitor . subTask ( ""<STR_LIT>"" ) ; SVDBTask new_func = null ; if ( superclass_decl != null ) { for ( ISVDBChildItem it : superclass_decl . getChildren ( ) ) { if ( it . getType ( ) == SVDBItemType . Function && it instanceof ISVDBNamedItem && ( ( ISVDBNamedItem ) it ) . getName ( ) . equals ( ""<STR_LIT>"" ) ) { new_func = ( SVDBTask ) it ; break ; } } } if ( new_func != null ) { if ( new_func . getParams ( ) != null && new_func . getParams ( ) . size ( ) > <NUM_LIT:0> ) { List < SVDBParamPortDecl > params = new_func . getParams ( ) ; template += ""<STR_LIT:n>"" ; template += ""<STR_LIT>"" ; for ( int i = <NUM_LIT:0> ; i < params . size ( ) ; i ++ ) { SVDBParamPortDecl p = params . get ( i ) ; template += p . getTypeName ( ) + ""<STR_LIT:U+0020>"" ; for ( ISVDBChildItem c : p . getChildren ( ) ) { template += ( ( SVDBVarDeclItem ) c ) .'}]","getName(); } template += ""<STR_LIT:n>"" ; } } monitor.worked(<NUM_LIT>); StringTextScanner scanner = new StringTextScanner(template); SVIndentScanner indent_scanner = new SVIndentScanner(scanner, new SVIndentScanner.IndentStrategy() { @Override public void indent(ISVIndenter indenter, String indent) { indenter.indent(indent); } @Override public void unindent(ISVIndenter indenter, String unindent) { indenter.unindent(unindent); } }); String subst = indent_scanner.scan(); monitor.done(); SVCorePlugin.getCore().generateFile(subst, file_path, monitor); } }",0.0002250455669883319
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . debug . core ; import org . eclipse . core . runtime . CoreException ; import org .'}]","rubypeople.rdt.debug.core.IExpression; import org.rubypeople.rdt.debug.core.IEvaluator; import org.rubypeople.rdt.debug.core.IScope; import org.rubypeople.rdt.debug.core.IScopeContext; import org.rubypeople.rdt.debug.core.IValue; import org.rubypeople.rdt.debug.core.ValueType; import org.rubypeople.rdt.debug.core.ValueTypeResolver; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IStatus; import org.eclipse.debug.core.DebugException; import org.eclipse.debug.core.DebugExceptionStatus; import org.eclipse.debug.core.DebugExceptionStatusConstants; import org.eclipse.debug.core.IDebugContext; import org.eclipse.debug.core.IExpression; import org.eclipse.debug.core.IEvaluator; import org.eclipse.debug.core.IScope; import org.eclipse.debug.core.IScopeContext; import org.eclipse.debug.core.IValue; import org.eclipse.debug.core.ValueType; import org.eclipse.debug.core.ValueTypeResolver; public class DebugValue implements IValue { private final Object value; private final ValueType type; public DebugValue ( Object value, ValueType type ) { super ; this. value = value ; this. type = type ; } public Object getValue ( ) { return value ; } public",0.0003367196888782847
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . nodewrapper ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . ConstNode ; import org . jruby . ast . DefsNode ; import org . jruby . ast . ModuleNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . NodeProvider ; public class ModuleNodeWrapper implements INodeWrapper { private final ModuleNode moduleNode ; private ModuleNodeWrapper parentModule ;'}]",public ModuleNodeWrapper(ModuleNode moduleNode) { this.moduleNode = moduleNode; } public ModuleNode getModuleNode() { return moduleNode; } public ModuleNodeWrapper getParentModule() { return parentModule; } public void setParentModule(ModuleNodeWrapper parentModule) { this.parentModule = parentModule; } public Collection<INodeWrapper> getChildren() { ArrayList<INodeWrapper> children = new ArrayList<INodeWrapper>(); //... add children here... return children; } public void accept(INodeVisitor visitor) { visitor.visit(this); } },0.00016298665753874833
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . jsch ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; import java . util . Set ; import java . util . TreeSet ; import org . junit . Assume ; import org . junit . Before ; import org . junit . Rule ; import org . junit . rules . TemporaryFolder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . yaess . core . ExecutionContext ; import com . asakusafw . yaess . core . ExecutionMonitor ; import com . asakusafw . yaess . core . ExecutionPhase ; import com . asakusafw . yaess . core . ExecutionScript ; import com . asakusafw . yaess . core . ExecutionScriptHandler ; public class SshScriptHandlerTestRoot { static final Logger LOG = LoggerFactory . getLogger ( SshScriptHandlerTestRoot . class ) ; @ Rule public final TemporaryFolder folder = new TemporaryFolder ( ) ; protected File privateKey ; @ Before public void setUp ( ) throws Exception { File home = new File ( System . getProperty ( ""<STR_LIT>"" ) ) ; privateKey = new File ( home , ""<STR_LIT>"" ) . getCanonicalFile ( ) ; if ( privateKey . isFile ( ) == false ) { System . err . printf ( ""<STR_LIT>"" , privateKey ) ; Assume . assumeTrue ( false ) ; } if ( new File ( ""<STR_LIT>"" ) . canExecute ( ) == false ) { System . err . printf ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Assume . assumeTrue ( false ) ; } } protected < T extends ExecutionScript > void execute ( T script , ExecutionScriptHandler < T > handler ) { ExecutionContext context = new ExecutionContext ( ""<STR_LIT:b>"" , ""<STR_LIT:f>"" , ""<STR_LIT:e>"" , ExecutionPhase . MAIN , map ( ) ) ; execute ( context , script , handler ) ; } protected < T extends ExecutionScript > void execute ( ExecutionContext context , T script , ExecutionScriptHandler < T > handler ) { try {'}]","ExecutionMonitor monitor = handler.execute(context, script); finally { monitor.close(); } } }",1.7845640872599712e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . server ; import java . io . IOException ; import java . util . Map ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . rdf . model . Statement ; import com . hp . hpl . jena . sparql . vocabulary . FOAF ; import com . hp . hpl . jena . vocabulary . RDFS ; public class ResourceDescriptionServlet extends HttpServlet { protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { D2RServer server = D2RServer . fromServletContext ( getServletContext ( ) ) ; server . checkMappingFileChanged ( ) ; String relativeResourceURI = request . getRequestURI ( ) . substring ( request . getContextPath ( ) . length ( ) + request . getServletPath ( ) . length ( ) ) ; if ( ! ""<STR_LIT>"" . equals ( relativeResourceURI ) && ""<STR_LIT:/>"" . equals ( relativeResourceURI . substring ( <NUM_LIT:0> , <NUM_LIT:1> ) ) ) { relativeResourceURI = relativeResourceURI .'}]","substring(<NUM_LIT:1>); } Model model = server.getModel(relativeResourceURI); if (model!= null) { response.setContentType(""application/rdf+xml""); response.setCharacterEncoding(""UTF-8""); QueryExecution qexec = QueryExecutionFactory.create(""SELECT * WHERE {?s?p?o }"", model); qexec.exec(); } else { response.sendError(HttpServletResponse.SC_NOT_FOUND); } }",0.00012971888554697694
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . jface . action . LegacyActionTools ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . jface . bindings . keys . KeySequence ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . ITextViewer ; import org . eclipse . jface . text . contentassist . ContentAssistEvent ; import org . eclipse . jface . text . contentassist . ContentAssistant ; import org . eclipse . jface . text . contentassist . ICompletionListener ; import org . eclipse . jface . text . contentassist . ICompletionProposal ; import org . eclipse . jface . text . contentassist . IContentAssistProcessor ; import org . eclipse . jface . text . contentassist . IContentAssistantExtension2 ; import org . eclipse . jface . text . contentassist . IContentAssistantExtension3 ; import org . eclipse . jface . text . contentassist . IContextInformation ; import org . eclipse . jface . text . contentassist . IContextInformationValidator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . PreferencesUtil ; import org . eclipse . ui . keys . IBindingService ; import org . eclipse . ui . texteditor . ITextEditorActionDefinitionIds ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyUIMessages ; import org . rubypeople . rdt . internal . ui . dialogs . OptionalMessageDialog ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . text . ruby . ContentAssistInvocationContext ; public class ContentAssistProcessor implements IContentAssistProcessor { private static final boolean DEBUG = ""<STR_LIT:true>"" . equalsIgnoreCase ( Platform . getDebugOption ( ""<STR_LIT>"" ) ) ; private static final String PREF_WARN_ABOUT_EMPTY_ASSIST_CATEGORY = ""<STR_LIT>"" ; private static final Comparator ORDER_COMPARATOR = new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { CompletionProposalCategory d1 = ( CompletionProposalCategory ) o1 ; CompletionProposalCategory d2 = ( CompletionProposalCategory ) o2 ; return d1 . getSortOrder ( ) - d2 . getSortOrder ( ) ; } } ; private final List fCategories ; private final String fPartition ; private final ContentAssistant fAssistant ; private char [ ] fCompletionAutoActivationCharacters ; private int fRepetition = - <NUM_LIT:1> ; private List < List < CompletionProposalCategory > > fCategoryIteration = null ; private String fIterationGesture = null ; private int fNumberOfComputedResults = <NUM_LIT:0> ; private String fErrorMessage ; public ContentAssistProcessor ( ContentAssistant assistant , String partition ) { Assert . isNotNull ( partition ) ; Assert . isNotNull ( assistant ) ; fPartition = partition ; fCategories = CompletionProposalComputerRegistry . getDefault ( ) . getProposalCategories ( ) ; fAssistant = assistant ; fAssistant . addCompletionListener ( new ICompletionListener ( ) { public void assistSessionStarted ( ContentAssistEvent event ) { if ( event . processor != ContentAssistProcessor . this ) return ; fIterationGesture = getIterationGesture ( ) ; KeySequence binding = getIterationBinding ( ) ; fCategoryIteration = getCategoryIteration ( ) ; for ( Iterator it = fCategories . iterator ( ) ; it . hasNext ( ) ; ) { CompletionProposalCategory cat = ( CompletionProposalCategory ) it . next ( ) ; cat . sessionStarted ( ) ; } fRepetition = <NUM_LIT:0> ; if ( event . assistant instanceof IContentAssistantExtension2 ) { IContentAssistantExtension2 extension = ( IContentAssistantExtension2 ) event . assistant ; if ( fCategoryIteration . size ( ) == <NUM_LIT:1> ) { extension . setRepeatedInvocationMode ( false ) ; extension . setShowEmptyList ( false ) ; } else { extension . setRepeatedInvocationMode ( true ) ; extension . setStatusLineVisible ( true ) ; extension . setStatusMessage ( createIterationMessage ( ) ) ; extension . setShowEmptyList ( true ) ; if ( extension instanceof IContentAssistantExtension3 ) { IContentAssistantExtension3 ext3 = ( IContentAssistantExtension3 ) extension ; ( ( ContentAssistant ) ext3 ) . setRepeatedInvocationTrigger ( binding ) ; } } } } public void assistSessionEnded ( ContentAssistEvent event ) { if ( event . processor != ContentAssistProcessor . this ) return ; for ( Iterator it = fCategories . iterator ( ) ; it . hasNext ( ) ; ) { CompletionProposalCategory cat = ( CompletionProposalCategory ) it . next ( ) ; cat . sessionEnded ( ) ; } fCategoryIteration = null ; fRepetition = - <NUM_LIT:1> ; fIterationGesture = null ; if ( event . assistant instanceof IContentAssistantExtension2 ) { IContentAssistantExtension2 extension = ( IContentAssistantExtension2 ) event . assistant ; extension . setShowEmptyList ( false ) ; extension . setRepeatedInvocationMode ( false ) ; extension . setStatusLineVisible ( false ) ; if ( extension instanceof IContentAssistantExtension3 ) { IContentAssistantExtension3 ext3 = ( IContentAssistantExtension3 ) extension ; ( ( ContentAssistant ) ext3 ) . setRepeatedInvocationTrigger ( null ) ; } } } public void selectionChanged ( ICompletionProposal proposal , boolean smartToggle ) { } } ) ; } public final ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { long start = DEBUG ? System . currentTimeMillis ( ) : <NUM_LIT:0> ; clearState ( ) ; IProgressMonitor monitor = createProgressMonitor ( ) ; monitor . beginTask ( RubyTextMessages . ContentAssistProcessor_computing_proposals , fCategories . size ( ) + <NUM_LIT:1> ) ; ContentAssistInvocationContext context = createContext ( viewer , offset ) ; long setup = DEBUG ? System . currentTimeMillis ( ) : <NUM_LIT:0> ; monitor . subTask ( RubyTextMessages . ContentAssistProcessor_collecting_proposals ) ; List proposals = collectProposals ( viewer ,'}]","context, monitor); long collect = DEBUG? System.currentTimeMillis() : <NUM_LIT:0>; monitor.subTask(RubyTextMessages.ContentAssistProcessor_sorting_proposals); List sortedProposals = new ArrayList(proposals); sortedProposals.sort(ORDER_COMPARATOR); long sort = DEBUG? System.currentTimeMillis() : <NUM_LIT:0>; monitor.worked(1); long end = DEBUG? System.currentTimeMillis() : <NUM_LIT:0>; if (DEBUG) { RubyTextMessages.ContentAssistProcessor_computing_proposals_time = (end - start) + ""ms""; RubyTextMessages.ContentAssistProcessor_collecting_proposals_time = (collect - setup) + ""ms""; RubyTextMessages.ContentAssistProcessor_sorting_proposals_time = (sort - collect) + ""ms""; } return sortedProposals.toArray(new ICompletionProposal[sortedProposals.size()]); } public final ICompletionProposal[] computeCompletionProposals(ContentAssistInvocationContext context) { long start = DEBUG? System.currentTimeMillis() : <NUM_LIT:0>; clearState(); IProgressMonitor monitor = createProgressMonitor(); monitor.beginTask(RubyTextMessages.ContentAssistProcessor_computing_proposals, fCategories.size() + <NUM_L",0.00042730764107780264
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renamelocal . conditionchecks ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . renamelocal . RenameLocalConditionChecker ; import org . rubypeople . rdt . refactoring . core . renamelocal . RenameLocalConfig ; import org . rubypeople . rdt . refactoring . tests . FilePropertyData ; import org . rubypeople . rdt . refactoring . tests . FileTestData ; import org . rubypeople . rdt . refactoring . tests . RefactoringConditionTestCase ; public class RenameLocalConditionTester extends RefactoringConditionTestCase { public RenameLocalConditionTester ( String fileName ) { super ( fileName ) ; } @ Override public void runTest ( ) throws FileNotFoundException , IOException { FilePropertyData testData = new FileTestData ( getName ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; RenameLocalConfig'}]",config = new RenameLocalConfig ( testData. getFilePath ( ) ) ; RenameLocalConditionChecker checker = new RenameLocalConditionChecker ( config ) ; checker. check ( ) ; } },6.44574408120848e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . action ; import org . rubypeople . rdt'}]",".core.api.model.Project; import org.eclipse.jdt.core.dom.AST; import org.eclipse.jdt.core.dom.ASTParser; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.CompilationUnit; import org.eclipse.jdt.core.dom.MethodInvocation; import org.eclipse.jdt.core.dom.SimpleName; import org.eclipse.jdt.core.dom.Type; import org.eclipse.jdt.core.dom.VariableDeclarationFragment; public class RefactoringAction { public static void main ( String [ ] args ) { ASTParser parser = ASTParser. newCompilationUnitParser ( null ) ; parser. setSource ( ""public class MyClass { public static void main(String[] args) { System.out.println(\""Hello, World!\""); } }"" ) ; CompilationUnit unit = ( CompilationUnit ) parser. createAST ( true ) ; unit. root ( ). accept ( new ASTVisitor ( ) { @ Override public boolean visit ( MethodInvocation node ) { System. out. println ( ""Found method invocation: "" + node. getName ( ) ) ; return true ; } @ Override public boolean visit ( VariableDeclarationFragment node ) { System. out. println ( ""Found variable declaration: "" + node. getName ( ) ) ; return true ; } @ Override public",0.0003368443425074997
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . operator ; import java . lang . annotation . Documented ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java .'}]",.lang.annotation.Target;,2.171914604997171e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . parser ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBAddChildItem ; import net . sf . sveditor . core . db . SVDBFieldItem ; import net . sf . sveditor . core . db . SVDBInterfaceDecl ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBLocation ; import net . sf . sveditor . core . db . SVDBModIfcDecl ; import net . sf . sveditor . core . db . SVDBModuleDecl ; import net . sf . sveditor . core . db . SVDBProgramDecl ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; public class SVModIfcProgDeclParser extends SVParserBase { public SVModIfcProgDeclParser ( ISVParser parser ) { super ( parser ) ; } public void parse ( ISVDBAddChildItem parent , int qualifiers ) throws SVParseException { String id ; String module_type_name = null ; SVDBModIfcDecl module = null ; if ( fDebugEn ) { debug ( ""<STR_LIT>"" ) ; } SVDBLocation start = fLexer . getStartLocation ( ) ; String type_name = fLexer . readKeyword ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; SVDBItemType type = null ; if ( type_name . equals ( ""<STR_LIT>"" ) || type_name . equals ( ""<STR_LIT>"" ) ) { type = SVDBItemType . ModuleDecl ; } else if ( type_name . equals ( ""<STR_LIT>"" ) ) { type = SVDBItemType . InterfaceDecl ; } else if ( type_name . equals ( ""<STR_LIT>"" ) ) { type = SVDBItemType . ProgramDecl ; } else { error ( ""<STR_LIT>"" + type_name ) ; } if ( fLexer . peekKeyword ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) { fLexer . eatToken ( ) ; } if ( type == SVDBItemType . ProgramDecl && fLexer . peekOperator ( ""<STR_LIT:;>"" ) ) { module_type_name = ""<STR_LIT>"" ; } else { module_type_name = fLexer . readId ( ) ; } switch ( type ) { case ModuleDecl : module = new SVDBModuleDecl ( module_type_name ) ; break ; case InterfaceDecl : module = new SVDBInterfaceDecl ( module_type_name ) ; break ; case ProgramDecl : module = new SVDBProgramDecl ( module_type_name ) ; break ; } module . setLocation ( start ) ; parent . addChildItem ( module ) ; if ( type != SVDBItemType . ProgramDecl ) { while ( fLexer . peekKeyword ( ""<STR_LIT>"" ) ) { parsers ( ) . impExpParser ( ) . parse_import ( module ) ; } } if ( fLexer . peekOperator ( ""<STR_LIT:#>"" ) ) { module . getParameters ( ) . addAll ( parsers ( ) . paramPortListParser ( ) . parse ( ) ) ; } if ( fLexer . peekOperator ( ""<STR_LIT:(>"" ) ) { List < SVDBParamPortDecl > ports = parsers ( ) . portListParser ( ) . parse ( ) ; for ( SVDBParamPortDecl p : ports ) { p . setParent ( module ) ; } module . getPorts ( ) . addAll ( ports ) ; } fLexer . readOperator ( ""<STR_LIT:;>"" ) ; if ( ( qualifiers & SVDBFieldItem . FieldAttr_Extern ) == <NUM_LIT:0> ) { while ( fLexer . peek ( ) != null && ! fLexer .'}]","isKeyword(""<STR_LIT>"")) { parsers().stmtParser().parse(parent); }",5.3741972026619574e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . modelgen ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public final class Constants { public static final String VERSION = ""<STR_LIT>"" ; public static final Charset OUTPUT_ENCODING = Charset . forName ( ""<STR_LIT:UTF-8>"" ) ; public static final String SOURCE_TABLE = ""<STR_LIT>"" ; public static final String SOURCE_VIEW = ""<STR_LIT>"" ; public static final String CATEGORY_MODEL = ""<STR_LIT>"" ; public static final String CATEGORY_IO = ""<STR_LIT>"" ; private static final String [ ] ENV_PREFIX = { ""<STR_LIT>"" , ""<STR_LIT>"" } ; public static final List < String > ENV_JDBC_PROPERTIES = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final List < String > ENV_BASE_PACKAGE = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final List < String > ENV_OUTPUT = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final List < String > ENV_MODEL_INCLUDES = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final List < String > ENV_MODEL_EXCLUDES = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final List < String > ENV_HEADER_COMENT = buildEnvProperties ( ""<STR_LIT>"" ) ; public static final String K_JDBC_DRIVER = ""<STR_LIT>"" ; public static final String K_JDBC_URL = ""<STR_LIT>"" ; public static final String K_JDBC_USER = ""<STR_LIT>"" ; public static final String K_JDBC_PASSWORD = ""<STR_LIT>"" ; public static final String K_DATABASE_NAME = ""<STR_LIT>"" ; public static final String NAME_OPTION_COPIER = ""<STR_LIT>"" ; public static final String NAME_OPTION_MODIFIER = ""<STR_LIT>"" ; public static final String NAME_OPTION_EXTRACTOR = ""<STR_LIT:get>"" ; public static final String NAME_OPTION_ERASER = ""<STR_LIT>"" ; public static final String NAME_OPTION_ADDER = ""<STR_LIT>"" ; public static final String NAME_OPTION_MAX = ""<STR_LIT>"" ; public static final String NAME_OPTION_MIN'}]","= ""<STR_LIT>"" ; public static final String NAME_OPTION_SUM = ""<STR_LIT>"" ; public static final String NAME_OPTION_AVG = ""<STR_LIT>"" ; public static final String NAME_OPTION_COUNT = ""<STR_LIT>"" ; public static final String NAME_OPTION_DISTINCT = ""<STR_LIT>"" ; public static final String NAME_OPTION_SORT = ""<STR_LIT>"" ; public static final String NAME_OPTION_LIMIT = ""<STR_LIT>"" ; public static final String NAME_OPTION_OFFSET = ""<STR_LIT>"" ; public static final String NAME_OPTION_JOIN = ""<STR_LIT>"" ; public static final String NAME_OPTION_GROUPBY = ""<STR_LIT>"" ; public static final String NAME_OPTION_HAVING = ""<STR_LIT>"" ; public static final String NAME_OPTION_ORDERBY = ""<STR_LIT>"" ; public static final String NAME_OPTION_ASC = ""<STR_LIT>"" ; public static final String NAME_OPTION_DESC = ""<STR_LIT>"" ; public static final String NAME_OPTION_EQUAL = ""<STR_LIT>"" ; public static final String NAME_OPTION_NOT_EQUAL = ""<STR_LIT>"" ; public static final String NAME_OPTION_LESS_THAN = ""<STR_LIT>"" ; public static final String NAME_OPTION_GREATER_THAN = ""<STR_LIT>"" ; public static",0.00036523575050808146
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . argfile . editor ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . ui . editor . CCommentRule ; import org . eclipse . core . filebuffers . IDocumentSetupParticipant ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentExtension3 ; import org . eclipse . jface . text . IDocumentPartitioner ; import org . eclipse . jface . text . rules . EndOfLineRule ; import org . eclipse . jface . text . rules . FastPartitioner ;'}]",import org.eclipse.jface.text.rules.FastPartitioner;,3.1674474551279344e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . launching ; import java . io . File ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . Platform ; import org . rubypeople . rdt . launching . IRubyLaunchConfigurationConstants ; import org . rubypeople . rdt . launching . VMRunnerConfiguration ; public class RubiniusVMRunner extends StandardVMRunner { @ Override protected void addStreamSync ( List < String > arguments ) { } @ Override protected List < String > constructProgramString ( VMRunnerConfiguration config , IProgressMonitor monitor ) throws CoreException { List < String > string = new ArrayList < String > ( ) ; if ( ! Platform . getOS ( ) . equals ( Platform . OS_WIN32 )'}]",") { string.add(MessageFormat.format(IRubyLaunchConfigurationConstants.STRUBINUS_PROGRAM, config.getRubiniusExecutable())); } return string; }",5.6645353312388444e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . spelling . engine ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Locale ;'}]",import java.util.ResourceBundle;,2.4797410889382306e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package jtwitter ; import java . net . MalformedURLException ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public class TwitterEntry { public static final String CREATED_AT = ""<STR_LIT>"" ; public static final String ID = ""<STR_LIT:id>"" ; public static final String TEXT = ""<STR_LIT:text>"" ; private Date createdAt ; private long id ; private String text ; private TwitterUser user ; public static final String TWITTER_DATE_FORMAT = ""<STR_LIT>"" ; public TwitterEntry ( Date createdAt , long id , String text , TwitterUser user ) { super ( ) ; this . createdAt = createdAt ; this . id = id ; this . text = text ; this . user = user ; } public TwitterEntry ( ) { this . user = new TwitterUser ( ) ; } public Date getCreatedAt ( ) { return createdAt ; } public void setCreatedAt ( Date createdAt ) { this . createdAt = createdAt ; } public long getId ( ) { return id ; } public void setId ( long id ) { this . id = id ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public TwitterUser getUser ( ) { return user ; } public void setUser ( TwitterUser user ) { this . user = user ; } @ Override public int hashCode ( ) { final int PRIME = <NUM_LIT:31> ; int result = <NUM_LIT:1> ; result = PRIME * result + ( int ) id ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final TwitterEntry other = ( TwitterEntry ) obj ; if ( id != other . id ) return false ; return true ; } public void addAttribute ( String key , String value ) throws ParseException , MalformedURLException { if ( key . equals ( CREATED_AT ) ) this . setCreatedAt ( makeDate ( value ) ) ; else if ( key . equals ( ID ) ) this . setId ( Long . parseLong ( value ) ) ; else if ( key . equals ( TEXT ) ) this . setText ( value ) ; else if ( key . equals ( TwitterUser . NAME ) ) this . getUser ( ) . setName ( value ) ; else if ( key . equals ( TwitterUser . SCREEN_NAME ) ) this . getUser ( ) . setScreenName ( value ) ; else if ( key . equals ( TwitterUser . LOCATION ) ) this . getUser ('}]",). setLocation ( value ) ; else if ( key. equals ( TwitterUser. PROFILE_IMAGE_URL ) ) this. getUser ( ). setProfileImageURL ( value ) ; else if ( key. equals ( TwitterUser. URL ) ) this. getUser ( ). setURL ( value ) ; else if ( key. equals ( TwitterUser. DESCRIPTION ) ) this. getUser ( ). setDescription ( value ) ; else if ( key. equals ( TwitterUser. FOLLOWERS_COUNT ) ) this. getUser ( ). setFollowersCount ( Long. parseLong ( value ) ) ; else if ( key. equals ( TwitterUser. FRIENDS_COUNT ) ) this. getUser ( ). setFriendsCount ( Long. parseLong ( value ) ) ; else if ( key. equals ( TwitterUser. FAVOURITES_COUNT ) ) this. getUser ( ). setFavouritesCount ( Long. parseLong ( value ) ) ; else if ( key. equals ( TwitterUser. LISTED_COUNT ) ) this. getUser ( ). setListedCount ( Long. parseLong ( value ) ) ; else if ( key. equals ( TwitterUser. STATUS_COUNT ) ) this. getUser ( ). setStatusCount ( Long. parseLong ( value ),0.00036739777908978454
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . io . IOException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . FailedToStopException ; import org . oddjob . Helper ; import org . oddjob . StateSteps ; import org . oddjob . Stoppable ; import org . oddjob . arooa . ArooaConfigurationException ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . MockArooaSession ; import org . oddjob . arooa . life . ComponentPersistException ; import org . oddjob . arooa . parsing . MockArooaContext ; import org . oddjob . arooa . registry . ComponentPool ; import org . oddjob . arooa . registry . MockComponentPool ; import org . oddjob . arooa . runtime . MockRuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeListener ; import org . oddjob . jobs . job . StopJob ; import org . oddjob . state . FlagState ; import org . oddjob . state . JobState ; import org . oddjob . state . ParentState ; import org . oddjob . state . StateOperator ; import org . oddjob . state . WorstStateOp ; public class StructuralJobTest extends TestCase { private static final Logger logger = Logger . getLogger ( StructuralJobTest . class ) ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; logger . info ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } private static class OurStructural extends StructuralJob < Runnable > { private static final long serialVersionUID = <NUM_LIT:1L> ; transient Runnable runnable ; @ Override protected StateOperator getStateOp ( ) { return new WorstStateOp ( ) ; } void setJob ( Runnable c ) { childHelper . insertChild ( <NUM_LIT:0> , c ) ; } protected void execute ( ) { if ( runnable != null ) { runnable . run ( ) ; } } } public void testRunComplete ( ) { final FlagState child = new FlagState ( JobState . COMPLETE ) ; final OurStructural test = new OurStructural ( ) ; test . setJob ( child ) ; test . runnable = new Runnable ( ) { public void run ( ) { child . run ( ) ; assertEquals ( ParentState . EXECUTING , test . lastStateEvent ( ) . getState ( ) ) ; } } ; test . onInitialised ( ) ; test . run ( ) ; assertEquals ( ParentState . COMPLETE , test . lastStateEvent ( ) . getState ( ) ) ; test . hardReset ( ) ; assertEquals ( JobState . READY , child . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( ParentState . READY , test . lastStateEvent ( ) . getState ( ) ) ; } public void testRunInComplete ( ) { final FlagState child = new FlagState ( JobState . INCOMPLETE ) ; final OurStructural test = new OurStructural ( ) ; test . setJob ( child ) ; test . runnable = new Runnable ( ) { public void run ( ) { child . run ( ) ;'}]","assertEquals(ParentState.INCOMPLETE, test.lastStateEvent().getState()); } test.onInitialised(); test.run(); assertEquals(ParentState.INCOMPLETE, test.lastStateEvent().getState()); test.hardReset(); assertEquals(JobState.READY, child.lastStateEvent().getState()); assertEquals(ParentState.READY, test.lastStateEvent().getState()); }",0.00012077448945088819
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import java . lang . annotation . Annotation ; import java . util . Collection ; import java . util . Collections ; import com . asakusafw . testdriver . model . SimpleDataModelDefinition ; public class ValueDefinition < T > implements DataModelDefinition < T > { public static final PropertyName VALUE = PropertyName . newInstance ( ""<STR_LIT:value>"" ) ; private final Class < T > type ; private final PropertyType kind ; public static < T > ValueDefinition < T > of ( Class < T > type ) { return new ValueDefinition < T > ( type ) ; } public ValueDefinition ( Class < T > type ) { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . type = type ; this . kind = SimpleDataModelDefinition . getType ( VALUE , type ) ; if ( kind == null ) { throw new IllegalArgumentException ( type . getName ( ) ) ; } } @ Override public Class < T > getModelClass ( ) { return type ; } @ Override public < A extends Annotation > A getAnnotation ( Class < A > annotationType ) {'}]",return type.getAnnotation(annotationType);,2.7930871154874368e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . pubby . negotiation ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class MediaRangeSpec { private final static Pattern tokenPattern ; private final static Pattern parameterPattern ; private final static Pattern mediaRangePattern ; private final static Pattern qValuePattern ; static { String token = ""<STR_LIT>"" ; String quotedString = ""<STR_LIT>"" ; String parameter = ""<STR_LIT>"" + token + ""<STR_LIT>"" + token + ""<STR_LIT>"" + quotedString + ""<STR_LIT:)>"" ; String qualityValue = ""<STR_LIT>"" ; String quality = ""<STR_LIT>"" ; String regex = ""<STR_LIT:(>"" + token + ""<STR_LIT>"" + token + ""<STR_LIT:)>"" + ""<STR_LIT>"" + parameter + ""<STR_LIT>"" + ""<STR_LIT>"" + quality + ""<STR_LIT>"" + ""<STR_LIT>"" + parameter + ""<STR_LIT>"" ; tokenPattern = Pattern . compile ( token ) ; parameterPattern = Pattern . compile ( parameter ) ; mediaRangePattern = Pattern . compile ( regex ) ; qValuePattern = Pattern . compile ( qualityValue ) ; } public static MediaRangeSpec parseType ( String mediaType ) { MediaRangeSpec m = parseRange ( mediaType ) ; if ( m == null || m . isWildcardType ( ) || m . isWildcardSubtype ( ) ) { return null ; } return m ; } public static MediaRangeSpec parseRange ( String mediaRange ) { Matcher m = mediaRangePattern . matcher ( mediaRange ) ; if ( ! m . matches ( ) ) { return null ; } String type = m . group ( <NUM_LIT:1> ) . toLowerCase ( ) ; String subtype = m . group ( <NUM_LIT:2> ) . toLowerCase ( ) ; String unparsedParameters = m . group ( <NUM_LIT:3> ) ; String qValue = m . group ( <NUM_LIT:7> ) ; m = parameterPattern . matcher ( unparsedParameters ) ; if ( ""<STR_LIT:*>"" . equals ( type ) && ! ""<STR_LIT:*>"" . equals ( subtype ) ) { return null ; } List < String > parameterNames = new ArrayList < String > ( ) ; List < String > parameterValues = new ArrayList < String > ( ) ; while ( m . find ( ) ) { String name = m . group ( <NUM_LIT:1> ) . toLowerCase ( ) ; String value = ( m . group ( <NUM_LIT:3> ) == null ) ? m . group ( <NUM_LIT:2> ) : unescape ( m . group ( <NUM_LIT:3> ) ) ; parameterNames . add ( name ) ; parameterValues . add ( value ) ; } double quality = <NUM_LIT:1.0> ; if ( qValue != null && qValuePattern . matcher ( qValue ) . matches ( ) ) { try { quality = Double . parseDouble ( qValue ) ; } catch ( NumberFormatException ex ) { } } return new MediaRangeSpec ( type , subtype , parameterNames , parameterValues , quality ) ; } public static List < MediaRangeSpec > parseAccept ( String s ) { List < MediaRangeSpec > result = new ArrayList < MediaRangeSpec > ( ) ; Matcher m = mediaRangePattern . matcher ( s ) ; while ( m . find ( ) ) { result . add ( parseRange ( m . group ('}]","()) ); } return result; } public static MediaRangeSpec parseType(String mediaType) { MediaRangeSpec m = parseRange(mediaType); if (m == null || m.isWildcardType() || m.isWildcardSubtype()) { return null; } return m; } public static MediaRangeSpec parseRange(String mediaRange) { Matcher m = mediaRangePattern.matcher(mediaRange); if (!m.matches()) { return null; } String type = m.group(<NUM_LIT:1>).toLowerCase(); String subtype = m.group(<NUM_LIT:2>).toLowerCase(); String unparsedParameters = m.group(<NUM_LIT:3); String qValue = m.group(<NUM_LIT:7); m = parameterPattern.matcher(unparsedParameters); if (""<STR_LIT:*>"".equals(type) &&!""<STR_LIT:*>"".equals(subtype)) { return null; } List<String> parameterNames = new ArrayList<String>(); List<String> parameterValues = new ArrayList<String>(); while (m.find()) { String name = m.group(<NUM_LIT:1>).toLowerCase(); String value = (m.group(<NUM_LIT:3>) == null)? m.group(<NUM_LIT:2>) : unescape(m.group(<NUM_LIT:3",0.00037557487016754776
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . List ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import com . asakusafw . compiler . flow . JobflowCompilerTestRoot ; import com . asakusafw . compiler . flow . processor . flow . LoggingFlowSimple ; import com . asakusafw . compiler . flow . processor . flow . LoggingFlowWithParameter ; import com . asakusafw . compiler . flow . stage . StageModel ; import com . asakusafw . compiler . flow . stage . StageModel . Fragment ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . runtime . core . Report ; import com . asakusafw . runtime . core . Result ; import com . asakusafw . runtime . testing . MockResult ; import com . asakusafw . utils . java . model . syntax . Name ; public class LoggingFlowProcessorTest extends JobflowCompilerTestRoot { @ Override @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; Report . setDelegate ( new Report . Default ( ) ) ; } @ Override @ After public void tearDown ( ) throws Exception { Report . setDelegate ( null ) ; super . tearDown ( ) ; } @ Test public void simple ( ) { List < StageModel > stages = compile ( LoggingFlowSimple . class ) ; Fragment fragment = stages . get ( <NUM_LIT:0> ) . getMapUnits ( ) . get ( <NUM_LIT:0> ) . getFragments ( ) . get ( <NUM_LIT:0> ) ; Name name = fragment . getCompiled ( ) .'}]","getName ( ) ; assertEquals ( ""ex1"", name. toJavaString ( ) ) ; } @Test public void withParameter ( ) { List < StageModel > stages = compile ( LoggingFlowWithParameter. class ) ; Fragment fragment = stages. get ( <NUM_LIT:0> ). getMapUnits ( ). get ( <NUM_LIT:0> ). getFragments ( ). get ( <NUM_LIT:0> ) ; Name name = fragment. getCompiled ( ). getName ( ) ; assertEquals ( ""ex2"", name. toJavaString ( ) ) ; } }",0.0001910775742467467
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; import org . oddjob . arooa . deploy . annotations . ArooaComponent ; import org . oddjob . framework . StructuralJob ; public class EqualsState extends StructuralJob < Stateful > implements Stoppable { private static final long serialVersionUID = <NUM_LIT> ; private StateCondition state = StateConditions . COMPLETE ; public StateCondition getState ( ) { return state ; } @ ArooaAttribute public void setState ( StateCondition state ) { this . state = state ; } @ Override protected StateOperator getStateOp ( ) { return new StateOperator ( ) { public ParentState evaluate ( State ... states ) { if ( states . length == <NUM_LIT:0> ) { return ParentState . READY ; } State state = states [ <NUM_LIT:0> ] ; if ('}]",state.equals(state)) { return ParentState.READY; } return ParentState.STOPPED; } } },4.539329365818421e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core . vocabulary ; public enum StreamProcess implements ConfigurationItem { STREAM_SUPPORT ('}]","true, ""Support the stream"" ), STREAM_SKIP ( false, ""Skip the stream"" ); private final boolean value; private final String description; StreamProcess ( boolean value, String description ) { this. value = value; this. description = description; } @ Override public String toString ( ) { return description; } @ Override public boolean getValue ( ) { return value; } }",4.1725056101003525e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . text . hover ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . ui . editor . SVEditor ; import net . sf . sveditor . ui . editor . actions . SelectionConverter ; import net . sf . sveditor . ui . text . SVWordFinder ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DefaultInformationControl ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IInformationControl ; import org . eclipse . jface'}]",".text. IInformationControlCreator;public class SVHoverInfoControl extends DefaultInformationControl implements IInformationControlCreator { private Shell shell; private SVWordFinder wordFinder; private SVEditor editor; public SVHoverInfoControl ( Shell shell ) { super ( shell, true ) ; this. shell = shell ; } @Override public void setDocument ( IDocument document ) { super. setDocument ( document ) ; if ( document!= null ) { this. editor = new SVEditor ( document ) ; this. wordFinder = new SVWordFinder ( this. editor, new SelectionConverter ( this. editor ) ) ; } } @Override public IInformationControl createInformationControl ( Shell shell, IDocument document ) { return new SVHoverInfoControl ( shell ) ; } @Override public void setEditor ( SVEditor editor ) { this. editor = editor ; } @Override public void setWordFinder ( SVWordFinder wordFinder ) { this. wordFinder = wordFinder ; } public SVWordFinder getWordFinder ( ) { return wordFinder ; } public SVEditor getEditor ( ) { return editor ; } public void showHover ( ISVDBItemBase item ) throws BadLocationException { IInformationControl infoControl = new DefaultInformationControl ( shell,",0.00035009079536102206
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . util ; import java . math . BigInteger ; public final class LiteralAnalyzer { private static final BigInteger MAX_INT = BigInteger . valueOf ( Integer . MAX_VALUE ) . add ( BigInteger . ONE ) ; private static final BigInteger MAX_LONG = BigInteger . valueOf ( Long . MAX_VALUE ) . add ( BigInteger . ONE ) ; private LiteralAnalyzer ( ) { return ; } public static LiteralToken parse ( String literal ) { if ( literal == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LiteralTokenKind kind = LiteralParser . scan ( literal ) ; Object value = valueOf ( kind , literal ) ; return new LiteralToken ( literal , kind , value ) ; } private static Object valueOf ( LiteralTokenKind kind , String literal ) { switch ( kind ) { case BOOLEAN : return booleanValueOf ( literal ) ; case CHAR : return charValueOf ( literal ) ; case DOUBLE : return doubleValueOf ( literal ) ; case FLOAT : return floatValueOf ( literal ) ; case INT : return intValueOf ( literal ) ; case LONG : return longValueOf ( literal ) ; case NULL : return null ; case STRING : return stringValueOf ( literal ) ; case UNKNOWN : return LiteralTokenKind . UNKNOWN ; default : throw new AssertionError ( literal ) ; } } public static boolean booleanValueOf ( String literal ) { if ( LiteralToken . TOKEN_TRUE . equals ( literal ) ) { return true ; } else if ( LiteralToken . TOKEN_FALSE . equals ( literal ) ) { return false ; } else { throw new IllegalArgumentException ( literal ) ; } } public static char charValueOf ( String literal ) { int length = literal . length ( ) ; if ( length < <NUM_LIT:3> || literal . charAt ( <NUM_LIT:0> ) != \'<STR_LIT>\' || literal . charAt'}]","(length - 1)!= '<STR_LIT>' ||!literal.substring(1, length - 1).matches(""[^<STR_LIT>]+"") { throw new IllegalArgumentException(literal); } return literal.charAt(1); } public static double doubleValueOf(String literal) { try { return Double.parseDouble(literal); } catch (NumberFormatException e) { throw new IllegalArgumentException(literal, e); } } public static float floatValueOf(String literal) { try { return Float.parseFloat(literal); } catch (NumberFormatException e) { throw new IllegalArgumentException(literal, e); } } public static int intValueOf(String literal) { try { return Integer.parseInt(literal); } catch (NumberFormatException e) { throw new IllegalArgumentException(literal, e); } } public static long longValueOf(String literal) { try { return Long.parseLong(literal); } catch (NumberFormatException e) { throw new IllegalArgumentException(literal, e); } } public static String stringValueOf(String literal) { return literal; } private static final int NUM_LIT = 4; }",0.0002950514496709846
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . browsing ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . search . ui . NewSearchUI ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveFactory ; import org . eclipse . ui . IPlaceholderFolderLayout ; import org . eclipse . ui . console . IConsoleConstants ; import org . eclipse . ui . progress . IProgressConstants ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . RubyUI ; public class RubyBrowsingPerspectiveFactory implements IPerspectiveFactory { static IRubyElement fgRubyElementFromAction ; public RubyBrowsingPerspectiveFactory ( ) { super ( ) ; } public void createInitialLayout ( IPageLayout layout ) { if ( stackBrowsingViewsVertically ( ) ) createVerticalLayout ( layout ) ; else createHorizontalLayout ( layout ) ; layout . addActionSet ( IDebugUIConstants . LAUNCH_ACTION_SET ) ; layout . addActionSet ( RubyUI . ID_ACTION_SET ) ; layout . addActionSet ( RubyUI . ID_ELEMENT_CREATION_ACTION_SET ) ; layout . addActionSet ( IPageLayout . ID_NAVIGATE_ACTION_SET ) ; layout . addShowViewShortcut ( RubyUI . ID_PROJECTS_VIEW ) ; layout . addShowViewShortcut ( RubyUI . ID_TYPES_VIEW ) ; layout . addShowViewShortcut ( RubyUI . ID_MEMBERS_VIEW ) ; layout . addShowViewShortcut ( NewSearchUI . SEARCH_VIEW_ID ) ; layout . addShowViewShortcut ( IConsoleConstants . ID_CONSOLE_VIEW ) ; layout . addShowViewShortcut ( IPageLayout . ID_OUTLINE ) ; layout . addShowViewShortcut ('}]","PreferenceConstants.ID_RUBY_BROWSING_PREFERENCES); layout.setInitialSize(IPageLayout.ID_EDITOR_AREA, 0.75); } public boolean stackBrowsingViewsVertically() { // implement your logic here } private void createVerticalLayout(IPageLayout layout) { // implement your logic here } private void createHorizontalLayout(IPageLayout layout) { // implement your logic here } }",0.00012289408035865608
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . persistence ; public interface IDBPersistenceTypes { int TYPE_INT_8 = <NUM_LIT:0> ; int TYPE_INT_16 = <NUM_LIT:1> ; int TYPE_INT_32 = <NUM_LIT:2> ; int TYPE_INT_64 = <NUM_LIT:3> ; int TYPE_INT_LIST = <NUM_LIT:4> ; int TYPE_STRING = <NUM_LIT:5> ; int TYPE_STRING_LIST = <NUM_LIT:6> ; int TYPE_NULL = <NUM_LIT:7> ; int TYPE_ITEM = <NUM_LIT:8> ; int TYPE_ITEM_LIST = <NUM_LIT:9> ; int TYPE_BOOL_FALSE = <NUM_LIT:10> ; int TYPE_BOOL_TRUE = <NUM_LIT:11> ;'}]",int TYPE_BOOL = 12;,2.7378455217242727e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . testing . io ; import java . io . IOException ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; import com . asakusafw . testdriver . testing . model . Naming ; public final class NamingOutput implements ModelOutput < Naming > { private final RecordEmitter emitter ; public NamingOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter ='}]",emitter; } @Override public void write ( Naming value ) throws IOException { emitter. emit ( value ); } @Override public void close ( ) throws IOException { emitter. close (); } @Override public void flush ( ) throws IOException { emitter. flush (); } },8.648799238606844e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . filebuffers . FileBuffers ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . ISynchronizable ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IFileEditorInput ; import org . eclipse . ui . editors . text . FileDocumentProvider ; import org . rubypeople . rdt . core . ElementChangedEvent ; import org . rubypeople . rdt . core . IElementChangedListener ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyElementDelta ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . IRubyPartitions ; import org . rubypeople . rdt . ui . text . RubyTextTools ; public class RubyScriptDocumentProvider extends FileDocumentProvider { public interface InputChangeListener { void inputChanged ( IRubyScriptEditorInput input ) ; } protected class RubyScriptSynchronizer implements IElementChangedListener { protected IRubyScriptEditorInput fInput ; protected ISourceFolderRoot fSourceFolderRoot ; public RubyScriptSynchronizer ( IRubyScriptEditorInput input ) { fInput = input ; IRubyElement parent = fInput . getRubyScript ( ) . getParent ( ) ; while ( parent != null && ! ( parent instanceof ISourceFolderRoot ) ) { parent = parent . getParent ( ) ; } fSourceFolderRoot = ( ISourceFolderRoot ) parent ; } public void install ( ) { RubyCore . addElementChangedListener ( this ) ; } public void uninstall ( ) { RubyCore . removeElementChangedListener ( this ) ; } public void elementChanged ( ElementChangedEvent e ) { check ( fSourceFolderRoot , e . getDelta ( ) ) ; } protected boolean check ( ISourceFolderRoot input , IRubyElementDelta delta ) { IRubyElement element = delta . getElement ( ) ; if ( ( delta . getKind ( ) & IRubyElementDelta . REMOVED ) != <NUM_LIT:0> || ( delta . getFlags ( ) & IRubyElementDelta . F_CLOSED ) != <NUM_LIT:0> ) { if ( element . equals ( input . getRubyProject ( ) ) || element . equals ( input ) ) { handleDeleted ( fInput ) ; return true ; } } if ( ( ( delta . getFlags ( ) & IRubyElementDelta . F_ARCHIVE_CONTENT_CHANGED ) != <NUM_LIT:0> ) && input . equals ( element ) ) { handleDeleted ( fInput ) ; return true ; } if ( ( ( delta . getFlags ( ) & IRubyElementDelta . F_REMOVED_FROM_CLASSPATH ) != <NUM_LIT:0> ) && input . equals ( element ) ) { handleDeleted ( fInput ) ; return true ; } IRubyElementDelta [ ] subdeltas = delta . getAffectedChildren ( ) ; for ( int i = <NUM_LIT:0> ; i < subdeltas . length ; i ++ ) { if ( check ( input , subdeltas [ i'}]",) ) { return true; } } return false; } protected void handleDeleted ( IRubyScriptEditorInput input ) { if (! input. isDirty ( ) ) { input. setDirty ( true ) ; } } public void dispose ( ) { RubyCore. removeElementChangedListener ( this ) ; } public void inputChanged ( IRubyScriptEditorInput input ) { fInput = input ; fSourceFolderRoot = ( ISourceFolderRoot ) fInput. getRubyScript ( ). getParent ( ) ; } } },0.0001779250874011228
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . srcgen ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . SVDBScopeItem ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . parser . ParserSVDBFileFactory ; import net . sf . sveditor . core . parser . SVParseException ; import net . sf . sveditor . core . srcgen . MethodGenerator ; import net . sf . sveditor . core . tests . indent . IndentComparator ; public class TestMethodGenerator extends TestCase { private SVDBTask parse_tf ( String content , String name ) throws SVParseException { SVDBScopeItem scope = new SVDBScopeItem ( ) ; ParserSVDBFileFactory parser = new ParserSVDBFileFactory ( null ) ; parser . init ( new StringInputStream ( content ) , name ) ; parser . parsers ( ) . taskFuncParser ( ) . parse ( scope , null , <NUM_LIT:0> ) ; return ( SVDBTask ) scope . getChildren ( ) . iterator ( ) . next ( ) ; } public void testVoidFunction ( ) throws SVParseException { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String exp = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBTask tf = parse_tf ( content , ""<STR_LIT>"" ) ; MethodGenerator gen = new MethodGenerator ( ) ; String src = gen . generate ( tf ) ; log . debug ( ""<STR_LIT>"" + src ) ; IndentComparator . compare ( log , ""<STR_LIT>"" , exp , src ) ; LogFactory . removeLogHandle ( log ) ; } public void testBuiltinRetFunction ( ) throws SVParseException { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String exp = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBTask tf = parse_tf ( content , ""<STR_LIT>"" ) ; MethodGenerator gen = new MethodGenerator ( ) ; String src = gen . generate ( tf ) ; log . debug ( ""<STR_LIT>"" + src ) ; IndentComparator . compare ( log , ""<STR_LIT>"" , exp , src ) ; LogFactory . removeLogHandle ( log ) ; } public void testParamClassRetFunction ( ) throws SVParseException { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String exp = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBTask tf = parse_tf ( content , ""<STR_LIT>"" ) ; MethodGenerator gen = new MethodGenerator ( ) ; String src = gen . generate ( tf ) ; log . debug ( ""<STR_LIT>"" + src ) ; IndentComparator . compare ( ""<STR_LIT>"" , exp , src ) ; LogFactory . removeLogHandle ( log ) ; } public void testParamClassParamFunction ( ) throws SVParseException { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String exp = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBTask tf = parse_tf ( content , ""<STR_LIT>"" ) ; MethodGenerator gen = new MethodGenerator ( ) ; String src = gen . generate ( tf ) ; log . debug ( ""<STR_LIT>"" + src ) ; IndentComparator . compare ( log , ""<STR_LIT>"" , exp , src ) ; LogFactory . removeLogHandle ( log ) ; } public void testRefParamFunction ( ) throws SVParseException { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String exp = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBTask tf = parse_tf ( content , ""<STR_LIT>"" ) ; MethodGenerator gen = new MethodGenerator ( ) ; String src = gen . generate ( tf ) ; log . debug ( ""<STR_LIT>"" + src ) ; IndentComparator . compare ( log , ""<STR_LIT>"" , exp , src ) ; LogFactory . removeLogHandle ( log ) ; } public void testRefVarListParamFunction ( ) throws SVParseException { SVCorePlugin . getDefault ('}]","().enableDebug(false); LogHandle log = LogFactory.getLogHandle(""<STR_LIT>""); String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>""; SVDBTask tf = parse_tf(content, ""<STR_LIT>""); MethodGenerator gen = new MethodGenerator(); String src = gen.generate(tf); log.debug(""<STR_LIT>"" + src); IndentComparator.compare(log, ""<STR_LIT>"", content, src); LogFactory.removeLogHandle(log);",0.000225051784609625
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . semantics . trait ; import java . util . List ; import com . asakusafw . dmdl . model . AstExpression ; import com . asakusafw . dmdl . model . AstSummarize ; import com . asakusafw . dmdl . semantics . Trait ; public class SummarizeTrait implements Trait < SummarizeTrait > { private final AstExpression < AstSummarize > expression ; private final List < ReduceTerm < AstSummarize > > terms ; public SummarizeTrait ( AstExpression < AstSummarize > expression , List < ReduceTerm < AstSummarize > > terms ) { if ( expression'}]","== null || terms == null ) { throw new NullPointerException ( ""expression or terms is null"" ) ; } this. expression = expression ; this. terms = terms ; } @ Override public AstExpression < AstSummarize > getExpression ( ) { return expression ; } @ Override public List < ReduceTerm < AstSummarize > > getTerms ( ) { return terms ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( expression == null )? 0 : expression. hashCode ( ) ) ; result = prime * result + ( ( terms == null )? 0 : terms. hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null || getClass ( )!= obj. getClass ( ) ) return false ; SummarizeTrait other = ( SummarizeTrait ) obj ; if ( expression == null ) { if ( other.expression!= null ) return false ; } else if (!expression.equals ( other. expression ) ) return false ; if ( terms == null ) { if ( other.terms!= null ) return false ; } else if (",0.0003418954567952052
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . pmd ; import java . io . File ; import java . io . FilenameFilter ; import org . rubypeople . rdt . internal . core . util . Util ; public class RubyLanguage implements Language { public static class RubyFileOrDirectoryFilter implements FilenameFilter { public boolean accept ( File dir , String filename ) { return Util . isValidRubyScriptName ( filename ) || ( new File ( dir . getAbsolutePath ( ) + fileSeparator + filename'}]",).isDirectory()); } }...,2.591874632581982e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import java . io . File ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Map ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . Path ; import org . rubypeople . rdt . core . IParent ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . WorkingCopyOwner ; import org . rubypeople . rdt . internal . core . util . MementoTokenizer ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . core . util . Util ; public class SourceFolder extends Openable implements ISourceFolder { public String [ ] names ; public SourceFolder ( SourceFolderRoot parent , String [ ] names ) { super ( parent ) ; this . names = names ; } public boolean hasChildren ( ) throws RubyModelException { return getChildren ( ) . length > <NUM_LIT:0> ; } @ Override protected boolean buildStructure ( OpenableElementInfo info , IProgressMonitor pm , Map newElements , IResource underlyingResource ) throws RubyModelException { if ( ! underlyingResource . isAccessible ( ) ) throw newNotPresentException ( ) ; if ( Util . isExcluded ( this ) ) throw newNotPresentException ( ) ; HashSet vChildren = new HashSet ( ) ; try { SourceFolderRoot root = getSourceFolderRoot ( ) ; char [ ] [ ] inclusionPatterns = root . fullInclusionPatternChars ( ) ; char [ ] [ ] exclusionPatterns = root . fullExclusionPatternChars ( ) ; IResource [ ] members = ( ( IContainer ) underlyingResource ) . members ( ) ; for ( int i = <NUM_LIT:0> , max = members . length ; i < max ; i ++ ) { IResource child = members [ i ] ; if ( child . getType ( ) != IResource . FOLDER && ! Util . isExcluded ( child , inclusionPatterns , exclusionPatterns ) ) { IRubyElement childElement ; if ( Util . isValidRubyScriptName ( child . getName ( ) ) ) { childElement = new RubyScript ( this , child . getName ( ) , DefaultWorkingCopyOwner . PRIMARY ) ; vChildren . add ( childElement ) ; } else if ( Util . isERBLikeFileName ( child . getName ( ) ) ) { childElement = new ERBScript ( this , child . getName ( ) , DefaultWorkingCopyOwner . PRIMARY ) ; vChildren . add ( childElement ) ; } } } } catch ( CoreException e ) { throw new RubyModelException ( e ) ; } IRubyScript [ ] primaryCompilationUnits = getRubyScripts ( DefaultWorkingCopyOwner . PRIMARY ) ; for ( int i = <NUM_LIT:0> , length = primaryCompilationUnits . length ; i < length ; i ++ ) { IRubyScript primary = primaryCompilationUnits [ i ] ; vChildren . add ( primary ) ; } IRubyElement [ ] children = new IRubyElement [ vChildren . size ( ) ] ; vChildren . toArray ( children ) ; info . setChildren ( children ) ; return true ; } @ Override protected Object createElementInfo ( ) { return new SourceFolderInfo ( ) ; } @ Override public int getElementType ( ) { return IRubyElement . SOURCE_FOLDER ; } @ Override public String getElementName ( ) { if ( names . length == <NUM_LIT:0> ) return ""<STR_LIT>"" ; return Util . concatWith ( this . names , File . separatorChar ) ; } public boolean containsRubyResources ( ) throws RubyModelException { return ( ( SourceFolderInfo ) getElementInfo ( ) ) . containsRubyResources ( ) ; } public IRubyScript createRubyScript ( String name , String contents , boolean force , IProgressMonitor monitor ) throws RubyModelException { CreateRubyScriptOperation op = new CreateRubyScriptOperation ( this , name , contents , force ) ; op . runOperation ( monitor ) ; return new RubyScript ( this , name , DefaultWorkingCopyOwner . PRIMARY ) ; } public Object [ ] getNonRubyResources ( ) throws RubyModelException { if ( this . isDefaultPackage ( ) ) { return RubyElementInfo . NO_NON_RUBY_RESOURCES ; } else { return ( ( SourceFolderInfo ) getElementInfo ( ) ) . getNonRubyResources ( getResource ( ) , getSourceFolderRoot ( ) ) ; } } public boolean isDefaultPackage ( ) { return this . names . length == <NUM_LIT:0> ; } public IRubyScript [ ] getRubyScripts ( ) throws RubyModelException { ArrayList < IRubyElement > list = getChildrenOfType ( SCRIPT ) ; IRubyScript [ ] array = new IRubyScript [ list . size ( ) ] ; list . toArray ( array ) ; return array ; } public IRubyScript [ ] getRubyScripts ( WorkingCopyOwner owner ) throws RubyModelException { IRubyScript [ ] workingCopies = RubyModelManager . getRubyModelManager ( ) . getWorkingCopies ( owner , false ) ; if ( workingCopies == null ) return RubyModelManager . NO_WORKING_COPY ; int length = workingCopies . length ; IRubyScript [ ] result = new IRubyScript [ length ] ; int index = <NUM_LIT:0> ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { IRubyScript wc = workingCopies [ i ] ; if ( equals ( wc . getParent ( ) ) && ! Util . isExcluded ( wc ) ) { result [ index ++ ] = wc ; } } if ( index != length ) { System . arraycopy ( result , <NUM_LIT:0> , result = new IRubyScript [ index ] , <NUM_LIT:0> , index ) ; } return result ; } public IPath getPath ( ) { SourceFolderRoot root = this . getSourceFolderRoot ( ) ; IPath path = root . getPath ( ) ; for ( int i = <NUM_LIT:0> , length = this . names . length ; i < length ; i ++ ) { String name = this . names [ i ] ; path = path . append ( name ) ; } return path ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof SourceFolder ) ) return false ; SourceFolder other = ( SourceFolder ) o ; return Util . equalArraysOrNull ( this . names , other . names ) && this . parent . equals ( other . parent ) ; } public boolean exists ( ) { return super . exists ( ) && ! Util . isExcluded ( this ) ; } public IResource getResource ( ) { SourceFolderRoot root = this . getSourceFolderRoot ( ) ;'}]",IContainer container = root.getResource(); for (int i = <NUM_LIT:0>; i < this.names.length; i++) { String name = this.names[i]; container = container.getFolder(name); } return container; } },0.00010854451824499317
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . movemethod ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = ""<STR_LIT>"" ; public static String MethodMover_An ; public static String MethodMover_DuToNameConflicts ; public static String MethodMover_ForField ;'}]",public static String MethodMover_MoveMethod ; public static String MethodMover_NoMethod ; public static String MethodMover_NoMethods ; public static String MethodMover_MoveMethodDescription ; public static String MethodMover_MoveMethodDescription2 ; },7.702466015687268e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . testunit . launcher ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . util . RubyElementVisitor ; public class TestSearchEngine { public static IType [ ] findTests ( final IFile file ) { IRubyScript script = RubyCore .'}]","getInstance().getScript(file); return script == null? new IType[0] : script.getTests(); } public static List<IRubyElement> findElements(final IFile file) { IRubyScript script = RubyCore.getInstance().getScript(file); return script == null? new ArrayList<>() : script.getElements(); } public static IProject getProject(final IFile file) { return RubyPlugin.getDefault().getProject(file.getProject()); } public static void assertTestFile(final IFile file) throws CoreException { IProject project = getProject(file); if (!project.hasNature(RubyPlugin.RUBY_NATURE_ID)) { throw new RubyModelException(""File is not a Ruby test file""); } } public static void assertScriptFile(final IFile file) throws CoreException { IProject project = getProject(file); if (!project.hasNature(RubyPlugin.RUBY_NATURE_ID)) { throw new RubyModelException(""File is not a Ruby script file""); } } public static void assertElementVisitor(IRubyElement element, RubyElementVisitor visitor) { visitor.visit(element); } }",0.0003057747278339097
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . index . persistence ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . util . ArrayList ; import junit . framework . TestCase ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . index . SVDBBaseIndexCacheData ; import net . sf . sveditor . core . db . index . SVDBDeclCacheItem ; import net . sf . sveditor . core . db . persistence . DBFormatException ; import net . sf . sveditor . core . db . persistence . DBWriteException ; import'}]","net.sf.sveditor.core.db.persistence.SVDBPersistenceManager; public class PersistenceTest extends TestCase { private SVDBPersistenceManager manager; private ByteArrayOutputStream baos; private DataOutputStream dos; private ByteArrayInputStream bais; private DataInputStream dis; private ArrayList<SVDBBaseIndexCacheData> data; private ArrayList<SVDBDeclCacheItem> items; public PersistenceTest ( String name ) { super ( name ) ; } protected void setUp ( ) throws DBWriteException, DBFormatException { baos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( baos ) ; manager = new SVDBPersistenceManager ( dos ) ; data = new ArrayList<SVDBBaseIndexCacheData> ( ) ; items = new ArrayList<SVDBDeclCacheItem> ( ) ; } protected void tearDown ( ) throws IOException { baos. close ( ) ; dos. close ( ) ; bais = new ByteArrayInputStream ( baos. toByteArray ( ) ) ; dis = new DataInputStream ( bais ) ; } public void testPersistence ( ) throws DBWriteException, DBFormatException, IOException { //... } }",0.0002971540034012615
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . widgets . property ; import java . util . Map . Entry ; class PropertyPair { String name ; String value ; public PropertyPair ( final String name , final String value ) { this . name = name ; this . value = value ; } public PropertyPair ( final Entry entry ) { this ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } public final String getName'}]",() { return name; } public final String getValue() { return value; } },1.385846415959945e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api . plus . activity ; public interface ActivityOperations { Activity getActivity ( String id ) ;'}]",List<Activity> getActivityFeed(String userId);,2.7130912420337807e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . inlinelocal ; import java . util . Collection ; import org . jruby . ast . MethodDefNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentProvider ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . LocalNodeWrapper ; public class InlineLocalConfig implements IRefactoringConfig { private boolean replaceTempWithQuery ; private String newMethodName = ""<STR_LIT>"" ; private IDocumentProvider docProvider ; private int caretPosition ; private MethodDefNode enclosingMethod ; private Node enclosingScopeNode ; private LocalNodeWrapper selectedItem ; private String selectedItemName ; private LocalNodeWrapper definitionNode ; private Collection < LocalNodeWrapper > localOccurrences ; public InlineLocalConfig ( DocumentProvider docProvider , int caretPosition ) { this . docProvider = docProvider ; this . caretPosition = caretPosition ; } public boolean isReplaceTempWithQuery ( ) { return replaceTempWithQuery ; } public void setReplaceTempWithQuery ( boolean replaceTempWithQuery ) { this . replaceTempWithQuery = replaceTempWithQuery ; } public String getNewMethodName ( ) { return newMethodName ; } public void setNewMethodName ( String newMethodName ) { this . newMethodName = newMethodName ; } public IDocumentProvider getDocumentProvider ( ) { return docProvider ; } public int getCaretPosition ( ) { return caretPosition ; } public String getActiveFileName ( ) { return docProvider . getActiveFileName ( ) ; } public LocalNodeWrapper getDefinitionNode ( ) { return definitionNode ; } public MethodDefNode'}]",getEnclosingMethod ( ) { return enclosingMethod ; },3.820597392316168e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . IField ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . ITypeHierarchy ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . WorkingCopyOwner ; import org . rubypeople . rdt . core . search . SearchEngine ; import org . rubypeople . rdt . internal . core . util . MementoTokenizer ; public class RubyType extends NamedMember implements IType { private static final String [ ] CORE_NAMES = new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:String>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ; public RubyType ( RubyElement parent , String name ) { super ( parent , name ) ; } public String getSuperclassName ( ) throws RubyModelException { if ( isCoreClass ( ) && ! isCoreStub ( ) ) { IType type = getCoreClass ( getElementName ( ) ) ; if ( type != null ) return type . getSuperclassName ( ) ; } RubyTypeElementInfo info = ( RubyTypeElementInfo ) getElementInfo ( ) ; return info . getSuperclassName ( ) ; } private boolean isCoreStub ( ) throws RubyModelException { ISourceFolderRoot root = ( ISourceFolderRoot ) getAncestor ( IRubyElement . SOURCE_FOLDER_ROOT ) ; return root . equals ( getCoreStubRoot ( ) ) ; } private IType getCoreClass ( String elementName ) throws RubyModelException { ISourceFolderRoot root = getCoreStubRoot ( ) ; if ( root == null ) return null ; ISourceFolder folder = root . getSourceFolder ( new String [ <NUM_LIT:0> ] ) ; IRubyScript script = folder . getRubyScript ( elementName . toLowerCase ( ) + ""<STR_LIT>"" ) ; return script . getType ( elementName ) ; } private ISourceFolderRoot getCoreStubRoot ( ) throws RubyModelException { ISourceFolderRoot [ ] roots = getRubyProject ( ) . getSourceFolderRoots ( ) ; for ( int i = <NUM_LIT:0> ; i < roots . length ; i ++ ) { IPath path = roots [ i ] . getPath ( ) ; String string = path . toPortableString ( ) ; if ( string . contains ( ""<STR_LIT>"" ) ) { return roots [ i ] ; } } return null ; } private boolean isCoreClass ( ) { String name = getElementName ( ) ; for ( int i = <NUM_LIT:0> ; i < CORE_NAMES . length ; i ++ ) { if ( CORE_NAMES [ i ] . equals ( name ) ) return true ; } return false ; } public String [ ] getIncludedModuleNames ( ) throws RubyModelException { RubyTypeElementInfo info = ( RubyTypeElementInfo ) getElementInfo ( ) ; String [ ] modules = info . getIncludedModuleNames ( ) ; if ( ( modules == null || modules . length == <NUM_LIT:0> ) && getFullyQualifiedName ( ) . equals ( ""<STR_LIT>"" ) ) { return new String [ ] { ""<STR_LIT>"" } ; } return modules ; } public boolean isMember ( ) { return getDeclaringType ( ) != null ; } public int getElementType ( ) { return IRubyElement . TYPE ; } public IField getField ( String fieldName ) { if ( fieldName . startsWith ( ""<STR_LIT>"" ) ) return new RubyClassVar ( this , fieldName ) ; if ( fieldName . startsWith ( ""<STR_LIT:@>"" ) ) return new RubyInstVar ( this , fieldName ) ; if ( fieldName . startsWith ( ""<STR_LIT:$>"" ) ) return new RubyGlobal ( this , fieldName ) ; if ( Character . isUpperCase ( fieldName . charAt ( <NUM_LIT:0> ) ) ) return new RubyConstant ( this , fieldName ) ; Assert . isTrue ( false , ""<STR_LIT>"" ) ; return null ; } public IField [ ] getFields ( ) throws RubyModelException { ArrayList list = getChildrenOfType ( CONSTANT ) ; list . addAll ( getChildrenOfType ( INSTANCE_VAR ) ) ; list . addAll ( getChildrenOfType ( CLASS_VAR ) ) ; IField [ ] array = new IField [ list . size ( ) ] ; list . toArray ( array ) ; return array ; } public IMethod getMethod ( String name , String [ ] parameterNames ) { return new RubyMethod ( this , name , parameterNames ) ; } public IMethod [ ] getMethods ( ) throws RubyModelException { ArrayList list = getChildrenOfType ( METHOD ) ; IMethod [ ] array = new IMethod [ list . size ( ) ] ; list . toArray ( array ) ; return array ; } public IType getDeclaringType ( ) { IRubyElement parentElement = getParent ( ) ; while ( parentElement != null ) { if ( parentElement . getElementType ( ) == IRubyElement . TYPE ) { return ( IType ) parentElement ; } else if ( parentElement instanceof IMember ) { parentElement = parentElement . getParent ( ) ; } else { return null ; } } return null ; } public IRubyElement getPrimaryElement ( boolean checkOwner ) { if ( checkOwner ) { RubyScript cu = ( RubyScript ) getAncestor ( SCRIPT ) ; if ( cu . isPrimary ( ) ) return this ; } IRubyElement primaryParent = this . parent . getPrimaryElement ('}]","(checkOwner);if (primaryParent == null) { return this;}return primaryParent;}public String getFullyQualifiedName() {IRubyElement parent = getParent();if (parent == null) { return getElementName();} else if (parent instanceof IType) { IType type = (IType) parent; return type.getFullyQualifiedName() + ""."" + getElementName();} else if (parent instanceof IMember) { return ((IMember) parent).getFullyQualifiedName() + ""."" + getElementName();} else { return getElementName();}}public String getDocumentation() throws RubyModelException {RubyTypeElementInfo info = (RubyTypeElementInfo) getElementInfo();return info.getDocumentation();}public boolean isClass() { return true;}public boolean isModule() { return false;}public boolean isInterface() { return false;}public boolean isEnum() { return false;}public boolean isAbstract() { return false;}public boolean isFinal() { return false;}public boolean isStatic() { return false;}public boolean isStrictFp() { return false;}public boolean isSynthetic() { return false;}public boolean isDeprecated() { return false;}public boolean isProtected() { return false;}",0.00041594845581906914
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . InstanceofExpression ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class InstanceofExpressionImpl extends ModelRoot implements InstanceofExpression { private Expression expression ; private Type type ; @ Override public'}]",void accept(Visitor visitor) { visitor.visit(this); },3.297867595903276e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . actions ; import net . ggtools . grand . filters . GraphFilter ; import net . ggtools . grand . filters . MissingNodeFilter ; import net . ggtools . grand . ui . graph . GraphControlerProvider ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FilterMissingNodesAction extends GraphControlerAction { private static final Log log = LogFactory . getLog ( FilterMissingNodesAction . class ) ; private static'}]",final GraphFilter filter = new MissingNodeFilter();,3.080321717556717e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; public class SVDBProgramDecl extends SVDBModIfcDecl { public SVDBProgramDecl ( ) { super ( ""<STR_LIT>""'}]",", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"" ) ; }",4.9673549728419365e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBForStmt extends SVDBBodyStmt { public SVDBStmt fInitExpr ; public SVDBStmt fTestStmt ; public SVDBStmt fIncrStmt ; public SVDBForStmt ( ) { super ( SVDBItemType . ForStmt ) ; } public SVDBStmt getInitExpr ( ) { return fInitExpr ; } public void setInitStmt ( SVDBStmt stmt ) { fInitExpr = stmt ; } public SVDBStmt getTestExpr ( ) { return fTestStmt ; } public void setTestStmt ( SVDBStmt stmt ) { fTestStmt = stmt ; } public SVDBStmt getIncrStmt ( ) { return fIncrStmt ; } public void setIncrstmt ( SVDBStmt stmt ) { fIncrStmt = stmt ; } public SVDBForStmt duplicate ( ) { return ( SVDBForStmt ) super . duplicate ( ) ; } public void init ( ISVDBItemBase other ) { super . init ( other ) ; SVDBForStmt o = ( SVDBForStmt ) other ; if ( o . fIncrStmt != null ) { fIncrStmt = o . fIncrStmt . duplicate ( ) ; } else { fIncrStmt = null ; } if ( o . fTestStmt != null ) { fTestStmt = o . fTestStmt . duplicate ( ) ; } else { fTestStmt = null ; } if ( o . fInitExpr != null ) { fInitExpr = o . fInitExpr . duplicate ( ) ; } else { fInitExpr = null ; } } @ Override public boolean equals ( ISVDBItemBase obj , boolean full ) { if ( ! super .'}]","equals(obj, full)) return false; SVDBForStmt o = (SVDBForStmt) obj; return (fInitExpr == null? o.fInitExpr == null : fInitExpr.equals(o.fInitExpr)) && (fTestStmt == null? o.fTestStmt == null : fTestStmt.equals(o.fTestStmt)) && (fIncrStmt == null? o.fIncrStmt == null : fIncrStmt.equals(o.fIncrStmt)); } @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + (fInitExpr == null? 0 : fInitExpr.hashCode()); result = 31 * result + (fTestStmt == null? 0 : fTestStmt.hashCode()); result = 31 * result + (fIncrStmt == null? 0 : fIncrStmt.hashCode()); return result; } }",0.00026666891875233253
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; public class VerifyEngine { private final VerifyRule rule ; private final Map < Object , DataModelReflection > expectedRest ; private final Map < Object , DataModelReflection > sawActual ; public VerifyEngine ( VerifyRule rule ) { if ( rule == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . rule = rule ; this . expectedRest = new LinkedHashMap < Object , DataModelReflection > ( ) ; this . sawActual = new HashMap < Object , DataModelReflection > ( ) ; } public VerifyEngine addExpected ( DataModelSource expected ) throws IOException { if ( expected == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } try { while ( true ) { DataModelReflection next = expected . next ( ) ; if ( next == null ) { break ; } Object key = rule . getKey ( next ) ; DataModelReflection old = expectedRest . put ( key , next ) ; if ( old != null ) { throw new IOException ( MessageFormat . format ( ""<STR_LIT>"" , key , old , next ) ) ; } } } finally { expected . close ( ) ; } return this ; } public List < Difference > inspectInput ( DataModelSource input ) throws IOException { if ( input == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } List < Difference > results = new ArrayList < Difference > ( ) ; try { while ( true ) { DataModelReflection actual = input'}]",".next();if (actual == null) {break;}Object key = rule.getKey(actual);DataModelReflection expected = expectedRest.get(key);if (expected == null) {throw new IOException(MessageFormat.format(""<STR_LIT>"", key));}results.add(new Difference(expected, actual));} finally {input.close();}return results;} }",0.00010981958933043318
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . thucydides . showcase . simple . pages ; import net . thucydides . core . annotations . DefaultUrl ; import net . thucydides . core . pages . PageObject ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . WebElement ; import org . openqa . selenium . support . FindBy ; @ DefaultUrl ( ""<STR_LIT>"" ) public class AdvancedSearchPage extends PageObject { private WebElement groupId ; private WebElement artifactId ; private String value ; private WebElement version ; private WebElement packaging ; private WebElement classifier ; private WebElement gavSearchButton ; public AdvancedSearchPage ( WebDriver driver ) { super ( driver ) ; } public void setGroupId ( String value ) { element ( groupId ) . type ( value ) ; } public void setArtifactId ( String value ) { element ( artifactId ) . type ( value ) ; } public void setVersion ( String'}]",value ) { element ( version ). type ( value ) ; } public void setPackaging ( String value ) { element ( packaging ). type ( value ) ; } public void setClassifier ( String value ) { element ( classifier ). type ( value ) ; } public void setGavSearchButton ( ) { element ( gavSearchButton ). click ( ) ; } },0.00011853234545038119
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . docs ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import net . sf . sveditor . core . Tuple ; import net . sf . sveditor . core . docs . model . DocTopic ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; public class DocCommentParser implements IDocCommentParser { private LogHandle fLog ; private IDocTopicManager fDocTopics ; public DocCommentParser ( ) { this ( null ) ; } public DocCommentParser ( IDocTopicManager docTopics ) { fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; fDocTopics = docTopics ; } private static Pattern fPatternHeaderLine = Pattern . compile ( ""<STR_LIT>"" , Pattern . CASE_INSENSITIVE ) ; private static Pattern fPatternIsDocComment = Pattern . compile ( ""<STR_LIT>"" , Pattern . CASE_INSENSITIVE | Pattern . DOTALL ) ; private static Pattern fPatternCodeSectionEnd = Pattern . compile ( ""<STR_LIT>"" , Pattern . CASE_INSENSITIVE ) ; private static Pattern fPatternDefinition = Pattern . compile ( ""<STR_LIT>"" ) ; private static Pattern fPatternCodeSectionStart = Pattern . compile ( ""<STR_LIT>"" , Pattern . CASE_INSENSITIVE ) ; private static Pattern headerLinePattern = Pattern . compile ( ""<STR_LIT>"" ) ; private static Pattern fSummaryPattern = Pattern . compile ( ""<STR_LIT>"" , Pattern . DOTALL ) ; public String isDocComment ( String comment ) { String lines [ ] = DocCommentCleaner . splitCommentIntoLines ( comment ) ; for ( String line : lines ) { Matcher matcher = fPatternIsDocComment . matcher ( line ) ; if ( matcher . matches ( ) ) { if ( fDocTopics == null ) { return matcher . group ( <NUM_LIT:2> ) ; } String keyword = matcher . group ( <NUM_LIT:1> ) . toLowerCase ( ) ; if ( fDocTopics . getTopicType ( keyword ) != null ) { return matcher . group ( <NUM_LIT:2> ) ; } } } return null ; } public DocTopic createDocItemForKeyword ( String keyword , String topicTitle ) { DocKeywordInfo kwi = fDocTopics . getTopicType ( keyword . toLowerCase ( ) ) ; if ( kwi == null ) { return null ; } DocTopic docItem ; String topicTypeName = kwi . getTopicType ( ) . getName ( ) ; docItem = new DocTopic ( topicTitle , topicTypeName , keyword ) ; return docItem ; } public void parse ( String comment , List < DocTopic > docTopics ) { String lines [ ] = DocCommentCleaner . splitCommentIntoLines ( comment ) ; try { DocCommentCleaner . clean ( lines ) ; parseComment ( lines , docTopics ) ; } catch ( Exception e ) { fLog . error ( ""<STR_LIT>"" , e ) ; } } enum TagType { POSSIBLE_OPENING_TAG , POSSIBLE_CLOSING_TAG , NOT_A_TAG } ; public int parseComment ( String lines [ ] , List < DocTopic > docTopics ) { int topicCount = <NUM_LIT:0> ; boolean prevLineBlank = true ; boolean inCodeSection = false ; int index = <NUM_LIT:0> ; String title = null ; String keyword = null ; int bodyStart = <NUM_LIT:0> ; int bodyEnd = <NUM_LIT:0> ; Tuple < String , String > tupleKeywordTitle = new Tuple < String , String > ( null , null ) ; while ( index < lines . length ) { if ( inCodeSection ) { if ( fPatternCodeSectionEnd . matcher ( lines [ index ] ) . matches ( ) ) { inCodeSection = false ; } prevLineBlank = false ; bodyEnd ++ ; } else if ( lines [ index ] . length ( ) == <NUM_LIT:0> ) { prevLineBlank = true ; if ( topicCount != <NUM_LIT:0> ) { bodyEnd ++ ; } } else if ( prevLineBlank && parseHeaderLine ( tupleKeywordTitle , lines [ index ] ) ) { if ( topicCount != <NUM_LIT:0> ) { String body = formatBody ( lines , bodyStart , bodyEnd ) ; String summary = ""<STR_LIT>"" ; if ( body != null ) { summary = getSummaryFromBody ( body ) ; } DocTopic newDocItem = createDocItemForKeyword ( keyword , title ) ; newDocItem . setBody ( body ) ; newDocItem . setSummary ( summary ) ; docTopics . add ( newDocItem ) ; } keyword = tupleKeywordTitle . first ( ) ; title = tupleKeywordTitle . second ( ) ; bodyStart = index + <NUM_LIT:1> ; bodyEnd = index + <NUM_LIT:1> ; topicCount ++ ; prevLineBlank = false ; } else if ( topicCount != <NUM_LIT:0> ) { prevLineBlank = false ; bodyEnd ++ ; if ( fPatternCodeSectionStart . matcher ( lines [ index ] ) . matches ( ) ) { inCodeSection = true ; } } index ++ ; } if ( topicCount != <NUM_LIT:0> ) { String body = formatBody ( lines , bodyStart , bodyEnd ) ; String summary = ""<STR_LIT>"" ; if ( body != null ) { summary = getSummaryFromBody ( body ) ; } DocTopic newTopic = createDocItemForKeyword ( keyword , title ) ; newTopic . setBody ( body ) ; newTopic . setSummary ( summary ) ; docTopics . add ( newTopic ) ; topicCount ++ ; } return topicCount ; } private boolean parseHeaderLine ( Tuple < String , String > tupleKeywordTitle , String line ) { Matcher matcher = fPatternHeaderLine . matcher ( line ) ; if'}]","matcher.matches()) { Matcher definitionMatcher = fPatternDefinition.matcher(line); if (definitionMatcher.matches()) { keyword = definitionMatcher.group(1); title = definitionMatcher.group(2); } else { Matcher keywordMatcher = fPatternIsDocComment.matcher(line); if (keywordMatcher.matches()) { keyword = keywordMatcher.group(1).toLowerCase(); title = keywordMatcher.group(2); } else { return false; } } return true; } return false; } private String formatBody(String lines[], int bodyStart, int bodyEnd) { StringBuilder body = new StringBuilder(); for (int i = bodyStart; i < bodyEnd; i++) { if (lines[i].length() > 0) { body.append(lines[i]).append(""\n""); } } return body.toString(); } private String getSummaryFromBody(String body) { Pattern pattern = Pattern.compile(""<STR_LIT>"", Pattern.CASE_INSENSITIVE | Pattern.DOTALL); Matcher matcher = pattern.matcher(body); if (matcher.find()) { return matcher.group(); } return null; } }",0.00034604357112504654
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . arooa . types ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . ConsoleCapture ; import org . oddjob . Oddjob ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . ParentState ; public class ListTypeExamplesTest extends TestCase { private static final Logger logger = Logger . getLogger ( ListTypeExamplesTest . class ) ; public void testFruitExample ( ) { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . setArgs ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; ConsoleCapture console = new ConsoleCapture ( ) ; console . capture ( Oddjob . CONSOLE ) ; oddjob . run ( ) ; assertEquals ( ParentState . COMPLETE , oddjob . lastStateEvent ( ) . getState ( ) ) ; console . close ( ) ; console . dump ( logger ) ; String [ ] lines = console . getLines ('}]",") ; for ( String line : lines ) { if ( line. contains ( ""1 apple"" ) || line. contains ( ""2 banana"" ) ) { fail ( ""Expected '1 apple' or '2 banana' in output"" ) ; } } } }",8.886495597679438e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . expr . SVDBExpr ; public class SVDBConstraintDistListItem extends SVDBStmt { public SVDBExpr fLHS ; public SVDBExpr fRHS ; public boolean fIsDist ; public SVDBConstraintDistListItem ( ) { super ( SVDBItemType . ConstraintDistListItem ) ; } public void setLHS ( SVDBExpr lhs ) { fLHS = lhs ; } public SVDBExpr getLHS ( ) { return fLHS ; } public void setRHS ( SVDBExpr rhs ) { fRHS = rhs ; } public SVDBExpr getRHS ( ) { return fRHS ; }'}]",public void setIsDist(boolean isDist) { fIsDist = isDist; },3.86471946866754e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . apache . camel . example . reportincident . dao . impl ; import org . apache . camel . example . reportincident . dao . IncidentDAO ; import org . apache . camel . example . reportincident . model . Incident ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . persistence . EntityManager ; import javax . persistence . Query ; import java . util . List ; public class IncidentDAOImpl implements IncidentDAO { private static final transient Log LOG = LogFactory . getLog ( IncidentDAOImpl . class ) ; private EntityManager em ; private static final String findIncidentByReference = ""<STR_LIT>"" ; private static final String findIncident = ""<STR_LIT>"" ; public void setEntityManager ( EntityManager e ) { em = e ; } public List < Incident > findIncident ( ) { Query q = this . em . createQuery ( ""<STR_LIT>"" ) ; List list = q . getResultList ( ) ; return list ; } public'}]","List<Incident> findIncidentByReference(String reference) { Query q = this.em.createQuery(findIncidentByReference); List list = q.setParameter(""reference"", reference).getResultList(); return list; }",7.227274710764054e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . event ; import java . lang . ref . WeakReference ; import java . lang . reflect . Method ; import java . util . Iterator ; import java . util . LinkedList ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class EventManager implements Runnable { private final class DispatchEventAction implements Runnable { private final Dispatcher dispatcher ; private final Object event ; public DispatchEventAction ( final Object event , final Dispatcher dispatcher ) { this . event = event ; this . dispatcher = dispatcher ; } public void run ( ) { dispatchOneEvent ( event , dispatcher ) ; } } private final class SubscriptionAction implements Runnable { private Object subscriber ; public SubscriptionAction ( final Object subscriber ) { this . subscriber = subscriber ; } public void run ( ) { doSubscribtion ( subscriber ) ; } } private final class UnsubscriptionAction implements Runnable { private Object subscriber ; public UnsubscriptionAction ( final Object subscriber ) { this . subscriber = subscriber ; } public void run ( ) { doUnsubscription ( subscriber ) ; } } private static final Log log = LogFactory . getLog ( EventManager . class ) ; private boolean defaultDispatchAsynchronous = true ; private final DispatcherFactory dispatcherFactory ; private Thread dispatcherThread ; private final LinkedList < Runnable > eventQueue = new LinkedList < Runnable > ( ) ; private final LinkedList < WeakReference < Object > > listenerList = new LinkedList < WeakReference < Object > > ( ) ; private final String name ; public EventManager ( ) { this ( ""<STR_LIT>"" ) ; } public EventManager ( final String name ) { this . name = name ; dispatcherThread = new Thread ( this , ""<STR_LIT>"" + name ) ; dispatcherThread . start ( ) ; dispatcherFactory = DispatcherFactory . getInstance ( ) ; } public void clear ( ) { if ( log . isInfoEnabled ( ) ) { log . info ( ""<STR_LIT>"" ) ; } synchronized ( eventQueue ) { eventQueue . clear ( ) ; } synchronized ( listenerList ) { listenerList . clear ( ) ; } } public Dispatcher createDispatcher ( final Method method ) { return dispatcherFactory . createDispatcher ( this , method ) ; } final public String getName ( ) { return name ; } public boolean isDefaultDispatchAnsynchronous ( ) { return defaultDispatchAsynchronous ; } public void run ( ) { while ( true ) { Runnable nextEvent ; do { nextEvent = null ; synchronized ( eventQueue ) { if ( ! eventQueue . isEmpty ( ) ) { nextEvent = eventQueue . removeFirst ( ) ; } } if ( nextEvent != null ) { nextEvent . run ( ) ; } } while ( nextEvent != null ) ; try { synchronized ( eventQueue ) { eventQueue . wait ( ) ; } } catch ( final InterruptedException e ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" ) ; } } } } public void setDefaultDispatchAnsynchronous ( final boolean defaultDispatchAnsynchronous ) { defaultDispatchAsynchronous = defaultDispatchAnsynchronous ; } public void subscribe ( final Object listener ) { synchronized ( eventQueue ) { eventQueue . add ( new SubscriptionAction ( listener ) ) ; } } public void unSubscribe ( final Object listener ) {'}]",synchronized ( listenerList ) { listenerList. remove ( new WeakReference < Object > ( listener ) ) ; } } },2.2808845899582793e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . jobqueue ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . Test ; import com . asakusafw . yaess . core . HadoopScriptHandler ; import com . asakusafw . yaess . core . ProfileContext ; import com . asakusafw . yaess . core . ServiceProfile ; import com . asakusafw . yaess . core . VariableResolver ; import com . asakusafw . yaess . jobqueue . client . HttpJobClient ; import com . asakusafw . yaess . jobqueue . client . JobClient ; public class JobClientProfileTest { @ Test public void convert ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile profile = JobClientProfile . convert ( original ) ; assertThat ( profile . getPrefix ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( profile . getTimeout ( ) , is ( JobClientProfile . DEFAULT_TIMEOUT ) ) ; assertThat ( profile . getPollingInterval ( ) , is ( JobClientProfile . DEFAULT_POLLING_INTERVAL ) ) ; List < JobClient > clients = profile . getClients ( ) ; assertThat ( clients . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( clients . get ( <NUM_LIT:0> ) , is ( HttpJobClient . class ) ) ; HttpJobClient c0 = ( HttpJobClient ) clients . get ( <NUM_LIT:0> ) ; assertThat ( c0 . getBaseUri ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( c0 . getUser ( ) , is ( nullValue ( ) ) ) ; } @ Test public void convert_explicit ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_TIMEOUT , String . valueOf ( JobClientProfile . DEFAULT_TIMEOUT + <NUM_LIT:1> ) , JobClientProfile . KEY_POLLING_INTERVAL , String . valueOf ( JobClientProfile . DEFAULT_POLLING_INTERVAL + <NUM_LIT:2> ) , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile profile = JobClientProfile . convert ( original ) ; assertThat ( profile . getPrefix ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( profile . getTimeout ( ) , is ( JobClientProfile . DEFAULT_TIMEOUT + <NUM_LIT:1> ) ) ; assertThat ( profile . getPollingInterval ( ) , is ( JobClientProfile . DEFAULT_POLLING_INTERVAL + <NUM_LIT:2> ) ) ; List < JobClient > clients = profile . getClients ( ) ; assertThat ( clients . size ( ) , is ( <NUM_LIT:2> ) ) ; assertThat ( clients . get ( <NUM_LIT:0> ) , is ( HttpJobClient . class ) ) ; assertThat ( clients . get ( <NUM_LIT:1> ) , is ( HttpJobClient . class ) ) ; HttpJobClient c0 = ( HttpJobClient ) clients . get ( <NUM_LIT:0> ) ; assertThat ( c0 . getBaseUri ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( c0 . getUser ( ) , is ( nullValue ( ) ) ) ; HttpJobClient c1 = ( HttpJobClient ) clients . get ( <NUM_LIT:1> ) ; assertThat ( c1 . getBaseUri ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( c1 . getUser ( ) , is ( ""<STR_LIT>"" ) ) ; } @ Test public void convert_resolve ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_TIMEOUT , ""<STR_LIT>"" , JobClientProfile . KEY_POLLING_INTERVAL , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT:url>"" , ""<STR_LIT>"" , ""<STR_LIT:user>"" , ""<STR_LIT>"" , ""<STR_LIT:password>"" , ""<STR_LIT:p>"" , } ) ) ) ) ; JobClientProfile profile = JobClientProfile . convert ( original ) ; assertThat ( profile . getTimeout ( ) , is ( <NUM_LIT> ) ) ; assertThat ( profile . getPollingInterval ( ) , is ( <NUM_LIT> ) ) ; List < JobClient > clients = profile . getClients ( ) ; assertThat ( clients . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( clients . get ( <NUM_LIT:0> ) , is ( HttpJobClient . class ) ) ; HttpJobClient c0 = ( HttpJobClient ) clients . get ( <NUM_LIT:0> ) ; assertThat ( c0 . getBaseUri ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( c0 . getUser ( ) , is ( ""<STR_LIT>"" ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void convert_malform_timeout ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_TIMEOUT , ""<STR_LIT:?>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile . convert ( original ) ; } @ Test ( expected = IllegalArgumentException . class ) public void convert_invalid_timeout ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_TIMEOUT , ""<STR_LIT:-1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile . convert ( original ) ; } @ Test ( expected = IllegalArgumentException . class ) public void convert_malform_interval ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_POLLING_INTERVAL , ""<STR_LIT:?>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile . convert ( original ) ; } @ Test ( expected = IllegalArgumentException . class ) public void convert_invalid_interval ( ) throws Exception { ServiceProfile < ? > original = new ServiceProfile < HadoopScriptHandler > ( ""<STR_LIT>"" , QueueHadoopScriptHandler . class , map ( new String [ ] { JobClientProfile . KEY_POLLING_INTERVAL , ""<STR_LIT:-1>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , } ) , new ProfileContext ( getClass ( ) . getClassLoader ( ) , new VariableResolver ( map ( new String [ ] { } ) ) ) ) ; JobClientProfile . convert'}]",(original) ; } },5.3896504350424394e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . melloware . jintellitype ; public interface JIntellitypeConstants { public static final String ERROR_MESSAGE = ""<STR_LIT>"" ; public static final int MOD_ALT = <NUM_LIT:1> ; public static final int MOD_CONTROL = <NUM_LIT:2> ; public static final int MOD_SHIFT = <NUM_LIT:4> ; public static final int MOD_WIN = <NUM_LIT:8> ; public static final int APPCOMMAND_BROWSER_BACKWARD = <NUM_LIT:1> ; public static final int APPCOMMAND_BROWSER_FORWARD = <NUM_LIT:2> ; public static final int APPCOMMAND_BROWSER_REFRESH = <NUM_LIT:3> ; public static final int APPCOMMAND_BROWSER_STOP = <NUM_LIT:4> ; public static final int APPCOMMAND_BROWSER_SEARCH = <NUM_LIT:5> ; public static final int APPCOMMAND_BROWSER_FAVOURITES = <NUM_LIT:6> ; public static final int APPCOMMAND_BROWSER_HOME = <NUM_LIT:7> ; public static final int APPCOMMAND_VOLUME_MUTE = <NUM_LIT:8> ; public static final int APPCOMMAND_VOLUME_DOWN = <NUM_LIT:9> ; public static final int APPCOMMAND_VOLUME_UP = <NUM_LIT:10> ; public static final int APPCOMMAND_MEDIA_NEXTTRACK = <NUM_LIT:11> ; public static final int APPCOMMAND_MEDIA_PREVIOUSTRACK = <NUM_LIT:12> ; public static final int APPCOMMAND_MEDIA_STOP = <NUM_LIT> ; public static final int APPCOMMAND_MEDIA_PLAY_PAUSE = <NUM_LIT> ; public static final int APPCOMMAND_LAUNCH_MAIL = <NUM_LIT:15> ; public static final int APPCOMMAND_LAUNCH_MEDIA_SELECT = <NUM_LIT:16> ; public static final int APPCOMMAND_LAUNCH_APP1 = <NUM_LIT> ; public static final int APPCOMMAND_LAUNCH_APP2 = <NUM_LIT> ; public static final int APPCOMMAND_BASS_DOWN = <NUM_LIT> ; public static final int APPCOMMAND_BASS_BOOST = <NUM_LIT:20> ; public static final int APPCOMMAND_BASS_UP = <NUM_LIT> ; public static final int APPCOMMAND_TREBLE_DOWN = <NUM_LIT> ; public static final int APPCOMMAND_TREBLE_UP = <NUM_LIT> ; public static final int APPCOMMAND_MICROPHONE_VOLUME_MUTE = <NUM_LIT:24> ; public static final int APPCOMMAND_MICROPHONE_VOLUME_DOWN = <NUM_LIT> ; public static final int APPCOMMAND_MICROPHONE_VOLUME_UP = <NUM_LIT> ; public static final int APPCOMMAND_HELP = <NUM_LIT> ; public static final int APPCOMMAND_FIND = <NUM_LIT> ; public static final int APPCOMMAND_NEW = <NUM_LIT> ; public static final int APPCOMMAND_OPEN = <NUM_LIT:30> ; public static final int APPCOMMAND_CLOSE = <NUM_LIT:31> ; public static final int APPCOMMAND_SAVE = <NUM_LIT:32> ; public static final int APPCOMMAND_PRINT = <NUM_LIT> ; public static final int APPCOMMAND_UNDO = <NUM_LIT> ;'}]",public static final int APPCOMMAND_MEDIA_PLAY = 13;,4.303146984896146e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . inlinemethod . conditions ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . inlinemethod . InlineMethodConditionChecker ; import org . rubypeople . rdt . refactoring . core . inlinemethod .'}]","InlineMethodRefactoring;public class InlineMethodConditionCheckerTest extends TestCase { private InlineMethodConditionChecker checker ; @ Before public void setUp ( ) throws IOException, FileNotFoundException { checker = new InlineMethodConditionChecker ( new InlineMethodRefactoring ( ) ) ; } @ Test public void testInlineMethodWithOneParameter ( ) { // test implementation } @ Test public void testInlineMethodWithMultipleParameters ( ) { // test implementation } @ Test public void testInlineMethodWithNoParameters ( ) { // test implementation } }",0.00014678551065749152
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import java . util . Collection ; import java . util . Iterator ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . text . ITextOperationTarget ; import org . eclipse . jface . text . source . ISourceViewer ; import org . eclipse . ui . texteditor . ITextEditor ; import org . rubypeople . rdt . internal . ui . text . ruby . CompletionProposalCategory ; import org . rubypeople . rdt . internal . ui . text . ruby . CompletionProposalComputerRegistry ; public final class SpecificContentAssistExecutor { private final CompletionProposalComputerRegistry fRegistry ; public SpecificContentAssistExecutor ( CompletionProposalComputerRegistry registry ) { Assert . isNotNull ( registry ) ; fRegistry = registry ; } public void invokeContentAssist ( final ITextEditor editor , String categoryId ) { Collection < CompletionProposalCategory > categories = fRegistry . getProposalCategories ( ) ; boolean [ ] inclusionState = new boolean [ categories . size ( ) ] ; boolean [ ] separateState = new boolean [ categories . size ( ) ] ; int i = <NUM_LIT:0> ; for ( Iterator < CompletionProposalCategory > it = categories . iterator ( ) ; it . hasNext ( ) ; i ++ ) { CompletionProposalCategory cat = it . next ( ) ; inclusionState [ i ] = cat . isIncluded ( ) ; cat . setIncluded ( cat . getId ( ) . equals ('}]","categoryId)); separateState[i] = cat.isSeparate()); } ISourceViewer sourceViewer = editor.getAdapter(ISourceViewer.class); if (sourceViewer!= null) { sourceViewer.computeCompletionProposals(inclusionState, separateState); } } }",8.686200815249952e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IField ; import org . rubypeople . rdt . core . IImportDeclaration ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . search . IRubySearchConstants ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui .'}]","RubyPluginActivator;public class ImportDeclarationAction extends Action { private IField field; public ImportDeclarationAction(IField field) { this.field = field; } public ImportDeclarationAction() { this.field = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActionBars().getStatusLineManager().getActiveView().getSite().getActionBars().getStatusLineManager().getActiveView().getSelection().getFirstElement(); } @Override public void run() { IImportDeclaration importDeclaration = new ImportDeclaration(field); IWorkbenchSite site = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActionBars().getStatusLineManager().getActiveView().getSite(); ISourceFolder sourceFolder = site.getWorkbench().getRoot().getProject().getNature().getBuild().getSourceFolders()[0]; IMethod method = new Method(importDeclaration, sourceFolder); IRubyScript script = new RubyScript(method, sourceFolder); IType type = new Type(script, sourceFolder); IRubySearchConstants constants = new RubySearchConstants(type, sourceFolder); RubyPluginActivator.getDefault().getSearchService().search(constants); } }",0.00032823909700103256
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import java . text . MessageFormat ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrLocation ; public class JavadocBlockInfo { private IrLocation location ; private String tagName ; private JavadocScanner'}]","scanner; public JavadocBlockInfo(IrLocation location, String tagName, JavadocScanner scanner) { this.location = location; this.tagName = tagName; this.scanner = scanner; } public IrLocation getLocation() { return location; } public String getTagName() { return tagName; } public JavadocScanner getScanner() { return scanner; } }",0.00010405773815710212
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import org . apache . log4j . Logger ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . deploy . annotations . ArooaHidden ; import org . oddjob . arooa . life . ArooaSessionAware ; import org . oddjob . beanbus . BadBeanException ; import org . oddjob . beanbus . BeanBus ; import org . oddjob . beanbus . BeanSheet ; import org . oddjob . beanbus . BusAware ; import org . oddjob . beanbus . BusEvent ; import org . oddjob . beanbus . BusException ; import org . oddjob . beanbus . BusListener ; import org . oddjob . beanbus . CrashBusException ; import org . oddjob . beanbus . StageEvent ; import org . oddjob . beanbus . StageListener ; import org . oddjob . io . StdoutType ; import org . oddjob . util . StreamPrinter ; public class SQLResultsSheet implements SQLResultsProcessor , ArooaSessionAware , BusAware { private static final Logger logger = Logger . getLogger ( SQLResultsSheet . class ) ; private OutputStream output ; private boolean dataOnly ; private ArooaSession session ; private long elapsedTime = System . currentTimeMillis ( ) ; @ Override @ ArooaHidden public void setArooaSession ( ArooaSession session ) { this . session = session ; } @ Override public void accept ( Object bean ) throws BadBeanException { elapsedTime = System . currentTimeMillis ( ) - elapsedTime ; if ( output == null ) { return ; } if ( bean instanceof List < ? > ) { List < ? > iterable = ( List < ? > ) bean ; BeanSheet sheet = new BeanSheet ( ) ; sheet . setOutput ( new FilterOutputStream ( output ) { public void close ( ) throws IOException { } ; { } }'}]","); new StreamPrinter(logger).print(iterable, sheet); } else { BeanSheet sheet = new BeanSheet(); sheet.setOutput(new FilterOutputStream(output) { public void close() throws IOException { } }); new StreamPrinter(logger).print(bean, sheet); } } @Override public void setBus(BeanBus bus) { // do nothing } @Override public void setBusListener(BeanBusListener listener) { // do nothing } @Override public void setOutput(OutputStream output) { this.output = output; } @Override public void setStdoutType(StdoutType type) { // do nothing } @Override public void setStageListener(StageListener listener) { // do nothing } @Override public void setStageName(String name) { // do nothing } @Override public void setStageName(String name, BusEvent event) { // do nothing } @Override public void setBusException(CrashBusException exception) { // do nothing } @Override public void setBusException(BusException exception) { // do nothing } @Override public void setBusException(BusException exception, BusEvent event) { // do nothing } @Override public void setBusException(BusException exception, BusEvent event, StageEvent stageEvent) { // do nothing }",0.0003606180899001929
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . value ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . text . MessageFormat ; import org . apache . hadoop . io . WritableComparator ; import com . asakusafw . runtime . io . util . WritableRawComparable ; public final class FloatOption extends ValueOption < FloatOption > { private float value ; public FloatOption ( ) { super ( ) ; } public FloatOption ( float value ) { super ( ) ; this . value = value ; this . nullValue = false ; } public float get ( ) { if ( nullValue ) { throw new NullPointerException ( ) ; } return value ; } public float or ( float alternate ) { if ( nullValue ) { return alternate ; } return value ; } public void add ( float delta ) { if ( nullValue ) { throw new NullPointerException ( ) ; } this . value += delta ; } public void add ( FloatOption other ) { if ( nullValue ) { throw new NullPointerException ( ) ; } if ( other . nullValue ) { return ; } this . value += other . value ; } @ Deprecated public FloatOption modify ( float newValue ) { this'}]",".value = newValue; return this; } @Override public void write(DataOutput out) throws IOException { WritableRawComparable.writeFloat(value, out); } @Override public void readFields(DataInput in) throws IOException { value = WritableRawComparable.readFloat(in); } @Override public String toString() { return MessageFormat.format(""FloatOption[value={0}]"", value); } @Override public int compareTo(FloatOption o) { return Float.compare(value, o.value); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + (int) (value ^ (value >>> 32)); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass()!= obj.getClass()) return false; FloatOption other = (FloatOption) obj; return Float.floatToIntBits(value) == Float.floatToIntBits(other.value); } @Override public FloatOption clone() { return new FloatOption(value); } @Override public int sizeInBytes() { return WritableRawComparable.sizeInBytes(value); } @Override public int compareTo(ValueOption o) { if (o instanceof FloatOption) { return compareTo((FloatOption)",0.0003470051469966355
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . common ; import static org . junit . Assert . * ; import java . sql . Connection ; import java . sql . SQLException ; import java . util . Arrays ; import java . util . Properties ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . testutil . UnitTestUtil ; public class DBConnectionTest { private static String targetName = ""<STR_LIT>"" ; private static String jobflowId = ""<STR_LIT>"" ; private static String executionId = ""<STR_LIT>"" ; @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { UnitTestUtil . setUpBeforeClass ( ) ; UnitTestUtil . setUpEnv ( ) ; } @ AfterClass public static void tearDownAfterClass ( ) throws Exception { UnitTestUtil . tearDownAfterClass ( ) ; } @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { } @ Test public void getConnectionTest01 ( ) throws Exception { Connection conn = null ; try { BulkLoaderInitializer . initDBServer ( jobflowId , executionId , Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) , targetName ) ; UnitTestUtil . startUp ( ) ; conn = DBConnection . getConnection ( ) ; DBConnection . closePs ( null ) ; DBConnection . closeRs ( null ) ; DBConnection . closeConn ( null ) ; DBConnection . closeConn ( conn ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( ) ; } finally { DBConnection . closeConn ( conn ) ; } } @ Test public void getConnectionTest02 ( ) throws Exception { Connection conn = null ; try { BulkLoaderInitializer . initDBServer ( jobflowId , executionId , Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) , targetName ) ; Properties p = ConfigurationLoader . getProperty ( ) ; p . setProperty ( Constants . PROP_KEY_NAME_DB_PRAM , ""<STR_LIT>"" ) ; ConfigurationLoader . setProperty ( p ) ; conn = DBConnection . getConnection ( ) ; DBConnection . closeConn ( conn ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( ) ; } finally { DBConnection . closeConn ( conn ) ; } } @ Test public void getConnectionTest03 ( ) throws Exception { Connection conn = null ; try { String appHome = System . getProperty ( Constants . THUNDER_GATE_HOME ) ; String propDir = appHome + ""<STR_LIT>"" ; BulkLoaderInitializer . initDBServer ( jobflowId , executionId , Arrays . asList ( new String [ ] { ""<STR_LIT>"" } ) , targetName ) ; Properties p = ConfigurationLoader . getProperty ( ) ; p . setProperty ( Constants . PROP_KEY_NAME_DB_PRAM , propDir ) ; ConfigurationLoader . setProperty ( p ) ; conn = DBConnection . getConnection ( ) ; DBConnection . closeConn ( conn ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( ) ; } finally { DBConnection . closeConn ( conn ) ; } }'}]","@Test public void getConnectionTest04() throws Exception { Connection conn = null; try { BulkLoaderInitializer.initDBServer(jobflowId, executionId, Arrays.asList(new String[] {""<STR_LIT>""}), targetName); Properties p = ConfigurationLoader.getProperty(); p.setProperty(Constants.PROP_KEY_NAME_DB_PRAM, ""<STR_LIT>""); ConfigurationLoader.setProperty(p); conn = DBConnection.getConnection(); DBConnection.closePs(null); DBConnection.closeRs(null); DBConnection.closeConn(conn); } catch (Exception e) { e.printStackTrace(); fail(); } finally { DBConnection.closeConn(conn); } }",0.00018891411821143626
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . jface . viewers . ITreeContentProvider ; public abstract class TreeProviderTester extends RefactoringTestCase { public TreeProviderTester ( ) { this ( ""<STR_LIT>"" ) ; } public TreeProviderTester ( String fileName ) { super ( fileName ) ; } private Map < String , Entry > elements ; private ITreeContentProvider provider ; @ Override public void setUp ( ) { elements = new HashMap < String , Entry > ( ) ; } public void addContent ( String [ ] content ) { Map < String , Entry > aktMap = elements ; for ( String str : content ) { if ( ! aktMap . containsKey ( str ) ) { aktMap . put ( str , new Entry ( str ) ) ; } aktMap = aktMap . get ( str ) . getChilds ( ) ; } } public void validate ( ITreeContentProvider provider ) { this . provider = provider ; checkElements ( elements , provider . getElements ( null ) ) ; } private void checkElements ( Map < String , Entry > expectedElements , Object [ ] elements ) { assertNotNull ( elements ) ; assertEquals ( expectedElements . size ( ) ,'}]","elements.length); for (Object element : elements) { Entry expectedEntry = expectedElements.get(element.toString()); assertNotNull(expectedEntry); if (expectedEntry.isLeaf()) { assertEquals(expectedEntry, element); } else { Map<String, Entry> childElements = expectedEntry.getChilds(); Object[] childElementsArray = new Object[childElements.size()]; int i = 0; for (Entry childEntry : childElements.values()) { childElementsArray[i++] = childEntry; } checkElements(childElements, childElementsArray); } } } }",0.00015898556814003686
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob ; abstract public class WaitHelper implements Runnable { static final long INTERVAL = <NUM_LIT> ; static final int RETRIES = <NUM_LIT> ; private final int retries ; private final long interval ; public WaitHelper ( ) { this ( INTERVAL , RETRIES'}]","); } public WaitHelper ( long interval, int retries ) { this.interval = interval; this.retries = retries; } @Override public void run ( ) { // implementation } }",6.536084051418387e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . Date ; import java . util . EventObject ; import org . oddjob . Stateful ; import org . oddjob . util . IO ; public class StateEvent extends EventObject implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; static final String REPLACEMENT_EXCEPTION_TEXT = ""<STR_LIT>"" ; private State state ; private Date time ; private Throwable exception ; class ExceptionReplacement extends Exception { private static final long serialVersionUID = <NUM_LIT> ; public ExceptionReplacement ( Throwable replacing ) { super ( REPLACEMENT_EXCEPTION_TEXT + replacing . getMessage ( ) ) ;'}]","this.replacing = replacing; } private final Throwable replacing; } public StateEvent(State state, Date time) { super(state); this.state = state; this.time = time; } public StateEvent(State state, Date time, Throwable exception) { super(state); this.state = state; this.time = time; this.exception = exception; } public StateEvent(State state, Date time, ExceptionReplacement replacement) { super(state); this.state = state; this.time = time; this.exception = replacement; } public StateEvent(State state, Date time, String message) { super(state); this.state = state; this.time = time; this.exception = new ExceptionReplacement(new Exception(message)); } public StateEvent(State state, Date time, String message, Throwable replacing) { super(state); this.state = state; this.time = time; this.exception = new ExceptionReplacement(replacing); } public StateEvent(State state, Date time, Throwable exception) { super(state); this.state = state; this.time = time; this.exception = exception; } public StateEvent(State state, Date time, ExceptionReplacement replacement, Throwable replacing) { super(state); this.state = state; this.time = time; this.exception = new ExceptionReplacement(replacing); } public StateEvent(State state,",0.0003459401578124276
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . overridemethod ; import java . util . ArrayList ; import java . util . Collection ; import org . rubypeople . rdt . refactoring . classnodeprovider . ClassNodeProvider ; import org . rubypeople . rdt . refactoring . classnodeprovider . IncludedClassesProvider ; import org . rubypeople . rdt . refactoring . core . overridemethod . MethodsOverrider . TreeClass . TreeMethod ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentProvider ; import org . rubypeople . rdt . refactoring . editprovider . EditAndTreeContentProvider ; import org . rubypeople . rdt . refactoring . editprovider . EditProvider ; import org . rubypeople . rdt . refactoring . editprovider . EditProviderGroups ; import org . rubypeople . rdt . refactoring . editprovider . ITreeClass ; import org . rubypeople . rdt . refactoring . exception . UnknownClassNameException ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . signatureprovider . ClassSignatureProvider ; import org . rubypeople . rdt . refactoring . signatureprovider . IClassSignatureProvider ; import org . rubypeople . rdt . refactoring . signatureprovider . MethodSignature ; import org . rubypeople . rdt . refactoring . ui . IItemSelectionReceiver ; import org . rubypeople . rdt . refactoring . ui . IParentProvider ; public class MethodsOverrider extends EditAndTreeContentProvider implements IItemSelectionReceiver { private ClassNodeProvider superClassNodeProvider ; private Object [ ] selectedTreeItems ; public MethodsOverrider ( DocumentProvider docProvider ) { superClassNodeProvider = docProvider . getClassNodeProvider ( ) ; IncludedClassesProvider includedClassesProvider = new IncludedClassesProvider ( docProvider ) ; if ( includedClassesProvider != null ) superClassNodeProvider . addClassNodeProvider ( includedClassesProvider ) ; initTreeClasses ( docProvider . getClassNodeProvider ( ) ) ; } @ Override public Collection < EditProvider > getEditProviders ( ) { EditProviderGroups editProviderGroups = new EditProviderGroups ( ) ; if ( selectedTreeItems != null ) { for ( Object o : selectedTreeItems ) { if ( o instanceof TreeMethod ) { TreeMethod treeMethod = ( TreeMethod ) o ; editProviderGroups . add ( treeMethod . getSignatureGroup ( ) , treeMethod . getOverriddenMethod ( ) ) ; } } } return editProviderGroups . getAllEditProviders ( ) ; } private IClassSignatureProvider getSuperSignatureProvider ( ClassNodeWrapper classNode ) throws UnknownClassNameException { String superClassName = ""<STR_LIT>"" ; superClassName = classNode'}]",.getClass().getName();ClassSignatureProvider signatureProvider = superClassNodeProvider.getClassSignatureProvider(superClassName);return signatureProvider;},5.40867301814367e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . expr ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import de . fuberlin . wiwiss . d2rq . algebra . AliasMap ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . algebra . ColumnRenamer ; import de . fuberlin . wiwiss . d2rq . sql . ConnectedDB ; public class Concatenation extends Expression { public static Expression create ( List < Expression > expressions ) { List < Expression > nonEmpty = new ArrayList < Expression > ( expressions . size ( ) ) ; for ( Expression expression : expressions ) { if ( expression instanceof Constant && ""<STR_LIT>"" . equals ( ( ( Constant ) expression ) . value ( ) ) ) { continue ; } nonEmpty . add ( expression ) ; } if ( nonEmpty . isEmpty ( ) ) { return new Constant ( ""<STR_LIT>"" ) ; } if ( nonEmpty . size ( ) == <NUM_LIT:1> ) { return nonEmpty . get ( <NUM_LIT:0> ) ; } return new Concatenation ( nonEmpty ) ; } private final List < Expression > parts ; private final Set < Attribute > attributes = new HashSet < Attribute > ( ) ; private Concatenation ( List < Expression > parts ) { this . parts = parts ; for ( Expression expression : parts ) { attributes . addAll ( expression . attributes ( ) ) ; } } public Set < Attribute > attributes ( ) { return attributes ; } public boolean isFalse ( ) { return false ; } public boolean isTrue ( ) { return false ; } public Expression renameAttributes ( ColumnRenamer columnRenamer ) { List < Expression > renamedExpressions = new ArrayList < Expression > ( parts . size ( ) ) ; for ( Expression expression : parts ) { renamedExpressions . add ( columnRenamer . applyTo ( expression ) ) ; } return new Concatenation ( renamedExpressions ) ; } public String toSQL ( ConnectedDB database , AliasMap aliases ) { String [ ] fragments = new String [ parts . size ( ) ] ; for ( int i = <NUM_LIT:0> ; i < parts . size ( ) ; i ++ ) { Expression part = ( Expression ) parts . get ( i ) ; fragments [ i ] = part . toSQL ( database , aliases ) ; } return database . vendor ( ) . getConcatenationExpression ( fragments ) ; } public boolean equals ( Object other ) {'}]",if ( this == other ) return true; if ( other == null || getClass ( )!= other. getClass ( ) ) return false; Concatenation that = ( Concatenation ) other; return parts.equals(that.parts); } public int hashCode ( ) { return parts.hashCode ( ) ; } },0.00010396061703719724
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . HashMap ; import java . util . Map ; @ SuppressWarnings ( ""<STR_LIT:rawtypes>"" ) public enum SVDBItemType { File , ModuleDecl , ClassDecl , ConfigDecl , InterfaceDecl , ProgramDecl , Bind , Task , Function , ModIfcInst , ModIfcInstItem , ModportDecl , ModportItem , ModportSimplePortsDecl , ModportSimplePort , ModportClockingPortDecl , ModportTFPortsDecl , ModportTFPort , MacroDef , MacroDefParam , PreProcCond , Include , PackageDecl , Covergroup , Coverpoint , CoverpointBins , CoverpointCross , CoverCrossBinsSel , Sequence , Property , ModIfcClassParam , Constraint , Assign , Marker , ParamValueAssign , ParamValueAssignList , GenerateBlock , GenerateFor , GenerateIf , GenerateRegion , ClockingBlock , TypeInfoBuiltin , TypeInfoBuiltinNet , TypeInfoClassItem , TypeInfoClassType , TypeInfoEnum , TypeInfoEnumerator , TypeInfoFwdDecl , TypeInfoStruct , TypeInfoUnion , TypeInfoUserDef , TypeInfoModuleIfc , ActionBlockStmt , AlwaysStmt , AssertStmt , AssignStmt , AssumeStmt , LabeledStmt , BlockStmt , BreakStmt , CaseItem , CaseStmt , ConfigCellClauseStmt , ConfigDefaultClauseStmt , ConfigDesignStmt , ConfigInstClauseStmt , ConstraintDistListStmt , ConstraintDistListItem , ConstraintForeachStmt , ConstraintIfStmt , ConstraintImplStmt , ConstraintSetStmt , ConstraintSolveBeforeStmt , ContinueStmt , CoverStmt , DisableStmt , DisableForkStmt , DefParamStmt , DefParamItem , DelayControlStmt , DoWhileStmt , EventControlStmt , EventTriggerStmt , ExportStmt , ExportItem , ExprStmt , FinalStmt , ForeachStmt , ForeverStmt , ForkStmt , ForStmt , IfStmt , ImportItem , ImportStmt , InitialStmt , NullStmt , ProceduralContAssignStmt , RepeatStmt , ReturnStmt , VarDeclItem , VarDeclStmt , WaitForkStmt , WaitOrderStmt , WaitStmt , WhileStmt , VarDimItem , ParamPortDecl , TypedefStmt , CoverageOptionStmt , CoverageCrossBinsSelectStmt , TimePrecisionStmt , TimeUnitsStmt , ArrayAccessExpr , AssignExpr , AssignmentPatternExpr , AssignmentPatternRepeatExpr , AssociativeArrayElemAssignExpr , BinaryExpr , CastExpr , ClockingEventExpr , ConcatenationExpr , CondExpr , CrossBinsSelectConditionExpr , CtorExpr , CycleDelayExpr , FieldAccessExpr , FirstMatchExpr , IdentifierExpr , IncDecExpr , InsideExpr , LiteralExpr , MinTypMaxExpr , NamedArgExpr , NameMappedExpr , NullExpr , ParamIdExpr , ParenExpr , PropertyWeakStrongExpr , RandomizeCallExpr , RangeDollarBoundExpr , RangeExpr , TFCallExpr , UnaryExpr , TypeExpr , PropertySpecExpr , PropertyIfStmt , PropertyCaseStmt , PropertyCaseItem , SequenceCycleDelayExpr , SequenceClockingExpr , SequenceMatchItemExpr , SequenceDistExpr , SequenceRepetitionExpr , StringExpr , CoverpointExpr , CoverBinsExpr , DocComment ; public boolean isElemOf ( SVDBItemType ... type_list ) { switch ('}]",this ) { case File : case ModIfcInst : case ModportClockingPortDecl : case ModportTFPort : case MacroDef : case PreProcCond : case Include : case PackageDecl : case Covergroup : case Coverpoint : case GenerateBlock : case ClockingBlock : case TypeInfoBuiltin : case TypeInfoClassItem : case Constraint : case DefParamStmt : case DisableStmt : case ExportStmt : case EventControlStmt : case EventTriggerStmt : case FinalStmt : case ForeachStmt : case ForeverStmt : case ImportItem : case ImportStmt : case InitialStmt : case NullStmt : case ProceduralContAssignStmt : case RepeatStmt : case ReturnStmt : case TypedefStmt : case CoverageOptionStmt : case TimePrecisionStmt : case TimeUnitsStmt : case ArrayAccessExpr : case AssignExpr : case AssignmentPatternExpr : case BinaryExpr : case CastExpr : case ClockingEventExpr : case CondExpr : case CrossBinsSelectConditionExpr : case CtorExpr : case FieldAccessExpr : case FirstMatchExpr : case IdentifierExpr : case IncDecExpr : case InsideExpr : case LiteralExpr : case MinTypMaxExpr : case NamedArgExpr : case NameMappedExpr : case NullExpr : case ParamIdExpr :,0.0003746865352463813
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . gems ; import java . util . Set ; import com . aptana . rdt . core . gems . Gem ; public class GemOnePointTwoParserTest extends AbstractGemParserTestCase { public void testParsingLocalGems ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT:7> , gems . size ( ) ) ; } public void testRubygems1dot3 ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT> , gems . size ( ) ) ; } public void testRubygems1dot3Remote ( )'}]",") throws GemParseException { String contents = getContents ( ""http://rubygems.org/gems/<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ). parse ( contents ) ; assertEquals ( <NUM_LIT>, gems. size ( ) ) ; }",9.210905307998794e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . model ; import javax . lang . model . element . ExecutableElement ; import javax . lang . model . type . TypeMirror ; import com . asakusafw . compiler . common . Precondition ; import com'}]",".asakusafw.compiler.operator.model.OperatorModelElementVisitor; public class OperatorModelElement extends ExecutableElement { private final TypeMirror returnType ; private final TypeMirror[] parameterTypes ; public OperatorModelElement ( TypeMirror returnType, TypeMirror[] parameterTypes ) { Precondition. checkNotNull ( returnType ) ; Precondition. checkNotNull ( parameterTypes ) ; this. returnType = returnType ; this. parameterTypes = parameterTypes ; } @Override public TypeMirror getReturnType ( ) { return returnType ; } @Override public TypeMirror[] getParameterTypes ( ) { return parameterTypes ; } public < R extends Visitor < R > > R accept ( Visitor < R > visitor ) { return visitor. visit ( this ) ; } }",0.00020100226477533323
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ExportTempImportTarget21 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class ExportTempImportTarget21ModelOutput implements ModelOutput < ExportTempImportTarget21 > { private final RecordEmitter emitter ; public ExportTempImportTarget21ModelOutput ('}]",RecordEmitter emitter) { this.emitter = emitter; } @Override public void emit(ExportTempImportTarget21 target) throws IOException { emitter.emit(target); } @Override public void emit(Iterable<ExportTempImportTarget21> targets) throws IOException { for (ExportTempImportTarget21 target : targets) { emit(target); } } @Override public void close() throws IOException { emitter.close(); } },0.0001231729999422422
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . client ; import java . io . Serializable ; public class HandlerVersion implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private final int major ; private final int minor ; public HandlerVersion ( int major , int minor ) { this . major = major ; this . minor = minor ; } public'}]",int getMajorVersion ( ) { return major ; } public int getMinorVersion ( ) { return minor ; } },4.718224477341118e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui ; import org . eclipse . ui . IEditorInput ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . internal . ui . rubyeditor .'}]","RubyEditorInput;public class RubyEditorInput implements IEditorInput { private final IRubyScript script; public RubyEditorInput(IRubyScript script) { this.script = script; } @Override public String getToolTipText() { return script.getToolTipText(); } @Override public String getName() { return script.getName(); } @Override public String getOriginalText() { return script.getOriginalText(); } @Override public String getDecoratedText() { return script.getDecoratedText(); } @Override public void dispose() { // No-op, as we don't hold any resources } }",0.00016695698010495342
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import javax . management . MBeanServerConnection ; import org . oddjob . Structural ; import org . oddjob . jmx . client . ClientSession ; import org . oddjob . jmx . client . ClientSessionImpl ; import org . oddjob . jmx . client . RemoteLogPoller ; import org . oddjob . jmx . client . ServerView ; import org . oddjob . jmx . server . OddjobMBeanFactory ; import org . oddjob . jobs . job . StopJob ; import org . oddjob . jobs . structural . ServiceManager ; import org . oddjob . logging . ConsoleArchiver ; import org . oddjob . logging . LogArchiver ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . structural . ChildHelper ; import org . oddjob . structural . StructuralListener ; public class JMXClientJob extends ClientBase implements Structural , LogArchiver , ConsoleArchiver , RemoteDirectoryOwner { public static final long DEFAULT_LOG_POLLING_INTERVAL = <NUM_LIT> ; private RemoteLogPoller logPoller ; private ChildHelper < Object > childHelper = new ChildHelper < Object > ( this ) ; private ClientSession clientSession ; private ServerView serverView ; private int maxLoggerLines = LogArchiver . MAX_HISTORY ; private int maxConsoleLines = LogArchiver . MAX_HISTORY ; private long logPollingInterval = <NUM_LIT> ; @ Deprecated public void setUrl ( String url ) { setConnection ( url ) ; } @ Override public void addLogListener ( LogListener l , Object component , LogLevel level , long last , int history ) { stateHandler . assertAlive ( ) ; if ( logPoller == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } logPoller . addLogListener ( l , component , level , last , history ) ; synchronized ( logPoller ) { logPoller . notifyAll ( ) ; } } @ Override public void removeLogListener ( LogListener l , Object component ) { if ( logPoller == null ) { return ; } logPoller . removeLogListener ( l , component ) ; } @ Override public void addConsoleListener ( LogListener l , Object component , long last , int max ) { stateHandler . assertAlive ( ) ; if ( logPoller == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } logPoller . addConsoleListener ( l , component , last , max ) ; synchronized ( this ) { notifyAll ( ) ; } } @ Override public void removeConsoleListener ( LogListener l , Object component ) { if ( logPoller == null ) { return ; } logPoller . removeConsoleListener ( l , component ) ; } @ Override public String consoleIdFor ( Object component ) { return logPoller . consoleIdFor ( component ) ; } @ Override public void onInitialised ( ) { if ( maxConsoleLines == <NUM_LIT:0> ) { maxConsoleLines = LogArchiver . MAX_HISTORY ; } if ( maxLoggerLines == <NUM_LIT:0> ) { maxLoggerLines = LogArchiver . MAX_HISTORY ; } if ( logPollingInterval == <NUM_LIT:0> ) { logPollingInterval = DEFAULT_LOG_POLLING_INTERVAL ; } } @ Override protected void doStart ( MBeanServerConnection mbsc , ScheduledExecutorService notificationProcessor ) throws Exception { clientSession = new ClientSessionImpl ( mbsc , notificationProcessor , getArooaSession ( ) , logger ( ) ) ; Object serverMain = clientSession . create ( OddjobMBeanFactory . objectName ( <NUM_LIT:0> ) ) ; if ( serverMain == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } serverView = new ServerView ( serverMain ) ; this . logPoller = new RemoteLogPoller ( serverMain , maxConsoleLines , maxLoggerLines ) ; serverView . startStructural ( childHelper ) ; notificationProcessor . scheduleAtFixedRate ( new Runnable ( ) { public void run ( ) { try { serverView . noop ( ) ; } catch ( RuntimeException e ) { try { doStop ( WhyStop . HEARTBEAT_FAILURE , e ) ; } catch ( Exception e1 ) { logger ( ) . error ( ""<STR_LIT>"" , e1 ) ; } } } @ Override public String toString ( ) { return'}]","""JMXClientJob["" + super.toString() + ""]""; } }",5.03428226946947e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . launching ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . StringReader ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . core . runtime . Path ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . core . Launch ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . IStreamsProxy ; import org . rubypeople . rdt . internal . launching . LaunchingMessages ; import org . rubypeople . rdt . internal . launching . LaunchingPlugin ; import org . rubypeople . rdt . internal . launching . LibraryInfo ; public abstract class AbstractVMInstallType implements IVMInstallType , IExecutableExtension { private List < IVMInstall > fVMs ; private String fId ; protected AbstractVMInstallType ( ) { fVMs = new ArrayList < IVMInstall > ( <NUM_LIT:10> ) ; } public IVMInstall [ ] getVMInstalls ( ) { IVMInstall [ ] vms = new IVMInstall [ fVMs . size ( ) ] ; return ( IVMInstall [ ] ) fVMs . toArray ( vms ) ; } public void disposeVMInstall ( String id ) { for ( int i = <NUM_LIT:0> ; i < fVMs . size ( ) ; i ++ ) { IVMInstall vm = ( IVMInstall ) fVMs . get ( i ) ; if ( vm . getId ( ) . equals ( id ) ) { fVMs . remove ( i ) ; RubyRuntime . fireVMRemoved ( vm ) ; return ; } } } public IVMInstall findVMInstall ( String id ) { for ( int i = <NUM_LIT:0> ; i < fVMs . size ( ) ; i ++ ) { IVMInstall vm = ( IVMInstall ) fVMs . get ( i ) ; if ( vm . getId ( ) . equals ( id ) ) { return vm ; } } return null ; } public IVMInstall createVMInstall ( String id ) throws IllegalArgumentException { if ( findVMInstall ( id ) != null ) { String format = LaunchingMessages . vmInstallType_duplicateVM ; throw new IllegalArgumentException ( MessageFormat . format ( format , id ) ) ; } IVMInstall vm = doCreateVMInstall ( id ) ; fVMs . add ( vm ) ; return vm ; } protected abstract IVMInstall doCreateVMInstall ( String id ) ; public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) { fId = config . getAttribute ( ""<STR_LIT:id>"" ) ; } public String getId ( ) { return fId ; } public IVMInstall findVMInstallByName ( String name ) { for ( int i = <NUM_LIT:0> ; i < fVMs . size ( ) ; i ++ ) { IVMInstall vm = ( IVMInstall ) fVMs . get ( i ) ; if ( vm . getName ( ) . equals ( name ) ) { return vm ; } } return null ; } protected LibraryInfo parseLibraryInfo ( IProcess process ) { IStreamsProxy streamsProxy = process . getStreamsProxy ( ) ; if ( streamsProxy == null ) return null ; String text = streamsProxy . getOutputStreamMonitor ( ) . getContents ( ) ; BufferedReader reader = new BufferedReader ( new StringReader ( text ) ) ; List < String > lines = new ArrayList < String > ( ) ; try { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { lines . add ( line ) ; } } catch ( IOException e ) { LaunchingPlugin . log ( e ) ; } if ( lines . size ( ) > <NUM_LIT:0> ) { String version = lines . remove ( <NUM_LIT:0> ) ; removeNotExistingLibs ( lines ) ; if ( lines . size ( ) > <NUM_LIT:0> ) { String [ ] loadpath = lines . toArray ( new String [ lines . size ( ) ] ) ; return new LibraryInfo ( version , loadpath ) ; } } return null ; } protected LibraryInfo generateLibraryInfo ( File rubyHome , File rubyExecutable ) { LibraryInfo info = null ; File file = getLibraryInfoGeneratorPath ( ) ; if ( file . exists ( ) ) { String rubyExecutablePath = rubyExecutable . getAbsolutePath ( ) ; String [ ] cmdLine = new String [ ] { rubyExecutablePath , file . getAbsolutePath ( ) } ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( cmdLine ) ; IProcess process = DebugPlugin . newProcess ( new Launch ( null , ILaunchManager . RUN_MODE , null ) , p , ""<STR_LIT>"" ) ; for ( int i = <NUM_LIT:0> ; i < <NUM_LIT> ;'}]","i++) {     IStreamsProxy streamsProxy = process.getStreamsProxy();     if (streamsProxy!= null) {         String text = streamsProxy.getOutputStreamMonitor().getContents();         info = parseLibraryInfo(process);         break;     }     // Wait for the process to exit     process.waitFor(); } } return info; } protected void removeNotExistingLibs ( List < String > lines ) { Collections. reverse ( lines ) ; for ( int i = <NUM_LIT:0> ; i < lines. size ( ) ; i ++ ) { String line = lines. get ( i ) ; if (! line. startsWith ( ""require"" ) ) { lines. remove ( i ) ; i -- ; } } Collections. reverse ( lines ) ; } protected File getLibraryInfoGeneratorPath ( ) { return new File ( new Path ( ""<STR_LIT>libinfo_generator.rb"" ). toFile ( ). getAbsolutePath ( ) ) ; } }",0.0003206896059381763
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . handlers ; import java . lang . reflect . UndeclaredThrowableException ; import javax . management . MBeanAttributeInfo ; import javax . management . MBeanException ; import javax . management . MBeanNotificationInfo ; import javax . management . MBeanOperationInfo ; import javax . management . ReflectionException ; import org . oddjob . jmx . RemoteOperation ; import org . oddjob . jmx . SharedConstants ; import org . oddjob . jmx . client . ClientHandlerResolver ; import org . oddjob . jmx . client . ClientInterfaceHandlerFactory ; import org . oddjob . jmx . client . ClientSideToolkit ; import org . oddjob . jmx . client . HandlerVersion ; import org . oddjob . jmx . client . LogPollable ; import org . oddjob . jmx . client . SimpleHandlerResolver ; import org . oddjob . jmx . server . JMXOperationPlus ; import org . oddjob . jmx . server . LogArchiverHelper ; import org . oddjob . jmx . server . ServerContext ; import org . oddjob . jmx . server . ServerInterfaceHandler ; import org . oddjob . jmx . server . ServerInterfaceHandlerFactory ; import org . oddjob . jmx . server . ServerSideToolkit ; import org . oddjob . logging . LogEvent ; public class LogPollableHandlerFactory implements ServerInterfaceHandlerFactory < Object , LogPollable > { public static final HandlerVersion VERSION = new HandlerVersion ( <NUM_LIT:1> , <NUM_LIT:0> ) ; private static final JMXOperationPlus < String > CONSOLE_ID = new JMXOperationPlus < String > ( ""<STR_LIT>"" , ""<STR_LIT>"" , String . class , MBeanOperationInfo . INFO ) ; private static final JMXOperationPlus < String > URL = new JMXOperationPlus < String > ( ""<STR_LIT:url>"" , ""<STR_LIT>"" , String . class , MBeanOperationInfo . INFO ) ; private static final JMXOperationPlus < LogEvent [ ] > RETRIEVE_CONSOLE_EVENTS = new JMXOperationPlus < LogEvent [ ] > ( SharedConstants . RETRIEVE_CONSOLE_EVENTS_METHOD , ""<STR_LIT>"" , LogEvent [ ] . class , MBeanOperationInfo . INFO ) . addParam ( ""<STR_LIT>"" , Long . TYPE , ""<STR_LIT>"" ) . addParam ( ""<STR_LIT>"" , Integer . TYPE , ""<STR_LIT>"" ) ; private static final JMXOperationPlus < LogEvent [ ] > RETRIEVE_LOG_EVENTS = new JMXOperationPlus < LogEvent [ ] > ( SharedConstants . RETRIEVE_LOG_EVENTS_METHOD , ""<STR_LIT>"" , LogEvent [ ] . class , MBeanOperationInfo . INFO ) . addParam ( ""<STR_LIT>"" , Long . TYPE , ""<STR_LIT>"" ) . addParam ( ""<STR_LIT>"" , Integer . TYPE , ""<STR_LIT>"" ) ; public Class < Object > interfaceClass ( ) { return Object . class ; } public MBeanAttributeInfo [ ] getMBeanAttributeInfo ( ) { return new MBeanAttributeInfo [ <NUM_LIT:0> ] ; } public MBeanOperationInfo [ ] getMBeanOperationInfo ( ) { return new MBeanOperationInfo [ ] { CONSOLE_ID . getOpInfo ( ) , URL . getOpInfo ( ) , RETRIEVE_CONSOLE_EVENTS . getOpInfo ( ) , RETRIEVE_LOG_EVENTS . getOpInfo ( ) } ; } public MBeanNotificationInfo [ ] getMBeanNotificationInfo ( ) { return new MBeanNotificationInfo [ <NUM_LIT:0> ] ; } public ServerInterfaceHandler createServerHandler ( Object target , ServerSideToolkit ojmb ) { return new ServerLogPollableHandler ( target , ojmb ) ; } public ClientHandlerResolver < LogPollable > clientHandlerFactory ( ) { return new SimpleHandlerResolver < LogPollable > ( ClientLogPollableHandlerFactory . class . getName ( ) , VERSION ) ; } public static class ClientLogPollableHandlerFactory implements ClientInterfaceHandlerFactory < LogPollable > { public Class < LogPollable > interfaceClass ( ) { return LogPollable . class ; } public HandlerVersion getVersion ( ) { return VERSION ; }'}]","public ClientInterfaceHandler createClientHandler ( LogPollable target, ClientSideToolkit toolkit ) {",5.422355952569141e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . model ; import java . text . MessageFormat ; import java . util . List ; import com . asakusafw . dmdl . Region ; public class AstModelDefinition < T extends AstTerm < T > > extends AbstractAstNode { private final Region region ; public final ModelDefinitionKind kind ; public final AstDescription description ; public final List < AstAttribute > attributes ; public final AstSimpleName name ; public final AstExpression < T > expression ; public AstModelDefinition ( Region region , ModelDefinitionKind kind , AstDescription description , List < AstAttribute > attributes , AstSimpleName name , AstExpression < T > expression ) { if ( kind == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( attributes == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( name == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( expression == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . region = region ; this . kind = kind ; this . description = description ; this . attributes = attributes ; this .'}]","name = name; this.expression = expression; } @Override public String toString() { return MessageFormat.format(""<STR_LIT>"", kind, description, attributes, name, expression); } }",6.717131330246298e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . statement ; import java . util . ArrayList ; import java . util . List ; import org . hibernate . Query ; import org . hibernate . Session ; import br . com . caelum . vraptor . ioc . Component ; @ Component public class StatementDao { private final Session session ; public StatementDao ( Session session ) { this . session = session ; } public void validate ( String hql , List < String > parameters ) { try { createQuery ( hql , parameters , <NUM_LIT:1000> ) . list ( ) ; } catch ( Exception exception ) { throw new IllegalArgumentException ( exception ) ; } } @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) public List < Object [ ] > execute ( Statement st , List < String > parameters , Integer size ) { List results = createQuery ( st . getHql ( ) , parameters , size ) . list ( ) ; if ('}]","results.size() == 0) { return new ArrayList<Object[]>(); } return results; } private Query createQuery(String hql, List<String> parameters, Integer size) { return session.createQuery(hql).setParameters(parameters).setMaxResults(size); } }",8.298585210000596e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . callhierarchy ; import java . util . Map ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . search . SearchMatch ; import org . rubypeople . rdt . core . search . SearchRequestor ; class MethodReferencesSearchRequestor extends SearchRequestor { private CallSearchResultCollector fSearchResults ; private boolean fRequireExactMatch = false ; MethodReferencesSearchRequestor ( ) { fSearchResults = new'}]","CallSearchResultCollector(); } public void setRequireExactMatch(boolean requireExactMatch) { fRequireExactMatch = requireExactMatch; } @Override public void search(IRubyElement element, Map<String, IMember> members, SearchMatch match) { //... } }",8.77335623388531e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . collections ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; public final class Lists { public static < E > List < E > create ( ) { return new ArrayList < E > ( ) ; } public static < E > List < E > of ( E elem ) { ArrayList < E > result = new ArrayList < E > ( ) ; result . add ( elem ) ; return result ; } public static < E > List < E > of ( E elem1 , E elem2 ) { ArrayList < E > result = new ArrayList < E > ( ) ; result . add ( elem1 ) ; result . add ( elem2 ) ; return result ; } public static < E > List < E > of ( E elem1 , E elem2 , E elem3 ) { ArrayList < E > result = new ArrayList < E > ( ) ; result . add ( elem1 ) ; result . add ( elem2 ) ; result . add ( elem3 ) ; return result ; } public static < E > List < E > of ( E elem1 , E elem2 , E elem3 , E elem4 , E ... rest ) { if ( rest == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ArrayList < E > result = new ArrayList < E > ( ) ; result . add ( elem1 ) ; result . add ( elem2 ) ; result . add ( elem3 ) ; result . add ( elem4 ) ; Collections . addAll ( result , rest ) ; return result ; } public static < E > List < E > from ( E [ ] elements ) { if ( elements == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ArrayList < E > result = new ArrayList < E > ( ) ; Collections . addAll ( result , elements ) ; return result ; } public static < E > List < E > from ( Iterable < ? extends E > elements ) { if ( elements == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ArrayList < E > copy = new ArrayList < E > ( ) ; for ( E element : elements ) { copy . add ( element ) ; } return copy ; } public static < E > List < E > freeze ( Iterable < ? extends E > elements ) { if ( elements == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Iterator < ? extends E > iter = elements . iterator ( ) ; if ( iter . hasNext ( ) == false ) { return Collections . emptyList ( ) ; } E first = iter . next'}]",() ; ArrayList < E > result = new ArrayList < E > ( ) ; result. add ( first ) ; while ( iter. hasNext ( ) ) { result. add ( iter. next ( ) ) ; } return result ; } public static < E > List < E > newArrayList ( E... elements ) { return of ( elements ) ; } },0.00012348951403670064
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package net . sf . sveditor . ui . editor ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DefaultIndentLineAutoEditStrategy ; import org . eclipse . jface . text . DocumentCommand ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITypedRegion ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . TextUtilities ; public class SVMultiLineCommentAutoIndentStrategy extends DefaultIndentLineAutoEditStrategy { private final String fPartitioning ; public SVMultiLineCommentAutoIndentStrategy ( String partitioning ) { fPartitioning = partitioning ; } private IRegion findPrefixRange ( IDocument doc , IRegion line ) throws BadLocationException { int lineOffset = line . getOffset ( ) ; int lineEnd = lineOffset + line . getLength ( ) ; int indentEnd = findEndOfWhiteSpace ( doc , lineOffset , lineEnd ) ; if ( ( indentEnd < lineEnd ) && ( doc . getChar ( indentEnd ) == '<CHAR_LIT>' ) ) { indentEnd ++ ; while ( ( indentEnd < lineEnd ) && Character . isWhitespace ( doc . getChar ( indentEnd ) ) ) { indentEnd ++ ; } } return new Region ( lineOffset , indentEnd - lineOffset ) ; } private boolean isCommentClosed ( IDocument doc , int offset ) { try { if ( ( doc . getLineOfOffset ( offset ) + <NUM_LIT:1> ) >= doc . getNumberOfLines ( ) ) { return false ; } IRegion line = doc . getLineInformation ( doc . getLineOfOffset ( offset )""}]","+ 1 ); IRegion prefix = findPrefixRange ( doc, line ); return ( prefix!= null ) && ( prefix.getLength ( ) > 0 ) && ( doc.getChar ( prefix.getOffset ( ) ) == '<CHAR_LIT>' ) && ( doc.getChar ( prefix.getOffset ( ) + prefix.getLength ( ) - 1 ) == '<CHAR_LIT>' ); } catch ( BadLocationException x ) { return false; } } private int findEndOfWhiteSpace ( IDocument doc, int offset, int limit ) { for ( int i = limit - 1; i >= offset; i-- ) { if (! Character.isWhitespace ( doc.getChar ( i ) ) ) { return i + 1; } } return limit; } @Override public void autoEdit ( IDocument doc, int offset ) { if ( isCommentClosed ( doc, offset ) ) { DocumentCommand command = new DocumentCommand ( doc, DocumentCommand. REMOVE, offset, offset + 1 ); command.execute ( ); } else { super. autoEdit ( doc, offset ); } } }",0.0003162498514736971
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . math . BigDecimal ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . ShortOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ TableModel ( name = ""<STR_LIT>"" , primary = { } ) @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class AllTypesWNoerr implements Writable { @ Property ( name = ""<STR_LIT>"" ) private StringOption cTag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cComment = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption cBigint = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private IntOption cInt = new IntOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private ShortOption cSmallint = new ShortOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private ByteOption cTinyint = new ByteOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cChar = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption cDatetime = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption cDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DecimalOption cDecimal200 = new DecimalOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DecimalOption cDecimal255 = new DecimalOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cVchar = new StringOption ( ) ; public Text getCTag ( ) { return this . cTag . get ( ) ; } public void setCTag ( Text cTag ) { this . cTag . modify ( cTag ) ; } public String getCTagAsString ( ) { return this . cTag . getAsString ( ) ; } public void setCTagAsString ( String cTag ) { this . cTag . modify ( cTag ) ; } public StringOption getCTagOption ( ) { return this . cTag ; } public void setCTagOption ( StringOption cTag ) { this . cTag . copyFrom ( cTag ) ; } public Text getCComment ( ) { return this . cComment . get ( ) ; } public void setCComment ( Text cComment ) { this . cComment . modify ( cComment ) ; } public String getCCommentAsString ( ) { return this . cComment . getAsString ( ) ; } public void setCCommentAsString ( String cComment ) { this . cComment . modify ( cComment ) ; } public StringOption getCCommentOption ( ) { return this . cComment ; } public void setCCommentOption ( StringOption cComment ) { this . cComment . copyFrom ( cComment ) ; } public long getCBigint ( ) { return this . cBigint . get ( ) ; } public void setCBigint ( long cBigint ) { this . cBigint . modify ( cBigint ) ; } public LongOption getCBigintOption ( ) { return this . cBigint ; } public void setCBigintOption ( LongOption cBigint ) { this . cBigint . copyFrom ( cBigint ) ; } public int getCInt ( ) { return this . cInt . get ( ) ; } public void setCInt ( int cInt ) { this . cInt . modify ( cInt ) ; } public IntOption getCIntOption ( ) { return this . cInt ; } public void setCIntOption ( IntOption cInt ) { this . cInt . copyFrom ( cInt ) ; } public short getCSmallint ( ) { return this . cSmallint . get ( ) ; } public void setCSmallint ( short cSmallint ) { this . cSmallint . modify ( cSmallint ) ; } public ShortOption getCSmallintOption ( ) { return this . cSmallint ; } public void setCSmallintOption ( ShortOption cSmallint ) { this . cSmallint . copyFrom ( cSmallint ) ; } public byte getCTinyint ( ) { return this . cTinyint . get ( ) ; } public void setCTinyint ( byte cTinyint ) { this . cTinyint . modify ( cTinyint ) ; } public ByteOption getCTinyintOption ( ) { return this . cTinyint ; } public void setCTinyintOption ( ByteOption cTinyint ) { this . cTinyint . copyFrom ( cTinyint ) ; } public Text getCChar ( ) { return this . cChar . get ( ) ; } public void setCChar ( Text cChar ) { this . cChar . modify ( cChar ) ; } public String getCCharAsString ( ) { return this . cChar . getAsString ( ) ; } public void setCCharAsString ( String cChar ) { this . cChar . modify ( cChar ) ; } public StringOption getCCharOption ( ) { return this . cChar ; } public void setCCharOption ( StringOption cChar ) { this . cChar . copyFrom ( cChar ) ; } public DateTime getCDatetime ( ) { return this . cDatetime . get ( ) ; } public void setCDatetime ( DateTime cDatetime ) { this . cDatetime . modify ( cDatetime ) ; } public DateTimeOption getCDatetimeOption ( ) { return this . cDatetime ; } public void setCDatetimeOption ( DateTimeOption cDatetime ) { this . cDatetime . copyFrom ( cDatetime ) ; } public Date getCDate ( ) { return this . cDate . get ( ) ; } public void setCDate ( Date cDate ) { this . cDate . modify ( cDate ) ; } public DateOption getCDateOption ( ) { return this . cDate ; } public void setCDateOption ( DateOption cDate ) { this . cDate . copyFrom ( cDate ) ; } public BigDecimal getCDecimal200 ( ) { return this . cDecimal200 . get ( ) ; } public void setCDecimal200 ( BigDecimal cDecimal200 ) { this . cDecimal200 . modify ( cDecimal200 ) ; } public DecimalOption getCDecimal200Option ( ) { return this . cDecimal200 ; } public void setCDecimal200Option ( DecimalOption cDecimal200 ) { this . cDecimal200 . copyFrom ( cDecimal200 ) ; } public BigDecimal getCDecimal255 ( ) { return this . cDecimal255 . get ( ) ; } public void setCDecimal255 ( BigDecimal cDecimal255 ) { this . cDecimal255 . modify ( cDecimal255 ) ; } public DecimalOption getCDecimal255Option ( ) { return this . cDecimal255 ; } public void setCDecimal255Option ( DecimalOption cDecimal255 ) { this . cDecimal255 . copyFrom ( cDecimal255 ) ; } public Text getCVchar ( ) { return this . cVchar . get ( ) ; } public void setCVchar ( Text cVchar ) { this . cVchar . modify ( cVchar ) ; } public String getCVcharAsString ( ) { return this . cVchar . getAsString ( ) ; } public void setCVcharAsString ( String cVchar ) { this . cVchar . modify ( cVchar ) ; } public StringOption getCVcharOption ( ) { return this . cVchar ; } public void setCVcharOption ( StringOption cVchar ) { this . cVchar . copyFrom ( cVchar ) ; } public void copyFrom ( AllTypesWNoerr source ) { this . cTag . copyFrom ( source . cTag ) ; this . cComment . copyFrom ( source . cComment ) ; this . cBigint . copyFrom ( source . cBigint ) ; this . cInt . copyFrom ( source . cInt ) ; this . cSmallint . copyFrom ( source . cSmallint ) ; this . cTinyint . copyFrom ( source . cTinyint ) ; this . cChar . copyFrom ( source . cChar ) ; this . cDatetime . copyFrom ( source . cDatetime ) ; this . cDate . copyFrom ( source . cDate ) ; this . cDecimal200 . copyFrom ( source . cDecimal200 ) ; this . cDecimal255 . copyFrom ( source . cDecimal255 ) ; this . cVchar . copyFrom ( source . cVchar ) ; } @ Override public void write ( DataOutput out ) throws IOException { cTag . write ( out ) ; cComment . write ( out ) ; cBigint . write ( out ) ; cInt . write ( out ) ; cSmallint . write ( out ) ; cTinyint . write ( out ) ; cChar . write ('}]",(out); cDatetime.write(out); cDate.write(out); cDecimal200.write(out); cDecimal255.write(out); cVchar.write(out); } @Override public void readFields(DataInput in) throws IOException { cTag.readFields(in); cComment.readFields(in); cBigint.readFields(in); cInt.readFields(in); cSmallint.readFields(in); cTinyint.readFields(in); cChar.readFields(in); cDatetime.readFields(in); cDate.readFields(in); cDecimal200.readFields(in); cDecimal255.readFields(in); cVchar.readFields(in); } },0.00023625877151357667
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . values ; import org . oddjob . arooa . ArooaAnnotations ; import org . oddjob . arooa . ArooaBeanDescriptor ; import org . oddjob . arooa . ArooaConstants ; import org . oddjob . arooa . ConfiguredHow ; import org . oddjob . arooa . ParsingInterceptor ; import org . oddjob . arooa . deploy . NoAnnotations ; public class VariablesJobArooa implements ArooaBeanDescriptor { public String getComponentProperty ( ) { return null ; } public ParsingInterceptor getParsingInterceptor ( ) { return null ; } public String getTextProperty ( ) { return null ; } public ConfiguredHow getConfiguredHow ( String property ) { if ( ArooaConstants . ID_PROPERTY . equals ( property ) ) { return ConfiguredHow . ATTRIBUTE ; } return ConfiguredHow . ELEMENT ; }'}]",public Class<?> getJavaClass() { return VariablesJob.class; },3.576299194817876e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . example . servletjspdemo . web ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . ServletException ; import javax . servlet . annotation . WebServlet ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; @ WebServlet ( urlPatterns = ""<STR_LIT>"" ) public class DataServlet extends HttpServlet { private static final long serialVersionUID = <NUM_LIT:1L> ; @ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( ""<STR_LIT:text/html>"" ) ; PrintWriter out = response . getWriter ( ) ; String selectedHobby = ""<STR_LIT>"" ; for ( String hobby :'}]","new String[] { ""Reading"", ""Writing"", ""Coding"" } ) { if ( selectedHobby == null && hobby.toLowerCase ( ). equals ( request. getParameter ( ""hobby"" ) ) ) { selectedHobby = hobby; } } out. println ( ""<h2>Selected Hobby:</h2><p>"" + selectedHobby + ""</p>"" ) ; out. close ( ) ; } @ Override protected void doPost ( HttpServletRequest request, HttpServletResponse response ) throws ServletException, IOException { // Handle POST requests } }",0.00015419015396461201
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . view ; import org . oddjob . arooa . design . screem . TextPseudoForm ; public class TextPseudoFormDummy implements DummyFormView { private TextPseudoForm textForm ; public TextPseudoFormDummy ( TextPseudoForm textForm ) { this . textForm = textForm ; } public DummyDialogue dialogue ( ) { return new DummyDialogue ( ) { public'}]",String getCaption ( ) { return textForm.getCaption ( ) ; } public String getHelp ( ) { return textForm.getHelp ( ) ; } public void setCaption ( String caption ) { textForm.setCaption ( caption ) ; } public void setHelp ( String help ) { textForm.setHelp ( help ) ; } }; },0.00010461234737161745
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IField ; import org . rubypeople . rdt . core . IImportDeclaration ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . internal . ui . search . RubySearchScopeFactory ; import org . rubypeople . rdt . internal . ui . search . SearchMessages ; import org . rubypeople . rdt . ui . search . ElementQuerySpecification ; import org . rubypeople . rdt . ui . search . QuerySpecification ; public class FindReferencesInProjectAction extends FindReferencesAction {'}]",private final ISourceFolder sourceFolder;public FindReferencesInProjectAction(ISourceFolder sourceFolder) {this.sourceFolder = sourceFolder;},5.835431241693125e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . sql . types ; import java . sql . ResultSet ; import java . sql . SQLException ; import de . fuberlin . wiwiss . d2rq . sql . SQL ; import de . fuberlin . wiwiss . d2rq . sql . vendor . Vendor ; public class SQLBinary extends DataType { private final boolean supportsDistinct ; public SQLBinary ( Vendor syntax , String name , boolean supportsDistinct ) { super ( syntax , name ) ; this . supportsDistinct = supportsDistinct ; } @ Override public boolean isIRISafe ( ) { return true ; } @ Override public boolean supportsDistinct ( ) { return supportsDistinct ; } @ Override public String rdfType ( ) { return ""<STR_LIT>"" ; } @ Override public String value ( ResultSet resultSet , int column ) throws SQLException { byte [ ] bytes = resultSet .'}]",getBinaryStream ( column ). readAllBytes ( ) ; return bytes ; } },4.140608378217935e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import java . util . Collections ; import java . util . Set ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . compiler . testing . TemporaryInputDescription ; import com . asakusafw . vocabulary . external . ImporterDescription ; public class MockHogeImporterDescription extends TemporaryInputDescription { @ Override public Class < ? > getModelType ( ) { return MockHoge . class ; } @ Override public Set'}]","< ImporterDescription > getImporters ( ) { return Collections. singleton ( new ImporterDescription ( ""MockHogeImporter"", MockHogeImporter. class ) ) ; } }",6.784214181277286e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . editprovider ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . resources . IFile ; public class FileNameChangeProvider { public Map < String ,'}]",Collection<String>> getFileNameChanges(IFile file) {... },3.2206480958367076e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . server ; import java . util . Random ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jetty . server . Server ; import org . eclipse . jetty . server . session . HashSessionIdManager ; import org . eclipse . jetty . webapp . WebAppContext ; import de . fuberlin . wiwiss . d2rq . SystemLoader ; public class JettyLauncher { private final static Log log = LogFactory . getLog ( JettyLauncher . class ) ; private final SystemLoader loader ; private final int port ; public JettyLauncher ( SystemLoader loader , int port ) {'}]","this.loader = loader; this.port = port; } public void start() throws Exception { Server server = new Server(port); WebAppContext context = new WebAppContext(""myapp"", ""/""); context.setSessionIdManager(new HashSessionIdManager()); context.setInitParameter(""org.mortbay.jetty.RequestLog"", ""org.mortbay.jetty.NCSARequestLog""); // Add this line server.setHandler(context); server.start(); } }",0.00013656459992964078
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui ; import java . util . HashSet ; import java . util . Set ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . ui . IViewPart ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . packageview . PackageExplorerPart ; public class RubyExplorerTracker implements ISelectionChangedListener { private IProject currentlySelectedProject ; private Set < IRubyProjectListener > projectListeners ; public RubyExplorerTracker ( ) { currentlySelectedProject = null ; projectListeners = new HashSet < IRubyProjectListener > ( ) ; } public void selectionChanged ( SelectionChangedEvent event ) { if ( event == null ) return ; ISelection sel = event . getSelection ( ) ; if ( ! ( sel instanceof IStructuredSelection ) ) return ; IProject inProject = getProjectFromSelection ( sel ) ; if ( inProject == null ) return ; if ( ! inProject . isOpen ( ) ) { setSelectedProject ( null ) ; } else { setSelectedProject ( inProject ) ; } } public void addProjectListener ( IRubyProjectListener listener ) { projectListeners . add ( listener ) ; listener . projectSelected ( currentlySelectedProject ) ; } public void removeProjectListener ( IRubyProjectListener listener ) { projectListeners . remove ( listener ) ; } private void notifyObservers ( ) { for ( IRubyProjectListener listener : projectListeners ) { listener . projectSelected ( currentlySelectedProject ) ; } } private void setSelectedProject ( IProject currentSelectedProject ) { if ( currentSelectedProject != this . currentlySelectedProject ) { this . currentlySelectedProject = currentSelectedProject ; notifyObservers ( ) ; } } public IProject getSelectedProject ( ) { return currentlySelectedProject ; } public IProject getSelectedByNatureID ( String natureId ) { try { if ( currentlySelectedProject == null ) { IViewPart part = PackageExplorerPart . getFromActivePerspective ( ) ; if ('}]","part!= null) {
    IProject project = part.getProject();
    IResource resource = project.findMember(natureId);
    if (resource!= null && resource.isAccessible()) {
        return project;
    }
}
return null;
} catch (CoreException e) {
    RubyCore.logError(e);
    return null;
}",0.0001129278270566062
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . cleaner . common ; public final class Constants { public static final int EXIT_CODE_SUCCESS = <NUM_LIT:0> ; public static final int EXIT_CODE_ERROR = <NUM_LIT:1> ; public static final int EXIT_CODE_WARNING = <NUM_LIT:2> ; public static final String CLEAN_MODE_NOMAL = ""<STR_LIT>"" ; public static final String CLEAN_MODE_RECURSIVE = ""<STR_LIT>"" ; public static final String CLEAN_HOME = ""<STR_LIT>"" ; public static final String PROP_KEY_LOG_CONF_PATH = ""<STR_LIT>"" ; public static final String PROP_KEY_LOCAL_FILE_CLEAN_DIR = ""<STR_LIT>"" ; public static final String PROP_KEY_LOCAL_FILE_CLEAN_PATTERN = ""<STR_LIT>"" ; public static final String PROP_KEY_LOCAL_FILE_KEEP_DATE = ""<STR_LIT>"" ; public static final String PROP_KEY_HDFS_PROTCOL_HOST = ""<STR_LIT>"" ; public static final'}]","String PROP_KEY_HDFS_PROTCOL_PORT = ""hdfs.protocol.port"";",3.885500184741065e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . SashForm ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Spinner ; import org . eclipse . swt . widgets . TabFolder ; import org . eclipse . swt . widgets . TabItem ; import org . rubypeople . rdt . core . formatter . EditableFormatHelper ; import org . rubypeople . rdt . refactoring . core . formatsource . PreviewGenerator ; public class FormatSourcePage extends RefactoringWizardPage { private static final String title = ""<STR_LIT>"" ; private StyledText previewText ; private EditableFormatHelper formatter ; private PreviewGenerator previewGenererator ; public FormatSourcePage ( EditableFormatHelper formatter , PreviewGenerator previewGenerator ) { super ( title ) ; setTitle ( title ) ; this . formatter = formatter ; this . previewGenererator = previewGenerator ; } private void createMethodsTab ( TabFolder categoryTab ) { TabItem methodsTabItem = createTabItem ( categoryTab , Messages . FormatSourcePage_Methods ) ; Composite optionComposite = createCompositeWithGridLayout ( categoryTab ) ; methodsTabItem . setControl ( optionComposite ) ; Group callArgumentsGroup = createGroupWithGridLayout ( optionComposite , Messages . FormatSourcePage_MethodCallArguments ) ; final Button callArgumentsParanthesizeWhereNecessary = createButton ( callArgumentsGroup , SWT . RADIO , Messages . FormatSourcePage_ParenthesizeWhereNecesary ) ; callArgumentsParanthesizeWhereNecessary . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setAlwaysParanthesizeMethodCalls ( ! callArgumentsParanthesizeWhereNecessary . getEnabled ( ) ) ; generatePreview ( ) ; } } ) ; final Button callArgumentsParanthesizeAlways = createButton ( callArgumentsGroup , SWT . RADIO , Messages . FormatSourcePage_AlwaysParenthesize ) ; callArgumentsParanthesizeAlways . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setAlwaysParanthesizeMethodCalls ( callArgumentsParanthesizeAlways . getEnabled ( ) ) ; generatePreview ( ) ; } } ) ; Group defArgumentsGroup = createGroupWithGridLayout ( optionComposite , Messages . FormatSourcePage_MethodDefArguments ) ; final Button defArgumentsParanthesizeWhereNecessary = createButton ( defArgumentsGroup , SWT . RADIO , Messages . FormatSourcePage_ParenthesizeWhereNecesary ) ; defArgumentsParanthesizeWhereNecessary . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setAlwaysParanthesizeMethodDefs ( ! defArgumentsParanthesizeWhereNecessary . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button defArgumentsParanthesizeAlways = createButton ( defArgumentsGroup , SWT . RADIO , Messages . FormatSourcePage_AlwaysParenthesize ) ; defArgumentsParanthesizeAlways . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setAlwaysParanthesizeMethodDefs ( defArgumentsParanthesizeAlways . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button newlineBetweenClassBodyElements = createButton ( optionComposite , SWT . CHECK , Messages . FormatSourcePage_NewlineBetweenClassElements ) ; newlineBetweenClassBodyElements . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setNewlineBetweenClassBodyElements ( newlineBetweenClassBodyElements . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; } private void createBlocksTab ( TabFolder categoryTab ) { TabItem misc = createTabItem ( categoryTab , Messages . FormatSourcePage_Blocks ) ; Composite composite = createCompositeWithGridLayout ( categoryTab ) ; misc . setControl ( composite ) ; final Button spaceBeforeIterBrackets = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpaceBeforeIterBrackets ) ; spaceBeforeIterBrackets . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpaceBeforeIterBrackets ( spaceBeforeIterBrackets . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spaceBeforeClosingIterBrackets = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpaceBeforeClosingIterBracket ) ; spaceBeforeClosingIterBrackets . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpaceBeforeClosingIterBrackets ( spaceBeforeClosingIterBrackets . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spaceBeforeIterVars = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpaceBeforeIterVars ) ; spaceBeforeIterVars . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpaceBeforeIterVars ( spaceBeforeIterVars . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spaceAfterIterVars = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpaceAfterIterVars ) ; spaceAfterIterVars . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpaceAfterIterVars ( spaceAfterIterVars . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; } private void createSpacesTab ( TabFolder categoryTab ) { TabItem spaces = createTabItem ( categoryTab , Messages . FormatSourcePage_Spaces ) ; Composite composite = createCompositeWithGridLayout ( categoryTab ) ; spaces . setControl ( composite ) ; final Button spaceAfterComma = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpaceAfterComma ) ; spaceAfterComma . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpaceAfterCommaInListings ( spaceAfterComma . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spacesAroundHashAss = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpacesAroundHashOperator ) ; spacesAroundHashAss . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpacesAroundHashAssignment ( spacesAroundHashAss . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spacesAroundHashContent = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpacesAroundHash ) ; spacesAroundHashContent . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpacesBeforeAndAfterHashContent ( spacesAroundHashContent . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; final Button spacesAroundAssignments = createButton ( composite , SWT . CHECK , Messages . FormatSourcePage_SpacesAroundAssignment ) ; spacesAroundAssignments . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setSpacesBeforeAndAfterAssignments ( spacesAroundAssignments . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; } private void createGeneralTab ( TabFolder categoryTab ) { TabItem spaces = createTabItem ( categoryTab , Messages . FormatSourcePage_General ) ; Composite composite = createCompositeWithGridLayout ( categoryTab ) ; spaces . setControl ( composite ) ; Group callArgumentsGroup = createGroupWithGridLayout ( composite , Messages . FormatSourcePage_Indentation ) ; final Button tabInsteadOfSpaces = createButton ( callArgumentsGroup , SWT . CHECK , Messages . FormatSourcePage_UseTab ) ; tabInsteadOfSpaces . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { formatter . setTabInsteadOfSpaces ( tabInsteadOfSpaces . getSelection ( ) ) ; generatePreview ( ) ; } } ) ; Composite indentationComposite = new Composite ( callArgumentsGroup , SWT . NONE ) ; indentationComposite . setLayout ( new RowLayout ( ) ) ; final Spinner indentationSteps = new Spinner ( indentationComposite , SWT . BORDER ) ; indentationSteps . setMinimum ( <NUM_LIT:0> ) ; indentationSteps . setMaximum ( <NUM_LIT:100> ) ; indentationSteps . setSelection ( <NUM_LIT:2> ) ; indentationSteps . setIncrement ( <NUM_LIT:1> ) ; indentationSteps . pack ( ) ; indentationSteps . addListener ( SWT'}]",".Selection, new Listener() { public void handleEvent(Event event) { formatter.setIndentationSteps(indentationSteps.getSelection()); generatePreview(); } } ); indentationComposite.pack(); callArgumentsGroup.layout(); } private void createPreview ( TabFolder categoryTab ) { TabItem preview = createTabItem ( categoryTab, Messages. FormatSourcePage_Preview ) ; Composite composite = new Composite ( categoryTab, SWT. NONE ) ; composite. setLayout ( new RowLayout ( ) ) ; preview. setControl ( composite ) ; previewText = new StyledText ( composite, SWT. MULTI | SWT. H_SCROLL | SWT. V_SCROLL ) ; previewText. setFont ( getFont ( ) ) ; previewText. setLayoutData ( new GridData ( ) ) ; previewText. setEditable ( false ) ; } private void generatePreview ( ) { previewText. setText ( previewGenererator. generatePreview ( formatter. getFormat ( ) ) ) ; } }",0.0003504671195524576
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . directio ; import java . lang . reflect . Type ; import java . text . MessageFormat ; import java . util . BitSet ; import java . util . List ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . asakusafw . compiler . flow . DataClass ; import com . asakusafw . compiler . flow . DataClass . Property ; import com . asakusafw . runtime . stage . directio . StringTemplate . Format ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . vocabulary . directio . DirectFileOutputDescription ; public final class OutputPattern { static final int CHAR_BRACE_OPEN = \'<CHAR_LIT>\' ; static final int CHAR_BRACE_CLOSE = \'<CHAR_LIT:}>\' ; static final int CHAR_BLOCK_OPEN = \'<CHAR_LIT:[>\' ; static final int CHAR_BLOCK_CLOSE = \'<CHAR_LIT:]>\' ; static final int CHAR_WILDCARD = \'<CHAR_LIT>\' ; static final int CHAR_SEPARATE_IN_BLOCK = \'<CHAR_LIT::>\' ; static final int CHAR_VARIABLE_START = \'<CHAR_LIT>\' ; static final BitSet CHAR_MAP_META = new BitSet ( ) ; static { CHAR_MAP_META . set ( <NUM_LIT:0> , <NUM_LIT> ) ; CHAR_MAP_META . set ( \'<STR_LIT:\\\\>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT:}>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT:[>\' ) ; CHAR_MAP_META . set ( \'<CHAR_LIT:]>\' ) ; } private static final Pattern PATTERN_ORDER = Pattern . compile ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:|>"" + ""<STR_LIT>"" + ""<STR_LIT:|>"" + ""<STR_LIT>"" + ""<STR_LIT:|>"" + ""<STR_LIT>"" + ""<STR_LIT:|>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ) ; private static final int [ ] ORDER_GROUP_INDEX = { <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:10> } ; private static final boolean [ ] ASC_MAP = { true , true , false , true , false } ; private OutputPattern ( ) { return ; } public static List < CompiledResourcePattern > compileResourcePattern ( String pattern , DataClass dataType ) { if ( pattern == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( dataType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } List < CompiledResourcePattern > results = Lists . create ( ) ; Cursor cursor = new Cursor ( pattern ) ; while ( cursor . isEof ( ) == false ) { if ( cursor . isLiteral ( ) ) { String literal = cursor . consumeLiteral ( ) ; results . add ( new CompiledResourcePattern ( literal ) ) ; } else if ( cursor . isPlaceHolder ( ) ) { Formatted ph = cursor . consumePlaceHolder ( ) ; DataClass . Property property = findProperty ( dataType , ( String ) ph . original ) ; if ( property == null ) { cursor . rewind ( ) ; throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , cursor , ph . original ) ) ; } String argument = ph . formatString ; Format format = findFormat ( property , argument ) ; if ( format == null ) { cursor . rewind ( ) ; throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , cursor , argument == null ? ""<STR_LIT>"" : argument ) ) ; } try { format . check ( property . getType ( ) , argument ) ; } catch ( IllegalArgumentException e ) { cursor . rewind ( ) ; throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , cursor , argument == null ? ""<STR_LIT>"" : argument ) , e ) ; } results . add ( new CompiledResourcePattern ( property , format , argument ) ) ; } else if ( cursor . isRandomNumber ( ) ) { Formatted rand = cursor . consumeRandomNumber ( ) ; RandomNumber source = ( RandomNumber ) rand . original ; results . add ( new CompiledResourcePattern ( source , Format . NATURAL , null ) ) ; } else if ( cursor . isWildcard ( ) ) { cursor . consumeWildcard ( ) ; results . add ( new CompiledResourcePattern ( ) ) ; } else { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , cursor ) ) ; } } return results ; } public static List < CompiledOrder > compileOrder ( List < String > orders , DataClass dataType ) { if ( orders == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( dataType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Set < String > saw = Sets . create ( ) ; List < CompiledOrder > results = Lists . create ( ) ; for ( String order : orders ) { boolean asc = false ; String name = null ; Matcher matcher = PATTERN_ORDER . matcher ( order . trim ( ) ) ; if ( matcher . matches ( ) == false ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , order ) ) ; } for ( int i = <NUM_LIT:0> ; i < ORDER_GROUP_INDEX . length ; i ++ ) { int groupIndex = ORDER_GROUP_INDEX [ i ] ; if ( matcher . group ( groupIndex ) != null ) { asc = ASC_MAP [ i ] ; name = matcher . group ( groupIndex ) ; break ; } } assert name != null ; DataClass . Property property = findProperty ( dataType , name ) ; if ( property == null ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , order , name ) ) ; } if ( saw . contains ( property . getName ( ) ) ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , order , name ) ) ; } saw . add ( property . getName ( ) ) ; results . add ( new CompiledOrder ( property , asc ) ) ; } return results ; } private static Property findProperty ( DataClass dataType , String name ) { assert dataType != null ; assert name != null ; return dataType . findProperty ( name ) ; } private static Format findFormat ( Property property , String argument ) { if ( argument == null ) { return Format . NATURAL ; } Type type = property . getType ( ) ; if ( type == DateOption . class ) { return Format . DATE ; } if ( type == DateTimeOption . class ) { return Format . DATETIME ; } return null ; } private static final class Cursor { private final char [ ] cbuf ; private int lastSegmentPosition ; private int position ; Cursor ( String value ) { assert value != null ; this . cbuf = value . toCharArray ( ) ; this . position = <NUM_LIT:0> ; } boolean isEof ( ) { return cbuf . length == position ; } boolean isLiteral ( ) { if ( isEof ( ) ) { return false ; } return CHAR_MAP_META . get ( cbuf [ position ] ) == false ; } boolean isPlaceHolder ( ) { if ( isEof ( ) ) { return false ; } return cbuf [ position ] == CHAR_BRACE_OPEN ; } boolean isRandomNumber ( ) { if ( isEof ( ) ) { return false ; } return cbuf [ position ] == CHAR_BLOCK_OPEN ; } boolean isWildcard ( ) { if ( isEof ( ) ) { return false ; } return cbuf [ position ] == CHAR_WILDCARD ; } void rewind ( ) { this . position = lastSegmentPosition ; } String consumeLiteral ( ) { assert isLiteral ('}]","()) ; lastSegmentPosition = position ; int length = 0 ; while ( isLiteral ( ) ) { length ++ ; position ++ ; } return new String ( cbuf, lastSegmentPosition, length ) ; } Formatted consumePlaceHolder ( ) { assert isPlaceHolder ( ) ; lastSegmentPosition = position + <NUM_LIT:1> ; int length = 0 ; while ( isLiteral ( ) ) { length ++ ; position ++ ; } return new Formatted ( cbuf, lastSegmentPosition - <NUM_LIT:1>, length, cbuf [ lastSegmentPosition ] ) ; } Formatted consumeRandomNumber ( ) { assert isRandomNumber ( ) ; lastSegmentPosition = position + <NUM_LIT:1> ; int length = 0 ; while ( isRandomNumber ( ) ) { length ++ ; position ++ ; } return new Formatted ( cbuf, lastSegmentPosition - <NUM_LIT:1>, length, cbuf [ lastSegmentPosition ] ) ; } void consumeWildcard ( ) { assert isWildcard ( ) ; position ++ ; } } private static final class Formatted { private final char [ ] cbuf ; private final int start ; private final int length ; private final char placeholder ;",0.0004257829158686655
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs . job ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; import org . oddjob . framework . SerializableJob ; import org . oddjob . state . MirrorState ; import org . oddjob . util . OddjobConfigException ; public class StartJob extends SerializableJob { private static final long'}]",SERIAL_VERSION_UID = 1L; @ArooaAttribute @MirrorState public String name; public StartJob() {} public StartJob(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } },9.265903657183758e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . jsr199 . testing ; import java . util . HashMap ; import java . util . Map ; public class DirectClassLoader extends ClassLoader { private Map < String , byte [ ] > classes ;'}]","public DirectClassLoader() { super(); classes = new HashMap<>(); } @Override protected Class<?> findClass(String name) throws ClassNotFoundException { byte[] b = classes.get(name); if (b == null) { throw new ClassNotFoundException(name); } return defineClass(name, b, 0, b.length); } public void addClass(String name, byte[] b) { classes.put(name, b); }",0.000116742897742862
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . content_assist ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . Tuple ; import net . sf . sveditor . core . content_assist . SVCompletionProposal ; import net . sf . sveditor . core . db . ISVDBFileFactory ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBMarker ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . db . SVDBUtil ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . index . ISVDBItemIterator ; import net . sf . sveditor . core . db . index . SVDBDeclCacheItem ; import net . sf . sveditor . core . db . index . SVDBIndexCollection ; import net . sf . sveditor . core . db . index . SVDBIndexRegistry ; import net . sf . sveditor . core . db . index . plugin_lib . SVDBPluginLibIndexFactory ; import net . sf . sveditor . core . db . search . SVDBFindDefaultNameMatcher ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclItem ; import net . sf . sveditor . core . log . ILogLevel ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . scanner . SVKeywords ; import net . sf . sveditor . core . scanutils . StringBIDITextScanner ; import net . sf . sveditor . core . tests . SVCoreTestsPlugin ; import net . sf . sveditor . core . tests . SVDBIndexValidator ; import net . sf . sveditor . core . tests . TestNullIndexCacheFactory ; import net . sf . sveditor . core . tests . TextTagPosUtils ; import net . sf . sveditor . core . tests . utils . BundleUtils ; import net . sf . sveditor . core . tests . utils . TestUtils ; import org . eclipse . core . runtime . NullProgressMonitor ; public class TestContentAssistBasics extends TestCase { private SVDBIndexCollection fIndexCollectionOVMMgr ; private SVDBIndexCollection fIndexCollectionVMMMgr ; private SVDBIndexCollection fIndexCollectionStandalone ; private ContentAssistIndex fIndex ; private File fTmpDir ; @ Override public void setUp ( ) { fTmpDir = TestUtils . createTempDir ( ) ; BundleUtils utils = new BundleUtils ( SVCoreTestsPlugin . getDefault ( ) . getBundle ( ) ) ; utils . copyBundleDirToFS ( ""<STR_LIT>"" , fTmpDir ) ; String pname = ""<STR_LIT>"" ; SVDBIndexRegistry rgy = SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) ; rgy . init ( new TestNullIndexCacheFactory ( ) ) ; fIndex = new ContentAssistIndex ( ) ; fIndex . init ( new NullProgressMonitor ( ) ) ; fIndexCollectionVMMMgr = new SVDBIndexCollection ( pname ) ; fIndexCollectionVMMMgr . addLibraryPath ( fIndex ) ; fIndexCollectionVMMMgr . addPluginLibrary ( rgy . findCreateIndex ( new NullProgressMonitor ( ) , pname , SVCoreTestsPlugin . VMM_LIBRARY_ID , SVDBPluginLibIndexFactory . TYPE , null ) ) ; } private SVDBIndexCollection createStandaloneIndexMgr ( ) { if ( fIndexCollectionStandalone == null ) { fIndexCollectionStandalone = new SVDBIndexCollection ( ""<STR_LIT>"" ) ; fIndexCollectionStandalone . addLibraryPath ( fIndex ) ; } return fIndexCollectionStandalone ; } private SVDBIndexCollection createOVMIndexMgr ( ) { if ( fIndexCollectionOVMMgr == null ) { SVDBIndexRegistry rgy = SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) ; fIndexCollectionOVMMgr = new SVDBIndexCollection ( ""<STR_LIT>"" ) ; fIndexCollectionOVMMgr . addLibraryPath ( fIndex ) ; fIndexCollectionOVMMgr . addPluginLibrary ( rgy . findCreateIndex ( new NullProgressMonitor ( ) , ""<STR_LIT>"" , SVCoreTestsPlugin . OVM_LIBRARY_ID , SVDBPluginLibIndexFactory . TYPE , null ) ) ; } return fIndexCollectionOVMMgr ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; TestUtils . delete ( fTmpDir ) ; } public void testOVMMacroContentAssist ( ) { String testname = ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . setDebugLevel ( ILogLevel . LEVEL_OFF ) ; LogHandle log = LogFactory . getLogHandle ( testname ) ; String doc1 = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc1 ) ; TextTagPosUtils tt_utils = ini . second ( ) ; ISVDBFileFactory factory = SVCorePlugin . createFileFactory ( null ) ; List < SVDBMarker > markers = new ArrayList < SVDBMarker > ( ) ; SVDBFile file = factory . parse ( tt_utils . openStream ( ) , ""<STR_LIT>"" , markers ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( tt_utils . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( testname , file , createOVMIndexMgr ( ) ) ; scanner . seek ( tt_utils . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; log . debug ( ILogLevel . LEVEL_MIN , ""<STR_LIT>"" ) ; cp . computeProposals ( scanner , file , tt_utils . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; log . debug ( ILogLevel . LEVEL_MIN , ""<STR_LIT>"" ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; LogFactory . removeLogHandle ( log ) ; } public void testVMMMacroContentAssist ( ) { String doc1 = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc1 ) ; TextTagPosUtils tt_utils = ini . second ( ) ; ISVDBFileFactory factory = SVCorePlugin . createFileFactory ( null ) ; List < SVDBMarker > markers = new ArrayList < SVDBMarker > ( ) ; SVDBFile file = factory . parse ( tt_utils . openStream ( ) , ""<STR_LIT>"" , markers ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( tt_utils . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ""<STR_LIT>"" , file , fIndexCollectionVMMMgr ) ; scanner . seek ( tt_utils . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , file , tt_utils . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" } , proposals ) ; } public void testScopedNonInheritanceAssist ( ) { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; ISVDBIndexIterator index_it = cp . getIndexIterator ( ) ; ISVDBItemIterator it = index_it . getItemIterator ( new NullProgressMonitor ( ) ) ; SVDBIndexValidator v = new SVDBIndexValidator ( ) ; v . validateIndex ( index_it . getItemIterator ( new NullProgressMonitor ( ) ) , SVDBIndexValidator . ExpectErrors ) ; SVDBClassDecl my_class2 = null ; List < SVDBDeclCacheItem > found = index_it . findGlobalScopeDecl ( new NullProgressMonitor ( ) , ""<STR_LIT>"" , SVDBFindDefaultNameMatcher . getDefault ( ) ) ; assertEquals ( <NUM_LIT:1> , found . size ( ) ) ; my_class2 = ( SVDBClassDecl ) found . get ( <NUM_LIT:0> ) . getSVDBItem ( ) ; assertNotNull ( my_class2 ) ; log . debug ( ""<STR_LIT>"" + SVDBUtil . getChildrenSize ( my_class2 ) + ""<STR_LIT>"" ) ; for ( ISVDBItemBase it_t : my_class2 . getChildren ( ) ) { log . debug ( ""<STR_LIT>"" + it_t . getType ( ) + ""<STR_LIT:U+0020>"" + SVDBItem . getName ( it_t ) ) ; } cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; LogFactory . removeLogHandle ( log ) ; } public void testScopedFieldContentAssist ( ) { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createStandaloneIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testScopedFieldDerefContentAssist ( ) { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testExternScopedFieldContentAssist ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testScopedTypedefFieldContentAssist ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testScopedInheritanceAssist ( ) { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testConstructorCompletion ( ) { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , createOVMIndexMgr ( ) ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; for ( SVCompletionProposal p : proposals ) { log . debug ( ""<STR_LIT>"" + p . getReplacement ( ) + ""<STR_LIT:\\"">"" ) ; } assertEquals ( ""<STR_LIT>"" , <NUM_LIT:2> , proposals . size ( ) ) ; SVDBTask new_f ; SVDBVarDeclItem new_field ; if ( proposals . get ( <NUM_LIT:0> ) . getItem ( ) . getType ( ) == SVDBItemType . Function ) { new_f = ( SVDBTask ) proposals . get ( <NUM_LIT:0> ) . getItem ( ) ; new_field = ( SVDBVarDeclItem ) proposals . get ( <NUM_LIT:1> ) . getItem ( ) ; } else { new_f = ( SVDBTask ) proposals . get ( <NUM_LIT:1> ) . getItem ( ) ; new_field = ( SVDBVarDeclItem ) proposals . get ( <NUM_LIT:0> ) . getItem ( ) ; } log . debug ( ""<STR_LIT>"" + new_f . getParent ( ) . getType ( ) + ""<STR_LIT:U+0020>"" + SVDBItem . getName ( new_f . getParent ( ) ) ) ; assertEquals ( ""<STR_LIT>"" , ""<STR_LIT>"" , new_f . getName ( ) ) ; assertEquals ( ""<STR_LIT>"" , ""<STR_LIT>"" , SVDBItem . getName ( new_field ) ) ; assertEquals ( ""<STR_LIT>"" , ""<STR_LIT>"" , SVDBItem . getName ( new_f . getParent ( ) ) ) ; assertEquals ( ""<STR_LIT>"" , ""<STR_LIT>"" , SVDBItem . getName ( new_field . getParent ( ) . getParent ( ) ) ) ; LogFactory . removeLogHandle ( log ) ; } public void testUntriggeredClassAssist ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , fIndex ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; for ( int i = <NUM_LIT:0> ; i < proposals . size ( ) ; i ++ ) { if ( SVKeywords . isSVKeyword ( proposals . get ( i ) . getReplacement ( ) ) ) { proposals . remove ( i ) ; i -- ; } } validateResults ( new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , proposals ) ; } public void testEmptyFileAssist ( ) { String doc = ""<STR_LIT>"" ; Tuple < SVDBFile , TextTagPosUtils > ini = contentAssistSetup ( doc ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( ini . second ( ) . getStrippedData ( ) ) ; TestCompletionProcessor cp = new TestCompletionProcessor ( ini . first ( ) , fIndex ) ; scanner . seek ( ini . second ( ) . getPosMap ( ) . get ( ""<STR_LIT>"" ) ) ; cp . computeProposals ( scanner , ini . first ( ) , ini . second ( ) . getLineMap ( ) . get ( ""<STR_LIT>"" ) ) ; List < SVCompletionProposal > proposals = cp . getCompletionProposals ( ) ; for ( int i = <NUM_LIT:0> ; i < proposals . size ( ) ; i ++ ) { if ( SVKeywords . isSVKeyword ( proposals . get ( i ) . getReplacement ( ) ) ) { proposals . remove ( i ) ; i -- ; } }'}]","public Tuple<SVDBFile, TextTagPosUtils> contentAssistSetup(String doc) {... }",0.00015676506837854556
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import java . util . Iterator ; import org . eclipse . core . resources . IMarker ; import org . eclipse . ui . texteditor . MarkerAnnotation ; import org . eclipse . ui . texteditor . MarkerUtilities ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyModelMarker ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyCore ; public class RubyMarkerAnnotation extends MarkerAnnotation implements IRubyAnnotation { public static final String RUBY_MARKER_TYPE_PREFIX = ""<STR_LIT>"" ; public static final String ERROR_ANNOTATION_TYPE = ""<STR_LIT>"" ; public static final String WARNING_ANNOTATION_TYPE = ""<STR_LIT>"" ; public static final String INFO_ANNOTATION_TYPE = ""<STR_LIT>"" ; public static final String TASK_ANNOTATION_TYPE = ""<STR_LIT>"" ; private IRubyAnnotation fOverlay ; public RubyMarkerAnnotation ( IMarker marker ) { super ( marker ) ; } public String [ ] getArguments ( ) { return null ; } public int getId ( ) { IMarker marker = getMarker ( ) ; if ( marker == null || ! marker . exists ( ) ) return - <NUM_LIT:1> ; if ( isProblem ( ) ) return marker . getAttribute ( IRubyModelMarker . ID , - <NUM_LIT:1> ) ; return - <NUM_LIT:1> ; } public boolean isProblem ( ) { String type = getType ( ) ; return WARNING_ANNOTATION_TYPE . equals ( type ) || ERROR_ANNOTATION_TYPE . equals ( type ) ; } public void setOverlay ( IRubyAnnotation RubyAnnotation ) { if ( fOverlay != null ) fOverlay . removeOverlaid ( this ) ; fOverlay = RubyAnnotation ; if ( ! isMarkedDeleted ( ) ) markDeleted ( fOverlay != null ) ; if ( fOverlay != null )'}]","fOverlay.addOverlaid(this); } public String getType() { return fMarker.getAttribute(IRubyModelMarker.ID, -1); } public IRubyElement getRubyElement() { return fMarker.getResource(); } public IRubyScript getRubyScript() { return fMarker.getResource(); } public void setRubyElement(IRubyElement element) { fMarker.setAttribute(IRubyModelMarker.RUBY_ELEMENT, element); } public void setRubyScript(IRubyScript script) { fMarker.setAttribute(IRubyModelMarker.RUBY_SCRIPT, script); } public void setProblem(boolean problem) { setAttribute(IRubyModelMarker.PROBLEM, problem); } public void setSeverity(String severity) { setAttribute(IRubyModelMarker.SEVERITY, severity); } public String getSeverity() { return getAttribute(IRubyModelMarker.SEVERITY, -1); } public void setLine(int line) { fMarker.setAttribute(IRubyModelMarker.LINE, line); } public int getLine() { return fMarker.getAttribute(IRubyModelMarker.LINE, -1); } public void setColumn(int column) { fMarker.setAttribute(IRubyModelMarker.COLUMN, column); } public int getColumn() { return fMarker.getAttribute(IRubyModelMarker.COLUMN, -1); } public void setFile(String file) { f",0.0003621942343846367
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . folding ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . text . Assert ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . source . Annotation ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . jface . text . source . projection . IProjectionListener ; import org . eclipse . jface . text . source . projection . IProjectionPosition ; import org . eclipse . jface . text . source . projection . ProjectionAnnotation ; import org . eclipse . jface . text . source . projection . ProjectionAnnotationModel ; import org . eclipse . jface . text . source . projection . ProjectionViewer ; import org . eclipse . ui . texteditor . IDocumentProvider ; import org . eclipse . ui . texteditor . ITextEditor ; import org . rubypeople . rdt . core . ElementChangedEvent ; import org . rubypeople . rdt . core . IElementChangedListener ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IParent ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyElementDelta ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceRange ; import org . rubypeople . rdt . core . ISourceReference ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . util . RDocUtil ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyAbstractEditor ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . ui . IWorkingCopyManager ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . text . folding . IRubyFoldingStructureProvider ; import org . rubypeople . rdt . ui . text . folding . IRubyFoldingStructureProviderExtension ; public class DefaultRubyFoldingStructureProvider implements IProjectionListener , IRubyFoldingStructureProvider , IRubyFoldingStructureProviderExtension { private ITextEditor fEditor ; private ProjectionViewer fViewer ; private IDocument fCachedDocument ; private ProjectionAnnotationModel fCachedModel ; private boolean fAllowCollapsing ; private IRubyElement fInput ; private IElementChangedListener fElementListener ; private boolean fCollapseInnerTypes ; private boolean fCollapseRubydoc ; private boolean fCollapseMethods ; public void install ( ITextEditor editor , ProjectionViewer viewer ) { if ( editor instanceof RubyAbstractEditor ) { fEditor = editor ; fViewer = viewer ; fViewer . addProjectionListener ( this ) ; } } public void uninstall ( ) { if ( isInstalled ( ) ) { projectionDisabled ( ) ; fViewer . removeProjectionListener ( this ) ; fViewer = null ; fEditor = null ; } } protected boolean isInstalled ( ) { return fEditor != null ; } public void initialize ( ) { if ( ! isInstalled ( ) ) return ; initializePreferences ( ) ; try { IDocumentProvider provider = fEditor . getDocumentProvider ( ) ; fCachedDocument = provider . getDocument ( fEditor . getEditorInput ( ) ) ; fAllowCollapsing = true ; if ( fEditor instanceof RubyEditor ) { IWorkingCopyManager manager = RubyPlugin . getDefault ( ) . getWorkingCopyManager ( ) ; fInput = manager . getWorkingCopy ( fEditor . getEditorInput ( ) ) ; } if ( fInput != null ) { ProjectionAnnotationModel model = ( ProjectionAnnotationModel ) fEditor . getAdapter ( ProjectionAnnotationModel . class ) ; if ( model != null ) { fCachedModel = model ; if ( fInput instanceof IRubyScript ) { IRubyScript unit = ( IRubyScript ) fInput ; synchronized ( unit ) { try { unit . reconcile ( ) ; } catch ( RubyModelException e ) { } } } Map < RubyProjectionAnnotation , Position > additions = computeAdditions ( ( IParent ) fInput ) ; List removals = new LinkedList ( ) ; Iterator existing = model . getAnnotationIterator ( ) ; while ( existing . hasNext ( ) ) removals . add ( existing . next ( ) ) ; model . replaceAnnotations ( ( Annotation [ ] ) removals . toArray ( new Annotation [ removals . size ( ) ] ) , additions ) ; } } } finally { fCachedDocument = null ; fAllowCollapsing = false ; fCachedModel = null ; } } private Map < RubyProjectionAnnotation , Position > computeAdditions ( IParent parent ) { Map < RubyProjectionAnnotation , Position > map = new HashMap < RubyProjectionAnnotation , Position > ( ) ; try { computeAdditions ( parent . getChildren ( ) , map ) ; } catch ( RubyModelException x ) { RubyPlugin . log ( x ) ; } return map ; } private void computeAdditions ( IRubyElement [ ] elements , Map < RubyProjectionAnnotation , Position > map ) throws RubyModelException { for ( int i = <NUM_LIT:0> ; i < elements . length ; i ++ ) { IRubyElement element = elements [ i ] ; computeAdditions ( element , map ) ; if ( element instanceof IParent ) { IParent parent = ( IParent ) element ; computeAdditions ( parent . getChildren ( ) , map ) ; } } } private void computeAdditions ( IRubyElement element , Map < RubyProjectionAnnotation , Position > map ) { boolean createProjection = false ; boolean collapse = false ; switch ( element . getElementType ( ) ) { case IRubyElement . TYPE : collapse = fAllowCollapsing && fCollapseInnerTypes && isInnerType ( ( IType ) element'}]",") ; break;case IRubyElement.DOCUMENT:collapse = fAllowCollapsing && fCollapseRubydoc;break;case IRubyElement.METHOD:collapse = fAllowCollapsing && fCollapseMethods;break;case IRubyElement.CLASS:case IRubyElement.MODULE:case IRubyElement.ENUM:case IRubyElement.SYNTHETIC:collapse = fAllowCollapsing;break;default:createProjection = true;break;}if ( createProjection ) {RubyProjectionAnnotation annotation = new RubyProjectionAnnotation(element, collapse);map.put(annotation, element.getPosition());}}private boolean isInnerType(IType type) {if (type == null) return false;if (type.isInner()) return true;if (type.getVisibility() == IType.PRIVATE) return true;if (type.getVisibility() == IType.PROTECTED) return true;if (type.getVisibility() == IType.PACKAGE) return true;return false;}public void projectionChanged(int start, int length) {if (isInstalled()) {computeAdditions(fInput.getChildren(), new HashMap<RubyProjectionAnnotation, Position>());} else {fViewer.setDirty(true);}}public void projectionDisabled() {if (isInstalled()) {fCachedDocument = null;fAllowColl",0.000407448293968415
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . explorer ; import java . text . Collator ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBScopeItem ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; public class SVFileSorter extends ViewerSorter { public SVFileSorter ( ) { } public SVFileSorter ( Collator collator ) { super ( collator ) ; }'}]","@Override public int compare(Viewer viewer, Object item1, Object item2) { ISVDBChildItem childItem1 = (ISVDBChildItem) item1; ISVDBChildItem childItem2 = (ISVDBChildItem) item2; if (childItem1 == null && childItem2 == null) return 0; if (childItem1 == null) return -1; if (childItem2 == null) return 1; return childItem1.getName().compareTo(childItem2.getName()); }",0.00015633641830201266
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . testunit . ui ; import org . eclipse . jface . action . Action ; public class EnableStackFilterAction extends Action { private FailureTrace fView ; public EnableStackFilterAction ( FailureTrace view ) { super ( TestUnitMessages . EnableStackFilterAction_action_label ) ; setDescription ( TestUnitMessages . EnableStackFilterAction_action_description ) ; setToolTipText ( TestUnitMessages . EnableStackFilterAction_action_tooltip ) ; setDisabledImageDescriptor'}]",(org. eclipse. ui. images. SharedPluginImages. LEGACY_IMAGE_DISABLE); fView = view; } public void run ( ) { fView. enableStackFilter ( ); },6.466031441711735e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . model . util ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public final class CommentEmitTrait { private static final String REGEX_LINE_DELIMITER = ""<STR_LIT>"" ; private List < String > contents ; public CommentEmitTrait ( List < String > contents ) { if ( contents == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . contents = new ArrayList < String > ( contents . size ( ) ) ; for ( String line : contents ) { String [ ] splitted = line . split ('}]","REGEX_LINE_DELIMITER ) ; this. contents. add ( splitted [ 0 ] ) ; } } public CommentEmitTrait ( List < String > contents, int capacity ) { this ( contents ) ; if ( capacity > 0 ) { this. contents. ensureCapacity ( capacity ) ; } } public List < String > getContents ( ) { return Collections. unmodifiableList ( this. contents ) ; } }",0.00012988729221892763
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import java . util . ArrayList ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ITreeViewerListener ; import org . eclipse . jface . viewers . TreeExpansionEvent ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . swt . widgets . Widget ; public class ContainerCheckedTreeViewer extends CheckboxTreeViewer { public ContainerCheckedTreeViewer ( Composite parent ) { super ( parent ) ; initViewer ( ) ; } public ContainerCheckedTreeViewer ( Composite parent , int style ) { super ( parent , style ) ; initViewer ( ) ; } public ContainerCheckedTreeViewer ( Tree tree ) { super ( tree ) ; initViewer ( ) ; } private void initViewer ( ) { setUseHashlookup ( true ) ; addCheckStateListener ( new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { doCheckStateChanged ( event . getElement ( ) ) ; } } ) ; addTreeListener ( new ITreeViewerListener ( ) { public void treeCollapsed ( TreeExpansionEvent event ) { } public void treeExpanded ( TreeExpansionEvent event ) { Widget item = findItem ( event . getElement ( ) ) ; if ( item instanceof TreeItem ) { initializeItem ( ( TreeItem ) item ) ; } } } ) ; } protected void doCheckStateChanged ( Object element ) { Widget item = findItem ( element ) ; if ( item instanceof TreeItem ) { TreeItem treeItem = ( TreeItem ) item ; treeItem . setGrayed ( false ) ; updateChildrenItems ( treeItem ) ; updateParentItems ( treeItem . getParentItem ( ) ) ; } } private void initializeItem ( TreeItem item ) { if ( item . getChecked ( ) && ! item . getGrayed ( ) ) { updateChildrenItems ( item ) ; } } private void updateChildrenItems ( TreeItem parent ) { Item [ ] children = getChildren ( parent ) ; boolean state = parent . getChecked ( ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; i ++ ) { TreeItem curr = ( TreeItem ) children [ i ] ; if ( curr . getData ( ) != null'}]",&&! curr. getGrayed ( ) ) { curr. setChecked ( state ) ; updateChildrenItems ( curr ) ; } } private void updateParentItems ( TreeItem item ) { if ( item!= null &&! item. getGrayed ( ) ) { if ( item. getChildrenCount ( ) == 0 ||! getChildren ( item ). any ( new Predicate <Item> ( ) { public boolean apply ( Item arg0 ) { return arg0 instanceof TreeItem && ( ( TreeItem ) arg0 ). getChecked ( ) ; } } ) ) { item. setChecked ( false ) ; } else { item. setGrayed ( true ) ; } } } private Item [ ] getChildren ( TreeItem item ) { Tree tree = ( Tree ) item. getParent ( ) ; return tree. getItems ( ) ; } },9.728354970602289e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . windgate . jdbc . driver ; import java . util . Map ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstAttributeElement ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; import com . asakusafw . dmdl . spi . ModelAttributeDriver ; import com . asakusafw . dmdl . util . AttributeUtil ; public class JdbcTableDriver extends ModelAttributeDriver { public static final String TARGET_NAME = ""<STR_LIT>"" ; public static final String ELEMENT_NAME ='}]","""<STR_LIT>"" ; public JdbcTableDriver ( ) { super ( new JdbcTableDriverFactory ( ) ) ; } @ Override public String getTargetName ( ) { return TARGET_NAME ; } @ Override public AstAttribute createAttribute ( DmdlSemantics semantics, ModelDeclaration modelDeclaration, Map < String, AstAttributeElement > elements ) { return new JdbcTableAttribute ( semantics, modelDeclaration, elements. get ( ELEMENT_NAME ) ) ; } }",0.00013699214184479096
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io ; import java . io . Closeable ; import java . io . IOException ; import com . asakusafw . runtime . value . BooleanOption ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . DoubleOption ; import com . asakusafw . runtime . value . FloatOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value .'}]","LongOption;import com.asakusafw.runtime.value.StringOption;import com.asakusafw.runtime.value.TimeOption;public class ValueInput implements Closeable { private final ValueInputFactory factory;private final InputStream input;private final OptionFactory optionFactory;public ValueInput(InputStream input, OptionFactory optionFactory, ValueInputFactory factory) throws IOException {this.input = input;this.optionFactory = optionFactory;this.factory = factory;}public ValueInput(InputStream input, ValueInputFactory factory) throws IOException {this(input, new DefaultOptionFactory(), factory);}public ValueInput(InputStream input) throws IOException {this(input, new DefaultOptionFactory(), new DefaultValueInputFactory());}public void close() throws IOException {input.close();}public static class ValueInputFactory { public abstract ValueInput create(InputStream input, OptionFactory optionFactory);public abstract ValueInput create(InputStream input);public abstract ValueInput create(InputStream input, OptionFactory optionFactory, ValueInputFactory factory);}public abstract class OptionFactory { public abstract <T extends Value> T getOption(Class<T> type, String key) throws IOException;public abstract <T extends Value> T getOption(Class<T> type, String key, T defaultValue) throws IOException;public abstract <T extends Value> T getOption",0.00034596165264130243
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ImportTableLock ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; @ Generated ( ""<STR_LIT>"" )'}]",public class ImportTableLockModelOutput extends ModelOutput<ImportTableLock> implements RecordEmitter<ImportTableLock> {,4.539848202773118e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . parser . javacc ; import static com . pogofish . jadt . ast . JavaComment . _JavaEOLComment ; import java . io . Reader ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import com . pogofish . jadt . ast . JavaComment ; import com . pogofish . jadt . comments . BlockCommentParser ; import com . pogofish . jadt . comments . JavaDocParser ; import com . pogofish . jadt . errors . SyntaxError ; import com . pogofish . jadt . parser . ParserImpl ; import com . pogofish . jadt . parser . javacc . generated . BaseJavaCCParserImpl ; import com . pogofish . jadt . parser . javacc . generated . Token ; import com . pogofish . jadt . util . Util ; public class JavaCCParserImpl extends BaseJavaCCParserImpl implements ParserImpl { private static final String COMMENT_NOT_ALLOWED = ""<STR_LIT>"" ; private static final String UNTERMINATED_COMMENT_STRING = ""<STR_LIT>"" ; private static final String EOF_STRING = ""<STR_LIT>"" ; private static final JavaDocParser javaDocParser = new JavaDocParser ( ) ; private static final BlockCommentParser blockCommentParser = new BlockCommentParser ( ) ; private boolean recovering = false ; private final String srcInfo ; ; private final List < SyntaxError > errors = new ArrayList < SyntaxError > ( ) ; private int nextId = <NUM_LIT:1> ; private static final Set < Integer > punctuation = Collections . unmodifiableSet ( Util . set ( LANGLE , RANGLE , EQUALS , LPAREN , RPAREN , COMMA , BAR , LBRACKET , RBRACKET , DOT , EOF ) ) ; public JavaCCParserImpl ( String srcInfo , Reader stream ) { super ( new JavaCCReader ( stream ) ) ; this . srcInfo = srcInfo ; } @ Override protected void checkNoComments ( String expected ) { final List < JavaComment > comments = tokenComments ( ) ; if ( ! comments . isEmpty ( ) ) { error ( expected , COMMENT_NOT_ALLOWED ) ; } } private boolean peekPunctuation ( ) { return ( punctuation . contains ( lookahead ( <NUM_LIT:1> ) . kind ) ) ; } @ Override protected String badIdentifier ( String expected ) { error ( expected ) ; final String id = ""<STR_LIT:@>"" + ( nextId ++ ) ; if ( ! peekPunctuation ( ) ) { final Token token = getNextToken ( ) ; return ""<STR_LIT>"" + ""<STR_LIT:_>"" + friendlyName ( token ) + id ; } else { return ""<STR_LIT>"" + id ; } } @ Override protected void recovered ( ) { recovering = false ; } @ Override public List < SyntaxError > errors ( ) { return errors ; } @ Override public String getSrcInfo ( ) { return srcInfo ; } @ Override protected void error ( String expected ) { error ( expected , friendlyName ( lookahead ( <NUM_LIT:1> ) ) ) ; } private void error ( String expected , String actual ) { if ( ! recovering ) { recovering = true ; final String outputString = ( EOF_STRING . equals ( actual ) || UNTERMINATED_COMMENT_STRING . equals ( actual ) || COMMENT_NOT_ALLOWED . equals ( actual ) ) ? actual : ""<STR_LIT:\'>"" + actual + ""<STR_LIT:\'>"" ; errors . add ( SyntaxError . _UnexpectedToken ( expected , outputString , lookahead ( <NUM_LIT:1> ) . beginLine ) ) ; } } private String friendlyName ( Token token ) { return token . kind == EOF ? EOF_STRING : token . kind == UNTERMINATED_COMMENT'}]","? UNTERMINATED_COMMENT_STRING : token. kind == COMMENT? COMMENT_NOT_ALLOWED : token. image ; } private List < JavaComment > tokenComments ( ) { final List < JavaComment > comments = new ArrayList < JavaComment > ( ) ; comments. addAll ( javaDocParser. parse ( ) ) ; comments. addAll ( blockCommentParser. parse ( ) ) ; return comments ; } @ Override protected void checkNoUnterminatedComments ( String expected ) { final List < JavaComment > comments = tokenComments ( ) ; comments. removeIf ( comment -> comment. kind == _JavaEOLComment ) ; if (! comments. isEmpty ( ) ) { error ( expected, UNTERMINATED_COMMENT_STRING ) ; } } @ Override protected void checkNoComments ( String expected, String actual ) { final List < JavaComment > comments = tokenComments ( ) ; if (! comments. isEmpty ( ) ) { error ( expected, COMMENT_NOT_ALLOWED ) ; } } @ Override protected void checkNoUnterminatedComments ( String expected, String actual ) { final List < JavaComment > comments = tokenComments ( ) ; comments. removeIf ( comment -> comment. kind == _JavaEOLComment ) ; if (! comments.",0.0003784016997271684
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . mapgen ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Pattern ; import de . fuberlin . wiwiss . d2rq . mapgen . Filter . IdentifierMatcher ; public class FilterParser { private final String s ; private final List < List < IdentifierMatcher > > result = new ArrayList < List < IdentifierMatcher > > ( ) ; private int index = <NUM_LIT:0> ; public FilterParser ( String filterSpec ) { s = filterSpec ; } public Filter parseSchemaFilter ( ) throws ParseException { List < Filter > result = new ArrayList < Filter > ( ) ; for ( List < IdentifierMatcher > list : parse ( ) ) { if ( list . size ( ) != <NUM_LIT:1> ) { throw new ParseException ( ""<STR_LIT>"" + s + ""<STR_LIT:\'>"" ) ; } result . add ( new FilterMatchSchema ( list . get ( <NUM_LIT:0> ) ) ) ; } return FilterMatchAny . create ( result ) ; } public Filter parseTableFilter ( boolean matchParents ) throws ParseException { List < Filter > result = new ArrayList < Filter > ( ) ; for ( List < IdentifierMatcher > list : parse ( ) ) { if ( list . size ( ) < <NUM_LIT:1> || list . size ( ) > <NUM_LIT:2> ) { throw new ParseException ( ""<STR_LIT>"" + s + ""<STR_LIT:\'>"" ) ; } if ( list . size ( ) == <NUM_LIT:1> ) { result . add ( new FilterMatchTable ( Filter . NULL_MATCHER , list . get ( <NUM_LIT:0> ) , matchParents ) ) ; } else { result . add ( new FilterMatchTable ( list . get ( <NUM_LIT:0> ) , list . get ( <NUM_LIT:1> ) , matchParents ) ) ; } } return FilterMatchAny . create ( result ) ; } public Filter parseColumnFilter ( boolean matchParents ) throws ParseException { List < Filter > result = new ArrayList < Filter > ( ) ; for ( List < IdentifierMatcher > list : parse ( ) ) { if ( list . size ( ) < <NUM_LIT:2> || list . size ( ) > <NUM_LIT:3> ) { throw new ParseException ( ""<STR_LIT>"" + s + ""<STR_LIT:\'>"" ) ; } if ( list . size ( ) == <NUM_LIT:2> ) { result . add ( new FilterMatchColumn ( Filter . NULL_MATCHER , list . get ( <NUM_LIT:0> ) , list . get ( <NUM_LIT:1> ) , matchParents ) ) ; } else { result . add ( new FilterMatchColumn ( list . get ( <NUM_LIT:0> ) , list . get ( <NUM_LIT:1> ) , list . get ( <NUM_LIT:2> ) , matchParents ) ) ; } } return FilterMatchAny . create ( result ) ; } public List < List < IdentifierMatcher > > parse ( ) throws ParseException { eatSeparators ( ) ; while ( ! atEnd ( ) ) { List < IdentifierMatcher > list = new ArrayList < IdentifierMatcher > ( ) ; while ( ! atEnd ( ) ) { if ( current ( ) == \'<CHAR_LIT:/>\' ) { list . add ( parseRegex ( ) ) ; } else { list . add ( parseIdentifier ( ) ) ; } if ( ! atEnd ( ) && atFilterTerminator ( ) ) { break ; } index ++ ; } result . add ( list ) ; eatSeparators ( ) ; } return result ; } private void eatSeparators ( ) { while ( ! atEnd ( ) && atSeparator ( ) ) index ++ ; } private char current ( ) { return s . charAt ( index ) ; } private boolean atSeparator ( ) { return current ( ) == \'<CHAR_LIT:U+0020>\' || current ( ) == \'<STR_LIT:\\n>\' || current ( ) == \'<STR_LIT>\' || current ( ) == \'<STR_LIT:\\t>\' || current ( ) == \'<CHAR_LIT:U+002C>\' ; }'}]",private boolean atEnd() { return index >= s.length(); },4.59235971980169e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . oddjob . io ; import java . io . File ; import java . io . FileFilter ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . Set ; import java . util . TreeSet ; import org . apache . commons . io . FilenameUtils ; public class WildcardSpec { private File file ; public WildcardSpec ( String spec ) { this ( new File ( spec ) ) ; } public WildcardSpec ( File file ) { this . file = file ; } public File [ ] findFiles ( ) { DirectorySplit split = new DirectorySplit ( file ) ; return findFiles ( split ) ; } public File [ ] findFiles ( final DirectorySplit split ) { Set < File > results = new TreeSet < File > ( ) ; if ( split . getParentFile ( ) == null ) { results . add ( new File ( split . getName ( ) ) ) ; } else { File [ ] matching = split . getParentFile ( ) . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return FilenameUtils . wildcardMatchOnSystem ( pathname . getName ( ) , split . getName ( ) ) ; } } ) ; for ( int i = <NUM_LIT:0> ; matching != null && i < matching . length ; ++ i ) { if ( ! split . isBottom ( ) ) { if ( matching [ i ] . isDirectory ( ) ) { File [ ] more = findFiles ( split . next ( matching [ i ] . getName ( ) ) ) ; results . addAll ( Arrays . asList ( more ) ) ; } } else { results . add ( matching [ i ] ) ; } } } return ( File [ ] ) results . toArray ( new File [ <NUM_LIT:0> ] ) ; } static class DirectorySplit { LinkedList < AboveAndBelow > split = new LinkedList < AboveAndBelow > ( ) ; private DirectorySplit ( ) { } DirectorySplit ( File file ) { for ( AboveAndBelow ab = new AboveAndBelow ( file ) ; true ; ab = new AboveAndBelow ( ab ) ) { split . add ( ab ) ; if ( ab . top ) { break ; } if ( ab . parent . getPath ( ) . indexOf ( '<CHAR_LIT>' ) < <NUM_LIT:0> && ab . parent . getPath ( ) . indexOf ( '<CHAR_LIT>' ) < <NUM_LIT:0> ) { break ; } } } File getParentFile ( ) { File parent = ( ( AboveAndBelow ) split . getLast ( ) ) . parent ; return parent ; } String getName ( ) { return ( ( AboveAndBelow ) split . getLast ( ) ) . name ; } boolean isBottom ( ) { return""}]","split.isEmpty(); } AboveAndBelow next(String name) { AboveAndBelow ab = split.getFirst(); ab.name = name; return ab; } } static class AboveAndBelow { File parent; String name; boolean top; AboveAndBelow(File file) { parent = file; top = file.isDirectory() || file.getName().equals(""<CHAR_LIT>""); } AboveAndBelow(AboveAndBelow ab) { parent = ab.parent; name = ab.name; top = ab.top; } } }",0.00015810856031044505
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . search ; import org . eclipse . core . runtime . CoreException ; public abstract class SearchRequestor { public abstract void acceptSearchMatch ( SearchMatch match ) throws CoreException ;'}]",public abstract void acceptSearchMatches ( SearchMatch[] matches ) throws CoreException;,3.6926370975275244e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package hudson . jbpm . model . gpd ; import com . thoughtworks . xstream . annotations . XStreamAlias ; import com . thoughtworks . xstream . annotations . XStreamAsAttribute ; @ XStreamAlias ( ""<STR_LIT:label>"" ) public class Label { public int getX ( ) { return x ; } public void setX ( int x ) { this .'}]",x = x; } @ XStreamAsAttribute private int x ; },3.440922609332436e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . callhierarchy ; import org . eclipse . jface . action . Action ; import org . rubypeople . rdt . core . search . IRubySearchScope ; abstract class SearchScopeAction extends Action { private final SearchScopeActionGroup fGroup ; public SearchScopeAction ('}]","IRubySearchScope scope, String text, SearchScopeActionGroup group) { super(text); this.fGroup = group; } public void run() { IRubySearchScope scope = getSearchScope(); if (scope!= null) { scope.search(); } } protected IRubySearchScope getSearchScope(); }",9.681427725990149e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package og . android . tether ; import android . app . Activity ; import android . content . Intent ; import android . os . Bundle ; import android . os . Looper ; import android . util . Log ; import com . facebook . android . DialogError ; import com . facebook . android . Facebook ; import com . facebook . android . Facebook . DialogListener ; import com . facebook . android . FacebookError ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . net . MalformedURLException ; import org . json . JSONException ; import org . json . JSONObject ; public class FBManager { private static final String TAG = ""<STR_LIT>"" ; private static final String FACEBOOK_APP_ID = ""<STR_LIT>"" ; public static final String MESSAGE_FB_CONNECTED = ""<STR_LIT>"" ; private Facebook mFacebook ; private TetherApplication mApplication ; FBManager ( TetherApplication application ) { mApplication = application ; mFacebook = new Facebook ( FACEBOOK_APP_ID ) ; } public void connectToFacebook ( final Activity activity ) { new Thread ( new Runnable ( ) { public void run ( ) { Log . d ( TAG , ""<STR_LIT>"" ) ; Looper . prepare ( ) ; mFacebook . authorize ( activity , new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , new FacebookConnectListener ( activity ) ) ; Looper . loop ( ) ; } } ) . start ( ) ; } public void postToFacebookWithAuthorize ( final Activity activity , final Bundle params , final OnPostCompleteListener listener ) { new Thread ( new Runnable ( ) { public void run ( ) { Log . d ( TAG , ""<STR_LIT>"" ) ; Looper . prepare ( ) ; mFacebook . authorize ( activity , new String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } , new FacebookPostListener ( activity , params , listener ) ) ; Looper . loop ( ) ; } } ) . start ( ) ; } public void postToFacebook ( final Bundle params , final OnPostCompleteListener listener ) { new Thread ( new Runnable ( ) { public void run ( ) {'}]","Looper. prepare ( ) ; mFacebook. request ( ""me"", params, new FacebookPostListener ( null, params, listener ), new com.facebook.android.HttpMethod ( ""<STR_LIT>"" ) ) ; Looper. loop ( ) ; } } ). start ( ) ; } }",0.0001043265563093075
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . movemethod ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Observable ; import org . rubypeople . rdt . refactoring . classnodeprovider . ClassNodeProvider ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ArgsNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . VisibilityNodeWrapper . METHOD_VISIBILITY ; import org . rubypeople . rdt . refactoring . util . NameHelper ; public class MoveMethodConfig extends Observable implements IRefactoringConfig { private IDocumentProvider docProvider ; private int caretPosition ; private MethodNodeWrapper methodNode ; private ClassNodeWrapper sourceClassNode ; private ClassNodeProvider allClassesNodeProvider ; private ClassNodeWrapper destinationClassNode ; private String fieldInSourceClassOfTypeDestinationClass ; private String fieldInDestinationClassOfTypeSourceClass ; private METHOD_VISIBILITY movedMethodVisibility ; private METHOD_VISIBILITY methodVisibility ; private Collection < String > targetClassNames ; private Collection < String > fieldInSourceClassOfTypeDestinationClassNames ; private boolean leaveDelegateMethodInSoruce ; private boolean newMethodHasReferenceToSourceClass ; private boolean sourceClassHasCallsToMovingMethod ; private ArgsNodeWrapper movedMethodArgs ; private String movedMethodName ; private Collection < String > warnings ; public MoveMethodConfig ( IDocumentProvider docProvider , int caretPosition ) { this . docProvider = docProvider ; this . caretPosition = caretPosition ; warnings = new ArrayList < String > ( ) ; } public boolean doesNewMethodNeedsReferenceToSourceClass ( ) { return newMethodHasReferenceToSourceClass ; } public void setNewMethodNeedsReferenceToSourceClass ( boolean newMethodNeedsReferenceToSourceClass ) { this . newMethodHasReferenceToSourceClass = newMethodNeedsReferenceToSourceClass ; } public String getFieldInSourceClassOfTypeDestinationClass ( ) { return fieldInSourceClassOfTypeDestinationClass ; } public void setFieldInSourceClassOfTypeDestinationClass ( String fieldOfDestinationClassType ) { this . fieldInSourceClassOfTypeDestinationClass = fieldOfDestinationClassType ; this . setChanged ( ) ; this . notifyObservers ( ) ; } public IDocumentProvider getDocumentProvider ( ) { return docProvider ; } public boolean isClassMethod ( ) { return methodNode . isClassMethod ( ) ; } public ClassNodeProvider getAllClassesNodeProvider ( ) { return allClassesNodeProvider ; } public void setAllClassesNodeProvider ( ClassNodeProvider allClassesNodeProvider ) { this . allClassesNodeProvider = allClassesNodeProvider ; } public ClassNodeWrapper getDestinationClassNode ( ) { return destinationClassNode ; } public void setDestinationClassNode ( String aktClassName ) { destinationClassNode = allClassesNodeProvider . getClassNode ( aktClassName ) ; movedMethodName = initMovedMethodName ( ) ; this . setChanged ( ) ; this . notifyObservers ( ) ; } private String initMovedMethodName ( ) { String name = getMethodNode ( ) . getName ( ) ; while ( NameHelper . methodnameExistsInClass ( name , destinationClassNode ) ) { name = NameHelper . createName ( name ) ; } return name ; } public MethodNodeWrapper getMethodNode ( ) { return methodNode ; } public void setMethodNode ( MethodNodeWrapper methodNode ) { this . methodNode = methodNode ; if ( methodNode !='}]",null) { movedMethodName = methodNode.getName(); } this.setChanged(); this.notifyObservers(); } public String getMovedMethodName() { return movedMethodName; } public ClassNodeWrapper getSourceClassNode() { return sourceClassNode; } public void setSourceClassNode(ClassNodeWrapper sourceClassNode) { this.sourceClassNode = sourceClassNode; this.setChanged(); this.notifyObservers(); } public String getFieldInDestinationClassOfTypeSourceClass() { return fieldInDestinationClassOfTypeSourceClass; } public void setFieldInDestinationClassOfTypeSourceClass(String fieldOfSourceClassType) { this.fieldInDestinationClassOfTypeSourceClass = fieldOfSourceClassType; this.setChanged(); this.notifyObservers(); } public METHOD_VISIBILITY getMovedMethodVisibility() { return movedMethodVisibility; } public void setMovedMethodVisibility(METHOD_VISIBILITY movedMethodVisibility) { this.movedMethodVisibility = movedMethodVisibility; } public METHOD_VISIBILITY getMethodVisibility() { return methodVisibility; } public void setMethodVisibility(METHOD_VISIBILITY methodVisibility) { this.methodVisibility = methodVisibility; } public Collection<String> getTargetClassNames() { return targetClassNames; } public void setTargetClassNames(Collection<String> targetClassNames) { this.targetClassNames = targetClass,0.0003776547386245126
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . action ; import java . awt . Component ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import javax . swing . JFrame ; import javax . swing . WindowConstants ; import junit . framework . TestCase ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design . view . SwingFormFactory ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . monitor . context . ExplorerContext ; import org . oddjob . monitor . model . MockExplorerContext ; import org . oddjob . state . ParentState ; public class DesignInsideActionTest extends TestCase { class OurExplorerContext extends MockExplorerContext { Object object ; @ Override public Object getThisComponent ( ) { return object ; } @ Override public ExplorerContext getParent ( ) { return null ; } } XMLConfiguration config ; DesignInsideAction test = new DesignInsideAction ( ) ; public void testBadRootConfig ( ) throws Exception { config = new XMLConfiguration ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( config ) ; oddjob . run ( ) ; assertEquals ( ParentState . EXCEPTION , oddjob . lastStateEvent ( ) . getState ( ) ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext . object = oddjob ; test . setSelectedContext ( explorerContext ) ; test . prepare ( ) ; assertTrue ( test . isVisible ( ) ) ; assertTrue ( test . isEnabled ( ) ) ; Form form = test . form ( ) ; assertNotNull ( form ) ; test . setSelectedContext ( null ) ; assertFalse ( test . isVisible ( ) ) ; assertFalse ( test . isEnabled ( ) ) ; } public void testGoodRootConfig ( ) throws Exception { config = new XMLConfiguration ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( config ) ; oddjob . run ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext . object = oddjob ; test . setSelectedContext ( explorerContext ) ; test . prepare ( ) ; assertTrue ( test . isVisible ( ) ) ; assertTrue ( test . isEnabled ( ) ) ; Form form = test . form ( ) ; assertNotNull ( form ) ; test . setSelectedContext ( null ) ; assertFalse ( test . isVisible ( ) ) ; assertFalse ( test . isEnabled ( ) ) ; } public void testNonConfigurationOwner ( ) { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; config = new XMLConfiguration ( ""<STR_LIT>"" , xml ) ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( config ) ; oddjob . run ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext . object = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" ) ; test . setSelectedContext ( explorerContext ) ; test . prepare ( ) ; assertFalse ( test . isVisible ( ) ) ; assertFalse ( test . isEnabled ( ) ) ; test . setSelectedContext ( null ) ; assertFalse ( test . isVisible ( ) ) ; assertFalse ( test . isEnabled ( ) ) ; } public void testNestedOddjobNoConfig ( ) { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; config = new XMLConfiguration ( ""<STR_LIT>"" , xml ) ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( config ) ; oddjob . load ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext . object = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" ) ; test . setSelectedContext ( explorerContext ) ;'}]","test.prepare(); } public void testNestedOddjobWithConfig ( ) { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; config = new XMLConfiguration ( ""<STR_LIT>"", xml ) ; Oddjob oddjob = new Oddjob ( ) ; oddjob. setConfiguration ( config ) ; oddjob. load ( ) ; assertEquals ( ParentState. READY, oddjob. lastStateEvent ( ). getState ( ) ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext. object = new OddjobLookup ( oddjob ). lookup ( ""<STR_LIT>"" ) ; test. setSelectedContext ( explorerContext ) ; test. prepare ( ) ; assertTrue ( test. isVisible ( ) ) ; assertTrue ( test. isEnabled ( ) ) ; Form form = test. form ( ) ; assertNotNull ( form ) ; test. setSelectedContext ( null ) ; assertFalse ( test. isVisible ( ) ) ; assertFalse ( test. isEnabled ( ) ) ; } public void testNoConfiguration ( ) { config = null ; Oddjob oddjob = new Oddjob ( ) ; OurExplorerContext explorerContext = new OurExplorerContext ( )",0.0003806960339303153
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . parser . warnings ; import java . util . List ; import junit . framework . TestCase ; import org . jruby . ast . Node ; import org . jruby . parser . RubyParserResult ; import org . rubypeople . rdt . core . compiler . CategorizedProblem ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import org . rubypeople . rdt . internal . core . parser . RubyParser ; public abstract class AbstractRubyLintVisitorTestCase extends TestCase { public AbstractRubyLintVisitorTestCase ( ) { super ( ) ; } public AbstractRubyLintVisitorTestCase ( String name ) { super ( name ) ; } protected List <'}]",CategorizedProblem> getExpectedWarnings ( RubyParserResult result ) {... },3.753218354504689e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . values . properties ; import junit . framework . TestCase ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignParser ; import org . oddjob . arooa . design . view . ViewMainHelper ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . values . properties . PropertiesJob ; public class PropertiesJobDesFaTest extends TestCase { DesignInstance design ; public void testCreate ( ) throws ArooaParseException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""'}]","+ Helper. getDescriptor ( PropertiesJob. class ) + "">\n"" + ""  <property name=\""testProperty\""/>\n"" + ""</STR_LIT>""; design = new DesignParser ( ). parse ( new XMLConfiguration ( xml ) ) ; PropertiesJob job = ( PropertiesJob ) design. createInstance ( ) ; job. setSession ( new StandardArooaSession ( ) ) ; } public void testCreate2 ( ) throws ArooaParseException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + Helper. getDescriptor ( PropertiesJob. class ) + "">\n"" + ""  <property name=\""testProperty\"" value=\""testValue\""/>\n"" + ""</STR_LIT>""; design = new DesignParser ( ). parse ( new XMLConfiguration ( xml ) ) ; PropertiesJob job = ( PropertiesJob ) design. createInstance ( ) ; job. setSession ( new",0.00035092367376331066
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . client ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public class DirectInvocationClientFactory < T > implements ClientInterfaceHandlerFactory < T > { private final Class < T > type ; public DirectInvocationClientFactory ( Class < T'}]","> type ) { this. type = type ; } @ Override public InvocationHandler createInvocationHandler ( T target ) { return new DirectInvocationHandler < T >( target, type ); } public static < T > DirectInvocationClientFactory < T > create ( Class < T > type ) { return new DirectInvocationClientFactory < T >( type ); } }",0.00010794184525927063
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package net . sf . sveditor . core . text ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . templates . ITemplateParameterProvider ; public class TagProcessor { private List < ITemplateParameterProvider > fProviders ; public TagProcessor ( ) { fProviders = new ArrayList < ITemplateParameterProvider > ( ) ; } public void addParameterProvider ( ITemplateParameterProvider p ) { fProviders . add ( p ) ; } public void removeParameterProvider ( ITemplateParameterProvider p ) { fProviders . remove ( p ) ; } public String process ( String in ) { StringInputStream in_str = new StringInputStream ( in ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { process ( in_str , out ) ; } catch ( IOException e ) { } return out . toString ( ) ; } public int process ( InputStream in , OutputStream out ) throws IOException { int ch ; int n_replacements = <NUM_LIT:0> ; StringBuilder sb = new StringBuilder ( ) ; while ( ( ch = in . read ( ) ) != - <NUM_LIT:1> ) { if ( ch == '<CHAR_LIT>' ) { int ch2 = in . read ( ) ; if ( ch2 == '<CHAR_LIT>' ) { sb . setLength ( <NUM_LIT:0> ) ; for ( int i = <NUM_LIT:0> ; i < <NUM_LIT> ; i ++ ) { if ( ( ch = in . read ( ) ) == '<CHAR_LIT:}>' || ch == - <NUM_LIT:1> ) { break ; } sb . append ( ( char ) ch ) ; } String val = sb . toString ( ) ; if ( ch == '<CHAR_LIT:}>' ) { String key = val ; String args = null ; if ( key . indexOf ( '<CHAR_LIT::>' ) != - <NUM_LIT:1> ) { args = key . substring ( key . indexOf (""}]","'<CHAR_LIT::>' ) + 1 ) ; key = key. substring ( 0, key. indexOf ( '<CHAR_LIT::>' ) ) ; } for ( ITemplateParameterProvider p : fProviders ) { if ( p. supports ( key ) ) { n_replacements ++ ; if ( args!= null ) { p. setParameter ( key, args ) ; } else { p. setParameter ( key ) ; } String replacement = p. getReplacement ( ) ; replacement = replacement. replace ( '<CHAR_LIT:__KEY__>', key ) ; replacement = replacement. replace ( '<CHAR_LIT:__ARGS__>', args!= null? args : """" ) ; sb. setLength ( <NUM_LIT:0> ) ; sb. append ( replacement ) ; } } } else { sb. append ( ( char ) ch ) ; } } else { sb. append ( '<CHAR_LIT:__KEY__>' ) ; sb. append ( '<CHAR_LIT:__ARGS__>' ) ; } } } out. write ( sb. toString ( ). toCharArray ( ), 0, sb. length ( ) ) ; return n_replacements ; } }",0.0003546271872917973
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . samples . whathow . data ; public abstract class IntBinaryTree { private IntBinaryTree ( ) { } public static final IntBinaryTree _Node ( int value , IntBinaryTree left , IntBinaryTree right ) { return new Node ( value , left , right ) ; } private static final IntBinaryTree _EmptyTree = new EmptyTree ( ) ; public static final IntBinaryTree _EmptyTree ( ) { return _EmptyTree ; } public static interface MatchBlock < ResultType > { ResultType _case ( Node x ) ; ResultType _case ( EmptyTree x ) ; } public static abstract class MatchBlockWithDefault < ResultType > implements MatchBlock < ResultType > { @ Override public ResultType _case ( Node x ) { return _default ( x ) ; } @ Override public ResultType _case ( EmptyTree x ) { return _default ( x ) ; } protected abstract ResultType _default ( IntBinaryTree x ) ; } public static interface SwitchBlock { void _case ( Node x ) ; void _case ( EmptyTree x ) ; } public static abstract class SwitchBlockWithDefault implements SwitchBlock { @ Override public void _case ( Node x ) { _default ( x ) ; } @ Override public void _case ( EmptyTree x ) { _default ( x ) ; } protected abstract void _default ( IntBinaryTree x ) ; } public static final class Node extends IntBinaryTree { public int value ; public IntBinaryTree left ; public IntBinaryTree right ; public Node ( int value ,'}]","IntBinaryTree left, IntBinaryTree right ) { this. value = value ; this. left = left ; this. right = right ; } public static final class EmptyTree extends IntBinaryTree { } }",7.401718881946471e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import java . util . List ; import com . asakusafw . utils . java . model . syntax . Attribute ; import com . asakusafw . utils . java . model . syntax . LocalVariableDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . VariableDeclarator ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class LocalVariableDeclarationImpl extends ModelRoot implements LocalVariableDeclaration { private List < ? extends Attribute > modifiers ; private Type type ; private List < ? extends VariableDeclarator > variableDeclarators ; @ Override public List < ? extends Attribute > getModifiers ( ) { return this . modifiers ; } public void setModifiers ( List < ? extends Attribute > modifiers ) { Util . notNull ( modifiers , ""<STR_LIT>"" ) ; Util . notContainNull ( modifiers , ""<STR_LIT>"" ) ; this . modifiers = Util . freeze ( modifiers ) ; } @ Override public Type getType ( ) { return this . type ; } public void setType ( Type type ) { Util'}]",".notNull(type, ""<STR_LIT>""); this.type = type; } @Override public List<? extends VariableDeclarator> getVariableDeclarators() { return this.variableDeclarators; } public void setVariableDeclarators(List<? extends VariableDeclarator> variableDeclarators) { Util.notNull(variableDeclarators, ""<STR_LIT>""); Util.notContainNull(variableDeclarators, ""<STR_LIT>""); this.variableDeclarators = Util.freeze(variableDeclarators); } @Override public <T> T accept(Visitor<T> visitor) { return visitor.visit(this); } }",0.00018471036137846593
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . mapgen ; import java . util . List ; import junit . framework . TestCase ; import de . fuberlin . wiwiss . d2rq . mapgen . Filter . IdentifierMatcher ; import de . fuberlin . wiwiss . d2rq . mapgen . FilterParser . ParseException ; public class FilterParserTest extends TestCase { public void testEmpty ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testSimple ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT:foo>"" ) . parse ( ) ) ) ; } public void testMultipleStrings ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testMultipleFilters ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testMultipleFiltersNewline ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testRegex ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testRegexWithFlag ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testMutlipleRegexes ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testMutlipleRegexFilters ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testDotInRegex ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testEscapedDotInRegex ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testCommaInRegex ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testIncompleteRegex ( ) { try { new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ; fail ( ""<STR_LIT>"" ) ; } catch ( ParseException ex ) { } } public void testIncompleteRegexNewline ( ) { try { new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ; fail ( ""<STR_LIT>"" ) ; } catch ( ParseException ex ) { } } public void testComplex ( ) throws ParseException { assertEquals ( ""<STR_LIT>"" , toString ( new FilterParser ( ""<STR_LIT>"" ) . parse ( ) ) ) ; } public void testParseAsSchemaFilter ( ) throws ParseException { Filter result = new FilterParser ( ""<STR_LIT>"" ) . parseSchemaFilter ( ) ; assertTrue ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertTrue ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertFalse ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertFalse ( result . matchesSchema ( null ) ) ; } public void testParseAsSchemaFilterWithRegex ( ) throws ParseException { Filter result = new FilterParser ( ""<STR_LIT>"" ) . parseSchemaFilter ( ) ; assertTrue ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertTrue ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertFalse ( result . matchesSchema ( ""<STR_LIT>"" ) ) ; assertFalse ( result . matchesSchema ( null ) ) ; } public void testParseAsSchemaFilterFail ( ) { try { new FilterParser ( ""<STR_LIT>"" ) . parseSchemaFilter'}]","( ) ; fail ( ""<STR_LIT>"" ) ; } catch ( ParseException ex ) { } }",5.7993473420991976e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . client ; import javax . management . ObjectName ; import org . apache . log4j . Logger ; import org . oddjob . framework . Transportable ;'}]",import org.oddkob.jmx.client.Connection;,2.815168820043504e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; public class MockSourceProvider implements DataModelSourceProvider { private final Map < URI , DataModelSource > sources = new HashMap < URI , DataModelSource > ( ) ; public MockSourceProvider ( ) { try { add ( new URI ( ""<STR_LIT>"" ) , ""<STR_LIT>"" ) ; } catch ( URISyntaxException e ) { throw new AssertionError ( e ) ; } } public final < T > MockSourceProvider add ( URI uri , DataModelDefinition < T > def , Iterable'}]","<? super T > data ) throws URISyntaxException { sources. put ( uri, new MockDataModelSource < T > ( def, data ) ) ; return this ; } public final < T > MockSourceProvider add ( URI uri, DataModelDefinition < T > def ) throws URISyntaxException { return add ( uri, def, null ) ; } public final < T > MockSourceProvider add ( URI uri, DataModelDefinition < T > def, T data ) throws URISyntaxException { return add ( uri, def, Arrays. asList ( data ) ) ; } public final < T > MockSourceProvider add ( URI uri, DataModelDefinition < T > def, Iterable <? extends T > data ) throws URISyntaxException { return add ( uri, def, data ) ; } public final DataModelSource get ( URI uri ) throws URISyntaxException { return sources. get ( uri ) ; } public final void clear ( ) { sources. clear ( ) ; } }",0.00027436233137878823
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . postmark . java ; import java . util . * ; public class TestClient { public static void main ( String [ ] args ) { List < NameValuePair > headers = new ArrayList < NameValuePair > ( ) ; headers . add ( new NameValuePair ( ""<STR_LIT>"" , ""<STR_LIT:test>"" ) ) ; PostmarkMessage message = new PostmarkMessage ( args [ <NUM_LIT:0> ] , args [ <NUM_LIT:1> ] , args [ <NUM_LIT:0> ]'}]",", headers); PostmarkClient client = new PostmarkClient ( ""your_api_key"" ) ; client. sendMessage ( message ) ; } }",5.344362538261298e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . prop_pages ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . db . index . SVDBIndexCollection ; import net . sf . sveditor . core . db . project . SVDBProjectData ; import net . sf . sveditor . core . db . project . SVDBProjectManager ; import net . sf . sveditor . core . db . search . SVDBSearchResult ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . text . Document ; import org . eclipse . jface . text . TextViewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . IWorkbenchPropertyPage ; import org . eclipse . ui . dialogs . PropertyPage ; public class SVFilePropertyPage extends PropertyPage implements IWorkbenchPropertyPage { public SVFilePropertyPage ( ) { } @ Override protected Control createContents ( Composite parent ) { StringBuilder index_info = new StringBuilder ( ) ; IAdaptable adaptable = getElement ( ) ; IFile file ; Composite c = new Composite ( parent , SWT . NONE ) ; c . setLayout ( new GridLayout ( ) ) ; file = ( IFile ) adaptable . getAdapter ( IFile . class ) ;'}]","if (file!= null) { Group g = new Group(c, SWT.NONE); g.setText(""File Information""); GridData gd = new GridData(SWT.FILL, SWT.FILL, true, false); g.setLayoutData(gd); Label label = new Label(g, SWT.NONE); label.setText(""Path:""); TextViewer tv = new TextViewer(g, SWT.MULTI | SWT.WRAP); tv.setEditable(false); tv.setText(file.getFullPath().toString()); gd = new GridData(SWT.FILL, SWT.FILL, true, false); tv.setLayoutData(gd); g.pack(); } return c; } @Override public boolean performOk() { return true; } }",0.0001982867312800302
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Writable ; import com . asakusafw . compiler . operator . io . MockJoinedInput ; import com . asakusafw . compiler . operator . io . MockJoinedOutput ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . vocabulary . model . Joined ; import com . asakusafw . vocabulary . model . Key ; @ DataModelKind ( ""<STR_LIT>"" ) @ Joined ( terms = { @ Joined . Term ( source = MockHoge . class , mappings = { @ Joined . Mapping ( source = ""<STR_LIT:value>"" , destination = ""<STR_LIT>"" ) } , shuffle = @ Key ( group = { ""<STR_LIT:value>"" } ) ) , @ Joined . Term ( source = MockFoo . class , mappings = { @ Joined . Mapping ( source = ""<STR_LIT:value>"" , destination = ""<STR_LIT>"" ) } , shuffle = @ Key ( group = { ""<STR_LIT:value>"" } ) ) } ) @ ModelInputLocation ( MockJoinedInput . class ) @ ModelOutputLocation ( MockJoinedOutput . class ) public class MockJoined implements DataModel < MockJoined > , Writable { private final IntOption hogeValue = new IntOption ( ) ; private final IntOption fooValue = new IntOption ( ) ; @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void reset ( ) { this . hogeValue . setNull ( ) ; this . fooValue . setNull ( ) ; } @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void copyFrom ( MockJoined other ) { this . hogeValue . copyFrom ( other . hogeValue ) ; this . fooValue . copyFrom ( other . fooValue ) ; } public int getHogeValue ( ) { return this . hogeValue . get ( ) ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setHogeValue ( int value ) { this . hogeValue . modify ('}]","value) } public int getFooValue() { return this.fooValue.get(); } @SuppressWarnings(""<STR_LIT:deprecation>"") public void setFooValue(int value) { this.fooValue.modify(value); } @Override public void readFields(DataInput in) throws IOException { // implementation } @Override public void write(DataOutput out) throws IOException { // implementation }",0.00012270968359540384
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . packageview ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . ResourceListSelectionDialog ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyModel ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; public class GotoResourceAction extends Action { private PackageExplorerPart fPackageExplorer ; private static class GotoResourceDialog extends ResourceListSelectionDialog { private IRubyModel fRubyModel ; public GotoResourceDialog ( Shell parentShell , IContainer container , StructuredViewer viewer ) { super ( parentShell , container , IResource . FILE | IResource . FOLDER | IResource . PROJECT ) ; fRubyModel = RubyCore . create ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ) ; setTitle ( PackagesMessages . GotoResource_dialog_title ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( parentShell , IRubyHelpContextIds . GOTO_RESOURCE_DIALOG ) ; } protected boolean select ( IResource resource ) { IProject project = resource . getProject ( ) ; try { if ( project . getNature ( RubyCore . NATURE_ID ) != null ) return fRubyModel . contains ( resource ) ; } catch ( CoreException e ) { } return true ; } } public GotoResourceAction ('}]","PackageExplorerPart packageExplorer) { this.fPackageExplorer = packageExplorer; } @Override public void run ( ) { new GotoResourceDialog ( PlatformUI. getWorkbench ( ). getActiveShell ( ), fPackageExplorer. getViewer ( ). getSelection ( ) == null? fPackageExplorer. getContainer ( ) : null, fPackageExplorer. getViewer ( ) ). open ( ) ; } }",0.0001380809243816238
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import java . util . HashSet ; import java . util . Set ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . TableViewer ; public class RubySearchTableContentProvider extends RubySearchContentProvider implements IStructuredContentProvider { public RubySearchTableContentProvider ( RubySearchResultPage page ) { super ( page ) ; } public Object [ ] getElements ( Object inputElement ) { if ( inputElement instanceof RubySearchResult ) { Set filteredElements = new HashSet ( ) ; Object [ ] rawElements = ( ( RubySearchResult )'}]","inputElement ). getElements ( ) ; for ( Object element : rawElements ) { if ( ((RubySearchResult) inputElement).isElementVisible(element)) { filteredElements.add(element); } } return filteredElements.toArray(new Object[0]); } @Override public void dispose ( ) { // TODO: implement dispose } public void inputChanged ( Viewer viewer, Object oldInput, Object newInput ) { super. inputChanged ( viewer, oldInput, newInput ) ; } }",0.00014075619870768571
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testtools . db ; import static org . junit . Assert . * ; import java . sql . Connection ; import java . util . ArrayList ; import java . util . List ; import org . junit . Test ; import com . asakusafw . testtools . ColumnInfo ; import com . asakusafw . testtools . excel . ExcelUtils ; public class DbUtilTest { @ Test public void testCreateTable01 ( ) throws Exception { String filename = ""<STR_LIT>"" ; ExcelUtils excelUtils = new ExcelUtils ( filename ) ; List < ColumnInfo > list = excelUtils . getColumnInfos ( ) ; Connection conn = null ; try { conn = DbUtils . getConnection ( ) ; String'}]",sql = excelUtils.getCreateTableSQL(list); Statement stmt = conn.createStatement(); stmt.execute(sql); } finally { if (conn!= null) { conn.close(); } } },6.181856646362062e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . io ; import java . io . IOException ; import test . modelgen . model . Foo ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class FooModelOutput implements ModelOutput < Foo > { private final RecordEmitter emitter ; public FooModelOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( Foo model ) throws IOException { emitter . emit ( model . getPkOption ( ) ) ; emitter . emit ( model . getDetailGroupIdOption ( ) ) ; emitter . emit ( model . getDetailTypeOption ( ) ) ; emitter . emit ( model . getDetailSenderIdOption ( ) ) ; emitter . emit ( model . getDetailReceiverIdOption ( ) ) ; emitter . emit ('}]",model. getDetailMessageOption ( ) ) ; } @ Override public void close ( ) throws IOException { emitter. close ( ) ; } },5.429891217618438e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . jruby . lexer . yacc ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . util . List ; import org . jruby . parser . ParserConfiguration ; import org . jruby . util . ByteList ; public class ReaderLexerSource extends LexerSource { private static final int INITIAL_PUSHBACK_SIZE = <NUM_LIT:100> ; private final Reader in ; private char buf [ ] = new char [ INITIAL_PUSHBACK_SIZE ] ; private int bufLength = - <NUM_LIT:1> ; private int oneAgo = '<STR_LIT:\\n>' ; private int twoAgo = <NUM_LIT:0> ; public ReaderLexerSource ( String sourceName , Reader in , List < String > list , int line , boolean extraPositionInformation ) { super ( sourceName , list , line , extraPositionInformation ) ; this . in = in ; } public int read ( ) throws IOException { int c ; if ( bufLength >= <NUM_LIT:0> ) { c = buf [ bufLength -- ] ; } else { c = wrappedRead ( ) ; if ( c == - <NUM_LIT:1> ) return RubyYaccLexer . EOF ; } twoAgo = oneAgo ; oneAgo = c ; offset ++ ; if ( c == '<STR_LIT:\\n>' ) line ++ ; return c ; } public void unread ( int c ) { if ( c == RubyYaccLexer . EOF ) return ; offset -- ; oneAgo = twoAgo ; twoAgo = <NUM_LIT:0> ; if ( c == '<STR_LIT:\\n>' ) line -- ; buf [ ++ bufLength ] = ( char ) c ; if ( bufLength + <NUM_LIT:1> == buf . length ) { char [ ] newBuf = new char [ buf . length + INITIAL_PUSHBACK_SIZE ] ; System . arraycopy ( buf , <NUM_LIT:0> , newBuf , <NUM_LIT:0> , buf . length ) ; buf = newBuf ; } } public boolean peek ( int to ) throws IOException { int captureTwoAgo = twoAgo ; int c = read ( ) ; unread ( c ) ; twoAgo = captureTwoAgo ; return c == to ; } private int wrappedRead ( ) throws IOException { int c = in . read ( ) ; if ( c == '<STR_LIT>' ) { if ( ( c = in . read ( ) ) != '<STR_LIT:\\n>' ) { unread ( ( char ) c ) ; c = '<STR_LIT:\\n>' ; } else { offset ++ ; } } captureFeature ( c ) ; return c ; } public static LexerSource getSource ( String name , InputStream content , List < String > list , ParserConfiguration configuration ) { return new InputStreamLexerSource ( name , content , list , configuration . getLineNumber (""}]","), configuration.isExtraPositionInformation()); } public static LexerSource getSource(String name, Reader reader, List<String> list, int line, boolean extraPositionInformation) { return new ReaderLexerSource(name, reader, list, line, extraPositionInformation); } }",9.496752984652976e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . view ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa'}]",.design.DesignElement; import org.oddjob.arooa.util.ReflectionHelper; import org.oddjob.design.DesignInstanceEditor; import org.oddjob.design.DesignInstanceEditorFactory; import org.oddjob.design.DesignInstanceEditorSupport; import org.oddjob.design.DesignInstanceEditorSupportFactory; import org.oddjob.design.DesignInstanceEditorSupportProvider; import org.oddjob.design.DesignInstanceEditorSupportProviderFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManager; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImpl; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImpl; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplImpl; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplImplFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplImplImpl; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplImplImplFactory; import org.oddjob.design.DesignInstanceEditorSupportProviderManagerImplImplImplImpl,0.0003441500978287991
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignParser ; import org . oddjob . arooa . design . view . ViewMainHelper ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . jobs . job . RunJob ; import org . oddjob . jobs . job . StopJob ; public class JustJobDCTest extends TestCase { private static final Logger logger = Logger . getLogger ( JustJobDCTest . class ) ; public void setUp ( ) { logger . debug ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } DesignInstance design ; public void testRun ( ) throws ArooaParseException { String xml = ""<STR_LIT>"" ; ArooaDescriptor descriptor = new OddjobDescriptorFactory ( ) . createDescriptor ( getClass ( ) . getClassLoader ( ) ) ; DesignParser parser = new DesignParser ( new StandardArooaSession ( descriptor ) ) ; parser'}]",".parse(xml); design = parser.getDesign(); design.execute(); } public void testStop() throws ArooaParseException { String xml = ""<STR_LIT>""; ArooaDescriptor descriptor = new OddjobDescriptorFactory().createDescriptor(getClass().getClassLoader()); DesignParser parser = new DesignParser(new StandardArooaSession(descriptor)); parser.parse(xml); design = parser.getDesign(); design.execute(); design.stop(); } }",0.00012744841110826115
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . dialogfields ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Table ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTableViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . TableViewer ; public class CheckedListDialogField extends ListDialogField { private int fCheckAllButtonIndex ; private int fUncheckAllButtonIndex ; private List fCheckedElements ; private List fGrayedElements ; public CheckedListDialogField ( IListAdapter adapter , String [ ] customButtonLabels , ILabelProvider lprovider ) { super ( adapter , customButtonLabels , lprovider ) ; fCheckedElements = new ArrayList ( ) ; fGrayedElements = new ArrayList ( ) ; fCheckAllButtonIndex = - <NUM_LIT:1> ; fUncheckAllButtonIndex = - <NUM_LIT:1> ; } public void setCheckAllButtonIndex ( int checkButtonIndex ) { Assert . isTrue ( checkButtonIndex < fButtonLabels . length ) ; fCheckAllButtonIndex = checkButtonIndex ; } public void setUncheckAllButtonIndex ( int uncheckButtonIndex ) { Assert . isTrue ( uncheckButtonIndex < fButtonLabels . length ) ; fUncheckAllButtonIndex = uncheckButtonIndex ; } protected TableViewer createTableViewer ( Composite parent ) { Table table = new Table'}]","(parent, SWT.VIRTUAL | SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL); CheckboxTableViewer viewer = new CheckboxTableViewer(table); viewer.addCheckStateListener(new ICheckStateListener() { @Override public void checkStateChanged(CheckStateChangedEvent event) { // update checked and grayed elements lists } }); //... return viewer; }",0.00011251428450197531
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import javax . swing . ImageIcon ; import junit . framework . TestCase ; import org . oddjob . Iconic ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . Resetable ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . images . IconEvent ;'}]",import org.oddkob.jmx.JMXIcon;,3.161887759862595e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . yaess . testing . mock ; import com . asakusafw . compiler . yaess . testing . model . Dummy ;'}]",import com.asakusafw.compiler.yaess.testing.model.DummyFactory;,3.779102173369837e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . expr . SVDBExpr ; public class SVDBAssignStmt extends SVDBStmt { public SVDBExpr'}]","expr ; public SVDBItemType type ; public SVDBAssignStmt ( SVDBExpr expr ) { super ( ) ; this. expr = expr ; } public SVDBAssignStmt ( SVDBExpr expr, SVDBItemType type ) { super ( ) ; this. expr = expr ; this. type = type ; } }",0.0001017495675650588
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . flow ; import com . asakusafw . compiler . fileio . model . Ex1 ; import com . asakusafw . vocabulary . external . FileExporterDescription ; public class Out4ExporterDesc extends FileExporterDescription { @ Override public Class < ? > getModelType ( ) { return Ex1 . class ; }'}]","@ Override public String getExportFileExtension ( ) { return ""ex1""; }",3.781941089656069e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . io . IOException ; import java . util . List ; import junit . framework . TestCase ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . beanbus . BeanTrap ; import org . oddjob . beanbus . BusException ; import org . oddjob . io . BufferType ; import org . oddjob . sql . SQLJob . DelimiterType ; public class SQLScriptParserTest extends TestCase { public void testNoDelimiter ( ) throws IOException , BusException { BeanTrap < String > results = new BeanTrap < String > ( ) ; ScriptParser test = new ScriptParser ( ) ; BufferType buffer = new BufferType ( ) ; buffer . setText ( ""<STR_LIT>"" ) ; buffer . configured ( ) ; test . setInput ( buffer . toInputStream ( ) ) ; test . setTo ( results ) ; test . go ( ) ; List < String > stmts = results . toValue ( ) ; assertEquals ( <NUM_LIT:1> , stmts . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , stmts . get ( <NUM_LIT:0> ) ) ; } public void testOneEmptyLine ( ) throws IOException , BusException { BeanTrap < String > results = new BeanTrap < String > ( ) ; ScriptParser test = new ScriptParser ( ) ; BufferType buffer = new BufferType ( ) ; buffer . setText ( ""<STR_LIT>"" ) ; buffer . configured ( ) ; test . setInput ( buffer . toInputStream ( ) ) ; test . setTo ( results ) ; test . go ( ) ; List < String > stmts = results . toValue ( ) ; assertEquals ( <NUM_LIT:2> , stmts . size ( ) ) ; assertEquals ( ""<STR_LIT>"" , stmts . get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"" , stmts . get ( <NUM_LIT:1> ) ) ; } public void testLotsOfEmptyLines ( ) throws IOException , BusException { BeanTrap < String > results = new BeanTrap < String > ( ) ; ScriptParser test = new ScriptParser ( ) ; BufferType buffer'}]","= new BufferType ( ) ; buffer. setText ( ""SELECT * FROM table;\n\n\nCREATE TABLE table2 (id INT PRIMARY KEY, name VARCHAR(255));"" ) ; buffer. configured ( ) ; test. setInput ( buffer. toInputStream ( ) ) ; test. setTo ( results ) ; test. setDelimiter ( DelimiterType. NEWLINE ) ; test. go ( ) ; List < String > stmts = results. toValue ( ) ; assertEquals ( <NUM_LIT:2>, stmts. size ( ) ) ; assertEquals ( ""<STR_LIT>"", stmts. get ( <NUM_LIT:0> ) ) ; assertEquals ( ""<STR_LIT>"", stmts. get ( <NUM_LIT:1> ) ) ; }",0.00023649721297734925
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testtools ; import java . util . HashMap ; import java . util . Map ; public enum RowMatchingCondition { EXACT ( ""<STR_LIT>"" ) , PARTIAL ( ""<STR_LIT>"" ) , NONE ( ""<STR_LIT>"" ) ; private String japaneseName ; private RowMatchingCondition ( String japaneseName ) { this . japaneseName = japaneseName ; } public String getJapaneseName ( ) { return japaneseName ; } private static Map < String , RowMatchingCondition > japaneseNameMap ='}]","new HashMap <> ( ) ; static { japaneseNameMap. put ( EXACT. getJapaneseName ( ), EXACT ) ; japaneseNameMap. put ( PARTIAL. getJapaneseName ( ), PARTIAL ) ; japaneseNameMap. put ( NONE. getJapaneseName ( ), NONE ) ; } public static RowMatchingCondition of ( String japaneseName ) { return japaneseNameMap. get ( japaneseName ) ; } }",0.00012919711162880362
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . helpers ; import de . fuberlin . wiwiss . d2rq . D2RQException ; import de . fuberlin . wiwiss . d2rq . D2RQTestSuite ; import de . fuberlin . wiwiss . d2rq . map . Database ; import de . fuberlin . wiwiss . d2rq . map . Mapping ; import de . fuberlin . wiwiss . d2rq . parser . MapParser ; import de . fuberlin . wiwiss . d2rq . sql . DummyDB ; public class MappingHelper { public static Mapping readFromTestFile ( String testFileName ) { return new MapParser ( D2RQTestSuite . loadTurtle ( testFileName ) , ""<STR_LIT>"" )'}]",". createMapping ( new DummyDB ( ), Database. RDB ) ; } }",3.991738792849112e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . ide . IDE ; import org . rubypeople . rdt . core . ILoadpathContainer ; import org . rubypeople . rdt . core . ILoadpathEntry ; import org . rubypeople . rdt . core . LoadpathContainerInitializer ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . viewsupport . RubyElementImageProvider ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . ui . ISharedImages ; import org . rubypeople . rdt . ui . RubyElementImageDescriptor ; import org . rubypeople . rdt . ui . RubyElementLabels ; import org . rubypeople . rdt . ui . RubyUI ; import org . rubypeople . rdt . ui . viewsupport . ImageDescriptorRegistry ; public class CPListLabelProvider extends LabelProvider { private String fNewLabel , fClassLabel , fCreateLabel ; private ImageDescriptorRegistry fRegistry ; private ISharedImages fSharedImages ; private ImageDescriptor fProjectImage ; public CPListLabelProvider ( ) { fNewLabel = NewWizardMessages . CPListLabelProvider_new ; fClassLabel = NewWizardMessages . CPListLabelProvider_classcontainer ; fCreateLabel = NewWizardMessages . CPListLabelProvider_willbecreated ; fRegistry = RubyPlugin . getImageDescriptorRegistry ( ) ; fSharedImages = RubyUI . getSharedImages ( ) ; IWorkbench workbench = RubyPlugin . getDefault ( ) . getWorkbench ( ) ; fProjectImage = workbench . getSharedImages ( ) . getImageDescriptor ( IDE . SharedImages . IMG_OBJ_PROJECT ) ; } public String getText ( Object element ) { if ( element instanceof CPListElement ) { return getCPListElementText ( ( CPListElement ) element ) ; } else if ( element instanceof CPListElementAttribute ) { CPListElementAttribute attribute = ( CPListElementAttribute ) element ; String text = getCPListElementAttributeText ( attribute ) ; if ( attribute . isInNonModifiableContainer ( ) ) { return Messages . format ( NewWizardMessages . CPListLabelProvider_non_modifiable_attribute , text ) ; } return text ; } else if ( element instanceof CPUserLibraryElement ) { return getCPUserLibraryText ( ( CPUserLibraryElement ) element ) ; } return super . getText ( element ) ; } public String getCPUserLibraryText ( CPUserLibraryElement element ) { String name = element . getName ( ) ; if ( element . isSystemLibrary ( ) ) { name = Messages . format ( NewWizardMessages . CPListLabelProvider_systemlibrary , name ) ; } return name ; } public String getCPListElementAttributeText ( CPListElementAttribute attrib ) { String notAvailable = NewWizardMessages . CPListLabelProvider_none ; String key = attrib . getKey ( ) ; if ( key . equals ( CPListElement . EXCLUSION ) ) { String arg = null ; IPath [ ] patterns = ( IPath [ ] ) attrib . getValue ( ) ; if ( patterns != null && patterns . length > <NUM_LIT:0> ) { int patternsCount = <NUM_LIT:0> ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = <NUM_LIT:0> ; i < patterns . length ; i ++ ) { String pattern = patterns [ i ] . toString ( ) ; if ( pattern . length ( ) > <NUM_LIT:0> ) { if ( patternsCount > <NUM_LIT:0> ) { buf . append ( NewWizardMessages . CPListLabelProvider_exclusion_filter_separator ) ; } buf . append ( pattern ) ; patternsCount ++ ; } } if ( patternsCount > <NUM_LIT:0> ) { arg = buf . toString ( ) ; } else { arg = notAvailable ; } } else { arg = notAvailable ; } return Messages . format ( NewWizardMessages . CPListLabelProvider_exclusion_filter_label , new String [ ] { arg } ) ; } else if ( key . equals ( CPListElement . INCLUSION ) ) { String arg = null ; IPath [ ] patterns = ( IPath [ ] ) attrib . getValue ( ) ; if ( patterns != null && patterns . length > <NUM_LIT:0> ) { int patternsCount = <NUM_LIT:0> ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = <NUM_LIT:0> ; i < patterns . length ; i ++ ) { String pattern = patterns [ i ] . toString ( ) ; if ( pattern . length ( ) > <NUM_LIT:0> ) { if ( patternsCount > <NUM_LIT:0> ) { buf . append ( NewWizardMessages . CPListLabelProvider_inclusion_filter_separator ) ; } buf . append ( pattern ) ; patternsCount ++ ; } } if ( patternsCount > <NUM_LIT:0> ) { arg = buf . toString ( ) ; } else { arg = notAvailable ; } } else { arg = NewWizardMessages . CPListLabelProvider_all ; } return Messages . format ( NewWizardMessages . CPListLabelProvider_inclusion_filter_label , new String [ ] { arg } ) ; } return notAvailable ; } public String getCPListElementText ( CPListElement cpentry ) { IPath path = cpentry . getPath ( ) ; switch ( cpentry . getEntryKind ( ) ) { case ILoadpathEntry . CPE_LIBRARY : { IResource resource = cpentry . getResource ( ) ; if ( resource instanceof IContainer ) { StringBuffer buf = new StringBuffer ( path . makeRelative ( ) . toString ( ) ) ; IPath linkTarget = cpentry . getLinkTarget ( ) ; if ( linkTarget != null ) { buf . append ( RubyElementLabels . CONCAT_STRING ) ; buf . append ( linkTarget . toOSString ( ) ) ; } buf . append ( '<CHAR_LIT:U+0020>' ) ; buf . append ( fClassLabel ) ; if ( ! resource . exists ( ) ) { buf . append ( '<CHAR_LIT:U+0020>' ) ; if ( cpentry . isMissing ( ) ) { buf . append ( fCreateLabel ) ; } else { buf . append ( fNewLabel ) ; } } return buf . toString ( ) ; } return path . makeRelative ( ) . toString ( ) ; } case ILoadpathEntry . CPE_VARIABLE : { return getVariableString ( path ) ; } case ILoadpathEntry . CPE_PROJECT : return path . lastSegment ( ) ; case ILoadpathEntry . CPE_CONTAINER : try { ILoadpathContainer container = RubyCore . getLoadpathContainer ( path , cpentry . getRubyProject ( ) ) ; if ( container != null ) { return container . getDescription ( ) ; } LoadpathContainerInitializer initializer = RubyCore . getLoadpathContainerInitializer ( path . segment ( <NUM_LIT:0> ) ) ; if ( initializer != null ) { String description = initializer . getDescription ( path , cpentry . getRubyProject ( ) ) ;""}]","return description; } catch ( RubyModelException e ) { return path. makeRelative ( ). toString ( ) ; } default : return path. makeRelative ( ). toString ( ) ; } } private String getVariableString ( IPath path ) { String name = path. lastSegment ( ) ; if (! path. isAbsolute ( ) ) { name = Messages. format ( NewWizardMessages. CPListLabelProvider_variable, name ) ; } return name ; } }",0.00018773120355902243
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . model ; import com . asakusafw . dmdl . Region ; public class AstReferenceType extends AbstractAstNode implements AstType { private final Region region ; public final AstSimpleName name ; public AstReferenceType ( Region region , AstSimpleName name ) { if ( name == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; }'}]",this.region = region; this.name = name; } public Region getRegion() { return region; } public AstSimpleName getName() { return name; } },5.854593138065842e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . Temp7 ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class Temp7ModelInput implements ModelInput < Temp7 > { private final RecordParser parser ; public Temp7ModelInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ) ; } this . parser = parser ; } @ Override public boolean readTo ( Temp7 model ) throws IOException { if ( parser . next ( ) == false ) { return false ; } parser . fill ( model . getTempSidOption ( ) ) ; parser . fill ( model . getSidOption ( ) ) ; parser . fill ( model .'}]",getTemp7Option ( ) ) ; return true ; } @ Override public Temp7 read ( ) throws IOException { Temp7 model = new Temp7 ( ) ; if ( readTo ( model ) == false ) { return null ; } return model ; } @ Override public Temp7 readOne ( ) throws IOException { Temp7 model = new Temp7 ( ) ; if ( readTo ( model ) == false ) { return null ; } return model ; } },0.00013752128235052248
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . cache ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . Timestamp ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import com . asakusafw . bulkloader . common . DBConnection ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; public class LocalCacheInfoRepository { static final Log LOG = new Log ( LocalCacheInfoRepository . class ) ; private final Connection connection ; public LocalCacheInfoRepository ( Connection connection ) { if ( connection == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . connection = connection ; } public LocalCacheInfo getCacheInfo ( String cacheId ) throws BulkLoaderSystemException { if ( cacheId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; PreparedStatement statement = null ; ResultSet resultSet = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , cacheId ) ; statement = connection . prepareStatement ( sql ) ; statement . setString ( <NUM_LIT:1> , cacheId ) ; resultSet = statement . executeQuery ( ) ; if ( resultSet . next ( ) == false ) { LOG . debugMessage ( ""<STR_LIT>"" , cacheId ) ; return null ; } LocalCacheInfo result = toCacheInfoObject ( resultSet ) ; assert resultSet . next ( ) == false ; LOG . debugMessage ( ""<STR_LIT>"" , cacheId ) ; return result ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql , cacheId ) ; } finally { DBConnection . closeRs ( resultSet ) ; DBConnection . closePs ( statement ) ; } } public Calendar putCacheInfo ( LocalCacheInfo current ) throws BulkLoaderSystemException { if ( current == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; boolean succeed = false ; PreparedStatement statement = null ; Calendar last = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , current ) ; last = getLastUpdated ( current . getTableName ( ) ) ; if ( last == null ) { throw new BulkLoaderSystemException ( getClass ( ) , ""<STR_LIT>"" , current ) ; } statement = connection . prepareStatement ( sql ) ; statement . setString ( <NUM_LIT:1> , current . getId ( ) ) ; statement . setTimestamp ( <NUM_LIT:2> , toTimestamp ( last ) ) ; statement . setTimestamp ( <NUM_LIT:3> , toTimestamp ( current . getRemoteTimestamp ( ) ) ) ; statement . setString ( <NUM_LIT:4> , current . getTableName ( ) ) ; statement . setString ( <NUM_LIT:5> , current . getPath ( ) ) ; int rows = statement . executeUpdate ( ) ; if ( rows == <NUM_LIT:0> ) { throw new BulkLoaderSystemException ( getClass ( ) , ""<STR_LIT>"" , current ) ; } DBConnection . commit ( connection ) ; succeed = true ; LOG . debugMessage ( ""<STR_LIT>"" , toTimestamp ( last ) ) ; return last ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql , current . getId ( ) , toTimestamp ( last ) , toTimestamp ( current . getRemoteTimestamp ( ) ) , current . getTableName ( ) , current . getPath ( ) ) ; } finally { DBConnection . closePs ( statement ) ; if ( succeed == false ) { DBConnection . rollback ( connection ) ; } } } private Calendar getLastUpdated ( String tableName ) throws SQLException { assert connection != null ; assert tableName != null ; Statement statement = connection . createStatement ( ) ; ResultSet resultSet = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , tableName ) ; statement . execute ( MessageFormat . format ( ""<STR_LIT>"" , tableName ) ) ; resultSet = statement . executeQuery ( ""<STR_LIT>"" ) ; if ( resultSet . next ( ) == false ) { return null ; } Calendar calendar = Calendar . getInstance ( ) ; Timestamp timestamp = resultSet . getTimestamp ( <NUM_LIT:1> , calendar ) ; calendar . setTime ( timestamp ) ; resultSet . close ( ) ; statement . execute ( ""<STR_LIT>"" ) ; LOG . debugMessage ( ""<STR_LIT>"" , tableName , timestamp ) ; return calendar ; } finally { DBConnection . closeRs ( resultSet ) ; DBConnection . closeStmt ( statement ) ; } } public boolean deleteCacheInfo ( String cacheId ) throws BulkLoaderSystemException { if ( cacheId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; boolean succeed = false ; PreparedStatement statement = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , cacheId ) ; statement = connection . prepareStatement ( sql ) ; statement . setString ( <NUM_LIT:1> , cacheId ) ; int rows = statement . executeUpdate ( ) ; DBConnection . commit ( connection ) ; succeed = true ; LOG . debugMessage ( ""<STR_LIT>"" , cacheId , rows ) ; return rows > <NUM_LIT:0> ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql , cacheId ) ; } finally { DBConnection . closePs ( statement ) ; if ( succeed == false ) { DBConnection . rollback ( connection ) ; } } } public int deleteTableCacheInfo ( String tableName ) throws BulkLoaderSystemException { if ( tableName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; boolean succeed = false ; PreparedStatement statement = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , tableName ) ; statement = connection . prepareStatement ( sql ) ; statement . setString ( <NUM_LIT:1> , tableName ) ; int rows = statement . executeUpdate ( ) ; DBConnection . commit ( connection ) ; succeed = true ; LOG . debugMessage ( ""<STR_LIT>"" , tableName , rows ) ; return rows ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql , tableName ) ; } finally { DBConnection . closePs ( statement ) ; if ( succeed == false ) { DBConnection . rollback ( connection ) ; } } } public void deleteAllCacheInfo ( ) throws BulkLoaderSystemException { final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; boolean succeed = false ; PreparedStatement statement = null ; try { LOG . debugMessage ( ""<STR_LIT>"" ) ; statement = connection . prepareStatement ( sql ) ; statement . executeUpdate ( ) ; DBConnection . commit ( connection ) ; succeed = true ; LOG . debugMessage ( ""<STR_LIT>"" ) ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql ) ; } finally { DBConnection . closePs ( statement ) ; if ( succeed == false ) { DBConnection . rollback ( connection ) ; } } } public List < LocalCacheInfo > listDeletedCacheInfo ( ) throws BulkLoaderSystemException { final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; PreparedStatement statement = null ; ResultSet resultSet = null ; try { LOG . debugMessage ( ""<STR_LIT>"" ) ; statement = connection . prepareStatement ( sql ) ; resultSet = statement . executeQuery ( ) ; List < LocalCacheInfo > results = new ArrayList < LocalCacheInfo > ( ) ; while ( resultSet . next ( ) ) { LocalCacheInfo found = toCacheInfoObject ( resultSet ) ; LOG . debugMessage ( ""<STR_LIT>"" , found . getId ( ) ) ; results . add ( found ) ; } LOG . debugMessage ( ""<STR_LIT>"" , results . size ( ) ) ; return results ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql ) ; } finally { DBConnection . closeRs ( resultSet ) ; DBConnection . closePs ( statement ) ; } } public boolean deleteCacheInfoCompletely ( String cacheId ) throws BulkLoaderSystemException { if ( cacheId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } final String sql = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; boolean succeed = false ; PreparedStatement statement = null ; try { LOG . debugMessage ( ""<STR_LIT>"" , cacheId ) ; statement = connection . prepareStatement ( sql ) ; statement . setString ( <NUM_LIT:1> , cacheId ) ; int rows = statement . executeUpdate ( ) ; DBConnection . commit ( connection ) ; succeed = true ; LOG . debugMessage ( ""<STR_LIT>"" , cacheId , rows ) ; return rows > <NUM_LIT:0> ; } catch ( SQLException e ) { throw BulkLoaderSystemException . createInstanceCauseBySQLException ( e , getClass ( ) , sql , cacheId ) ; } finally { DBConnection . closePs ( statement ) ; if ( succeed == false ) { DBConnection . rollback ( connection ) ; } } } private LocalCacheInfo toCacheInfoObject ( ResultSet resultSet ) throws SQLException { assert resultSet != null ; String'}]","id = resultSet.getString(<NUM_LIT:1>);String tableName = resultSet.getString(<NUM_LIT:2>);String path = resultSet.getString(<NUM_LIT:3>);Timestamp remoteTimestamp = resultSet.getTimestamp(<NUM_LIT:4>);Timestamp localTimestamp = resultSet.getTimestamp(<NUM_LIT:5>);LocalCacheInfo result = new LocalCacheInfo(id, tableName, path, remoteTimestamp, localTimestamp);return result;",0.00019259131676718614
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . parser . warnings ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . jruby . ast . CallNode ; import org . jruby . ast . DVarNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . DefsNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . jruby . ast . SelfNode ; import org . jruby . ast . VCallNode ; import org . jruby . lexer . yacc . ISourcePosition ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import org . rubypeople . rdt . internal . core . util . ASTUtil ; import com . aptana . rdt . AptanaRDTPlugin ; import com . aptana . rdt . IProblem ; public class FeatureEnvy extends RubyLintVisitor { private static final int DEFAULT_MIN_REFERENCES_FOR_REPORT = <NUM_LIT:2> ; private static final String SELF = ""<STR_LIT>"" ; private HashMap < String , List < ISourcePosition > > references = new HashMap < String , List < ISourcePosition > > ( ) ; private boolean recordReferences = false ; private int minReferences ; public FeatureEnvy ( String src ) { this ( AptanaRDTPlugin . getDefault ( ) . getOptions ( ) , src ) ; } public FeatureEnvy ( Map < String , String > options , String src ) { super ( options , src ) ; minReferences = getInt ( AptanaRDTPlugin . COMPILER_PB_MIN_REFERENCES_FOR_ENVY , DEFAULT_MIN_REFERENCES_FOR_REPORT ) ; } private int getInt ( String key , int defaultValue ) { try { return Integer . parseInt ( ( String ) fOptions . get ( key ) ) ; }'}]","catch ( NumberFormatException e ) { return defaultValue ; } } public void visitDefnNode ( DefnNode node ) { super. visitDefnNode ( node ) ; recordReferences = true ; } public void visitVCallNode ( VCallNode node ) { if ( recordReferences ) { ISourcePosition position = node. getPosition ( ) ; String name = node. getName ( ) ; if ( references. containsKey ( name ) ) { references. get ( name ). add ( position ) ; } else { references. put ( name, new ArrayList < ISourcePosition > ( ) { { add ( position ) ; } } ) ; } } super. visitVCallNode ( node ) ; } public void visitSelfNode ( SelfNode node ) { if ( recordReferences ) { ISourcePosition position = node. getPosition ( ) ; references. get ( SELF ). add ( position ) ; } super. visitSelfNode ( node ) ; } public void visitFCallNode ( FCallNode node ) { if ( recordReferences ) { ISourcePosition position = node. getPosition ( ) ; String name = node. getName ( ) ; if ( references. containsKey ( name ) ) { references. get ( name ). add ( position",0.0003600450984196379
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package info . naturwerk . app ; import android . content . Intent ; import android . database . Cursor ; import android . os . Bundle ; import android . util . Log ; import android . view . View ; import android . widget . AdapterView ; import android . widget . AdapterView . OnItemClickListener ; import android . widget . ListView ; import android . widget . SimpleCursorAdapter ; public class NWFaunaActivity extends NWBaseActivity { private static final String TAG = NWFaunaActivity . class . getSimpleName ( ) ; Cursor cursor ; ListView listCategory ; SimpleCursorAdapter adapter ; static final String [ ] FROM_FAUNA = { NWDataBase . FAUNA_NAME_DE , NWDataBase . FAUNA_SPECIES } ; static final String [ ] FROM_FLORA = { NWDataBase . FLORA_NAME_DE , NWDataBase . FLORA_NAME } ; static final int [ ] TO = { R . id . textFaunaName , R . id . textFaunaLatinName } ;'}]","static final String [ ] TO_FLORA = { R. id. textFloraName, R. id. textFloraNameLatin } ;",5.653781076487132e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core ; import java . text . MessageFormat ; import java . util . ResourceBundle ; public class YaessCoreLogger extends YaessLogger { private static final ResourceBundle BUNDLE = ResourceBundle . getBundle ( ""<STR_LIT>"" ) ; public YaessCoreLogger ( Class < ?'}]","> clazz ) { super ( MessageFormat. format ( BUNDLE. getString ( ""logger.name"" ), clazz. getName ( ) ) ) ; } }",5.622095687575992e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core ; public interface IRubyModelMarker { public static final String RUBY_MODEL_PROBLEM_MARKER = RubyCore . PLUGIN_ID + ""<STR_LIT>"" ; public static final String TRANSIENT_PROBLEM = RubyCore . PLUGIN_ID + ""<STR_LIT>"" ; public static final String TASK_MARKER = RubyCore . PLUGIN_ID + ""<STR_LIT>"" ; public static'}]",void markRubyModel(RubyCore rubyCore);,2.951982676650232e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . dummy . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . math . BigDecimal ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ TableModel ( name = ""<STR_LIT:foo>"" , primary = { } ) @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class Foo implements Writable { @ Property ( name = ""<STR_LIT>"" ) private LongOption pk = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailGroupId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailSenderId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailReceiverId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailTestType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailStatus = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private IntOption detailLineNo = new IntOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption deleteFlg = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption insertDatetime = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption updateDatetime = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private ByteOption lineNo = new ByteOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption deliveryDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption storeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption buyerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption salesTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption sellerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tenantCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption netPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption sellingPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentStoreCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentSalesTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption deductionCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption accountCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DecimalOption decCol = new DecimalOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption ownershipDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption cutoffDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption payoutDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption ownershipFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cutoffFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption payoutFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption disposeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption disposeDate = new DateOption ( ) ; public long getPk ( ) { return this . pk . get ( ) ; } public void setPk ( long pk ) { this . pk . modify ( pk ) ; } public LongOption getPkOption ( ) { return this . pk ; } public void setPkOption ( LongOption pk ) { this . pk . copyFrom ( pk ) ; } public Text getDetailGroupId ( ) { return this . detailGroupId . get ( ) ; } public void setDetailGroupId ( Text detailGroupId ) { this . detailGroupId . modify ( detailGroupId ) ; } public String getDetailGroupIdAsString ( ) { return this . detailGroupId . getAsString ( ) ; } public void setDetailGroupIdAsString ( String detailGroupId ) { this . detailGroupId . modify ( detailGroupId ) ; } public StringOption getDetailGroupIdOption ( ) { return this . detailGroupId ; } public void setDetailGroupIdOption ( StringOption detailGroupId ) { this . detailGroupId . copyFrom ( detailGroupId ) ; } public Text getDetailType ( ) { return this . detailType . get ( ) ; } public void setDetailType ( Text detailType ) { this . detailType . modify ( detailType ) ; } public String getDetailTypeAsString ( ) { return this . detailType . getAsString ( ) ; } public void setDetailTypeAsString ( String detailType ) { this . detailType . modify ( detailType ) ; } public StringOption getDetailTypeOption ( ) { return this . detailType ; } public void setDetailTypeOption ( StringOption detailType ) { this . detailType . copyFrom ( detailType ) ; } public Text getDetailSenderId ( ) { return this . detailSenderId . get ( ) ; } public void setDetailSenderId ( Text detailSenderId ) { this . detailSenderId . modify ( detailSenderId ) ; } public String getDetailSenderIdAsString ( ) { return this . detailSenderId . getAsString ( ) ; } public void setDetailSenderIdAsString ( String detailSenderId ) { this . detailSenderId . modify ( detailSenderId ) ; } public StringOption getDetailSenderIdOption ( ) { return this . detailSenderId ; } public void setDetailSenderIdOption ( StringOption detailSenderId ) { this . detailSenderId . copyFrom ( detailSenderId ) ; } public Text getDetailReceiverId ( ) { return this . detailReceiverId . get ( ) ; } public void setDetailReceiverId ( Text detailReceiverId ) { this . detailReceiverId . modify ( detailReceiverId ) ; } public String getDetailReceiverIdAsString ( ) { return this . detailReceiverId . getAsString ( ) ; } public void setDetailReceiverIdAsString ( String detailReceiverId ) { this . detailReceiverId . modify ( detailReceiverId ) ; } public StringOption getDetailReceiverIdOption ( ) { return this . detailReceiverId ; } public void setDetailReceiverIdOption ( StringOption detailReceiverId ) { this . detailReceiverId . copyFrom ( detailReceiverId ) ; } public Text getDetailTestType ( ) { return this . detailTestType . get ( ) ; } public void setDetailTestType ( Text detailTestType ) { this . detailTestType . modify ( detailTestType ) ; } public String getDetailTestTypeAsString ( ) { return this . detailTestType . getAsString ( ) ; } public void setDetailTestTypeAsString ( String detailTestType ) { this . detailTestType . modify ( detailTestType ) ; } public StringOption getDetailTestTypeOption ( ) { return this . detailTestType ; } public void setDetailTestTypeOption ( StringOption detailTestType ) { this . detailTestType . copyFrom ( detailTestType ) ; } public Text getDetailStatus ( ) { return this . detailStatus . get ( ) ; } public void setDetailStatus ( Text detailStatus ) { this . detailStatus . modify ( detailStatus ) ; } public String getDetailStatusAsString ( ) { return this . detailStatus . getAsString ( ) ; } public void setDetailStatusAsString ( String detailStatus ) { this . detailStatus . modify ( detailStatus ) ; } public StringOption getDetailStatusOption ( ) { return this . detailStatus ; } public void setDetailStatusOption ( StringOption detailStatus ) { this . detailStatus . copyFrom ( detailStatus ) ; } public int getDetailLineNo ( ) { return this . detailLineNo . get ( ) ; } public void setDetailLineNo ( int detailLineNo ) { this . detailLineNo . modify ( detailLineNo ) ; } public IntOption getDetailLineNoOption ( ) { return this . detailLineNo ; } public void setDetailLineNoOption ( IntOption detailLineNo ) { this . detailLineNo . copyFrom ( detailLineNo ) ; } public Text getDeleteFlg ( ) { return this . deleteFlg . get ( ) ; } public void setDeleteFlg ( Text deleteFlg ) { this . deleteFlg . modify ( deleteFlg ) ; } public String getDeleteFlgAsString ( ) { return this . deleteFlg . getAsString ( ) ; } public void setDeleteFlgAsString ( String deleteFlg ) { this . deleteFlg . modify ( deleteFlg ) ; } public StringOption getDeleteFlgOption ( ) { return this . deleteFlg ; } public void setDeleteFlgOption ( StringOption deleteFlg ) { this . deleteFlg . copyFrom ( deleteFlg ) ; } public Date getInsertDatetime ( ) { return this . insertDatetime . get ( ) ; } public void setInsertDatetime ( Date insertDatetime ) { this . insertDatetime . modify ( insertDatetime ) ; } public DateOption getInsertDatetimeOption ( ) { return this . insertDatetime ; } public void setInsertDatetimeOption ( DateOption insertDatetime ) { this . insertDatetime . copyFrom ( insertDatetime ) ; } public Date getUpdateDatetime ( ) { return this . updateDatetime . get ( ) ; } public void setUpdateDatetime ( Date updateDatetime ) { this . updateDatetime . modify ( updateDatetime ) ; } public DateOption getUpdateDatetimeOption ( ) { return this . updateDatetime ; } public void setUpdateDatetimeOption ( DateOption updateDatetime ) { this . updateDatetime . copyFrom ( updateDatetime ) ; } public Text getPurchaseNo ( ) { return this . purchaseNo . get ( ) ; } public void setPurchaseNo ( Text purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public String getPurchaseNoAsString ( ) { return this . purchaseNo . getAsString ( ) ; } public void setPurchaseNoAsString ( String purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public StringOption getPurchaseNoOption ( ) { return this . purchaseNo ; } public void setPurchaseNoOption ( StringOption purchaseNo ) { this . purchaseNo . copyFrom ( purchaseNo ) ; } public Text getPurchaseType ( ) { return this . purchaseType . get ( ) ; } public void setPurchaseType ( Text purchaseType ) { this . purchaseType . modify ( purchaseType ) ; } public String getPurchaseTypeAsString ( ) { return this . purchaseType . getAsString ( ) ; } public void setPurchaseTypeAsString ( String purchaseType ) { this . purchaseType . modify ( purchaseType ) ; } public StringOption getPurchaseTypeOption ( ) { return this . purchaseType ; } public void setPurchaseTypeOption ( StringOption purchaseType ) { this . purchaseType . copyFrom ( purchaseType ) ; } public Text getTradeType ( ) { return this . tradeType . get ( ) ; } public void setTradeType ( Text tradeType ) { this . tradeType . modify ( tradeType ) ; } public String getTradeTypeAsString ( ) { return this . tradeType . getAsString ( ) ; } public void setTradeTypeAsString ( String tradeType ) { this . tradeType . modify ( tradeType ) ; } public StringOption getTradeTypeOption ( ) { return this . tradeType ; } public void setTradeTypeOption ( StringOption tradeType ) { this . tradeType . copyFrom ( tradeType ) ; } public Text getTradeNo ( ) { return this . tradeNo . get ( ) ; } public void setTradeNo ( Text tradeNo ) { this . tradeNo . modify ( tradeNo ) ; } public String getTradeNoAsString ( ) { return this . tradeNo . getAsString ( ) ; } public void setTradeNoAsString ( String tradeNo ) { this . tradeNo . modify ( tradeNo ) ; } public StringOption getTradeNoOption ( ) { return this . tradeNo ; } public void setTradeNoOption ( StringOption tradeNo ) { this . tradeNo . copyFrom ( tradeNo ) ; } public byte getLineNo ( ) { return this . lineNo . get ( ) ; } public void setLineNo ( byte lineNo ) { this . lineNo . modify ( lineNo ) ; } public ByteOption getLineNoOption ( ) { return this . lineNo ; } public void setLineNoOption ( ByteOption lineNo ) { this . lineNo . copyFrom ( lineNo ) ; } public Date getDeliveryDate ( ) { return this . deliveryDate . get ( ) ; } public void setDeliveryDate ( Date deliveryDate ) { this . deliveryDate . modify ( deliveryDate ) ; } public DateOption getDeliveryDateOption ( ) { return this . deliveryDate ; } public void setDeliveryDateOption ( DateOption deliveryDate ) { this . deliveryDate . copyFrom ( deliveryDate ) ; } public Text getStoreCode ( ) { return this . storeCode . get ( ) ; } public void setStoreCode ( Text storeCode ) { this . storeCode . modify ( storeCode ) ; } public String getStoreCodeAsString ( ) { return this . storeCode . getAsString ( ) ; } public void setStoreCodeAsString ( String storeCode ) { this . storeCode . modify ( storeCode ) ; } public StringOption getStoreCodeOption ( ) { return this . storeCode ; } public void setStoreCodeOption ( StringOption storeCode ) { this . storeCode . copyFrom ( storeCode ) ; } public Text getBuyerCode ( ) { return this . buyerCode . get ( ) ; } public void setBuyerCode ( Text buyerCode ) { this . buyerCode . modify ( buyerCode ) ; } public String getBuyerCodeAsString ( ) { return this . buyerCode . getAsString ( ) ; } public void setBuyerCodeAsString ( String buyerCode ) { this . buyerCode . modify ( buyerCode ) ; } public StringOption getBuyerCodeOption ( ) { return this . buyerCode ; } public void setBuyerCodeOption ( StringOption buyerCode ) { this . buyerCode . copyFrom ( buyerCode ) ; } public Text getSalesTypeCode ( ) { return this . salesTypeCode . get ( ) ; } public void setSalesTypeCode ( Text salesTypeCode ) { this . salesTypeCode . modify ( salesTypeCode ) ; } public String getSalesTypeCodeAsString ( ) { return this . salesTypeCode . getAsString ( ) ; } public void setSalesTypeCodeAsString ( String salesTypeCode ) { this . salesTypeCode . modify ( salesTypeCode ) ; } public StringOption getSalesTypeCodeOption ( ) { return this . salesTypeCode ; } public void setSalesTypeCodeOption ( StringOption salesTypeCode ) { this . salesTypeCode . copyFrom ( salesTypeCode ) ; } public Text getSellerCode ( ) { return this . sellerCode . get ( ) ; } public void setSellerCode ( Text sellerCode ) { this . sellerCode . modify ( sellerCode ) ; } public String getSellerCodeAsString ( ) { return this . sellerCode . getAsString ( ) ; } public void setSellerCodeAsString ( String sellerCode ) { this . sellerCode . modify ( sellerCode ) ; } public StringOption getSellerCodeOption ( ) { return this . sellerCode ; } public void setSellerCodeOption ( StringOption sellerCode ) { this . sellerCode . copyFrom ( sellerCode ) ; } public Text getTenantCode ( ) { return this . tenantCode . get ( ) ; } public void setTenantCode ( Text tenantCode ) { this . tenantCode . modify ( tenantCode ) ; } public String getTenantCodeAsString ( ) { return this . tenantCode . getAsString ( ) ; } public void setTenantCodeAsString ( String tenantCode ) { this . tenantCode . modify ( tenantCode ) ; } public StringOption getTenantCodeOption ( ) { return this . tenantCode ; } public void setTenantCodeOption ( StringOption tenantCode ) { this . tenantCode . copyFrom ( tenantCode ) ; } public long getNetPriceTotal ( ) { return this . netPriceTotal . get ( ) ; } public void setNetPriceTotal ( long netPriceTotal ) { this . netPriceTotal . modify ( netPriceTotal ) ; } public LongOption getNetPriceTotalOption ( ) { return this . netPriceTotal ; } public void setNetPriceTotalOption ( LongOption netPriceTotal ) { this . netPriceTotal . copyFrom ( netPriceTotal ) ; } public long getSellingPriceTotal ( ) { return this . sellingPriceTotal . get ( ) ; } public void setSellingPriceTotal ( long sellingPriceTotal ) { this . sellingPriceTotal . modify ( sellingPriceTotal ) ; } public LongOption getSellingPriceTotalOption ( ) { return this . sellingPriceTotal ; } public void setSellingPriceTotalOption ( LongOption sellingPriceTotal ) { this . sellingPriceTotal . copyFrom ( sellingPriceTotal ) ; } public Text getShipmentStoreCode ( ) { return this . shipmentStoreCode . get ( ) ; } public void setShipmentStoreCode ( Text shipmentStoreCode ) { this . shipmentStoreCode . modify ( shipmentStoreCode ) ; } public String getShipmentStoreCodeAsString ( ) { return this . shipmentStoreCode . getAsString ( ) ; } public void setShipmentStoreCodeAsString ( String shipmentStoreCode ) { this . shipmentStoreCode . modify ( shipmentStoreCode ) ; } public StringOption getShipmentStoreCodeOption ( ) { return this . shipmentStoreCode ; } public void setShipmentStoreCodeOption ( StringOption shipmentStoreCode ) { this . shipmentStoreCode . copyFrom ( shipmentStoreCode ) ; } public Text getShipmentSalesTypeCode ( ) { return this . shipmentSalesTypeCode . get ( ) ; } public void setShipmentSalesTypeCode ( Text shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . modify ( shipmentSalesTypeCode ) ; } public String getShipmentSalesTypeCodeAsString ( ) { return this . shipmentSalesTypeCode . getAsString ( ) ; } public void setShipmentSalesTypeCodeAsString ( String shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . modify ( shipmentSalesTypeCode ) ; } public StringOption getShipmentSalesTypeCodeOption ( ) { return this . shipmentSalesTypeCode ; } public void setShipmentSalesTypeCodeOption ( StringOption shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . copyFrom ( shipmentSalesTypeCode ) ; } public Text getDeductionCode ( ) { return this . deductionCode . get ( ) ; } public void setDeductionCode ( Text deductionCode ) { this . deductionCode . modify ( deductionCode ) ; } public String getDeductionCodeAsString ( ) { return this . deductionCode . getAsString ( ) ; } public void setDeductionCodeAsString ( String deductionCode ) { this . deductionCode . modify ( deductionCode ) ; } public StringOption getDeductionCodeOption ( ) { return this . deductionCode ; } public void setDeductionCodeOption ( StringOption deductionCode ) { this . deductionCode . copyFrom ( deductionCode ) ; } public Text getAccountCode ( ) { return this . accountCode . get ( ) ; } public void setAccountCode ( Text accountCode ) { this . accountCode . modify ( accountCode ) ; } public String getAccountCodeAsString ( ) { return this . accountCode . getAsString ( ) ; } public void setAccountCodeAsString ( String accountCode ) { this . accountCode . modify ( accountCode ) ; } public StringOption getAccountCodeOption ( ) { return this . accountCode ; } public void setAccountCodeOption ( StringOption accountCode ) { this . accountCode . copyFrom ( accountCode ) ; } public BigDecimal getDecCol ( ) { return this . decCol . get ( ) ; } public void setDecCol ( BigDecimal decCol ) { this . decCol . modify ( decCol ) ; } public DecimalOption getDecColOption ( ) { return this . decCol ; } public void setDecColOption ( DecimalOption decCol ) { this . decCol . copyFrom ( decCol ) ; } public Date getOwnershipDate ( ) { return this . ownershipDate . get ( ) ; } public void setOwnershipDate ( Date ownershipDate ) { this . ownershipDate . modify ( ownershipDate ) ; } public DateOption getOwnershipDateOption ( ) { return this . ownershipDate ; } public void setOwnershipDateOption ( DateOption ownershipDate ) { this . ownershipDate . copyFrom ( ownershipDate ) ; } public Date getCutoffDate ( ) { return this . cutoffDate . get ( ) ; } public void setCutoffDate ( Date cutoffDate ) { this . cutoffDate . modify ( cutoffDate ) ; } public DateOption getCutoffDateOption ( ) { return this . cutoffDate ; } public void setCutoffDateOption ( DateOption cutoffDate ) { this . cutoffDate . copyFrom ( cutoffDate ) ; } public Date getPayoutDate ( ) { return this . payoutDate . get ( ) ; } public void setPayoutDate ( Date payoutDate ) { this . payoutDate . modify ( payoutDate ) ; } public DateOption getPayoutDateOption ( ) { return this . payoutDate ; } public void setPayoutDateOption ( DateOption payoutDate ) { this . payoutDate . copyFrom ( payoutDate ) ; } public Text getOwnershipFlag ( ) { return this . ownershipFlag . get ( ) ; } public void setOwnershipFlag ( Text ownershipFlag ) { this . ownershipFlag . modify ( ownershipFlag ) ; } public String getOwnershipFlagAsString ( ) { return this . ownershipFlag . getAsString ( ) ; } public void setOwnershipFlagAsString ( String ownershipFlag ) { this . ownershipFlag . modify ( ownershipFlag ) ; } public StringOption getOwnershipFlagOption ( ) { return this . ownershipFlag ; } public void setOwnershipFlagOption ( StringOption ownershipFlag ) { this . ownershipFlag . copyFrom ( ownershipFlag ) ; } public Text getCutoffFlag ( ) { return this . cutoffFlag . get ( ) ; } public void setCutoffFlag ( Text cutoffFlag ) { this . cutoffFlag . modify ( cutoffFlag ) ; } public String getCutoffFlagAsString ( ) { return this . cutoffFlag . getAsString ( ) ; } public void setCutoffFlagAsString ( String cutoffFlag ) { this . cutoffFlag . modify ( cutoffFlag ) ; } public StringOption getCutoffFlagOption ( ) { return this . cutoffFlag ; } public void setCutoffFlagOption ( StringOption cutoffFlag ) { this . cutoffFlag . copyFrom ( cutoffFlag ) ; } public Text getPayoutFlag ( ) { return this . payoutFlag . get ( ) ; } public void setPayoutFlag ( Text payoutFlag ) { this . payoutFlag . modify ( payoutFlag ) ; } public String getPayoutFlagAsString ( ) { return this . payoutFlag . getAsString ( ) ; } public void setPayoutFlagAsString ( String payoutFlag ) { this . payoutFlag . modify ( payoutFlag ) ; } public StringOption getPayoutFlagOption ( ) { return this . payoutFlag ; } public void setPayoutFlagOption ( StringOption payoutFlag ) { this . payoutFlag . copyFrom ( payoutFlag ) ; } public Text getDisposeNo ( ) { return this . disposeNo . get ( ) ; } public void setDisposeNo ( Text disposeNo ) { this . disposeNo . modify ( disposeNo ) ; } public String getDisposeNoAsString ( ) { return this . disposeNo . getAsString ( ) ; } public void setDisposeNoAsString ( String disposeNo ) { this . disposeNo . modify ( disposeNo ) ; } public StringOption getDisposeNoOption ( ) { return this . disposeNo ; } public void setDisposeNoOption ( StringOption disposeNo ) { this . disposeNo . copyFrom ( disposeNo ) ; } public Date getDisposeDate ( ) { return this . disposeDate . get ( ) ; } public void setDisposeDate ( Date disposeDate ) { this . disposeDate . modify ( disposeDate ) ; } public DateOption getDisposeDateOption ( ) { return this . disposeDate ; } public void setDisposeDateOption ( DateOption disposeDate ) { this . disposeDate . copyFrom ( disposeDate ) ; } public void copyFrom ( Foo source ) { this . pk . copyFrom ( source . pk ) ; this . detailGroupId . copyFrom ( source . detailGroupId ) ; this . detailType . copyFrom ( source . detailType ) ; this . detailSenderId . copyFrom ( source . detailSenderId ) ; this . detailReceiverId . copyFrom ( source . detailReceiverId ) ; this . detailTestType . copyFrom ( source . detailTestType ) ; this . detailStatus . copyFrom ( source . detailStatus ) ; this . detailLineNo . copyFrom ( source . detailLineNo ) ; this . deleteFlg . copyFrom ( source . deleteFlg ) ; this . insertDatetime . copyFrom ( source . insertDatetime ) ; this . updateDatetime . copyFrom ( source . updateDatetime ) ; this . purchaseNo . copyFrom ( source . purchaseNo ) ; this . purchaseType . copyFrom ( source . purchaseType ) ; this . tradeType . copyFrom ( source . tradeType ) ; this . tradeNo . copyFrom ( source . tradeNo ) ; this . lineNo . copyFrom ( source . lineNo ) ; this . deliveryDate . copyFrom ( source . deliveryDate ) ; this . storeCode . copyFrom ( source . storeCode ) ; this . buyerCode . copyFrom ( source . buyerCode ) ; this . salesTypeCode . copyFrom ( source . salesTypeCode ) ; this . sellerCode . copyFrom ( source . sellerCode ) ; this . tenantCode . copyFrom ( source . tenantCode ) ; this . netPriceTotal . copyFrom ( source . netPriceTotal ) ; this . sellingPriceTotal . copyFrom ( source . sellingPriceTotal ) ; this . shipmentStoreCode . copyFrom ( source . shipmentStoreCode ) ; this . shipmentSalesTypeCode . copyFrom ( source . shipmentSalesTypeCode ) ; this . deductionCode . copyFrom ( source . deductionCode ) ; this . accountCode . copyFrom ( source . accountCode ) ; this . decCol . copyFrom ( source . decCol ) ; this . ownershipDate . copyFrom ( source . ownershipDate ) ; this . cutoffDate . copyFrom ( source . cutoffDate ) ; this . payoutDate . copyFrom ( source . payoutDate ) ; this . ownershipFlag . copyFrom ( source . ownershipFlag ) ; this . cutoffFlag . copyFrom ( source . cutoffFlag ) ; this . payoutFlag . copyFrom ( source . payoutFlag ) ; this . disposeNo . copyFrom ( source . disposeNo ) ; this . disposeDate . copyFrom ( source . disposeDate ) ; } @ Override public void write ( DataOutput out ) throws IOException { pk . write ( out ) ; detailGroupId . write ( out ) ; detailType . write ( out ) ; detailSenderId . write ( out ) ; detailReceiverId . write ( out ) ; detailTestType . write ( out ) ; detailStatus . write ( out ) ; detailLineNo . write ( out ) ; deleteFlg . write ( out ) ; insertDatetime . write ( out ) ; updateDatetime . write ( out ) ; purchaseNo . write ( out ) ; purchaseType . write ( out ) ; tradeType . write ( out ) ; tradeNo . write ( out ) ; lineNo . write ( out ) ; deliveryDate . write ( out ) ; storeCode . write ( out ) ; buyerCode . write ( out ) ; salesTypeCode . write ( out ) ; sellerCode . write ( out ) ; tenantCode . write ( out ) ; netPriceTotal . write ( out ) ; sellingPriceTotal . write ('}]",.write(out); sellingPriceTotal.write(out); shipmentStoreCode.write(out); shipmentSalesTypeCode.write(out); deductionCode.write(out); accountCode.write(out); decCol.write(out); ownershipDate.write(out); cutoffDate.write(out); payoutDate.write(out); ownershipFlag.write(out); cutoffFlag.write(out); payoutFlag.write(out); disposeNo.write(out); disposeDate.write(out); } @Override public void readFields(DataInput in) throws IOException { pk.readFields(in); detailGroupId.readFields(in); detailType.readFields(in); detailSenderId.readFields(in); detailReceiverId.readFields(in); detailTestType.readFields(in); detailStatus.readFields(in); detailLineNo.readFields(in); deleteFlg.readFields(in); insertDatetime.readFields(in); updateDatetime.readFields(in); purchaseNo.readFields(in); purchaseType.readFields(in); tradeType.readFields(in); tradeNo.readFields(in); lineNo.readFields(in); deliveryDate.readFields(in); storeCode.readFields(in); buyerCode.readFields(in); salesTypeCode.readFields(in); sellerCode.readFields(in); tenantCode.readFields(in); netPriceTotal.readFields(in); sellingPriceTotal.readFields(in); shipmentStoreCode.readFields(in); shipmentSalesTypeCode.readFields(in);,0.0007291301544236289
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBInsideExpr extends SVDBExpr { public SVDBExpr fLhs ;'}]",public List<SVDBExpr> fChildren = new ArrayList<>();,3.4222594029302194e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . samples . petclinic ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . persistence . Basic ; import javax . persistence . CascadeType ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . OneToMany ; import javax . persistence . Table ; import org . hibernate . annotations . Index ; import org . springframework . beans . support . MutableSortDefinition ; import org . springframework . beans . support . PropertyComparator ; import org . springframework . core . style . ToStringCreator ; @ Entity @ Table ( name = ""<STR_LIT>"" ) public class Owner implements Person { @ Basic private String address ; @ Basic private String city ; @ Basic @ Column ( name = ""<STR_LIT>"" ) private String firstName ; @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) private Integer id ; @ Basic @ Column ( name = ""<STR_LIT>"" ) @ Index ( name = ""<STR_LIT>"" ) private String lastName ; @ OneToMany ( targetEntity = Pet . class , mappedBy = ""<STR_LIT>"" , fetch = FetchType . EAGER , cascade = CascadeType . ALL ) private Set < Pet > pets ; @ Basic private String telephone ; public void addPet ( Pet pet ) { getPetsInternal ( ) . add ( pet ) ; pet . setOwner ( this ) ; } public String getAddress ( ) { return this . address ; } public String getCity ( ) { return this . city ; } @ Override public String getFirstName ( ) { return this . firstName ; } @ Override public Integer getId ( ) { return id ; } @ Override public'}]","String getLastName() { return this.lastName; } public Set<Pet> getPets() { return getPetsInternal(); } public Set<Pet> getPetsInternal() { if (pets == null) { pets = new HashSet<Pet>(); } return pets; } public String getTelephone() { return this.telephone; } public void setAddress(String address) { this.address = address; } public void setCity(String city) { this.city = city; } public void setFirstName(String firstName) { this.firstName = firstName; } public void setLastName(String lastName) { this.lastName = lastName; } public void setTelephone(String telephone) { this.telephone = telephone; } @Override public String toString() { return new ToStringCreator(this).append(""address"", getAddress()).append(""city"", getCity()).append(""firstName"", getFirstName()).append(""id"", getId()).append(""lastName"", getLastName()).append(""telephone"", getTelephone()).toString(); }",0.0002780306642381183
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBParamIdExpr extends SVDBIdentifierExpr { public List < SVDBExpr > fParamExpr ; public SVDBParamIdExpr ( ) { this ( null ) ; } public'}]",SVDBParamIdExpr ( List < SVDBExpr > paramExpr ) { super ( ) ; fParamExpr = paramExpr!= null? paramExpr : new ArrayList <> ( ) ; } },6.602564558313688e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . srcgen ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . indent . ISVIndenter ; import net . sf . sveditor . core . indent . SVIndentScanner ; import net . sf . sveditor . core . scanner . SVCharacter ; import net . sf . sveditor .'}]","core. scanner. SVScanner;public class SVCodeGenerator { private static final String CORE_PLUGIN = SVCorePlugin. PLUGIN_ID;private StringInputStream in;private ISVDBIndexIterator iterator;private ISVIndenter indenter;private SVScanner scanner;private SVCharacter character;public SVCodeGenerator(StringInputStream in, ISVDBIndexIterator iterator, ISVIndenter indenter, SVScanner scanner, SVCharacter character) {this.in = in;this.iterator = iterator;this.indenter = indenter;this.scanner = scanner;this.character = character;}",0.00016763137393490754
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . formatsource ; import java . io . PrintWriter ; import java . io . StringWriter ; import org . rubypeople . rdt . core . formatter . FormatHelper ; import org . rubypeople . rdt . core . formatter . ReWriteVisitor ; import org . rubypeople . rdt . core . formatter . ReWriterContext ; import org . rubypeople . rdt . core . formatter . ReWriterFactory ; import org . rubypeople . rdt .'}]","core.formatter.FormatterException; public class FormatSource { public static String formatSource(String source, String language) throws FormatterException { FormatHelper helper = FormatHelper.getInstance(); ReWriterFactory factory = helper.getReWriterFactory(language); ReWriteVisitor visitor = factory.createVisitor(source); StringWriter writer = new StringWriter(); PrintWriter printer = new PrintWriter(writer); ReWriterContext context = new ReWriterContext(printer, visitor); factory.createRewriter(source, context).rewrite(); return writer.toString(); } }",0.00014259289871175056
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . formatter ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . parsers .'}]","SAXParserFactory;import javax.xml.parsers.SAXParser;import org.xml.sax.InputSource;import org.xml.sax.XMLReader;public class XmlInputSource extends InputSource { private final SAXParserFactory spf;private final String systemId;public XmlInputSource(InputStream inputStream, String systemId) throws IOException { this(inputStream, null, systemId);}public XmlInputSource(InputStream inputStream, SAXParserFactory spf, String systemId) throws IOException {super(inputStream);this.spf = spf;this.systemId = systemId;}public XmlInputSource(InputStream inputStream, String encoding, String systemId) throws IOException {super(inputStream, encoding);this.systemId = systemId;}public XmlInputSource(InputStream inputStream, String encoding, SAXParserFactory spf, String systemId) throws IOException {super(inputStream, encoding);this.spf = spf;this.systemId = systemId;}public XmlInputSource(String systemId) throws IOException {super(systemId);}public XmlInputSource(String systemId, String encoding) throws IOException {super(systemId, encoding);}public XmlInputSource(String systemId, SAXParserFactory spf) throws IOException {super(systemId);this.spf = spf;}public XmlInputSource(String systemId, String encoding, SAXParserFactory",1.251693860901422e-06
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages . encapsulatefield ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Group ; import org . rubypeople . rdt . refactoring . nodewrapper . VisibilityNodeWrapper ; public class EncapsulateFieldAccessorComposite extends Group { private Button enableDisableCheckBox ; private IVisibilitySelectionListener visibilitySelectionListener ; private VisibilityNodeWrapper . METHOD_VISIBILITY selectedVisibility ; private Button publicButton ; private Button protectedButton ; private Button privateButton ; public EncapsulateFieldAccessorComposite ( Composite parent , String name , VisibilityNodeWrapper . METHOD_VISIBILITY selectedVisibility , boolean isOptional ) { super ( parent , SWT . NONE ) ; this . selectedVisibility = selectedVisibility ; setLayoutData ( getDefaultGridData ( ) ) ; setLayout ( new GridLayout ( <NUM_LIT:1> , true ) ) ; setText ('}]",name ) ; createEnableDisableCheckBox ( ) ; createVisibilityButtons ( ) ; if ( isOptional ) { getShell ( ). setForceClose ( true ) ; } },6.414832020132541e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . logging . cache ; import org . oddjob . logging . LogArchive ; import org . oddjob . logging . LogLevel ; import'}]",java.util.List;,2.1495411396516144e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . search ; import org . eclipse . jface . preference . JFacePreferences ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ColumnViewer ; import org . eclipse . jface . viewers . DecoratingStyledCellLabelProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . StyledString ; import org . eclipse . jface . viewers . StyledString . Styler ; import org . eclipse . jface . viewers . ViewerColumn ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . StyleRange ; import org . eclipse .'}]","swt.events.SelectionEvent; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableItem; import org.eclipse.ui.part.ViewPart; import org.eclipse.ui.views.contentoutline.IContentOutlinePage; import org.eclipse.ui.views.contentoutline.IContentOutlinePageListener; public class SearchView extends ViewPart { @Override public void init ( IContentOutlinePage page ) { super. init ( page ) ; page. addListener ( IContentOutlinePageListener. PREPARE_CHILDREN, this ) ; } @Override public void prepareChildren ( IContentOutlinePage page ) { // Add a column viewer to the page ColumnViewer viewer = new ColumnViewer ( ) ; viewer. addFilter ( new SearchFilter ( ) ) ; viewer. setContentProvider ( new SearchContentProvider ( ) ) ; viewer. setLabelProvider ( new SearchLabelProvider ( ) ) ; ViewerColumn column = new ViewerColumn ( viewer ) ; column. setLabelProvider ( new SearchColumnLabelProvider ( ) ) ; page. setViewer ( viewer ) ; } @Override public void createPartControl ( Composite parent ) { super. createPartControl ( parent ) ; Display. getDefault ( ). asyncExec ( new Runnable",0.0003475160323977525
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . launching ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . rubypeople . rdt . launching . IRuntimeLoadpathEntry ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class VariableLoadpathEntry extends AbstractRuntimeLoadpathEntry { public static final String TYPE_ID = ""<STR_LIT>"" ; private String variableString ; public VariableLoadpathEntry ( ) { } public VariableLoadpathEntry ( String variableString ) { this . variableString = variableString ; } protected void buildMemento ( Document document , Element memento ) throws CoreException { memento . setAttribute ( ""<STR_LIT>"" , variableString ) ; } public void initializeFrom ( Element memento ) throws CoreException { variableString = memento . getAttribute ( ""<STR_LIT>"" ) ; } public String getTypeId ( ) { return TYPE_ID ; } public IRuntimeLoadpathEntry [ ] getRuntimeLoadpathEntries ( ILaunchConfiguration configuration ) throws CoreException { return new IRuntimeLoadpathEntry [ <NUM_LIT:0> ] ; } public String getName ( ) { return variableString ; } public int getType ( ) { return OTHER ; } public String getVariableString ( ) { return variableString ; } public void setVariableString ( String variableString ) { this . variableString = variableString ; } public int hashCode ( ) { if ('}]",variableString == null ) return 0; int result = 31; result = result * 17 + variableString.hashCode(); return result; } public boolean equals ( Object obj ) { if ( this == obj ) return true; if ( obj == null || getClass ()!= obj.getClass () ) return false; VariableLoadpathEntry other = ( VariableLoadpathEntry ) obj; if ( variableString == null ) { if ( other.variableString!= null ) return false; } else if (!variableString.equals ( other.variableString ) ) return false; return true; } },0.00017080326916081175
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search ; import java . util . HashSet ; import java . util . Iterator ; import org . rubypeople . rdt . core . search . SearchParticipant ; import org . rubypeople . rdt . core . search . SearchPattern ; public class PathCollector'}]",extends SearchParticipant { private final HashSet<String> pathCollector = new HashSet<>(); @Override public boolean accept(SearchPattern pattern) { return pattern.getPath().equals(getPath()); } public String getPath() { return getPath(); } public void addPath(String path) { pathCollector.add(path); } public Iterator<String> iterator() { return pathCollector.iterator(); } },0.0001061932777944589
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . modelgen . emitter ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . modelgen . model . JoinedModelDescription ; import com . asakusafw . modelgen . model . PropertyTypeKind ; import com . asakusafw . modelgen . model . StringType ; import com . asakusafw . modelgen . model . TableModelDescription ; import com . asakusafw . modelgen . util . JoinedModelBuilder ; import com . asakusafw . modelgen . util . TableModelBuilder ; public class JoinedModelEntityEmitterTest extends EmitterTestRoot { @ Test public void simple ( ) throws Throwable { TableModelDescription a = new TableModelBuilder ( ""<STR_LIT:A>"" ) . add ( null , ""<STR_LIT:id>"" , PropertyTypeKind . LONG ) . add ( null , ""<STR_LIT>"" , new StringType ( <NUM_LIT:255> ) ) . toDescription ( ) ; TableModelDescription b = new TableModelBuilder ( ""<STR_LIT:B>"" ) . add ( null , ""<STR_LIT:id>"" , PropertyTypeKind . LONG ) . add ('}]","(null, ""<STR_LIT>"", new StringType(<NUM_LIT:255>)). toDescription(); JoinedModelDescription joined = new JoinedModelBuilder().add(a).add(b).toDescription(); JoinedModelEntityEmitter emitter = new JoinedModelEntityEmitter(); String emitted = emitter.emit(joined, new StringReader(""<STR_LIT>"")); assertThat(emitted, is(""<STR_LIT>A</STR_LIT>\n<STR_LIT>B</STR_LIT>"")); } }",0.00014466785085776897
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . external ; import java . util . Collections ; import java . util . Set ; import com . asakusafw . compiler . flow . testing . model . Part1 ; import com . asakusafw . compiler . testing . TemporaryInputDescription ; public class'}]","TemporaryZipInputDescription extends TemporaryInputDescription { public TemporaryZipInputDescription(String name, Set<Part1> elements) { super(name, Collections.unmodifiableSet(elements)); } }",6.20500751941933e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IParent ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . ISourceRange ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . RubyScript ; import org . rubypeople . rdt . internal . core . util . Util ; public class TypeDeclarationLocator extends PatternLocator { private TypeDeclarationPattern pattern ; public TypeDeclarationLocator ( TypeDeclarationPattern pattern ) { super ( pattern ) ; this . pattern = pattern ; } @ Override public void reportMatches ( RubyScript script , MatchLocator locator ) { reportMatches ( ( IParent ) script , locator ) ; } private void reportMatches ( IParent parent , MatchLocator locator ) { try { IRubyElement [ ] children = parent . getChildren ( ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; i ++ ) { IRubyElement child = children [ i ] ; if ( child . isType ( IRubyElement . TYPE ) && locator . encloses ( child ) ) { int accuracy = getAccuracy ( ( IType ) child ) ; if ( accuracy != IMPOSSIBLE_MATCH ) { IMember member = ( IMember ) child ; ISourceRange range = member . getSourceRange ( ) ; try { locator . report ( locator . newDeclarationMatch ( child , accuracy , range . getOffset ( ) , range . getLength ( ) ) ) ; } catch ( CoreException e ) { RubyCore . log ( e'}]",); } } } } catch ( RubyModelException e ) { RubyCore. log ( e ) ; } } private int getAccuracy ( IType type ) { if ( type. isClass ( ) ) { return ACCURATE_MATCH ; } else if ( type. isModule ( ) ) { return ACCURATE_MATCH ; } else if ( type. isMethod ( ) ) { return ACCURATE_MATCH ; } else { return IMPOSSIBLE_MATCH ; } } },0.00015161751340730264
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . common ; import java . util . Set ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . SimpleName ; public class NameGenerator { private final ModelFactory factory ; private final Set < String > used = Sets . create ( ) ; public NameGenerator ( ModelFactory factory ) { Precondition . checkMustNotBeNull ( factory , ""<STR_LIT>"" ) ; this'}]",".factory = factory; } public SimpleName generateName(String prefix) { Precondition.checkMustNotBeNull(prefix, ""<STR_LIT>""); return factory.createSimpleName(prefix, used); } }",6.291422497863037e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package og . android . tether . data ; import java . util . ArrayList ; import og . android . tether . R ; import og . android . tether . AccessControlActivity ; import og . android . tether . TetherApplication ; import android . graphics . Color ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . BaseAdapter ; import android . widget . CheckBox ; import android . widget . CompoundButton ; import android . widget . TextView ; import android . widget . CompoundButton . OnCheckedChangeListener ; public class ClientAdapter extends BaseAdapter { public static final String MSG_TAG = ""<STR_LIT>"" ; private LayoutInflater inflater ; private ArrayList < ClientData > rows = new ArrayList < ClientData > ( ) ; public boolean saveRequired = false ; public boolean accessControlActive = false ; public TetherApplication application ; public AccessControlActivity accessControlActivity ; public ClientAdapter ( AccessControlActivity accessControlActivity , ArrayList < ClientData > rows , TetherApplication app ) { super ( ) ; this . accessControlActivity = accessControlActivity ; this . application = app ; this . accessControlActive = application . whitelist .'}]","isAccessControlActive ( ) ; this. rows = rows ; this. inflater = accessControlActivity. getLayoutInflater ( ) ; } @ Override public View getView ( int position, View convertView, ViewGroup parent ) { View view = convertView ; if ( view == null ) { view = inflater. inflate ( R. layout. client_list_item, parent, false ) ; } ClientData row = rows. get ( position ) ; TextView name = ( TextView ) view. findViewById ( R. id. client_name ) ; TextView ip = ( TextView ) view. findViewById ( R. id. client_ip ) ; CheckBox checked = ( CheckBox ) view. findViewById ( R. id. checked ) ; name. setText ( row. name ) ; ip. setText ( row. ip ) ; checked. setChecked ( row. checked ) ; checked. setOnCheckedChangeListener ( new OnCheckedChangeListener ( ) { @ Override public void onCheckedChanged ( CompoundButton buttonView, boolean isChecked ) { if ( isChecked ) { Log. d ( MSG_TAG, ""Client "" + row. name + "" checked"" ) ; } else { Log. d ( MSG_TAG, ""Client "" + row. name + "" unchecked"" ) ; } } } ) ; return view ; } @ Override public",0.0003516217318751436
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . modelgen . util ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import com . asakusafw . modelgen . model . JoinedModelDescription ; import com . asakusafw . modelgen . model . ModelDescription ; import com . asakusafw . modelgen . model . ModelProperty ; import com . asakusafw . modelgen . model . Source ; public class JoinedModelBuilder extends ModelBuilder < JoinedModelBuilder > { private List < String > columns ; private Side left ; private Side right ; public JoinedModelBuilder ( String name , ModelDescription left , String leftAlias , ModelDescription right , String rightAlias ) { super ( name ) ; if ( left == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( right == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . columns = new ArrayList < String > ( ) ; this . left = new Side ( left ) ; this . right = new Side ( right ) ; if ( leftAlias != null ) { this . left . alias = leftAlias ; } if ( rightAlias != null ) { this . right . alias = rightAlias ; } if ( this . left . alias . equals ( this . right . alias ) ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , this . left . alias ) ) ; } } public JoinedModelBuilder on ( String aProperty , String bProperty ) { if ( aProperty == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( bProperty == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Ref a = resolve ( aProperty ) ; Ref b = resolve ( bProperty ) ; if ( a . side == b . side ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , aProperty , bProperty ) ) ; } a . side . condition . add ( a . side . find ( a . name ) ) ; b . side . condition . add ( b . side . find ( b . name ) ) ; return this ; } public JoinedModelBuilder add ( String columnName , String sourceProperty ) { if ( columnName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( sourceProperty == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Ref source = resolve ( sourceProperty ) ; columns . add ( columnName ) ; source . side . mapping . put ( source . name , columnName ) ; return this ; } @ Override public JoinedModelDescription toDescription ( ) { if ( left . condition . isEmpty ( ) ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , getReference ( ) ) ) ; } if ( columns . isEmpty ( ) ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , getReference ( ) ) ) ; } pairingTrivialSource ( left , right ) ; pairingTrivialSource ( right , left ) ; pairingSourceWithSameNamed ( left , right ) ; pairingSourceWithSameNamed ( right , left ) ; return new JoinedModelDescription ( getReference ( ) , buildProperties ( ) , left . condition , right . condition ) ; } private void pairingTrivialSource ( Side a , Side b ) { assert a !='}]","b; assert!a.condition.isEmpty(); assert!b.condition.isEmpty(); Ref aRef = a.find(a.name); Ref bRef = b.find(b.name); if (aRef.side == bRef.side) { a.condition.add(aRef); b.condition.add(bRef); } } private void pairingSourceWithSameNamed ( Side a, Side b ) { assert a!= b; assert!a.condition.isEmpty(); assert!b.condition.isEmpty(); Ref aRef = a.find ( a. name ) ; Ref bRef = b. find ( b. name ) ; if ( aRef. side == bRef. side ) { a. condition. add ( aRef ) ; b. condition. add ( bRef ) ; } } private Map < String, ModelProperty > buildProperties ( ) { Map < String, ModelProperty > properties = new TreeMap < String, ModelProperty > ( ) ; for ( Ref ref : getReferences ( ) ) { ModelProperty property = ref. side. mapping. get ( ref. name ) ; if ( property == null ) { throw new IllegalStateException ( MessageFormat. format ( ""<STR_LIT>"", ref. name ) ) ; } properties. put ( ref. name, property ) ; } return properties ;",0.0003706585591472274
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . Temp7 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw'}]",".runtime.io.ModelOutputFactory;public class Temp7ModelOutput implements ModelOutput<Temp7> { @Generated(""ModelGen"") public static Temp7ModelOutput create() { return new Temp7ModelOutput(); } @Override public void output(Temp7 bean) throws IOException {} @Override public Class<Temp7> getModelClass() { return Temp7.class; } @Override public ModelOutput<Temp7> setModelOutputFactory(ModelOutputFactory factory) { return this; } }",0.0001372965702397777
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . parser ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . core . IRubyModelMarker ; class IgnoreMarker { private IResource resource ; private int id ; private int offset ; private int endOffset ; IgnoreMarker ( IMarker marker ) throws CoreException { this . id = ( ( Integer ) marker . getAttribute ( IRubyModelMarker . ID ) ) . intValue ( ) ; this . offset = ( ( Integer ) marker . getAttribute ( IMarker . CHAR_START ) ) . intValue ( ) ; this . endOffset = ( ( Integer ) marker . getAttribute ( IMarker . CHAR_END ) ) . intValue ( ) ; this . resource = marker . getResource ( ) ; } public int getEndOffset ( ) { return endOffset ; } public int getOffset ( ) { return offset ; } public int getId ( ) { return id ; } public IResource getResource ( ) { return resource ; } IgnoreMarker ( IResource resource , int id , int offset , int endOffset ) { this . resource = resource ; this . id = id ; this . offset = offset ; this . endOffset = endOffset ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( obj instanceof IgnoreMarker ) { IgnoreMarker other = ( IgnoreMarker ) obj ; return other . getId ( ) == getId ( ) && other .'}]",getResource ( ). equals ( getResource ( ) ) && other. getOffset ( ) == getOffset ( ) && other. getEndOffset ( ) == getEndOffset ( ) ; } return false ; } @ Override public int hashCode ( ) { return getId ( ) + getResource ( ). hashCode ( ) + getOffset ( ) + getEndOffset ( ) ; } },0.00011854361279746023
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . lang ; public abstract class ScalarModel implements Model { @ Override public void visit ( ModelVisitor'}]",mv ) throws Exception { mv. visitScalar ( this ); } },3.392737120536345e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . search . FieldReferenceMatch ; import org . rubypeople . rdt . core . search . SearchMatch ; import org . rubypeople . rdt . core . search . SearchParticipant ; import org . rubypeople . rdt . core . search . SearchRequestor ; public class NewSearchResultCollector extends SearchRequestor { private RubySearchResult fSearch ; private boolean fIgnorePotentials ; public NewSearchResultCollector ( RubySearchResult search , boolean ignorePotentials ) { super ( ) ; fSearch = search ; fIgnorePotentials = ignorePotentials ; } public void acceptSearchMatch ( SearchMatch match ) throws CoreException { IRubyElement enclosingElement = ( IRubyElement ) match . getElement ( ) ; if ( enclosingElement != null ) { if ( fIgnorePotentials && ( match . getAccuracy ( ) == SearchMatch . A_INACCURATE ) ) return ; boolean isWriteAccess = false ; boolean isReadAccess = false ; if ( match instanceof FieldReferenceMatch ) { FieldReferenceMatch fieldRef = ( ( FieldReferenceMatch ) match ) ;'}]",isWriteAccess = fieldRef.isWriteAccess();isReadAccess = fieldRef.isReadAccess(); } //... rest of the code... } },5.755311985445844e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; public class RubyFieldElementInfo extends MemberElementInfo { protected String fieldName ; protected String typeName ; public String getName ( ) { return this . fieldName ; } public String getTypeName ( ) { return this . typeName ; } protected void'}]",init(RubyFieldElementInfo info) { this.fieldName = info.fieldName; this.typeName = info.typeName; },4.858169389853892e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package info . naturwerk . app ; public final class R { public static final class attr { } public static final class drawable { public static final int background = <NUM_LIT> ; public static final int ic_launcher = <NUM_LIT> ; public static final int naturweklogo = <NUM_LIT> ; } public static final class id { public static final int buttonCreateObservation = <NUM_LIT> ; public static final int buttonGetFoto = <NUM_LIT> ; public static final int detailTextFamily = <NUM_LIT> ; public static final int detailTextName = <NUM_LIT> ; public static final int detailTextNameDe = <NUM_LIT> ; public static final int detailTextOpt1 = <NUM_LIT> ; public static final int detailTextOpt2 = <NUM_LIT> ; public static final int imageViewFoto = <NUM_LIT> ; public static final int itemPrefs = <NUM_LIT> ; public static final int itemToggleService = <NUM_LIT> ; public static final int listCategory = <NUM_LIT> ; public static final int listFauna = <NUM_LIT> ; public static'}]",final int listObservation = <NUM_LIT> ; } public static final class layout { public static final int activity_create_observation = <NUM_LIT> ; public static final int activity_detail_observation = <NUM_LIT> ; public static final int activity_main = <NUM_LIT> ; public static final int activity_main_settings = <NUM_LIT> ; public static final int fragment_foto = <NUM_LIT> ; public static final int fragment_list_fauna = <NUM_LIT> ; public static final int fragment_list_observation = <NUM_LIT> ; public static final int fragment_list_settings = <NUM_LIT> ; } },0.00019419802414203066
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core ; import java . io . Closeable ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . runtime . core . context . SimulationSupport ; import com . asakusafw . windgate . core . process . ProcessProfile ; import com . asakusafw . windgate . core . process . ProcessProvider ; import com . asakusafw . windgate . core . resource . DriverRepository ; import com . asakusafw . windgate . core . resource . ResourceMirror ; import com . asakusafw . windgate . core . resource . ResourceProfile ; import com . asakusafw . windgate . core . resource . ResourceProvider ; import com . asakusafw . windgate . core . session . SessionMirror ; import com . asakusafw . windgate . core . session . SessionProfile ; import com . asakusafw . windgate . core . session . SessionProvider ; @ SimulationSupport public class GateTask implements Closeable { static final WindGateLogger WGLOG = new WindGateCoreLogger ( GateTask . class ) ; static final Logger LOG = LoggerFactory . getLogger ( GateTask . class ) ; private final ExecutorService executor ; private final SessionProvider sessionProvider ; private final List < ResourceProvider > resourceProviders ; private final Map < String , ProcessProvider > processProviders ; final GateProfile profile ; final GateScript script ; final String sessionId ; private final boolean createSession ; private final boolean completeSession ; private final ParameterList arguments ; public GateTask ( GateProfile profile , GateScript script , String sessionId , boolean createSession , boolean completeSession , ParameterList arguments ) throws IOException { if ( profile == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( sessionId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( arguments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . profile = profile ; this . script = script ; this . sessionId = sessionId ; this . createSession = createSession ; this . completeSession = completeSession ; this . arguments = arguments ; this . sessionProvider = loadSessionProvider ( profile . getSession ( ) ) ; this . resourceProviders = loadResourceProviders ( profile . getResources ( ) ) ; this . processProviders = loadProcessProviders ( profile . getProcesses ( ) ) ; this . executor = Executors . newFixedThreadPool ( profile . getCore ( ) . getMaxProcesses ( ) ) ; } private SessionProvider loadSessionProvider ( SessionProfile session ) throws IOException { assert session != null ; LOG . debug ( ""<STR_LIT>"" , session . getProviderClass ( ) . getName ( ) ) ; SessionProvider result = session . createProvider ( ) ; return result ; } private List < ResourceProvider > loadResourceProviders ( List < ResourceProfile > resources ) throws IOException { assert resources != null ; List < ResourceProvider > results = new ArrayList < ResourceProvider > ( ) ; for ( ResourceProfile resourceProfile : resources ) { LOG . debug ( ""<STR_LIT>"" , resourceProfile . getName ( ) , resourceProfile . getProviderClass ( ) . getName ( ) ) ; ResourceProvider provider = resourceProfile . createProvider ( ) ; results . add ( provider ) ; } return results ; } private Map < String , ProcessProvider > loadProcessProviders ( List < ProcessProfile > processes ) throws IOException { assert processes != null ; Map < String , ProcessProvider > results = new TreeMap < String , ProcessProvider > ( ) ; for ( ProcessProfile processProfile : processes ) { LOG . debug ( ""<STR_LIT>"" , processProfile . getName ( ) , processProfile . getProviderClass ( ) . getName ( ) ) ; assert results . containsKey ( processProfile . getName ( ) ) == false ; ProcessProvider provider = processProfile . createProvider ( ) ; results . put ( processProfile . getName ( ) , provider ) ; } return results ; } public void execute ( ) throws IOException , InterruptedException { WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; long start = System . currentTimeMillis ( ) ; try { WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; SessionMirror session = attachSession ( createSession ) ; try { WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; List < ResourceMirror > resources = createResources ( ) ; if ( createSession ) { WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; fireSessionCreated ( resources ) ; } WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; prepareResources ( resources ) ; WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; runGateProcesses ( resources ) ; if ( completeSession ) { WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; fireSessionCompleted ( resources ) ; WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; session . complete ( ) ; } } finally { try { session . close ( ) ; } catch ( IOException e ) { WGLOG . warn ( e , ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; } } WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) ) ; } finally { long end = System . currentTimeMillis ( ) ; WGLOG . info ( ""<STR_LIT>"" , sessionId , profile . getName ( ) , script . getName ( ) , end - start ) ; } } private SessionMirror attachSession ( boolean create ) throws IOException { if ( create ) { LOG . debug ( ""<STR_LIT>"" , sessionId ) ; if ( RuntimeContext . get ( ) . canExecute ( sessionProvider ) ) { return sessionProvider . create ( sessionId ) ; } else { return new SessionMirror . Null ( sessionId ) ; } } else { LOG . debug ( ""<STR_LIT>"" , sessionId ) ; if ( RuntimeContext . get ( ) . canExecute ( sessionProvider ) ) { return sessionProvider . open ( sessionId ) ; } else { return new SessionMirror . Null ( sessionId ) ; } } } private List < ResourceMirror > createResources ( ) throws IOException { List < ResourceMirror > results = new ArrayList < ResourceMirror > ( ) ; for ( ResourceProvider provider : resourceProviders ) { LOG . debug ( ""<STR_LIT>"" , provider . getClass ( ) . getName ( ) ) ; ResourceMirror resource = provider . create ( sessionId , arguments ) ; results . add ( resource ) ; } return results ; } private void fireSessionCreated ( List < ResourceMirror >'}]",resources) { if (sessionProvider instanceof SessionProvider) { ((SessionProvider) sessionProvider).fireSessionCreated(resources); } },8.057670323622322e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs . structural ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . Executor ; import javax . swing . SwingUtilities ; import javax . swing . event . TreeModelEvent ; import javax . swing . event . TreeModelListener ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . ConsoleCapture ; import org . oddjob . FailedToStopException ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . OddjobSessionFactory ; import org . oddjob . OurDirs ; import org . oddjob . StateSteps ; import org . oddjob . Stateful ; import org . oddjob . Structural ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ComponentTrinity ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; import org . oddjob . arooa . parsing . MockArooaContext ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . registry . BeanRegistry ; import org . oddjob . arooa . registry . ComponentPool ; import org . oddjob . arooa . registry . Path ; import org . oddjob . arooa . runtime . MockRuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeConfiguration ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . types . XMLConfigurationType ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . framework . SimpleJob ; import org . oddjob . monitor . context . ExplorerContext ; import org . oddjob . monitor . model . EventThreadLaterExecutor ; import org . oddjob . monitor . model . ExplorerContextFactory ; import org . oddjob . monitor . model . ExplorerModel ; import org . oddjob . monitor . model . JobTreeModel ; import org . oddjob . monitor . model . JobTreeNode ; import org . oddjob . monitor . model . MockExplorerContext ; import org . oddjob . monitor . model . MockExplorerModel ; import org . oddjob . persist . MockPersisterBase ; import org . oddjob . state . FlagState ; import org . oddjob . state . JobState ; import org . oddjob . state . ParentState ; import org . oddjob . state . StateEvent ; import org . oddjob . state . StateListener ; import org . oddjob . structural . StructuralEvent ; import org . oddjob . structural . StructuralListener ; public class ForEachJobTest extends TestCase { private static final Logger logger = Logger . getLogger ( ForEachJobTest . class ) ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; logger . info ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } public static class OurJob extends SimpleJob { Object stuff ; int index ; boolean ran ; @ Override protected int execute ( ) throws Throwable { ran = true ; return <NUM_LIT:0> ; } @ ArooaAttribute public void setStuff ( Object stuff ) { this . stuff = stuff ; } public void setIndex ( int index ) { this . index = index ; } @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + ""<STR_LIT>"" + index ; } } private class ChildCatcher implements StructuralListener { final List < Object > children = new ArrayList < Object > ( ) ; public void childAdded ( StructuralEvent event ) { children . add ( event . getIndex ( ) , event . getChild ( ) ) ; } public void childRemoved ( StructuralEvent event ) { children . remove ( event . getIndex ( ) ) ; } } public void testOneJobTwoValues ( ) throws ArooaParseException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + OurJob . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; ForEachJob test = new ForEachJob ( ) ; test . setArooaSession ( new OddjobSessionFactory ( ) . createSession ( ) ) ; test . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; test . setValues ( Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ChildCatcher children = new ChildCatcher ( ) ; test . addStructuralListener ( children ) ; test . run ( ) ; assertEquals ( ParentState . COMPLETE , test . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( <NUM_LIT:2> , children . children . size ( ) ) ; OurJob job1 = ( OurJob ) children . children . get ( <NUM_LIT:0> ) ; OurJob job2 = ( OurJob ) children . children . get ( <NUM_LIT:1> ) ; assertEquals ( ""<STR_LIT>"" , job1 . stuff ) ; assertEquals ( <NUM_LIT:0> , job1 . index ) ; assertTrue ( job1 . ran ) ; assertEquals ( ""<STR_LIT>"" , job2 . stuff ) ; assertEquals ( <NUM_LIT:1> , job2 . index ) ; assertTrue ( job2 . ran ) ; } public void testWithEmptyList ( ) { String xml = ""<STR_LIT>"" ; ForEachJob test = new ForEachJob ( ) ; test . setArooaSession ( new OddjobSessionFactory ( ) . createSession ( ) ) ; test . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; test . setValues ( Collections . emptyList ( ) ) ; StateSteps state = new StateSteps ( test ) ; state . startCheck ( ParentState . READY , ParentState . EXECUTING , ParentState . READY ) ; test . run ( ) ; state . checkNow ( ) ; } public void testLoadOnJobTwoValues ( ) throws ArooaParseException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + OurJob . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; ForEachJob test = new ForEachJob ( ) ; test . setArooaSession ( new OddjobSessionFactory ( ) . createSession ( ) ) ; test . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; test . setValues ( Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ChildCatcher children = new ChildCatcher ( ) ; test . addStructuralListener ( children ) ; assertTrue ( test . isLoadable ( ) ) ; test . load ( ) ; assertFalse ( test . isLoadable ( ) ) ; assertEquals ( <NUM_LIT:2> , children . children . size ( ) ) ; OurJob job1 = ( OurJob ) children . children . get ( <NUM_LIT:0> ) ; OurJob job2 = ( OurJob ) children . children . get ( <NUM_LIT:1> ) ; assertEquals ( ""<STR_LIT>"" , job1 . stuff ) ; assertEquals ( <NUM_LIT:0> , job1 . index ) ; assertFalse ( job1 . ran ) ; assertEquals ( ""<STR_LIT>"" , job2 . stuff ) ; assertEquals ( <NUM_LIT:1> , job2 . index ) ; assertFalse ( job2 . ran ) ; } public static class RegistryCheck extends SimpleJob { ArooaSession session ; protected int execute ( ) throws Throwable { session = getArooaSession ( ) ; return <NUM_LIT:0> ; } } private class OurContext extends MockArooaContext { ArooaSession session ; OurContext ( ArooaSession session ) { this . session = session ; } @ Override public ArooaSession getSession ( ) { return session ; } } public void testPseudoRegistry ( ) { String findMe = new String ( ""<STR_LIT>"" ) ; StandardArooaSession session = new StandardArooaSession ( ) ; session . getBeanRegistry ( ) . register ( ""<STR_LIT>"" , findMe ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + RegistryCheck . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; ForEachJob test = new ForEachJob ( ) ; test . setValues ( Arrays . asList ( ""<STR_LIT:one>"" ) ) ; test . setArooaSession ( session ) ; test . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; ComponentPool pool = session . getComponentPool ( ) ; pool . registerComponent ( new ComponentTrinity ( test , test , new OurContext ( session ) { @ Override public RuntimeConfiguration getRuntime ( ) { return new MockRuntimeConfiguration ( ) { @ Override public void configure ( ) { } } ; } } ) , ""<STR_LIT:test>"" ) ; test . run ( ) ; ChildCatcher child = new ChildCatcher ( ) ; test . addStructuralListener ( child ) ; RegistryCheck instance = ( RegistryCheck ) child . children . get ( <NUM_LIT:0> ) ; BeanRegistry crRecovered = instance . session . getBeanRegistry ( ) ; Object bean = crRecovered . lookup ( ""<STR_LIT:test>"" ) ; assertNotNull ( bean ) ; assertEquals ( ForEachJob . LocalBean . class , bean . getClass ( ) ) ; ForEachJob . LocalBean lb = ( ForEachJob . LocalBean ) bean ; int index = lb . getIndex ( ) ; assertEquals ( <NUM_LIT:0> , index ) ; String current = ( String ) lb . getCurrent ( ) ; assertEquals ( ""<STR_LIT:one>"" , current ) ; } public void testBasic ( ) throws ParseException { checks = new Object [ ] { new String ( ""<STR_LIT:hello>"" ) , DateHelper . parseDate ( ""<STR_LIT>"" ) , null , new File ( ""<STR_LIT>"" ) } ; executed = <NUM_LIT:0> ; Oddjob oj = new Oddjob ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oj . run ( ) ; Check check = ( Check ) new OddjobLookup ( oj ) . lookup ( ""<STR_LIT>"" ) ; assertNull ( check ) ; assertEquals ( <NUM_LIT:4> , executed ) ; oj . destroy ( ) ; } static Object [ ] checks ; static int executed ; public static class Check extends SimpleJob { Object o ; int i ; @ ArooaAttribute public void setObject ( Object o ) { this . o = o ; } public void setIndex ( int i ) { this . i = i ; } protected int execute ( ) { executed ++ ; logger . debug ( ""<STR_LIT>"" + o + ""<STR_LIT:]>"" ) ; assertEquals ( checks [ i ] , o ) ; return <NUM_LIT:0> ; } } public void testReset ( ) throws Exception { ChildCatcher childs = new ChildCatcher ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + FlagState . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; ForEachJob test = ( ForEachJob ) Helper . createComponentFromXml ( xml ) ; test . addStructuralListener ( childs ) ; test . run ( ) ; assertEquals ( JobState . COMPLETE , Helper . getJobState ( childs . children . get ( <NUM_LIT:0> ) ) ) ; assertEquals ( JobState . INCOMPLETE , Helper . getJobState ( childs . children . get ( <NUM_LIT:1> ) ) ) ; assertEquals ( JobState . READY , Helper . getJobState ( childs . children . get ( <NUM_LIT:2> ) ) ) ; assertEquals ( ParentState . INCOMPLETE , Helper . getJobState ( test ) ) ; test . softReset ( ) ; assertEquals ( JobState . COMPLETE , Helper . getJobState ( childs . children . get ( <NUM_LIT:0> ) ) ) ; assertEquals ( JobState . READY , Helper . getJobState ( childs . children . get ( <NUM_LIT:1> ) ) ) ; assertEquals ( JobState . READY , Helper . getJobState ( childs . children . get ( <NUM_LIT:2> ) ) ) ; assertEquals ( ParentState . READY , Helper . getJobState ( test ) ) ; test . run ( ) ; Stateful child1 = ( Stateful ) childs . children . get ( <NUM_LIT:0> ) ; Stateful child2 = ( Stateful ) childs . children . get ( <NUM_LIT:1> ) ; assertEquals ( JobState . COMPLETE , child1 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( JobState . INCOMPLETE , child2 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( ParentState . INCOMPLETE , test . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( <NUM_LIT:3> , test . getIndex ( ) ) ; test . hardReset ( ) ; assertEquals ( <NUM_LIT:0> , test . getIndex ( ) ) ; assertEquals ( JobState . DESTROYED , child1 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( JobState . DESTROYED , child2 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( <NUM_LIT:0> , childs . children . size ( ) ) ; test . run ( ) ; child1 = ( Stateful ) childs . children . get ( <NUM_LIT:0> ) ; child2 = ( Stateful ) childs . children . get ( <NUM_LIT:1> ) ; assertEquals ( JobState . COMPLETE , child1 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( JobState . INCOMPLETE , child2 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( ParentState . INCOMPLETE , test . lastStateEvent ( ) . getState ( ) ) ; test . destroy ( ) ; assertEquals ( <NUM_LIT:0> , childs . children . size ( ) ) ; assertEquals ( JobState . DESTROYED , child1 . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( JobState . DESTROYED , child2 . lastStateEvent ( ) . getState ( ) ) ; } public void testIdenticalIdInForEachConfig ( ) throws Exception { String config = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration'}]","(new XMLConfiguration(""<STR_LIT>"", config)); oddjob.run(); ForEachJob test = (ForEachJob) oddjob.lookup(""<STR_LIT>""); test.setValues(Arrays.asList(""<STR_LIT>"", ""<STR_LIT>"")); test.setConfiguration(new XMLConfiguration(""<STR_LIT>"", xml)); test.run(); JobTreeModel model = new JobTreeModel(); model.addJob(test); model.addJob(test); JobTreeNode node1 = model.getJobNode(test); JobTreeNode node2 = model.getJobNode(test); assertEquals(node1, node2); } public void testIdenticalIdInForEachConfigWithJobId ( ) throws Exception { String config = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""",0.000531858995920463
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import java . io . File ; import java . io . IOException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . OperationCanceledException ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . core . search . SearchParticipant ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . core . index . EntryResult ; import org . rubypeople . rdt . internal . core . index . Index ; import org . rubypeople . rdt . internal . core . search . IndexQueryRequestor ; import org . rubypeople . rdt . internal . core . search . RubySearchScope ; public abstract class InternalSearchPattern { IRubyElement focus ; int kind ; boolean mustResolve = true ; void acceptMatch ( String relativePath , String containerPath , SearchPattern pattern , IndexQueryRequestor requestor , SearchParticipant participant , IRubySearchScope scope ) { if ( scope instanceof RubySearchScope ) { String documentPath = documentPath ( containerPath , relativePath ) ; if ( ! requestor . acceptIndexMatch ( documentPath , pattern , participant ) ) throw new OperationCanceledException ( ) ; } else { String documentPath = documentPath ( containerPath , relativePath ) ; if ( scope . encloses ( documentPath ) ) if ( ! requestor . acceptIndexMatch ( documentPath , pattern , participant ) ) throw new OperationCanceledException ( ) ; } } SearchPattern currentPattern ( ) { return ( SearchPattern ) this ; } String documentPath ( String containerPath , String relativePath ) { String separator = ""<STR_LIT:/>"" ; StringBuffer buffer = new StringBuffer ( containerPath . length ( ) + separator . length ( ) + relativePath . length ( ) ) ; buffer . append ('}]",containerPath). append(separator). append(relativePath). toString(); return buffer.toString(); } },4.850075279165871e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import java . util . HashMap ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . ILocalVariable ; import org . rubypeople . rdt . internal . core . util . Util ; public class LocalVariable extends RubyField implements ILocalVariable { private int start ; private int end ; public LocalVariable ( RubyElement parent , String name , int start , int end ) { super ( parent , name ) ; } public int getElementType ( ) { return RubyElement . LOCAL_VARIABLE ; } protected Object createElementInfo ( ) { return null ; } public IResource getCorrespondingResource ( ) { return null ; } public int hashCode ( ) { return Util . combineHashCodes ( this . parent .'}]","hashCode ( ), this. name. hashCode ( ) ) ; } public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( )!= obj. getClass ( ) ) { return false ; } LocalVariable other = ( LocalVariable ) obj ; return this. parent. equals ( other. parent ) && this. name. equals ( other. name ) ; } }",0.00012947917844376264
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . wizards ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . wizards .'}]","IRubyWizard;public class NewRubyWizard extends Dialog { private IRubyWizard wizard; public NewRubyWizard(Shell shell) { super(shell, SWT.DIALOG_TRAY | SWT.APPLICATION_MODAL); setShellStyle(SWT.CLOSE | SWT.TITLE); PlatformUI.getWorkbench().getDialogSettings().put(IRubyHelpContextIds.NEW_RUBY_WIZARD_SETTINGS, true); } public NewRubyWizard(Shell shell, IRubyWizard wizard) { this(shell); this.wizard = wizard; } public void createControl(Composite parent) { super.createControl(parent); Control control = getShell(); GridLayout layout = new GridLayout(); control.setLayout(layout); layout.numColumns = 1; control.layout(); } public void doOK() throws CoreException { if (wizard!= null) { wizard.doOK(getShell()); } super.doOK(); } }",0.00024109476626999244
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . hibernate . stats ; import org . hibernate . stat . SecondLevelCacheStatistics ; public class CacheStatsWrapper { private final String cacheName ; private final SecondLevelCacheStatistics statistics ; public CacheStatsWrapper ( String cacheName , SecondLevelCacheStatistics statistics ) { this . cacheName = cacheName ; this . statistics = statistics ; } public long getHitCount ( ) {'}]",return statistics.getHitCount();,2.4040696699826848e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . collector ; import java . io . IOException ; import java . io . OutputStream ; import java . net . URI ; import java . net . URISyntaxException ; import java . text . MessageFormat ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . io . output . CountingOutputStream ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileStatus ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . FileUtil ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . Writable ; import org . apache . hadoop . mapreduce . lib . output . FileOutputCommitter ; import com . asakusafw . bulkloader . bean . ExportTargetTableBean ; import com . asakusafw . bulkloader . bean . ExporterBean ; import com . asakusafw . bulkloader . common . ConfigurationLoader ; import com . asakusafw . bulkloader . common . Constants ; import com . asakusafw . bulkloader . common . FileCompType ; import com . asakusafw . bulkloader . common . FileNameUtil ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; import com . asakusafw . bulkloader . transfer . FileList ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . TsvIoFactory ; import com . asakusafw . runtime . stage . temporary . TemporaryStorage ; public class ExportFileSend { static final Log LOG = new Log ( ExportFileSend . class ) ; Map < String , Integer > fileNameMap = new HashMap < String , Integer > ( ) ; public boolean sendExportFile ( ExporterBean bean , String user ) { String strCompType = ConfigurationLoader . getProperty ( Constants . PROP_KEY_EXP_FILE_COMP_TYPE ) ; FileCompType compType = FileCompType . find ( strCompType ) ; OutputStream output = getOutputStream ( ) ; try { FileList . Writer writer ; try { writer = FileList . createWriter ( output , compType == FileCompType . DEFLATED ) ; } catch ( IOException e ) { throw new BulkLoaderSystemException ( e , getClass ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } Configuration conf = new Configuration ( ) ; List < String > l = bean . getExportTargetTableList ( ) ; for ( String tableName : l ) { ExportTargetTableBean'}]","targetTableBean = bean.getTargetTableBean(tableName); URI uri = null; try { uri = new URI(targetTableBean.getExportUri()); } catch (URISyntaxException e) { throw new BulkLoaderSystemException(e, getClass(), ""<STR_LIT>"", ""<STR_LIT>""); } FileSystem fs = FileSystem.get(conf); Path path = new Path(uri); FileStatus status = fs.getFileStatus(path); if (!status.isDirectory()) { LOG.error(""Not a directory: {}"", path); return false; } Path dirPath = new Path(uri, fileNameMap.get(targetTableBean.getTableName())); try { fs.mkdirs(dirPath); } catch (IOException e) { throw new BulkLoaderSystemException(e, getClass(), ""<STR_LIT>"", ""<STR_LIT>""); } writer.write(targetTableBean.getTableName(), targetTableBean.getExportTableName(), targetTableBean.getExportFile(), targetTableBean.getExportDate()); } finally { writer.close(); } return true; } private OutputStream getOutputStream() { OutputStream output = null; try { output = new CountingOutputStream(new TemporaryStorage().getOutputStream()); } catch (IOException e) { throw new BulkLoaderSystemException(e, getClass(), ""<STR_LIT>"", ""<STR_LIT>""); } return output; } }",0.00036698588021068603
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . value ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import org . junit . Test ; @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class LongOptionTest extends ValueOptionTestRoot { @ Test public void init ( ) { LongOption option = new LongOption ( ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; } @ Test public void get ( ) { LongOption option = new LongOption ( ) ; option . modify ( <NUM_LIT:100> ) ; assertThat ( option . get ( ) , is ( <NUM_LIT> ) ) ; assertThat ( option . isNull ( ) , is ( false ) ) ; } @ Test public void or ( ) { LongOption option = new LongOption ( ) ; assertThat ( option . or ( <NUM_LIT:30> ) , is ( <NUM_LIT> ) ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; } @ Test public void orNotNull ( ) { LongOption option = new LongOption ( ) ; option . modify ( <NUM_LIT:100> ) ; assertThat ( option . or ( <NUM_LIT:30> ) , is ( <NUM_LIT> ) ) ; } @ Test public void copy ( ) { LongOption option = new LongOption ('}]","() ); LongOption copy = option.copy(); assertThat(copy.isNull(), is(false)); } @Test public void modify ( ) { LongOption option = new LongOption ( ) ; option. modify ( <NUM_LIT:100> ) ; assertThat ( option. get ( ), is ( <NUM_LIT> ) ) ; } @Test public void equals ( ) { LongOption option1 = new LongOption ( ) ; LongOption option2 = new LongOption ( ) ; option1. modify ( <NUM_LIT:100> ) ; option2. modify ( <NUM_LIT:100> ) ; assertThat ( option1. equals ( option2 ), is ( true ) ) ; } @Test public void hashCode ( ) { LongOption option = new LongOption ( ) ; option. modify ( <NUM_LIT:100> ) ; assertThat ( option. hashCode ( ), is ( <NUM_LIT> ) ) ; } @Test public void toString ( ) { LongOption option = new LongOption ( ) ; option. modify ( <NUM_LIT:100> ) ; assertThat ( option. toString ( ), is ( ""LongOption(value=100)"" ) ) ; } @Test public void equalsNull ( ) { LongOption",0.00034870179539825874
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . QualifiedName ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . IWorkbenchPropertyPage ; import org . eclipse . ui . dialogs . PropertyPage ; public class RubyExecutionArgumentsPage extends PropertyPage implements IWorkbenchPropertyPage { protected Text interpreterArgumentsText , programArgumentsText ; public RubyExecutionArgumentsPage ( ) { } protected Control createContents ( Composite parent ) { noDefaultAndApplyButton ( ) ; Composite composite = new Composite ( parent , SWT . NONE ) ;'}]","GridLayout layout = new GridLayout ( 2, true ) ; composite. setLayout ( layout ) ; new Label ( composite, SWT. LEFT ). setText ( ""Interpreter Arguments"" ) ; interpreterArgumentsText = new Text ( composite, SWT. BORDER | SWT. MULTI_LINE | SWT. READONLY ) ; new Label ( composite, SWT. LEFT ). setText ( ""Program Arguments"" ) ; programArgumentsText = new Text ( composite, SWT. BORDER | SWT. MULTI_LINE | SWT. READONLY ) ; return composite ; } }",0.00015890763054498937
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . entity . customerservice . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import fi . koku . services . entity . customerservice . model . CommunityRole ; import fi . koku . services . entity . community . v1 . CommunityType ; import fi . koku . services . entity . community . v1 . MemberType ; import fi . koku . services . entity . community . v1 . MembersType ; public class Family { private CommunityType community ; public Family ( ) { } public Family ( CommunityType community ) { this . community = community ; } public String getCommunityId ( ) { return community . getId ( ) ; } public String getCommunityType ( ) { return community . getType ( ) ; } public String getCommunityName ( ) { return community . getName'}]","( ) ; public MembersType getMembers ( ) { return community. getMembers ( ) ; } public void setCommunity ( CommunityType community ) { this. community = community ; } public void setMembers ( MembersType members ) { this. community. setMembers ( members ) ; } public String toString ( ) { return ""Family [community="" + community + "", members="" + community. getMembers ( ) + ""]"" ; } }",0.00013003580442559905
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . List ; public class SVDBTypeInfoUserDef extends SVDBTypeInfo { public SVDBParamValueAssignList fParamAssignList ; public SVDBLocation fEndLocation ; public List < ISVDBItemBase > fItems ; public SVDBTypeInfoUserDef ( ) { this ( ""<STR_LIT>"" ) ; } public SVDBTypeInfoUserDef ( String typename ) { this ( typename , SVDBItemType . TypeInfoUserDef ) ; } public SVDBTypeInfoUserDef ( String typename , SVDBItemType type ) { super ( typename , type ) ; } public SVDBLocation getEndLocation ( ) { return fEndLocation ; } public List < ISVDBItemBase > getItems ( ) { return fItems ; } public void setEndLocation ( SVDBLocation loc ) { } public SVDBParamValueAssignList getParameters ( ) { return fParamAssignList ; } public void setParameters ( SVDBParamValueAssignList params ) { fParamAssignList = params ; } public String toString ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( getName ( ) ) ; if ( fParamAssignList != null && fParamAssignList . getParameters ( ) . size ( ) > <NUM_LIT:0> ) { ret . append ( ""<STR_LIT>"" ) ; for ( SVDBParamValueAssign p : fParamAssignList . getParameters ( ) ) { if ( fParamAssignList . getIsNamedMapping ( ) ) { ret . append ( ""<STR_LIT:.>"" + p . getName ( ) + ""<STR_LIT:(>"" + p . getValue ( ) + ""<STR_LIT>"" ) ; } else { ret . append ( p . getValue ( ) + ""<STR_LIT:U+002CU+0020>"" ) ; } } ret . setLength ( ret'}]",".length() - 1); ret.append(""<STR_LIT>""); } return ret.toString(); }",4.8060985577221944e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . samples . petclinic . web ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . sun . syndication . feed . atom . Entry ; import com . sun . syndication . feed . atom . Feed ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import org . joda . time . LocalDate ; import org . junit . Before ; import org . junit . Test ; import org . springframework . samples . petclinic . Pet ; import org . springframework . samples . petclinic . PetType ; import org . springframework . samples . petclinic . Visit ; public class VisitsAtomViewTest { private VisitsAtomView visitView ; private Map < String , Object > model ; private Feed feed ; @ Before public void setUp ( ) { visitView = new VisitsAtomView ( ) ; PetType dog = new PetType ( ) ; dog . setName ( ""<STR_LIT>"" ) ; Pet bello = new Pet ( ) ; bello . setName ( ""<STR_LIT>"" ) ; bello . setType ( dog ) ;'}]","Visit visit = new Visit ( ) ; visit. setPet ( bello ) ; visit. setDate ( new Date ( ) ) ; model = new HashMap < String, Object > ( ) ; model. put ( ""petclinic:visits"", new ArrayList < Visit > ( ) ) ; (( ArrayList < Visit > ) model. get ( ""petclinic:visits"" ) ). add ( visit ) ; } @ Test public void testFeed ( ) { feed = visitView. createFeed ( model ) ; assertNotNull ( feed ) ; } @ Test public void testEntries ( ) throws Exception { feed = visitView. createFeed ( model ) ; assertNotNull ( feed ) ; assertEquals ( 1, feed. getEntries ( ). size ( ) ) ; Entry entry = feed. getEntries ( ). get ( 0 ) ; assertEquals ( ""http://localhost:8080/petclinic/visits/"" + entry. getId ( ), entry. getLink ( ). getHref ( ) ) ; } @ Test public void testEntry ( ) throws Exception { feed = visitView. createFeed ( model ) ; assertNotNull ( feed ) ; assertEquals ( 1, feed. getEntries ( ). size ( ) ) ; Entry entry =",0.0003532186010922079
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import junit . framework . TestCase ; import org . eclipse . jface . text . Document ; import org . eclipse . jface . text . rules . IToken ; import org . eclipse . jface . text . rules . Token ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . IRubyColorConstants ; import org . rubypeople . rdt . internal . ui . text . RubyColorManager ; public class TC_RubyTokenScanner extends TestCase { private RubyColoringTokenScanner fScanner ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; RubyColorManager colorManager = new RubyColorManager ( false ) ; fScanner = new RubyColoringTokenScanner ( colorManager , RubyPlugin . getDefault ( ) . getPreferenceStore ( ) ) { @ Override public Token getToken ( String key ) { return new Token ( key ) ; } } ; } private void setUpScanner ( String code ) { setUpScanner ( code , <NUM_LIT:0> , code . length ( ) ) ; } private void setUpScanner ( String code , int offset , int length ) { Document doc = new Document ( code ) ; fScanner . setRange ( doc , offset , length ) ; } private void assertToken ( String color , int offset , int length ) { IToken token = fScanner . nextToken ( ) ; assertEquals ( ""<STR_LIT>"" , offset , fScanner . getTokenOffset ( ) ) ; assertEquals ( ""<STR_LIT>"" , length , fScanner . getTokenLength ( ) ) ; assertEquals ( ""<STR_LIT>"" , color , token . getData ( ) ) ; } public void testSimpleClassDefinition ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_KEYWORD , <NUM_LIT:0> , <NUM_LIT:5> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:5> , <NUM_LIT:6> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:11> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_KEYWORD , <NUM_LIT:12> , <NUM_LIT:3> ) ; } public void testSymbolAtEndOfLine ( ) { String code = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:0> , <NUM_LIT:15> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT:15> , <NUM_LIT:2> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT> , <NUM_LIT:10> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_KEYWORD , <NUM_LIT> , <NUM_LIT:5> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT> , <NUM_LIT:7> ) ; } public void testSymbolInsideBrackets ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:0> , <NUM_LIT:4> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:4> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT:5> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT:6> , <NUM_LIT:5> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:11> , <NUM_LIT:1> ) ; } public void testSymbolInsideParentheses ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:0> , <NUM_LIT:6> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:6> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:7> , <NUM_LIT> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT> , <NUM_LIT:8> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:31> , <NUM_LIT:1> ) ; } public void testAliasWithTwoSymbols ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_KEYWORD , <NUM_LIT:0> , <NUM_LIT:5> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT:5> , <NUM_LIT:2> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT:7> , <NUM_LIT:16> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT> , <NUM_LIT:2> ) ; assertToken ( IRubyColorConstants . RUBY_SYMBOL , <NUM_LIT> , <NUM_LIT:8> ) ; } public void testSymbolInsideBracketsTwo ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants . RUBY_INSTANCE_VARIABLE , <NUM_LIT:0> , <NUM_LIT:11> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:11> , <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants . RUBY_DEFAULT , <NUM_LIT:12>'}]",", <NUM_LIT:1> ); } public void testSymbolInsideParenthesesTwo ( ) { String code = ""<STR_LIT>"" ; setUpScanner ( code ) ; assertToken ( IRubyColorConstants. RUBY_INSTANCE_VARIABLE, <NUM_LIT:0>, <NUM_LIT:8> ) ; assertToken ( IRubyColorConstants. RUBY_DEFAULT, <NUM_LIT:8>, <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants. RUBY_DEFAULT, <NUM_LIT:9>, <NUM_LIT> ) ; assertToken ( IRubyColorConstants. RUBY_DEFAULT, <NUM_LIT>, <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants. RUBY_SYMBOL, <NUM_LIT>, <NUM_LIT:1> ) ; assertToken ( IRubyColorConstants. RUBY_SYMBOL, <NUM_LIT>, <NUM_LIT:8> ) ; } }",0.000331312949142779
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . batch ; import com . asakusafw . vocabulary . batch . Batch ; import com . asakusafw . vocabulary . batch . BatchDescription ; import com . asakusafw . vocabulary . batch . Work ; @ Batch ( name = ""<STR_LIT>"" ) public class JoinBatch extends BatchDescription { @ Override protected void describe ( ) { Work first = run ( FirstJobFlow . class ) . soon ( ) ; Work second = run ( SecondJobFlow . class ) .'}]",soon ( ) ; Work third = run ( ThirdJobFlow. class ). soon ( ) ; first. join ( second ). join ( third ) ; } },5.918827641107247e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . directio . csv . driver ; import java . util . Arrays ; import java . util . Map ; import com . asakusafw . dmdl . Diagnostic ; import com . asakusafw . dmdl . Diagnostic . Level ; import com . asakusafw . dmdl . directio . csv . driver . CsvFieldTrait . Kind ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstAttributeElement ; import com . asakusafw . dmdl . model . BasicTypeKind ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . dmdl . semantics . Type ; import com . asakusafw . dmdl . semantics . type . BasicType ; import com . asakusafw . dmdl . spi . PropertyAttributeDriver ; import com . asakusafw . dmdl . util . AttributeUtil ; public class'}]","CsvFieldTraitAttributeDriver implements PropertyAttributeDriver<PropertyDeclaration> { @Override public void apply ( PropertyDeclaration target, AstAttribute attribute ) { Diagnostic. log ( Level. DEBUG, ""CsvFieldTraitAttributeDriver#apply: %s"", attribute ) ; if (! attribute. hasElement ( CsvFieldTrait. KIND ) ) { return ; } Kind kind = AttributeUtil. toEnum ( CsvFieldTrait. Kind. class, attribute. getElement ( CsvFieldTrait. KIND ) ) ; switch ( kind ) { case AUTO : target. setType ( BasicType. of ( BasicTypeKind. STRING ) ) ; break ; case FIXED_WIDTH : target. setProperty ( DmdlSemantics. FIXED_WIDTH ) ; break ; case DELIMITED : target. setProperty ( DmdlSemantics. DELIMITER ) ; break ; case HEADER : target. setProperty ( DmdlSemantics. HEADER ) ; break ; case QUOTE : target. setProperty ( DmdlSemantics. QUOTE ) ; break ; default : Arrays. asList ( kind. values ( ) ). stream ( ). filter ( k -> k!= kind ). map ( CsvFieldTrait. Kind :: valueOf ). forEach ( Diagnostic :: log ) ; } } }",0.00034828846430267875
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . nodes ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import com . hp . hpl . jena . graph . Node ; import de . fuberlin . wiwiss . d2rq . algebra . ColumnRenamer ; import de . fuberlin . wiwiss . d2rq . algebra . OrderSpec ; import de . fuberlin . wiwiss . d2rq . algebra . ProjectionSpec ; import de . fuberlin . wiwiss . d2rq . algebra . RelationalOperators ; import de . fuberlin . wiwiss . d2rq . sql . ResultRow ; public interface NodeMaker { static NodeMaker EMPTY = new NodeMaker ( ) { public boolean isUnique ( ) { return true ; } public Node makeNode ( ResultRow tuple ) { return null ; } public void describeSelf ( NodeSetFilter c ) { c . limitToEmptySet ( ) ; } public Set < ProjectionSpec > projectionSpecs ( ) {'}]",return Collections. emptySet ( ) ; } public OrderSpec orderSpec ( ) { return null ; } public void setOrderSpec ( OrderSpec orderSpec ) { } public boolean isUnique ( ) { return false ; } } public Node makeNode ( ResultRow tuple ) ; },9.249261565583883e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core . task ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . HashMap ; import java . util . Map ; import com . asakusafw . yaess . core . ExecutionContext ; import com . asakusafw . yaess . core . ExecutionScript ; import com . asakusafw . yaess . core . ExecutionScriptHandler ; public interface ExecutionTracker { String KEY_CLASS = ""<STR_LIT>"" ; String KEY_ID = ""<STR_LIT>"" ; void add ( Id id , Record record ) throws IOException , InterruptedException ; public class Record { public final ExecutionContext context ; public final ExecutionScript script ; public final ExecutionScriptHandler < ? > handler ;'}]","public Record(ExecutionContext context, ExecutionScript script, ExecutionScriptHandler<?> handler) { this.context = context; this.script = script; this.handler = handler; } }",6.108780456264678e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ti ; import java . util . LinkedList ; import java . util . List ; import org . jruby . parser . StaticScope ; public class Variable { private List < ITypeGuess > typeGuesses ; private Scope scope ; private String name ; private int count ; public Variable ( Scope scope , String name , int count ) { super ( ) ; this . count = count ; this . scope = scope ; this . name = name ; this . typeGuesses = new LinkedList < ITypeGuess > ( ) ; } public int getCount ( ) { return count ; } public void setCount ( int count ) { this . count = count ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Scope getScope ( ) { return scope ; } public void setScope ( Scope scope ) { this . scope = scope ; } public List < ITypeGuess > getTypeGuesses ( ) { return typeGuesses ; } public static void insertLocalsFromScopeNode'}]","(StaticScope scope, List<Variable> locals) { locals.addAll(scope.getLocals()); }",4.3582315782229586e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . io ; import java . io . IOException ; import com . asakusafw . compiler . fileio . model . ExSummarized ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class ExSummarizedOutput implements ModelOutput < ExSummarized > { private final RecordEmitter emitter ; public ExSummarizedOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( ExSummarized model ) throws IOException { emitter .'}]",emit(model);,2.279275735938231e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamelocal ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . Document ; import org . eclipse . text . edits . MalformedTreeException ; import org . eclipse . text . edits . TextEdit ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentProvider ; import org . rubypeople . rdt . refactoring . documentprovider . StringDocumentProvider ; public class LocalVariableRenamer { private final DocumentProvider doc ; private final String from ; private final String to ; public LocalVariableRenamer ( DocumentProvider doc , String from , String to ) { this . doc = doc ; this . from = from ; this . to = to ; } public TextEdit getEdit ( ) { RenameLocalConfig config = new RenameLocalConfig ( doc , <NUM_LIT:0> ) ; new RenameLocalConditionChecker ( config ) ; RenameLocalEditProvider editProvider = new RenameLocalEditProvider ( config'}]",", doc, from, to); return editProvider.getEdit(); } }",3.73737913689854e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . expr . eval ; import java . math . BigInteger ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBTypeInfoEnum ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import'}]",net.sf.sveditor.core.db.index.SVDBIndexIterator;,3.5133249578293366e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . util ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . fail ; import java . io . IOException ; import org . junit . Test ; public class ExceptionActionTest { @ Test public void testNoException ( ) { final String result = Util . execute ( new ExceptionAction < String > ( ) { @ Override public String doAction ( ) throws IOException { return ""<STR_LIT:hello>"" ; } } ) ; assertEquals ( ""<STR_LIT:hello>"" , result'}]","); } @Test public void testIOException ( ) { try { final String result = Util.execute(new ExceptionAction<String>() { @Override public String doAction() throws IOException { throw new IOException(""<STR_LIT:hello>""); } }); fail(""Expected IOException""); } catch (IOException e) { assertEquals(""<STR_LIT:hello>"", e.getMessage()); } } @Test public void testOtherException ( ) { try { final String result = Util.execute(new ExceptionAction<String>() { @Override public String doAction() throws Exception { throw new Exception(""<STR_LIT:hello>""); } }); fail(""Expected Exception""); } catch (Exception e) { assertEquals(""<STR_LIT:hello>"", e.getMessage()); } } }",0.00020161282884036732
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . io . File ; public class SVDBFile extends SVDBScopeItem { public String fFile ; public SVDBFile ( ) { super ( ""<STR_LIT>"" , SVDBItemType . File ) ; fFile = ""<STR_LIT>"" ; } public SVDBFile ( String'}]","filePath) { super(filePath, SVDBItemType.File); fFile = filePath; } }",3.8446320227578874e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . persistence ; import java . io . DataInput ; import java . io . DataOutput ; import java . util . Set ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; public interface ISVDBPersistenceRWDelegate { void init ( ISVDBPersistenceRWDelegateParent parent , DataInput in , DataOutput'}]",out ) throws Exception ; void readChildItems ( Set < ISVDBChildItem > childItems ) ; void readItemBase ( ISVDBItemBase itemBase ) ; void readItem ( ISVDBItemBase itemBase ) ; void readItemChildren ( ISVDBItemBase itemBase ) ; void readItemData ( ISVDBItemBase itemBase ) ; void readItemMetadata ( ISVDBItemBase itemBase ) ; void readItemName ( ISVDBItemBase itemBase ) ; void readItemType ( ISVDBItemBase itemBase ) ; void writeItemBase ( ISVDBItemBase itemBase ) ; void writeItem ( ISVDBItemBase itemBase ) ; void writeItemChildren ( ISVDBItemBase itemBase ) ; void writeItemData ( ISVDBItemBase itemBase ) ; void writeItemMetadata ( ISVDBItemBase itemBase ) ; void writeItemName ( ISVDBItemBase itemBase ) ; void writeItemType ( ISVDBItemBase itemBase ) ; },0.00029035226525477644
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . map ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . Resource ; import de . fuberlin . wiwiss . d2rq . D2RQException ; import de . fuberlin . wiwiss . d2rq . pp . PrettyPrinter ; public abstract class MapObject { private Resource resource ; public MapObject ( Resource resource ) { this . resource = resource ; } public Resource resource ( ) { return this . resource ; } public abstract void validate ( ) throws D2RQException ; public String toString ( ) { return PrettyPrinter . toString ( this . resource ) ; } protected void assertNotYetDefined ( Object object , Property property , int errorCode ) { if ( object == null ) { return ; }'}]","Object value = object.getProperty(property); if (value == null) { throw new D2RQException(""Not yet defined: "" + object + "" "" + property + "" "" + errorCode); }",7.184140563294256e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . mergewithexternalclassparts . conditionchecks ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . mergewithexternalclassparts . ExternalClassPartsMerger ; import org . rubypeople . rdt . refactoring . core . mergewithexternalclassparts . MergeWithExternalClassPartConfig ; import org . rubypeople . rdt . refactoring . core . mergewithexternalclassparts . MergeWithExternalClassPartsConditionChecker ; import org . rubypeople . rdt . refactoring . tests . MultiFileTestData ; import org . rubypeople . rdt . refactoring . tests . RefactoringConditionTestCase ; public class MergeWithExternalConditionTester extends RefactoringConditionTestCase { private MergeWithExternalClassPartConfig config ; public MergeWithExternalConditionTester ( String fileName ) { super ( fileName ) ; } @ Override'}]","protected void setUp() throws FileNotFoundException, IOException { super.setUp(); config = new MergeWithExternalClassPartConfig(getTestData()); }",5.1682930685775325e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import java . text . MessageFormat ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrLocation ; public class MissingJavadocBlockParserException extends JavadocParseException { private static final long serialVersionUID = <NUM_LIT:1L> ; private final String tagName ; public MissingJavadocBlockParserException ( String tagName , IrLocation location , Throwable cause ) { super ( buildMessage ( tagName ) , location , cause ) ; this . tagName = tagName ; }'}]","private static MessageFormat buildMessageFormat = MessageFormat. getInstance ( ""{0}: Missing javadoc block for tag '{1}'"" ) ; private static String buildMessage ( String tagName ) { return buildMessageFormat. format ( new Object [] { ""Missing javadoc block"", tagName } ) ; }",9.794852284625581e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package edsdk ; import com . sun . jna . NativeLong ; import com . sun . jna . Structure ; public class EdsSize extends Structure { public NativeLong width ; public NativeLong height ; public EdsSize ( ) { super ( ) ; initFieldOrder ( ) ; } protected void initFieldOrder ( ) { setFieldOrder ( new java . lang . String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public EdsSize ( NativeLong width , NativeLong height ) { super ( ) ; this . width = width ; this . height = height ; initFieldOrder ( ) ; }'}]",},1.9632089464166054e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . formatter ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import org . rubypeople . rdt . core . formatter . CodeFormatter ; import org . xml . sax . SAXException ; public class TC_CodeFormatter extends AbstractCodeFormatterTestCase { public TC_CodeFormatter ( String name ) throws SAXException , IOException , ParserConfigurationException , FactoryConfigurationError { super ( name ) ; } protected'}]","void setUp() throws IOException, SAXException, ParserConfigurationException, FactoryConfigurationError { CodeFormatter formatter = new CodeFormatter(); // add your setup code here }",5.791206694176561e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . stream ; import java . io . IOException ; import java . io . OutputStream ; public final class CountingOutputStream extends OutputStream { private final OutputStream stream ; private long count ; public CountingOutputStream ( OutputStream stream ) { if ( stream == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . stream = stream ; } public long getCount ( ) { return count ; } @ Override public void write ( int b ) throws IOException { count += <NUM_LIT:1> ;'}]",stream.write(b);,2.222573430672919e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . docs . model ; import java . io . IOException ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import net . sf . sveditor . core . log . ILogLevel ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; public class SymbolTable { private LogHandle fLog ; private Map < String , SymbolTableEntry > fSymbolTable ; public SymbolTable ( ) { fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; fSymbolTable = new HashMap < String , SymbolTableEntry > ( ) ; } public void addSymbol ( SymbolTableEntry symbol ) { if ( fSymbolTable . containsKey ( symbol . getSymbol ( ) ) ) { fLog . error ( String . format ( ""<STR_LIT>"" , symbol . getSymbol ( ) ) ) ; } else { fSymbolTable . put ( symbol . getSymbol ( ) , symbol ) ; } } public Set < String > getSymbolSet ( ) { return fSymbolTable . keySet ( ) ; } public void dumpSymbols ( ) { fLog . debug ( ILogLevel . LEVEL_MID , ""<STR_LIT>"" ) ; fLog . debug ( ILogLevel . LEVEL_MID , ""<STR_LIT>"" ) ; fLog . debug ( ILogLevel . LEVEL_MID , ""<STR_LIT>"" ) ; List < String > sortedSymbols = new ArrayList < String > ( getSymbolSet ( ) ) ; Collections . sort ( sortedSymbols , String . CASE_INSENSITIVE_ORDER ) ; for ( String symbol : sortedSymbols ) { fLog . debug ( ILogLevel . LEVEL_MID , ""<STR_LIT>"" + symbol ) ; } fLog . debug ( ILogLevel . LEVEL_MID , ""<STR_LIT>"" ) ; } public void dumpSymbolsToFile ( Writer writer ) throws IOException { writer . write ( ""<STR_LIT>"" ) ; writer . write ( ""<STR_LIT>"" ) ; writer . write ( ""<STR_LIT>"" ) ; List < String > sortedSymbols = new ArrayList < String > ( getSymbolSet ( ) ) ; Collections . sort ( sortedSymbols , String . CASE_INSENSITIVE_ORDER ) ; for ( String symbol : sortedSymbols ) { writer . write ( String . format ( ""<STR_LIT>"" , symbol ) ) ; writer . write ( String . format ( ""<STR_LIT>"" , fSymbolTable . get ( symbol ) . isDocumented ( ) ) ) ; writer . write ( String . format ( ""<STR_LIT>"" , fSymbolTable . get ( symbol ) . getTopicType ( ) ) ) ; writer . write ( String . format ( ""<STR_LIT>"" , fSymbolTable . get ( symbol ) . getSymbolType ( ) ) ) ; } writer . write ( ""<STR_LIT>"" ) ; } public SymbolTableEntry getSymbol ( String symbol ) { return fSymbolTable . get ( symbol ) ; } public boolean symbolIsValid ( String symbol ) { return fSymbolTable . containsKey ( symbol ) ; } public SymbolTableEntry resolveSymbol ( DocTopic docTopic , String symbol ) { fLog . debug ( ILogLevel .'}]","LEVEL_MID, ""<STR_LIT>"" + docTopic.getTopicId()); return fSymbolTable.get(symbol); } }",6.204677110919856e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renamefield . conditionchecks ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . renamefield . FieldRenamer ; import org . rubypeople . rdt . refactoring . core . renamefield . RenameFieldConditionChecker ; import org . rubypeople . rdt .'}]",refactoring.core.renamefield.FieldRenamer.FieldRenamerBuilder;,3.2317677752267654e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . operation . IRunnableContext ; import org . eclipse . search . ui . ISearchQuery ; import org . eclipse . search . ui . NewSearchUI ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . PlatformUI ; import org . osgi . framework . Bundle ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; public class SearchUtil { public static final int LRU_WORKINGSET_LIST_SIZE = <NUM_LIT:3> ; private static LRUWorkingSetsList fgLRUWorkingSets ; private static final String DIALOG_SETTINGS_KEY = ""<STR_LIT>"" ; private static final String STORE_LRU_WORKING_SET_NAMES = ""<STR_LIT>"" ; public static boolean isSearchPlugInActivated ( ) { return Platform . getBundle ( ""<STR_LIT>"" ) . getState ( ) == Bundle . ACTIVE ; } public static void runQueryInBackground ( Object query ) { NewSearchUI . runQueryInBackground ( ( ISearchQuery ) query ) ; } public static IStatus runQueryInForeground ( IRunnableContext context , Object query ) { return NewSearchUI . runQueryInForeground ( context , ( ISearchQuery ) query ) ; } static IRubyScript findCompilationUnit ( IRubyElement element ) { if'}]",(element instanceof IRubyScript) return (IRubyScript) element; if (element instanceof IRubyElement) { IRubyScript script = ((IRubyElement) element).getScript(); return script; } return null; },8.413174759705953e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui'}]",import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.Timer;,3.9475367084064186e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . values . properties ; import java . io . IOException ; import java . util . Map ; import java . util . Properties ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . OurDirs ; import org . oddjob . Resetable ; import org . oddjob . Stateful ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . framework . SimpleJob ; import org . oddjob . persist . MapPersister ; import org . oddjob . state . JobState ; public class PropertiesJobTest extends TestCase { private static final Logger logger = Logger . getLogger ( PropertiesJobTest . class ) ; @ Override protected void setUp ( ) throws Exception { logger . info ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } public void testSimpleSetGet ( ) throws Exception { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . run ( ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; assertEquals ( ""<STR_LIT>"" , lookup . lookup ( ""<STR_LIT>"" , String . class ) ) ; Resetable properties = lookup . lookup ( ""<STR_LIT:test>"" , Resetable . class ) ; properties . hardReset ( ) ; assertEquals ( ""<STR_LIT>"" , lookup . lookup ( ""<STR_LIT>"" , String . class ) ) ; assertEquals ( null , lookup . lookup ( ""<STR_LIT>"" ) ) ; oddjob . destroy ( ) ; } public void testPropertiesFromValues ( ) throws Exception { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . run ( ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; assertEquals ( ""<STR_LIT>"" , lookup . lookup ( ""<STR_LIT>"" , String . class ) ) ; oddjob . destroy ( ) ; } public void testSetFromInput ( ) throws Exception { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . run ( ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; assertEquals ( ""<STR_LIT>"" , lookup . lookup ( ""<STR_LIT>"" , String . class ) ) ; oddjob . destroy ( ) ; } public static class MyComp extends SimpleJob { Properties props ; public void setProps ( Properties props ) { this . props = props ; } @ Override protected int execute ( ) throws Throwable { return <NUM_LIT:0> ; } } public void testSetPropertiesFromFile ( ) { OurDirs dirs = new OurDirs ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dirs . base ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + MyComp . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . run ( ) ; MyComp myComp = ( MyComp ) new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" ) ; assertNotNull ( myComp ) ; assertEquals ( ""<STR_LIT:test>"" , myComp . props . get ( ""<STR_LIT>"" ) ) ; } public void testSetFromPrevious ( ) { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + MyComp . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . run ( ) ; MyComp myComp = ( MyComp ) new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" ) ; assertNotNull ( myComp ) ; assertEquals ( ""<STR_LIT>"" , myComp . props . get ( ""<STR_LIT>"" ) ) ; } public void testSettingSelfFromPrevious ( ) throws ArooaConversionException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" +'}]","MyComp.class.getName() + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>""; Oddjob oddjob = new Oddjob(); oddjob.setConfiguration(new XMLConfiguration(""<STR_LIT>"", xml)); oddjob.run(); MyComp myComp = (MyComp) new OddjobLookup(oddjob).lookup(""<STR_LIT>""); myComp.setProps(myComp.props); myComp.execute(); } }",0.00021550907617111977
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . inlineclass ; import org . eclipse . osgi . util . NLS ;'}]",import org.eclipse.jdt.core.dom.AST; import org.eclipse.jdt.core.dom.ASTNode; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.IField; import org.eclipse.jdt.core.dom.IMethod; import org.eclipse.jdt.core.dom.IType; import org.eclipse.jdt.core.dom.IVariable; import org.eclipse.jdt.core.dom.Node; import org.eclipse.jdt.core.dom.NodeList; import org.eclipse.jdt.core.dom.StructuredDocument; import org.eclipse.jdt.core.dom.StructuredDocumentRegion; import org.eclipse.jdt.core.dom.StructuredDocumentScanner; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerContext; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResult; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResultScannerResult; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResultScannerResultScannerResult; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResultScannerResultScannerResultScannerResultScannerResult; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResultScannerResultScannerResultScannerResultScannerResultScannerResultScannerResult; import org.eclipse.jdt.core.dom.StructuredDocumentScannerScannerResultScannerResultScannerResultScannerResultScanner,0.00033690090952073564
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; public class SVDBTask extends SVDBScopeItem implements IFieldItemAttr { public List < SVDBParamPortDecl > fParams ; public int fAttr ; public SVDBTask ( ) { super ( ""<STR_LIT>"" , SVDBItemType . Task ) ; } public SVDBTask ( String name , SVDBItemType type ) { super ( name , type ) ; fParams = new ArrayList < SVDBParamPortDecl > ( ) ; } public void setAttr ( int attr ) { fAttr ='}]",attr; } public void addParam ( SVDBParamPortDecl param ) { if ( fParams == null ) { fParams = new ArrayList < SVDBParamPortDecl > ( ) ; } fParams. add ( param ) ; } },8.196153224430331e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . preferences ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTableViewer ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; import org . rubypeople . rdt . internal . debug . ui . RdtDebugUiMessages ; import org . rubypeople . rdt . internal . debug . ui . rubyvms . AddVMDialog ; import org . rubypeople . rdt . internal . debug . ui . rubyvms . IAddVMDialogRequestor ; import org . rubypeople . rdt . internal . debug . ui . rubyvms . RubyVMMessages ; import org . rubypeople . rdt . internal . debug . ui . rubyvms . RubyVMsUpdater ; import org . rubypeople . rdt . internal . ui . util . CollectionContentProvider ; import org . rubypeople . rdt . launching . IVMInstall ; import org . rubypeople . rdt . launching . IVMInstallType ; import org . rubypeople . rdt . launching . RubyRuntime ; import org . rubypeople . rdt . launching . VMStandin ; public class RubyInterpreterPreferencePage extends PreferencePage implements IWorkbenchPreferencePage , IAddVMDialogRequestor { private List < IVMInstall > fVMs = new ArrayList < IVMInstall > ( ) ; protected CheckboxTableViewer fVMList ; protected Button addButton , editButton , removeButton ; public RubyInterpreterPreferencePage ( ) { super ( ) ; setTitle ( RubyVMMessages . JREsPreferencePage_1 ) ; setDescription ( RubyVMMessages . JREsPreferencePage_2 ) ; } public void init ( IWorkbench workbench ) { } protected Control createContents ( Composite parent ) { noDefaultAndApplyButton ( ) ; Composite composite = createPageRoot ( parent ) ; Label tableLabel = new Label ( composite , SWT . NONE ) ; tableLabel . setText ( RubyVMMessages . InstalledJREsBlock_15 ) ; GridData data = new GridData ( ) ; data . horizontalSpan = <NUM_LIT:2> ;'}]","2; tableLabel.setLayoutData(data); fVMList = CheckboxTableViewer.newCheckList(composite, SWT.BORDER | SWT.V_SCROLL); fVMList.setContentProvider(new CollectionContentProvider()); fVMList.addCheckSelectionChangedListener(new ICheckStateListener() { public void checkStateChanged(CheckStateChangedEvent event) { if (event.getChecked() && event.getElement() instanceof IVMInstall) { IVMInstall vm = (IVMInstall) event.getElement(); vm.addInstallListener(new IVMInstallListener() { public void installRemoved(IVMInstall install) { fVMList.remove(install); } }); } } }); fVMList.addSelectionChangedListener(new ISelectionChangedListener() { public void selectionChanged(SelectionChangedEvent event) { IStructuredSelection selection = event.getStructuredSelection(); if (selection!= null && selection.size() == 1 && selection.getFirstElement() instanceof IVMInstall) { IVMInstall vm = (IVMInstall) selection.getFirstElement(); if (addButton!= null && addButton.isEnabled()) { addButton.setEnabled(false); } if (editButton!= null && editButton.isEnabled()) { editButton.setEnabled(false); } if (removeButton!= null && removeButton.isEnabled()) { removeButton.setEnabled(false); } } } }); Grid",0.00037665986397219197
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . bulkloader ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . ResultSet ; import java . sql . Statement ; import java . util . List ; import org . junit . Rule ; import org . junit . Test ; public class H2ResourceTest { @ Rule public H2Resource h2 = new H2Resource ( ""<STR_LIT:test>"" ) { @ Override protected void before ( ) throws Exception { execute ( ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:)>"" ) ; } } ; @ Test public void execute_resource ( ) throws Exception { h2 . execute ( ""<STR_LIT>"" ) ; List < List < Object > > results = h2 . query ( ""<STR_LIT>"" ) ; assertThat ( results . size ( ) , is ( <NUM_LIT:1> ) ) ; List < Object > columns = results . get ( <NUM_LIT:0> ) ; assertThat ( columns . size ( ) , is ( <NUM_LIT:2> ) ) ;'}]","assertThat(columns.get(<NUM_LIT:0>), is(""<STR_LIT>""));",4.248894470325368e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import'}]","org. eclipse. debug. internal. ui. messages. Messages ; import org. eclipse. ui. jobs. UIJob ; import org. eclipse. ui. views. IViewPart ; public class RDTDebugUIActivator extends DebugUIPlugin { public static final String PLUGIN_ID = ""org.rubypeople.rdt.internal.debug.ui"" ; public static final String RDT_DEBUG_VIEW_ID = ""org.rubypeople.rdt.internal.debug.ui.rdtDebugView"" ; public RDTDebugUIActivator ( ) { super ( ) ; } @ Override public void start ( IProgressMonitor monitor ) throws Exception { super. start ( monitor ) ; registerPlugin ( ) ; } @ Override public void stop ( IProgressMonitor monitor ) throws Exception { super. stop ( monitor ) ; } private void registerPlugin ( ) { // register the RDT debug view getPluginRegistry ( ). registerPlugin ( RDT_DEBUG_VIEW_ID, RDTDebugView. class ) ; } public static void showRDTDebugView ( IViewPart view ) { Messages. showInformationMessage ( view, ""RDT Debug View"", ""Select a process to debug"" ) ; } public static void showRDTDebugView ( ) { Messages. showInformation",0.0003415253518548913
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . index . cache ; import junit . framework . Test ; import junit . framework . TestSuite ; public class'}]","CacheTest extends TestCase { public CacheTest ( String testName ) { super ( testName ) ; } public static Test suite ( ) { return new TestSuite ( new String [] { ""net.sf.sveditor.core.tests.index.cache.CacheTest"" } ) ; } public static void main ( String [] args ) { junit. textui. TestRunner. run ( suite ( ), args ) ; } }",0.00011749090123853634
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renamemethod . selection ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . Collection ; import org . eclipse . jface . text . BadLocationException ; import org . jruby . ast . SymbolNode ; import org . rubypeople . rdt . refactoring . core .'}]","RenameMethodSelectionTest; public class RenameMethodSelectionTest extends AbstractRenameMethodSelectionTest { @Override protected void renameMethod ( String sourcePath, String destinationPath, String methodName, Collection<SymbolNode> expectedNodes ) throws FileNotFoundException, IOException, BadLocationException { super. renameMethod ( sourcePath, destinationPath, methodName, expectedNodes ) ; } }",0.00010854616840733155
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . logging . log4j ; import java . util . HashMap ; import java . util . Map ; import junit . framework . TestCase ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; import org . apache . log4j . SimpleLayout ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . cache . MockLogArchiverCache ; public class ArchiveAppenderTest extends TestCase { private static final Logger logger = Logger . getLogger ( ArchiveAppenderTest . class ) ; private class OurArchiver extends MockLogArchiverCache { Map < LogLevel , String > messages = new HashMap < LogLevel , String > ( ) ; @ Override public void addEvent ( String archive , LogLevel level , String message ) { assertEquals ( ArchiveAppenderTest . class . getName ( ) , archive ) ; messages . put ( level , message ) ; } @ Override public boolean hasArchive ( String archive ) { assertEquals ( ArchiveAppenderTest . class . getName ( ) , archive ) ; return true ; } } public void testAppender ( ) { OurArchiver archiver = new OurArchiver ( ) ; ArchiveAppender test ='}]","new ArchiveAppender ( archiver ) ; logger. setLevel ( Level. DEBUG ) ; logger. info ( ""test"" ) ; logger. warn ( ""test"" ) ; logger. error ( ""test"" ) ; logger. debug ( ""test"" ) ; assertEquals ( archiver. messages. get ( LogLevel. INFO ), ""test"" ) ; assertEquals ( archiver. messages. get ( LogLevel. WARN ), ""test"" ) ; assertEquals ( archiver. messages. get ( LogLevel. ERROR ), ""test"" ) ; assertEquals ( archiver. messages. get ( LogLevel. DEBUG ), ""test"" ) ; } }",0.00019105071704347967
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . model ; import org . oddjob . logging . ConsoleArchiver ; import org . oddjob . logging . LogArchiver ; import org . oddjob . monitor . context . ContextInitialiser ; import org . oddjob . monitor . context . ExplorerContext ; public class LogContextInialiser implements ContextInitialiser { public static String LOG_ARCHIVER = ""<STR_LIT>"" ; public static String CONSOLE_ARCHIVER = ""<STR_LIT>"" ; private final ExplorerModel explorerModel ; public LogContextInialiser ( ExplorerModel explorerModel ) { this . explorerModel = explorerModel ; } public void initialise ( ExplorerContext context ) { LogArchiver logArchiver ; ConsoleArchiver consoleArchiver ; ExplorerContext parent = context . getParent ( ) ; if ( parent == null ) { logArchiver = explorerModel . getLogArchiver ( ) ; consoleArchiver = explorerModel . getConsoleArchiver ( ) ; } else { if ( parent . getThisComponent ( ) instanceof LogArchiver ) { logArchiver = ( ( LogArchiver ) parent . getThisComponent ( ) ) ; } else { logArchiver = ( LogArchiver ) parent . getValue ( LOG_ARCHIVER ) ; } if ( parent . getThisComponent ( ) instanceof ConsoleArchiver ) { consoleArchiver'}]",= ( ( ConsoleArchiver ) parent. getThisComponent ( ) ) ; } else { consoleArchiver = ( ConsoleArchiver ) parent. getValue ( CONSOLE_ARCHIVER ) ; } } context. setLogArchiver ( logArchiver ) ; context. setConsoleArchiver ( consoleArchiver ) ; } },0.00010469965076216348
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . elements . schedule ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignParser ; import org . oddjob . arooa . design . view . ViewMainHelper ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . schedules . schedules . YearlySchedule ; import org . oddjob'}]",".schedules.Schedules;public class ScheduleDesignParserTest extends TestCase { public ScheduleDesignParserTest ( String name ) { super ( name ) ; } public void testParseSchedule ( ) throws ArooaParseException { Logger logger = Logger.getLogger ( ScheduleDesignParserTest. class ) ; StandardArooaSession session = new StandardArooaSession ( new XMLConfiguration ( ""schedule.xml"" ), logger ) ; DesignParser parser = new DesignParser ( new OddjobDescriptorFactory ( ), new ViewMainHelper ( ) ) ; ArooaDescriptor descriptor = parser.parse ( session ) ; DesignInstance design = ( DesignInstance ) descriptor ; Schedules schedules = design. getSchedules ( ) ; YearlySchedule yearlySchedule = ( YearlySchedule ) schedules. getSchedule ( ""yearly"" ) ; } }",0.0002252208688173976
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . windgate ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import org . junit . Test ; import com . asakusafw . windgate . core . DriverScript ; import com . asakusafw . windgate . core . vocabulary . DataModelStreamSupport ; import com . asakusafw . windgate . core . vocabulary . FileProcess ; import com . asakusafw . windgate . core . vocabulary . StreamProcess ; public class FsImporterDescriptionTest { @ Test public void simple ( ) { Mock desc = new Mock ( ""<STR_LIT>"" , StringSupport . class ) ; DriverScript script = desc . getDriverScript ( ) ; assertThat ( script . getResourceName ( ) , is ( Constants . LOCAL_FILE_RESOURCE_NAME ) ) ; assertThat ( script . getConfiguration ( ) . get ( FileProcess . FILE . key ( ) ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( script . getConfiguration ( ) . get ( StreamProcess . STREAM_SUPPORT . key ( ) ) , is ( StringSupport . class . getName ( ) ) ) ; } @ Test ( expected = IllegalStateException . class ) public void invalid_path_null ( ) { Mock desc = new Mock ( null , StringSupport . class ) ; desc . getDriverScript ( ) ; } @ Test ( expected = IllegalStateException . class ) public void invalid_path_empty ( ) { Mock desc = new Mock ( ""<STR_LIT>"" , StringSupport . class ) ; desc . getDriverScript ( ) ; } @ Test ( expected = IllegalStateException . class ) public void invalid_support_null ( ) { Mock desc = new Mock ( ""<STR_LIT>"" , null ) ; desc . getDriverScript ( ) ; } @ Test ( expected = IllegalStateException . class ) public void invalid_support_inconsistent ( ) { Mock desc = new Mock ( ""<STR_LIT>"" , VoidSupport . class ) ; desc . getDriverScript ( ) ; }'}]","@Test public void invalid_support_inconsistent_classname ( ) { Mock desc = new Mock ( ""<STR_LIT>"", ""com.asakusafw.vocabulary.windgate.StringSupport"" ) ; desc. getDriverScript ( ) ; }",8.608844572026962e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . typehierarchy ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . IMenuCreator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; public class HistoryDropDownAction extends Action implements IMenuCreator { public static class ClearHistoryAction extends Action { private TypeHierarchyViewPart fView ; public ClearHistoryAction ( TypeHierarchyViewPart view ) { super ( TypeHierarchyMessages . HistoryDropDownAction_clearhistory_label ) ; fView = view ; } public void run ( ) { fView . setHistoryEntries ( new IRubyElement [ <NUM_LIT:0> ] ) ; fView . setInputElement ( null ) ; } } public static final int RESULTS_IN_DROP_DOWN = <NUM_LIT:10> ; private TypeHierarchyViewPart fHierarchyView ; private Menu fMenu ; public HistoryDropDownAction ( TypeHierarchyViewPart view ) { fHierarchyView = view ; fMenu = null ; setToolTipText ( TypeHierarchyMessages . HistoryDropDownAction_tooltip ) ; RubyPluginImages . setLocalImageDescriptors ( this , ""<STR_LIT>"" ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IRubyHelpContextIds . TYPEHIERARCHY_HISTORY_ACTION ) ; setMenuCreator ( this ) ; } public void dispose ( ) { if ( fMenu != null ) { fMenu . dispose ( ) ; fMenu = null ; } } public Menu getMenu ( Menu parent ) { return null ; } public Menu getMenu ( Control parent ) { if ( fMenu != null ) { fMenu . dispose ( ) ; } fMenu'}]","= new Menu(parent, SWT.DROP_DOWN); return fMenu; } public void run ( ) { if ( fMenu == null ) { fMenu = new Menu ( PlatformUI. getWorkbench ( ). getActiveShell ( ), SWT. DROP_DOWN ) ; } fMenu. removeAll ( ) ; if ( fHierarchyView == null ) { return ; } final int historySize = fHierarchyView. getHistoryEntries ( ). length ; if ( historySize > RESULTS_IN_DROP_DOWN ) { fMenu. add ( new MenuItem ( fMenu, SWT. SEPARATOR ) ) ; } for ( int i = historySize - 1 ; i >= 0 ; i -- ) { final IRubyElement entry = fHierarchyView. getHistoryEntries ( ) [ i ] ; final MenuItem item = new MenuItem ( fMenu, SWT. RADIO ) ; item. setText ( entry. toString ( ) ) ; item. setData ( entry ) ; if ( i == 0 ) { item. setSelection ( true ) ; } } fMenu. add ( new ClearHistoryAction ( fHierarchyView ) ) ; PlatformUI. getWorkbench ( ). getActiveShell ( ). setMenuBar ( fMenu ) ; } }",0.0003601008330547475
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . view ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design . screem . StandardForm ; import org . oddjob . arooa . design . screem . TextPseudoForm ;'}]",import org.odjob.designer.view.DesignerForm;,2.91028217458358e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . java . emitter . driver ; import java . util . List ; import com . asakusafw . dmdl . java . emitter . EmitContext ; import com . asakusafw . dmdl . java . spi . JavaDataModelDriver ; import com . asakusafw . dmdl . semantics .'}]","JavaDataModel;public class JavaEmitterDriver implements JavaDataModelDriver<JavaDataModel> { @Override public List<JavaDataModel> emit(List<JavaDataModel> dataModels, EmitContext context) { // implementation } }",7.462649171278992e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages . encapsulatefield ; import org .'}]",rubypeople.rdt.refactoring.ui.pages.encapsulatefield.EncapsulateFieldWizardPage;,4.03387402842686e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . action ; import org . rubypeople . rdt . refactoring . core . mergewithexternalclassparts . MergeWithExternalClassPartsRefactoring ; public class MergeClassPartsAction extends WorkbenchWindowActionDelegate { @ Override public void'}]",run(WorkbenchWindow window) { new MergeWithExternalClassPartsRefactoring().execute(); } },4.2588793261951724e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . cleaner . common ; import com . asakusafw . cleaner . exception . CleanerSystemException ; import com . asakusafw . cleaner . log . Log ; import com . asakusafw . cleaner . log . LogInitializer ; public final class CleanerInitializer { private CleanerInitializer ( ) { return ; } public static boolean initLocalFileCleaner ( String [ ] properties ) { return initialize ( properties , true , false ) ; } public static boolean initDFSCleaner ( String [ ] properties ) { return initialize ( properties , false , true ) ; } private static boolean initialize ( String [ ] properties , boolean doLocalCleanPropCheck , boolean doDFSCleanPropCheck ) { try { ConfigurationLoader . init ( properties , doLocalCleanPropCheck , doDFSCleanPropCheck ) ; } catch ( CleanerSystemException e ) { if ( initLog ( ) ) { Log . log ( e . getCause ( ) , e . getClazz ( ) , e . getMessageId ( ) , e . getMessageArgs ( ) ) ; return false ; } else { printPropLoadError ( properties , e ) ; return false ; } } catch ( Exception e ) { printPropLoadError ( properties , e ) ; return false ; } if ( ! initLog ( ) ) { return false ; } return true ; } private static boolean initLog ( ) { String logConfFilePath = null ; try { logConfFilePath = ConfigurationLoader . getProperty ( Constants . PROP_KEY_LOG_CONF_PATH ) ; LogInitializer'}]",".init(logConfFilePath); } catch (Exception e) { printPropLoadError(new String[]{Constants.PROP_KEY_LOG_CONF_PATH}, e); return false; } return true; } private static void printPropLoadError(String[] properties, Exception e) { LogInitializer.init(); Log.log(e.getCause(), e.getClazz(), Log.MessageId.ERROR, Log.MessageArgs.of(""Failed to load properties"", e.getMessage())); } }",0.00013426454961145448
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . sparql . vocabulary . FOAF ; import com . hp . hpl . jena . vocabulary . DC ; import com . hp . hpl . jena . vocabulary . DCTerms ; import com . hp . hpl . jena . vocabulary . RDF ; import com . hp . hpl . jena . vocabulary . RDFS ; import de . fuberlin . wiwiss . d2rq . algebra . Relation ; import de . fuberlin . wiwiss . d2rq . algebra . RelationalOperators ; import de . fuberlin . wiwiss . d2rq . algebra . TripleRelation ; import de . fuberlin . wiwiss . d2rq . find . FindQuery ; import de . fuberlin . wiwiss . d2rq . find . TripleQueryIter ; import de . fuberlin . wiwiss . d2rq . map . Mapping ; import de . fuberlin . wiwiss . d2rq . nodes . FixedNodeMaker ; import de . fuberlin . wiwiss . d2rq . nodes . NodeMaker ; import de . fuberlin . wiwiss . d2rq . vocab . SKOS ; public class ClassMapLister { private static final Log log = LogFactory . getLog ( ClassMapLister . class ) ; private final Mapping mapping ; private Map < String , List < TripleRelation > > classMapInventoryBridges = new HashMap < String , List < TripleRelation > > ( ) ; private Map < String , NodeMaker > classMapNodeMakers = new HashMap < String , NodeMaker > ( ) ; public ClassMapLister ( Mapping mapping ) { this . mapping = mapping ; groupTripleRelationsByClassMap ( ) ; } private void groupTripleRelationsByClassMap ( ) { if ( ! classMapInventoryBridges . isEmpty ( ) || ! classMapNodeMakers . isEmpty ( ) ) return ; for ( Resource classMapResource : mapping . classMapResources ( ) ) { NodeMaker resourceMaker = this . mapping . classMap ( classMapResource ) . nodeMaker ( ) ; Node classMap = classMapResource . asNode ( ) ; this . classMapNodeMakers . put ( toClassMapName ( classMap ) , resourceMaker ) ; List < TripleRelation > inventoryBridges = new ArrayList < TripleRelation > ( ) ; for ( TripleRelation bridge : mapping . classMap ( classMapResource ) . compiledPropertyBridges ( ) ) { bridge = bridge . orderBy ( TripleRelation . SUBJECT , true ) ; if ( bridge . selectTriple ( new Triple ( Node . ANY , RDF . Nodes . type , Node . ANY ) ) != null ) { inventoryBridges . add ( bridge ) ; } if ( bridge . selectTriple ( new Triple ( Node . ANY , RDFS . label . asNode ( ) , Node . ANY ) ) != null ) { inventoryBridges . add ( bridge ) ; } else if ( bridge . selectTriple ( new Triple ( Node . ANY , SKOS . prefLabel . asNode ( ) , Node . ANY ) ) != null ) { inventoryBridges . add ( bridge ) ; } else if ( bridge . selectTriple ( new Triple ( Node . ANY , DC . title . asNode ( ) , Node . ANY ) ) != null ) { inventoryBridges . add ( bridge ) ; } else if ( bridge . selectTriple ( new Triple ( Node . ANY , DCTerms . title . asNode ( ) , Node . ANY ) ) !='}]","!= null) { inventoryBridges.add(bridge); } } this.classMapInventoryBridges.put(toClassMapName(classMap), inventoryBridges); } } private String toClassMapName(Node classMap) { return classMap.toString(); } }",0.0001026057614275322
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . analyzer . driver ; import com . asakusafw . dmdl . model . AstBasicType ; import com . asakusafw . dmdl . model . AstType ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . type . BasicType ; import com . asakusafw .'}]","dmdl. semantics. type. Type ; import com. asakusafw. dmdl. analyzer. driver. DmdlAnalyzerDriver ; import com. asakusafw. dmdl. analyzer. driver. DmdlAnalyzerDriverFactory ; import com. asakusafw. dmdl. analyzer. driver. DmdlAnalyzerException ; import com. asakusafw. dmdl. analyzer. driver. DmdlDriverOptions ; public class DmdlAnalyzerDriverFactory { public static DmdlAnalyzerDriver createAnalyzerDriver ( DmdlSemantics semantics, DmdlDriverOptions options ) throws DmdlAnalyzerException { return new DmdlAnalyzerDriver ( semantics, options ) ; } }",0.0001964924428218647
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . basic ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . Assume ; import org . junit . Test ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . runtime . core . context . RuntimeContext . ExecutionMode ; import com . asakusafw . yaess . core . CommandScript ; import com . asakusafw . yaess . core . CommandScriptHandler ; import com . asakusafw . yaess . core . ExecutionContext ; import com . asakusafw . yaess . core . ExecutionMonitor ; import com . asakusafw . yaess . core . ExecutionPhase ; import com . asakusafw . yaess . core . ProfileContext ; import com . asakusafw . yaess . core . ServiceProfile ; public class BasicCommandScriptHandlerTest extends BasicScriptHandlerTestRoot { @ Test public void simple ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( shell . getAbsolutePath ( ) , ""<STR_LIT>"" ) , map ( ) ) ; CommandScriptHandler handler = handler ( ) ; execute ( script , handler ) ; List < String > results = getOutput ( shell ) ; assertThat ( results , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; } @ Test public void multiple_arguments ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( shell . getAbsolutePath ( ) , ""<STR_LIT:A>"" , ""<STR_LIT:B>"" , ""<STR_LIT:C>"" , ""<STR_LIT:D>"" ) , map ( ) ) ; CommandScriptHandler handler = handler ( ) ; execute ( script , handler ) ; List < String > results = getOutput ( shell ) ; assertThat ( results , is ( Arrays . asList ( ""<STR_LIT:A>"" , ""<STR_LIT:B>"" , ""<STR_LIT:C>"" , ""<STR_LIT:D>"" ) ) ) ; } @ Test public void with_prefix ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( ""<STR_LIT>"" ) , map ( ) ) ; CommandScriptHandler handler = handler ( ""<STR_LIT>"" , shell . getAbsolutePath ( ) ) ; execute ( script , handler ) ; List < String > results = getOutput ( shell ) ; assertThat ( results , is ( Arrays . asList ( ""<STR_LIT>"" ) ) ) ; } @ Test public void complex_prefix ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( ""<STR_LIT:A>"" , ""<STR_LIT:B>"" , ""<STR_LIT:C>"" ) , map ( ) ) ; CommandScriptHandler handler = handler ( ""<STR_LIT>"" , shell . getAbsolutePath ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; execute ( script , handler ) ; List < String > results = getOutput ( shell ) ; assertThat ( results , is ( Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT:A>"" , ""<STR_LIT:B>"" , ""<STR_LIT:C>"" ) ) ) ; } @ Test public void environment ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( shell . getAbsolutePath ( ) ) , map ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; CommandScriptHandler handler = handler ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; execute ( script , handler ) ; List < String > results = getOutput ( shell ) ; assertThat ( results , hasItem ( equalToIgnoringWhiteSpace ( ""<STR_LIT>"" ) ) ) ; assertThat ( results , hasItem ( equalToIgnoringWhiteSpace ( ""<STR_LIT>"" ) ) ) ; assertThat ( results , hasItem ( equalToIgnoringWhiteSpace ( ""<STR_LIT>"" ) ) ) ; } @ Test public void runtime_context ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( shell . getAbsolutePath ( ) ) , map ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; CommandScriptHandler handler = handler ( ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; RuntimeContext rc'}]","= new RuntimeContext(); rc.setExecutionMode(ExecutionMode.NORMAL); ExecutionContext ec = new ExecutionContext(); ec.setProfileContext(new ProfileContext()); ec.setServiceProfile(new ServiceProfile()); ec.setExecutionMonitor(new ExecutionMonitor()); script.setExecutionContext(ec); execute(script, handler); } @Test public void profile_context ( ) throws Exception { File shell = putScript ( ""<STR_LIT>"", ""<STR_LIT>"" ) ; CommandScript script = new CommandScript ( ""<STR_LIT>"", set ( ), ""<STR_LIT>"", ""<STR_LIT>"", Arrays. asList ( shell. getAbsolutePath ( ) ), map ( ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"" ) ) ; CommandScriptHandler handler = handler ( ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"", ""<STR_LIT>"" ) ; ProfileContext pc = new ProfileContext ( ) ; pc. set ( ""<STR_LIT>"", ""<STR_LIT>"" ) ; ExecutionContext ec = new ExecutionContext ( ) ; ec. setProfileContext ( pc ) ; ec. setExecutionMonitor ( new ExecutionMonitor ( ) ) ; script. setExecutionContext ( ec ) ; execute ( script",0.00040181329050720927
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . eclipse . shams . resources ; import java . io . ByteArrayInputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . net . URI ; import java . nio . charset . Charset ; import junit . framework . Assert ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IFileState ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IProjectDescription ; import org . eclipse . core . resources . IResourceVisitor ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . ResourceAttributes ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . QualifiedName ; import org . eclipse . core . runtime . content . IContentDescription ; import org . eclipse . core . runtime . content . IContentType ; public class ShamFile extends ShamResource implements IFile { public static final String WORKSPACE_ROOT = ""<STR_LIT>"" ; protected String contents = ""<STR_LIT>"" ; protected boolean readContentFromFile ; private InputStream inputStream ; private IProject project ; public void setCharset ( String newCharset , IProgressMonitor monitor ) throws CoreException { } public ShamFile ( String fullPath ) { this ( fullPath , false ) ; } public ShamFile ( IPath aPath ) { this ( aPath , false ) ; } public String getCharset ( ) throws CoreException { return Charset . defaultCharset ( ) . name ( ) ; } public ShamFile ( String fullPath , boolean readContentFromFile ) { this ( new Path ( fullPath ) , readContentFromFile ) ; } public ShamFile ( IPath aPath , boolean readContentFromFile ) { super ( aPath ) ; this . readContentFromFile = readContentFromFile ; project = new ShamProject ( ""<STR_LIT>"" ) ; } public void appendContents ( InputStream source , boolean force , boolean keepHistory , IProgressMonitor monitor ) throws CoreException { } public void appendContents ( InputStream source , int updateFlags , IProgressMonitor monitor ) throws CoreException { } public void create ( InputStream source , boolean force , IProgressMonitor monitor ) throws CoreException { } public void create ( InputStream source , int updateFlags , IProgressMonitor monitor ) throws CoreException { } public void delete ( boolean force , boolean keepHistory , IProgressMonitor monitor ) throws CoreException { } public InputStream getContents ( ) throws CoreException { if ( readContentFromFile ) { try { return openStream ( new FileInputStream ( this . path . toString ( ) ) ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e . toString ( ) ) ; } } return openStream ( new ByteArrayInputStream ( contents . getBytes ( ) ) ) ; } private InputStream openStream ( InputStream newStream ) { Assert . assertNull ( ""<STR_LIT>"" , inputStream ) ; inputStream = new MonitoredInputStream ( newStream ) ; return inputStream ; } public void assertContentStreamClosed ( ) { Assert . assertNull ( ""<STR_LIT>"" , inputStream ) ; } public InputStream getContents ( boolean force ) throws CoreException { return getContents ( ) ; } public int getEncoding ( ) throws CoreException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IFileState [ ] getHistory ( IProgressMonitor monitor ) throws CoreException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isReadOnly ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public void move ( IPath destination , boolean force , boolean keepHistory , IProgressMonitor monitor ) throws CoreException { } public void setContents ( InputStream source , boolean force , boolean keepHistory , IProgressMonitor monitor ) throws CoreException { } public void setContents ( IFileState source , boolean force , boolean keepHistory , IProgressMonitor monitor ) throws CoreException { } public void setContents ( InputStream source , int updateFlags , IProgressMonitor monitor ) throws CoreException { } public void setContents ( IFileState source , int updateFlags , IProgressMonitor monitor ) throws CoreException { } public void setContents ( String shamContents ) { this . contents = shamContents ; } public void accept ( IResourceVisitor visitor ) throws CoreException { } public void accept ( IResourceVisitor visitor , int depth , boolean includePhantoms ) throws CoreException { } public void accept ( IResourceVisitor visitor , int depth , int memberFlags ) throws CoreException { } public void clearHistory ( IProgressMonitor monitor ) throws CoreException { } public void copy ( IProjectDescription description , boolean force , IProgressMonitor monitor ) throws CoreException { } public void copy ( IPath destination , boolean force , IProgressMonitor monitor ) { } public void copy ( IProjectDescription description , int updateFlags , IProgressMonitor monitor ) throws CoreException { }'}]",private IPath getProjectPath() { return project.getFullPath(); },5.251559957890785e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import org . oddjob . images . StateIcons ; import org . oddjob . state . StateEvent ; abstract public class SerializableJob extends SimpleJob implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public SerializableJob ( ) { completeConstruction ( ) ; } private void completeConstruction ( ) { } private void writeObject ( ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; s . writeObject ( getName ( ) ) ; if ( loggerName ( ) . startsWith ( getClass ( ) . getName ( ) ) ) { s . writeObject ( null ) ; } else { s . writeObject ( loggerName ( ) ) ; } s . writeObject ( stateHandler . lastStateEvent ( ) ) ; } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject'}]",( ) ; name = ( String ) s. readObject ( ) ; loggerName = s. readObject ( ) ; stateHandler. lastStateEvent = ( StateEvent ) s. readObject ( ) ; } },7.572034744494658e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . driver ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . lang . reflect . Method ; import org . junit . Before ; import org . junit . Test ; import com . asakusafw . dmdl . thundergate . GeneratorTesterRoot ; import com . asakusafw . vocabulary . bulkloader . OriginalName ; public class OriginalNameEmitterTest extends GeneratorTesterRoot { @ Before public void setUp ( ) throws Exception { emitDrivers . add ( new OriginalNameEmitter ( ) ) ; } @ Test public void explicit ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; Class < ? > type = loaded . modelType ( ""<STR_LIT>"" ) ; assertThat ( type . isAnnotationPresent ( OriginalName . class ) , is ( true ) ) ; assertThat ( type . getAnnotation ( OriginalName . class ) . value ( ) , is ( ""<STR_LIT>"" ) ) ; Method method = type . getMethod ( ""<STR_LIT>"" ) ; assertThat ( method . isAnnotationPresent ( OriginalName . class ) , is'}]","( true ) ) ; assertThat ( method. getAnnotation ( OriginalName. class ). value ( ), is ( ""<STR_LIT>"" ) ) ; } @ Test public void implicit ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; Class <? > type = loaded. modelType ( ""<STR_LIT>"" ) ; assertThat ( type. isAnnotationPresent ( OriginalName. class ), is ( true ) ) ; assertThat ( type. getAnnotation ( OriginalName. class ). value ( ), is ( ""<STR_LIT>"" ) ) ; } }",0.00017641682384662955
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . dnd ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . util . TransferDragSourceListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface'}]",".viewers.ISelectionChangedListener; public class DnDSelectionManager implements TransferDragSourceListener, ISelectionChangedListener { private final IStructuredSelection selection; public DnDSelectionManager(IStructuredSelection selection) { Assert.isNotNull(selection); this.selection = selection; } @Override public void dragStarted() { } @Override public void dragFinished() { } @Override public void dragOver() { } @Override public void dragDropped(TransferDropTargetEvent event) { } @Override public void dragGestureRecognized(DragSourceEvent event) { } @Override public void selectionChanged(ISelectionChangedEvent event) { selection.selectAll(); } }",0.0001873787967411229
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . indexing ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . search . SearchParticipant ; import org . rubypeople . rdt . internal . compiler . util . SimpleLookupTable ; import org . rubypeople . rdt . internal . core . RubyModelManager ; import org . rubypeople . rdt . internal . core . index . Index ; import org . rubypeople . rdt . internal . core . search . BasicSearchEngine ; import org . rubypeople . rdt . internal . core . search . ERBSearchDocument ; import org . rubypeople . rdt . internal . core . search . RubySearchDocument ; import org . rubypeople . rdt . internal . core . search . processing . JobManager ; import org . rubypeople . rdt . internal . core . util . Util ; public class AddExternalFolderToIndex extends IndexRequest { public AddExternalFolderToIndex ( IPath containerPath , IndexManager manager ) { super ( containerPath , manager ) ; } public boolean execute ( IProgressMonitor progressMonitor ) { if ( this . isCancelled || progressMonitor != null && progressMonitor . isCanceled ( ) ) return true ; try { Index index = this . manager . getIndexForUpdate ( this . containerPath , false , false ) ; if ( index != null ) { if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + this . containerPath ) ; return true ; } index = this . manager . getIndexForUpdate ( this . containerPath , true , true ) ; if ( index == null ) { if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + this . containerPath ) ; return true ; } ReadWriteMonitor monitor = index . monitor ; if ( monitor == null ) { if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + this . containerPath + ""<STR_LIT>"" ) ; return true ; } File file = null ; try { monitor . enterWrite ( ) ; if ( RubyModelManager . ZIP_ACCESS_VERBOSE ) System . out . println ( ""<STR_LIT:(>"" + Thread . currentThread ( ) + ""<STR_LIT>"" + this . containerPath ) ; file = this . containerPath . toFile ( ) ; if ( this . isCancelled ) { if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + file . getName ( ) + ""<STR_LIT>"" ) ; return false ; } if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + file . getName ( ) ) ; long initialTime = System . currentTimeMillis ( ) ; String [ ] paths = index . queryDocumentNames ( ""<STR_LIT>"" ) ; if ( paths != null ) { int max = paths . length ; String EXISTS = ""<STR_LIT:OK>"" ; String DELETED = ""<STR_LIT>"" ; SimpleLookupTable indexedFileNames = new SimpleLookupTable ( max == <NUM_LIT:0> ? <NUM_LIT> : max + <NUM_LIT:11> ) ; for ( int i = <NUM_LIT:0> ; i < max ; i ++ ) indexedFileNames . put ( paths [ i ] , DELETED ) ; addDirectorysChildren ( file , EXISTS , indexedFileNames ) ; boolean needToReindex = indexedFileNames . elementSize != max ; if ( ! needToReindex ) { Object [ ] valueTable = indexedFileNames . valueTable ; for ( int i = <NUM_LIT:0> , l = valueTable . length ; i < l ; i ++ ) { if ( valueTable [ i ] == DELETED ) { needToReindex = true ; break ; } } if ( ! needToReindex ) { if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + file . getName ( ) + ""<STR_LIT:U+0020(>"" + ( System . currentTimeMillis ( ) - initialTime ) + ""<STR_LIT>"" ) ; this . manager . saveIndex ( index ) ; return true ; } } } SearchParticipant participant = BasicSearchEngine . getDefaultSearchParticipant ( ) ; index = manager . recreateIndex ( this . containerPath ) ; if ( index == null ) { manager . removeIndex ( this . containerPath ) ; return false ; } if ( ! indexFiles ( index , file , participant ) ) return false ; this . manager . saveIndex ( index ) ; if ( JobManager . VERBOSE ) org . rubypeople . rdt . internal . core . util . Util . verbose ( ""<STR_LIT>"" + file . getName ( ) + ""<STR_LIT:U+0020(>"" + ( System . currentTimeMillis ( ) - initialTime ) + ""<STR_LIT>"" ) ; } finally { monitor . exitWrite ( ) ; } } catch ( IOException e ) {'}]","if ( JobManager.VERBOSE) org.rubypeople.rdt.internal.core.util.Util.verbose(""<STR_LIT>"" + e.getMessage() + ""<STR_LIT>""); return false; } finally { monitor.exitWrite(); } } catch (FileNotFoundException e) { if (JobManager.VERBOSE) org.rubypeople.rdt.internal.core.util.Util.verbose(""<STR_LIT>"" + e.getMessage() + ""<STR_LIT>""); return false; }",0.000161991345630476
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . browsing ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . viewers . DecoratingLabelProvider ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . part . IShowInTargetList ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . actions . SelectAllAction ; import org . rubypeople . rdt . internal . ui . filters . NonRubyElementFilter ; import org . rubypeople . rdt . internal . ui . viewsupport . AppearanceAwareLabelProvider ; import org . rubypeople . rdt . internal . ui . viewsupport . RubyUILabelProvider ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . RubyElementLabels ; import org . rubypeople . rdt . ui . RubyUI ; public class TypesView extends RubyBrowsingPart { private SelectAllAction fSelectAllAction ; private boolean fLastInputWasProject ; protected RubyUILabelProvider createLabelProvider ( ) { return new AppearanceAwareLabelProvider ( AppearanceAwareLabelProvider . DEFAULT_TEXTFLAGS | RubyElementLabels . T_CATEGORY | RubyElementLabels . T_NAME_FULLY_QUALIFIED , AppearanceAwareLabelProvider . DEFAULT_IMAGEFLAGS ) ; } public Object getAdapter ( Class key ) { if ( key == IShowInTargetList . class ) { return new IShowInTargetList ( ) { public String [ ] getShowInTargetIds ( ) { return new String [ ] { RubyUI . ID_RUBY_EXPLORER , IPageLayout . ID_RES_NAV } ; } } ; } return super . getAdapter ( key ) ; } protected void addFilters ( ) { super . addFilters ( ) ; getViewer ( ) . addFilter ( new NonRubyElementFilter ( ) ) ; } protected boolean isValidInput ( Object element ) { if ( element instanceof IRubyProject || ( element instanceof ISourceFolderRoot && ( ( IRubyElement ) element ) . getElementName ( ) != ISourceFolderRoot . DEFAULT_PACKAGEROOT_PATH ) ) try { IRubyProject jProject = ( ( IRubyElement ) element ) . getRubyProject ( ) ; if ( jProject != null ) return jProject . getProject ( ) . hasNature ( RubyCore . NATURE_ID ) ; } catch ( CoreException ex ) { return false ; } return false ; } @ Override protected IContentProvider createContentProvider ( ) { return new TypesContentProvider ( this ) ; } protected boolean isValidElement ( Object element ) { if ( element instanceof IRubyScript ) return super . isValidElement ( ( ( IRubyScript ) element ) . getParent ( ) ) ; else if ( element instanceof IType ) { IType type = ( IType ) element ; return isValidElement ( type . getRubyScript ( ) ) ; } return false ; } protected IRubyElement findElementToSelect ( IRubyElement je ) { if ( je == null ) return null ; switch ( je . getElementType ( ) ) { case IRubyElement . TYPE : IType type = ( ( IType ) je ) . getDeclaringType ( ) ; if ( type == null ) type = ( IType ) je ; return getSuitableRubyElement ( type ) ; case IRubyElement . SCRIPT'}]",". CASE IRubyElement. CLASS : return getSuitableRubyElement ( ( ( IClass ) je ). getDeclaringClass ( ) ) ; case IRubyElement. PACKAGE : return getSuitableRubyElement ( ( ( IPackage ) je ). getDeclaringPackage ( ) ) ; case IRubyElement. MODULE : return getSuitableRubyElement ( ( ( IModule ) je ). getDeclaringModule ( ) ) ; case IRubyElement. FILE : return getSuitableRubyElement ( ( ( IRubyScript ) je ). getDeclaringScript ( ) ) ; case IRubyElement. FOLDER : return getSuitableRubyElement ( ( ( ISourceFolderRoot ) je ). getDeclaringFolder ( ) ) ; } return null; } private IRubyElement getSuitableRubyElement ( IRubyElement element ) { return element == null? null : element. getRubyProject ( ) == null? null : element ; } @ Override protected void createActions ( IActionBars actionBars ) { super. createActions ( actionBars ) ; fSelectAllAction = new SelectAllAction ( this ) ; actionBars. setGlobalActionHandlers ( fSelectAllAction. getAction ( ), null ) ; }",0.0003807970515814447
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . quickstart . config ; import javax . sql . DataSource ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Scope ; import org . springframework . context . annotation . ScopedProxyMode ; import org . springframework . core . env . Environment ; import org . springframework . security . crypto . encrypt . Encryptors ; import org . springframework . social . connect . ConnectionFactory ; import org . springframework . social . connect . ConnectionFactoryLocator ; import org . springframework . social . connect . ConnectionRepository ; import org . springframework . social . connect . NotConnectedException ; import org . springframework . social . connect . UsersConnectionRepository ; import org . springframework . social . connect .'}]","WebConnectionHandler;import org.springframework.social.connectjdbc.JdbcUsersConnectionRepository;import org.springframework.social.connectjdbc.JdbcUsersConnectionRowMapper;@Configurationpublic class QuickstartConfig {    @Autowired    private DataSource dataSource;    @Bean    public JdbcUsersConnectionRepository usersConnectionRepository() {        JdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource, new JdbcUsersConnectionRowMapper());        repository.setConnectionFactoryLocator(new ConnectionFactoryLocator());        repository.setUsersConnectionHandler(new WebConnectionHandler());        return repository;    }}",0.00015577471391432584
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . model ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface Joined { Term [ ] terms ( ) ; @ Target ( { } ) public @ interface Term { Class < ? > source ( ) ; Mapping'}]",class mapping ( ) ; },2.5082544654125066e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyModelStatusConstants ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . WorkingCopyOwner ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . core . util . Util ; public class ERBScript extends RubyScript implements IRubyScript { public ERBScript ( SourceFolder parent , String name , WorkingCopyOwner owner ) { super ( parent , name , owner ) ; } @ Override public IRubyElement getElementAt ( int position ) throws RubyModelException { getElementInfo ( ) ; return super . getElementAt ( position ) ; } @ Override protected char [ ] getCharacters ( IProgressMonitor pm , RubyScriptElementInfo unitInfo ) throws RubyModelException { char [ ] cs = super . getCharacters ( pm , unitInfo ) ; return Util . replaceNonRubyCodeWithWhitespace ( new String ( cs ) ) ; } protected IStatus validateRubyScript ( IResource resource ) { ISourceFolderRoot root = getSourceFolderRoot ( ) ; if ( resource != null ) { char [ ] [ ] inclusionPatterns = ( ( SourceFolderRoot ) root ) . fullInclusionPatternChars ( ) ; char [ ] [ ] exclusionPatterns = ( ( SourceFolderRoot ) root ) . fullExclusionPatternChars ( ) ; if ( Util . isExcluded ( resource , inclusionPatterns , exclusionPatterns ) ) return new RubyModelStatus ( IRubyModelStatusConstants . ELEMENT_NOT_ON_CLASSPATH , this ) ; if ( ! resource . isAccessible ( ) ) return new RubyModelStatus ( IRubyModelStatusConstants . ELEMENT_DOES_NOT_EXIST , this ) ; } if ( name == null ) { return new Status ( IStatus . ERROR , RubyCore . PLUGIN_ID , - <NUM_LIT:1> , Messages . bind ( Messages . convention_unit_nullName ) ,'}]","null ); } return Status. OK_STATUS ; } @Override public IStatus validateRubyScript(IResource resource, IProgressMonitor pm) { IStatus status = validateRubyScript(resource); if (status!= Status.OK_STATUS) { return status; } return super.validateRubyScript(resource, pm); } @Override public void setSourceFolderRoot(ISourceFolderRoot root) { super.setSourceFolderRoot(root); if (root!= null) { setSourceFolderRoot((SourceFolderRoot) root); } } }",0.00015925761525989798
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . argfile . editor ; import net . sf . sveditor . ui . editor . SVCodeScanner ; import net . sf . sveditor . ui . editor . SVDocumentPartitions ; import net . sf . sveditor . ui . editor . SVEditorColors ; import net . sf . sveditor . ui . editor . SVPresentationReconciler ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . TextAttribute ; import org . eclipse . jface . text . presentation . IPresentationReconciler ; import org . eclipse . jface . text . presentation . PresentationReconciler ; import org . eclipse . jface . text . rules . BufferedRuleBasedScanner ; import org . eclipse . jface . text . rules . DefaultDamagerRepairer ; import org . eclipse . jface . text . rules . Token ; import org . eclipse . jface .'}]",".text.rules.RuleContext;public class SVArgFileEditor extends SVCodeScanner { public SVArgFileEditor(IDocument document) { super(new SVDocumentPartitions(document), new SVEditorColors(), new DefaultDamagerRepairer(new SVArgFileScanner()), new DefaultDamagerRepairer(new SVArgFileReconciler())); } }",0.00010444367460579305
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . exporter ; import java . util . Date ; import java . util . List ; import com . asakusafw . bulkloader . bean . ExportTempTableBean ; import com . asakusafw . bulkloader . bean . ExporterBean ; import com . asakusafw . bulkloader . common . ConfigurationLoader ; import com . asakusafw . bulkloader . common . Constants ; import com . asakusafw . bulkloader . common . DBAccessUtil ; import com . asakusafw . bulkloader . common . ExportTempTableStatus ; import com . asakusafw . bulkloader . common . TsvDeleteType ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; public class JudgeExecProcess { static final Log LOG = new Log ( JudgeExecProcess . class ) ; private boolean execTempTableDelete = false ; private boolean execReceive = false ; private boolean execLoad = false ; private boolean execCopy = false ; private boolean execLockRelease = false ; private boolean execFileDelete = false ; List < ExportTempTableBean > exportTempTableBean = null ; public boolean judge ( ExporterBean bean ) { if ( bean . getJobflowSid ( ) == null || bean . getJobflowSid ( ) . isEmpty ( ) ) { LOG . error ( ""<STR_LIT>"" , new Date ( ) , bean . getTargetName ( ) , bean . getBatchId ( ) , bean . getJobflowId ( ) , bean . getExecutionId ( ) ) ; return false ; } String deleteTsv = ConfigurationLoader . getProperty ( Constants . PROP_KEY_EXPORT_TSV_DELETE ) ; TsvDeleteType delType = TsvDeleteType . find ( deleteTsv ) ; boolean isDeleteTsv = false ; if ( TsvDeleteType . TRUE . equals ( delType ) ) { isDeleteTsv = true ; }'}]",} if ( isDeleteTsv ) { if ( bean. getDeleteTsvType ( )!= null && bean. getDeleteTsvType ( ). equals ( TsvDeleteType. TRUE ) ) { execTempTableDelete = true ; } } return true ; } },0.00010005636243395106
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . inlinemethod ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org'}]","rubypeople.rdt.refactoring.core.model.Method; public class InlineMethodRefactoring extends Refactoring { private final Method method; private final IDocumentProvider documentProvider; public InlineMethodRefactoring(Method method, IDocumentProvider documentProvider) { super(); this.method = method; this.documentProvider = documentProvider; } @Override public void execute() throws RefactoringException { // implementation } @Override public String getName() { return ""Inline Method""; } }",0.00012857043741191902
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . mcbans . firestar . mcbans . org . json ; import java . io . * ; public class JSONTokener { private int character ; private boolean eof ; private int index ; private int line ; private char previous ; private Reader reader ; private boolean usePrevious ; public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . eof = false ; this . usePrevious = false ; this . previous = <NUM_LIT:0> ; this . index = <NUM_LIT:0> ; this . character = <NUM_LIT:1> ; this . line = <NUM_LIT:1> ; } public JSONTokener ( InputStream inputStream ) throws JSONException { this ( new InputStreamReader ( inputStream ) ) ; } public JSONTokener ( String s ) { this ( new StringReader ( s ) ) ; } public void back ( ) throws JSONException { if ( usePrevious || index <= <NUM_LIT:0> ) { throw new JSONException ( ""<STR_LIT>"" ) ; } this . index -= <NUM_LIT:1> ; this . character -= <NUM_LIT:1> ; this . usePrevious = true ; this . eof = false ; } public static int dehexchar ( char c ) { if ( c >= \'<CHAR_LIT:0>\' && c <= \'<CHAR_LIT:9>\' ) { return c - \'<CHAR_LIT:0>\' ; } if ( c >= \'<CHAR_LIT:A>\' && c <= \'<CHAR_LIT>\' ) { return c - ( \'<CHAR_LIT:A>\' - <NUM_LIT:10> ) ; } if ( c >= \'<CHAR_LIT:a>\' && c <= \'<CHAR_LIT>\' ) { return c - ( \'<CHAR_LIT:a>\' - <NUM_LIT:10> ) ; } return - <NUM_LIT:1> ; } public boolean end ( ) { return eof && ! usePrevious ; } public boolean more ( ) throws JSONException { next ( ) ; if ( end ( ) ) { return false ; } back ( ) ; return true ; } public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= <NUM_LIT:0> ) { this . eof = true ; c = <NUM_LIT:0> ; } } this . index += <NUM_LIT:1> ; if ( this . previous == \'<STR_LIT>\' ) { this . line += <NUM_LIT:1> ; this . character = c == \'<STR_LIT:\\n>\' ? <NUM_LIT:0> : <NUM_LIT:1> ; } else if'}]",c == '<STR_LIT:\n>' { this. line += <NUM_LIT:1> ; this. character = <NUM_LIT:0> ; } else { this. character += <NUM_LIT:1> ; } this. previous = c ; return ( char ) c ; } public void nextLine ( ) throws JSONException { try { this. reader. readLine ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } this. line += <NUM_LIT:1> ; this. character = <NUM_LIT:0> ; this. eof = true ; } },0.00019743549399894462
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . search ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . index . ISVDBItemIterator ; import org . eclipse . core . runtime . NullProgressMonitor ; public class SVDBFindIncludedFile { private ISVDBIndexIterator fIndexIterator ; private ISVDBFindNameMatcher fMatcher ; public SVDBFindIncludedFile ( ISVDBIndexIterator index_it ) { this ( index_it , SVDBFindDefaultNameMatcher . getDefault ( ) ) ; } public SVDBFindIncludedFile ( ISVDBIndexIterator index_it , ISVDBFindNameMatcher matcher ) { fIndexIterator = index_it ; fMatcher = matcher ; } public List < SVDBFile > find ( String name ) { ISVDBItemIterator item_it = fIndexIterator . getItemIterator ( new NullProgressMonitor ( ) ) ; List < SVDBFile > ret = new ArrayList < SVDBFile > ('}]",") ; while ( item_it. hasNext ( ) ) { ISVDBItemBase item = item_it. nextItem ( ) ; if ( fMatcher. matches ( item. getName ( ), name ) ) { ret. add ( ( SVDBFile ) item ) ; } } return ret ; } }",0.000101842002311398
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . util ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . rubypeople . rdt . core . util . Util . Displayable ; public class UtilTest extends TestCase { public void testGetFileByteContent ( ) throws Exception { byte [ ] content = new byte [ ] { <NUM_LIT:0> , <NUM_LIT> } ; File file = File . createTempFile ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; try { FileOutputStream out = null ; try { out = new FileOutputStream ( file ) ; out . write ( content ) ; } finally { if ( out != null ) out . close ( ) ; } assertArrayContentsEquals ( content , Util . getFileByteContent ( file ) ) ; } finally { file . delete ( ) ; } } private void assertArrayContentsEquals ( byte [ ] expected , byte [ ] actual ) { if ( expected == null ) { assertNull ( actual ) ; return ; } assertEquals ( expected . length , actual . length ) ; int length = expected . length ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { assertEquals ( expected [ i ] , actual [ i ] ) ; } } private void assertArrayContentsEquals ( char [ ] expected , char [ ] actual ) { if ( expected == null ) { assertNull ( actual ) ; return ; } assertEquals ( expected . length , actual . length ) ; int length = expected . length ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { assertEquals ( expected [ i ] , actual [ i ] ) ; } } public void testToStringObjectArrayDisplayable ( ) { assertEquals ( ""<STR_LIT>"" , Util . toString ( new Object [ ] { <NUM_LIT:1> , null , <NUM_LIT:2> } , new Displayable ( ) { public String displayString ( Object o ) { if ( o == null ) return ""<STR_LIT>"" ; return o . toString ( ) ; } } ) ) ; } public void testToStringObjectArray ( ) { assertEquals ( ""<STR_LIT>"" , Util .'}]","toString(new Object[] { ""1"", null, ""2"" }, new Displayable() { public String displayString(Object o) { if (o == null) return ""<STR_LIT>""; return o.toString(); } })); } public void testToStringCollectionDisplayable() { List<String> list = new ArrayList<String>(); list.add(""1""); list.add(null); list.add(""2""); assertEquals(""<STR_LIT>1<STR_LIT><STR_LIT>2<STR_LIT>"", Util.toString(list, new Displayable() { public String displayString(Object o) { if (o == null) return ""<STR_LIT>""; return o.toString(); } })); } public void testToStringCollection() { List<String> list = new ArrayList<String>(); list.add(""1""); list.add(null); list.add(""2""); assertEquals(""1null2"", Util.toString(list)); } }",0.00026244242319161244
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . cache ; import java . sql . Connection ; import java . util . Arrays ; import java . util . List ; import com . asakusafw . bulkloader . common . BulkLoaderInitializer ; import com . asakusafw . bulkloader . common . Constants ; import com . asakusafw . bulkloader . common . DBConnection ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; import com . asakusafw . runtime . core . context . RuntimeContext ; public class ReleaseCacheLock { static final Log LOG = new Log ( ReleaseCacheLock . class ) ; private static final List < String > PROPERTIES = Constants . PROPERTIES_DB ; public static void main ( String [ ] args ) { RuntimeContext . set ( RuntimeContext . DEFAULT . apply ( System'}]",".out::getProperties(), PROPERTIES));BulkLoaderInitializer.init();Connection connection = DBConnection.getConnection();try { // cache lock release logic here } finally { connection.close();}}",6.398990747292562e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . values ; public interface Translator { public static Translator IDENTITY = new Translator ( ) { public String'}]",translate ( String value ) { return value; } }; public String translate ( String value ); },3.828528741301285e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . index ; import java . io . File ; import java . util . List ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . db . index . SVDBIndexRegistry ; import net . sf . sveditor . core . db . index . SVDBLibPathIndexFactory ; import net . sf . sveditor . core . db . refs . SVDBFileRefCollector ; import net . sf . sveditor . core . db . refs . SVDBRefCacheEntry ; import net . sf . sveditor . core . db . refs . SVDBRefCacheItem ; import net . sf . sveditor . core . db . refs . SVDBRefItem ; import net . sf . sveditor . core . db . refs . SVDBRefType ; import net . sf . sveditor . core . db . refs . SVDBTypeRefMatcher ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . tests . IndexTestUtils ; import net . sf . sveditor . core . tests . SVCoreTestsPlugin ; import net . sf . sveditor . core . tests . TestIndexCacheFactory ; import net . sf . sveditor . core . tests . utils . BundleUtils ; import net . sf . sveditor . core . tests . utils . TestUtils ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . NullProgressMonitor ; public class TestIndexFileRefs extends TestCase { private File fTmpDir ; private IProject fProject ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; fTmpDir = TestUtils . createTempDir ( ) ; fProject = null ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; SVDBIndexRegistry rgy = SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) ; rgy . save_state ( ) ; if ( fProject != null ) { TestUtils . deleteProject ( fProject ) ; } if ( fTmpDir != null && fTmpDir . exists ( ) ) { TestUtils . delete ( fTmpDir ) ; } } public void testUVMIncludeRefs ( ) { SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; BundleUtils utils = new BundleUtils ( SVCoreTestsPlugin . getDefault ( ) . getBundle ( ) ) ; LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; File test_dir = new File ( fTmpDir , ""<STR_LIT>"" ) ; if ( test_dir . exists ( ) ) { TestUtils . delete ( test_dir ) ; } test_dir . mkdirs ( ) ; utils . unpackBundleZipToFS ( ""<STR_LIT>"" , test_dir ) ; File uvm_src = new File ( test_dir , ""<STR_LIT>"" ) ; fProject = TestUtils . createProject ( ""<STR_LIT>"" , uvm_src ) ; File db = new File ( fTmpDir , ""<STR_LIT>"" ) ; if ( db . exists ( ) ) { db . delete ( ) ; } SVDBIndexRegistry rgy ='}]",SVCorePlugin.getDefault().getSVDBIndexRegistry();,4.1858534460524555e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package d2rq ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import jena . cmdline . ArgDecl ; import jena . cmdline . CommandLine ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import com . hp . hpl . jena . rdf . model . Model ; import de . fuberlin . wiwiss . d2rq . CommandLineTool ; import de . fuberlin . wiwiss . d2rq . SystemLoader ; import de . fuberlin . wiwiss . d2rq . mapgen . MappingGenerator ; public class generate_mapping extends CommandLineTool { private final static Log log = LogFactory . getLog ( generate_mapping . class ) ; public static void main ( String [ ] args ) { new generate_mapping ( ) . process ( args ) ; } public void usage ( ) { System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ) ; printStandardArguments ( false ) ; System . err . println ( ""<STR_LIT>"" ) ; printConnectionOptions ( ) ; System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ""<STR_LIT>"" ) ; System . err . println ( ) ; System . exit ( <NUM_LIT:1> ) ; } private ArgDecl outfileArg = new ArgDecl ( true , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; private ArgDecl vocabAsOutput = new ArgDecl ( false , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; public void initArgs ( CommandLine cmd ) { cmd . add ( outfileArg ) ; cmd . add ( vocabAsOutput ) ; } public void run ( CommandLine cmd , SystemLoader loader ) throws IOException {'}]",Model model = loader.getModel();,3.0326900223076128e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; public class TesterDriver < T > implements TestRule { private final ModelTester < ? super T > verifier ; private final DataModelDefinition < ? extends T > definition ; public TesterDriver ( ModelTester < ? super T > verifier , DataModelDefinition < ? extends T > definition ) { if ( verifier == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( definition == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; }'}]","this.verifier = verifier; this.definition = definition; } @Override public Statement apply ( Statement base, Description description ) throws Throwable { return verifier. test ( definition, base ); } }",6.617707100045478e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import javax . management . Attribute ; import javax . management . AttributeList ; import javax . management . AttributeNotFoundException ; import javax . management . DynamicMBean ; import javax . management . InvalidAttributeValueException ; import javax . management . MBeanAttributeInfo ; import javax . management . MBeanConstructorInfo ; import javax . management . MBeanException ; import javax . management . MBeanInfo ; import javax . management . MBeanNotificationInfo ; import javax . management . MBeanOperationInfo ; import javax . management . MBeanServer ; import javax . management . MBeanServerConnection ; import javax . management . MBeanServerFactory ; import javax . management . Notification ; import javax . management . NotificationBroadcasterSupport ; import javax . management . NotificationListener ; import javax . management . ObjectName ; import javax . management . ReflectionException ; import javax . management . remote . JMXConnector ; import javax . management . remote . JMXConnectorFactory ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . log4j . Logger ; import junit . framework . TestCase ; public class JMXAssumptionsTest extends TestCase { private static final Logger logger = Logger . getLogger ( JMXAssumptionsTest . class ) ; public class OurMBean extends NotificationBroadcasterSupport implements DynamicMBean { @ Override public Object getAttribute ( String attribute ) throws AttributeNotFoundException , MBeanException , ReflectionException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } @ Override public AttributeList getAttributes ( String [ ] attributes ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } @ Override public MBeanInfo getMBeanInfo ( ) { return new MBeanInfo ( OurMBean . class . getName ( ) , ""<STR_LIT:Test>"" , new MBeanAttributeInfo [ <NUM_LIT:0> ] , new MBeanConstructorInfo [ <NUM_LIT:0> ] , new MBeanOperationInfo [ <NUM_LIT:0> ] , new MBeanNotificationInfo [ ] { new MBeanNotificationInfo ( new String [ ] { ""<STR_LIT:test1>"" } , Notification . class . getName ( ) , ""<STR_LIT>"" ) , new MBeanNotificationInfo ( new String [ ] { ""<STR_LIT>"" } , Notification . class . getName ( ) , ""<STR_LIT>"" ) } ) ; } @ Override public Object invoke ( String actionName , Object [ ] params , String [ ] signature ) throws MBeanException , ReflectionException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } @ Override public void setAttribute ( Attribute attribute ) throws AttributeNotFoundException , InvalidAttributeValueException , MBeanException , ReflectionException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } @ Override public AttributeList setAttributes ( AttributeList attributes ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } } class OurListener implements NotificationListener { Set < Thread > threads = new HashSet < Thread > ( ) ; AtomicInteger count = new AtomicInteger ( ) ; long last = - <NUM_LIT:1> ; boolean badSequence ; @ Override public void handleNotification ( Notification notification , Object handback ) { synchronized ( threads ) { threads . add ( Thread . currentThread ( ) ) ; }'}]","long now = System. currentTimeMillis ( ) ; if ( last + <NUM_LIT:1000> <= now ) { count. incrementAndGet ( ) ; } last = now ; if ( count. get ( ) >= 2 ) { badSequence = true ; } } } public void test ( ) throws Exception { MBeanServer server = MBeanServerFactory. createMBeanServer ( ""test"", null, null ) ; OurMBean mbean = new OurMBean ( ) ; ObjectName name = new ObjectName ( ""test"" ) ; server. registerMBean ( mbean, name ) ; JMXConnector connector = JMXConnectorFactory. connect ( new JMXServiceURL ( ""service:jmx:rmi:///jndi/rmi://localhost:1099/jmx"" ) ) ; MBeanServerConnection connection = connector. getMBeanServerConnection ( ) ; OurListener listener = new OurListener ( ) ; connection. addNotificationListener ( name, listener, null, null ) ; Thread. sleep ( <NUM_LIT:5000> ) ; connector. close ( ) ; if (! listener. badSequence ) { fail ( ""expected a bad sequence of notifications"" ) ; } } }",0.0003777254463744964
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . doclet ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintWriter ; import org . oddjob . arooa . ConfiguredHow ; import org . oddjob . arooa . beandocs . BeanDoc ; import org . oddjob . arooa . beandocs . ExampleDoc ; import org . oddjob . arooa . beandocs . PropertyDoc ; public class ManualWriter { private final File directory ; private final String title ; public ManualWriter ( String directory , String title ) { this . directory = new File ( directory ) ; this . title = title == null ? ""<STR_LIT>"" : title ; } public void writePage ( BeanDoc beanDoc ) { PrintWriter out = null ; try { File file = new File ( directory , getFileName ( beanDoc . getClassName ( ) ) ) ; file . getParentFile ( ) . mkdirs ( ) ; out = new PrintWriter ( new FileOutputStream ( file ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" + title + ""<STR_LIT:U+0020-U+0020>"" + beanDoc . getName ( ) + ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" + getIndexFile ( beanDoc . getClassName ( ) ) + ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" + beanDoc . getName ( ) + ""<STR_LIT>"" ) ; if ( beanDoc . getAllText ( ) != null ) { out . println ( ""<STR_LIT>"" ) ; out . println ( beanDoc . getAllText ( ) ) ; } PropertyDoc [ ] propertyDocs = beanDoc . getPropertyDocs ( ) ; if ( propertyDocs . length > <NUM_LIT:0> ) { out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" ) ; out . println ( ""<STR_LIT>"" + ""<STR_LIT>"" ) ; int i = <NUM_LIT:0> ; for ( PropertyDoc elem : propertyDocs ) { if ( ConfiguredHow . HIDDEN'}]",".isApplied(elem)) { continue; } out.println(""<STR_LIT>"" + elem.getName() + ""<STR_LIT:U+0020-U+0020>"" + elem.getDescription() + ""<STR_LIT>""); i++; } out.println(""<STR_LIT>"" + ""<STR_LIT>"" + i + ""<STR_LIT>"" + ""<STR_LIT>""); } catch (IOException e) { throw new RuntimeException(e); } finally { if (out!= null) { out.close(); } } public void writeIndex ( ExampleDoc exampleDoc ) { PrintWriter out = null ; try { File file = new File ( directory, getFileName ( exampleDoc. getClassName ( ) ) ) ; file. getParentFile ( ). mkdirs ( ) ; out = new PrintWriter ( new FileOutputStream ( file ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } out. println ( ""<STR_LIT>"" ) ; out. println ( ""<STR_LIT>"" ) ; out. println ( ""<STR_LIT>"" + title + ""<STR_LIT:U+0020-U+0020>"" + exampleDoc. getName ( ) + ""<STR_LIT>"" ) ; out. println ( ""<STR_LIT>"" ) ; out",0.0003550559427634934
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui ; import java . util . Collection ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Text ; import org . rubypeople . rdt . refactoring . core . IValidator ; public class NewNameListener implements IErrorMessageGenerator { private final INewNameReceiver receiver ; private IErrorMessageReceiver errorReceiver ; private final Collection < String > fields ; private final IValidator validator ; public NewNameListener ( INewNameReceiver receiver , IValidator validator , Collection < String > fields ) { this . receiver = receiver ; this . validator = validator ; this . fields = fields ; } public void handleEvent ( Event event ) { if ( event . widget instanceof Text ) { String name = ( ( Text ) event . widget ) . getText ( ) ; if ( isValid ( name ) ) { receiver'}]",.receiveNewName(name); } else { errorReceiver.receiveError(validator.getErrorMessage(name)); } } private boolean isValid(String name) { return validator.validate(name); } public void setErrorReceiver(IErrorMessageReceiver errorReceiver) { this.errorReceiver = errorReceiver; } },8.35060677608667e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . quickstart . config ; import javax . sql . DataSource ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . ComponentScan ; import org . springframework . context . annotation . ComponentScan . Filter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . io . ClassPathResource ; import org'}]",.springframework.jdbc.datasource.DriverManagerDataSource;,2.6836988311926874e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . excel . legacy ; import java . util . HashMap ; import java . util . Map ; public enum NullValueCondition { NORMAL ( ""<STR_LIT>"" ) , NULL_IS_OK ( ""<STR_LIT>"" ) , NULL_IS_NG ( ""<STR_LIT>"" ) , NOT_NULL_IS_OK ( ""<STR_LIT>"" ) , NOT_NULL_IS_NG ( ""<STR_LIT>"" ) ; private String japaneseName ; private NullValueCondition ( String japaneseName ) { this . japaneseName = japaneseName ; } public String getJapaneseName ( ) { return japaneseName ; } private static Map < String , NullValueCondition > japaneseNameMap = new HashMap < String , NullValueCondition > ( ) ; static { for ( NullValueCondition conditon : NullValueCondition . values ( ) ) { String key = conditon . getJapaneseName ( ) ; if ( japaneseNameMap . containsKey ( key ) ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } japaneseNameMap . put ( key , conditon ) ; } } public static NullValueCondition getConditonByJapanseName ( String key ) { return japaneseNameMap . get ( key ) ; } public static String [ ] getJapaneseNames ( ) { NullValueCondition [ ] values = NullValueCondition'}]",.values(); String[] array = new String[values.length]; for (int i = 0; i < array.length; i++) { array[i] = values[i].getJapaneseName(); } return array; } },7.692349912458008e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import junit . framework . TestCase ; public class SQLBuilderTest extends TestCase { String EOL = System . getProperty ( ""<STR_LIT>"" ) ; public void testLineFeedTest ( ) { String sql = ""<STR_LIT>"" +'}]","""SELECT * FROM table"" + EOL + ""WHERE column = <value>"" + EOL + ""ORDER BY column;""",4.9253522478396496e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . flow ; import com . asakusafw . compiler . fileio . external . Ex1MockImporterDescription ; import com . asakusafw . compiler . fileio . model . Ex1 ; import com . asakusafw . compiler . fileio . operator . ExOperatorFactory ; import com . asakusafw . compiler . fileio . operator . ExOperatorFactory . Update ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; @ JobFlow ( name = ""<STR_LIT>"" ) public class MultipleOutputJob extends FlowDescription { private final In < Ex1 > input ; private final Out < Ex1 > output1 ; private final Out < Ex1 > output2 ; private final Out < Ex1 > output3 ; private final Out < Ex1 > output4 ; public MultipleOutputJob ( @ Import ( name = ""<STR_LIT>"" , description = Ex1MockImporterDescription . class ) In < Ex1 > input , @ Export ( name = ""<STR_LIT>"" , description = Out1ExporterDesc . class ) Out < Ex1 > output1 , @ Export ( name = ""<STR_LIT>"" , description = Out2ExporterDesc . class ) Out < Ex1 > output2 , @ Export ( name = ""<STR_LIT>"" , description = Out3ExporterDesc . class ) Out < Ex1 > output3 , @ Export ( name = ""<STR_LIT>"" , description = Out4ExporterDesc . class ) Out < Ex1 > output4 ) { this . input = input ; this . output1 = output1 ; this . output2 = output2 ; this . output3 = output3 ; this . output4 = output4 ; } @ Override protected void describe ( ) { ExOperatorFactory op = new ExOperatorFactory ('}]","()); op.add(Update.of(input, output1)); op.add(Update.of(input, output2)); op.add(Update.of(input, output3)); op.add(Update.of(input, output4)); }",7.802552385921175e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . flow ; import static com . asakusafw . vocabulary . flow . util . CoreOperators . * ; import com . asakusafw . compiler . fileio . external . Ex1MockExporterDescription ; import com . asakusafw . compiler . fileio . model . Ex1 ; import com . asakusafw . compiler . fileio . model . Ex2 ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; @ JobFlow ( name = ""<STR_LIT>"" ) public class MixedInputJob extends FlowDescription { private final In < Ex1 > input1 ; private final In < Ex2 > input2 ; private final Out < Ex1 > output ; public MixedInputJob ( @ Import ( name = ""<STR_LIT>"" , description = NormalImporterDescription . class ) In < Ex1 > input1 , @ Import ( name = ""<STR_LIT>"" , description = TinyImporterDescription . class )'}]","In < Ex2 > input2 ) { this. input1 = input1 ; this. input2 = input2 ; output = createOut ( input1, input2 ) ; } private Out < Ex1 > createOut ( In < Ex1 > input1, In < Ex2 > input2 ) { return Export. of ( input1, input2 ). to ( Ex1. class ) ; } }",0.00013013603258465594
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . io ; import java . io . File ; import junit . framework . TestCase ; import org . apache . commons . io . FileUtils ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OurDirs ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . ParentState ; public class MkdirJobTest extends TestCase { File dir ; public void setUp ( ) throws Exception { OurDirs dirs = new OurDirs ( ) ; dir = dirs . relative ( ""<STR_LIT>"" ) ; if ( dir . exists ( ) ) { FileUtils . forceDelete ( dir ) ; } } public void testSimple ( ) { MkdirJob test = new MkdirJob ( ) ; test . setDir ( dir ) ; test . run ( ) ; assertTrue ( dir . exists ( ) ) ; } public void testFileExists ( ) throws Exception { FileUtils . touch ( dir ) ; MkdirJob test = new MkdirJob ( ) ; test . setDir ( dir ) ; try { test . run ( ) ; fail ( ""<STR_LIT>"" ) ; } catch ( Exception e ) { } assertTrue ( dir . isFile ( ) ) ; } public void testDirExists ( ) throws Exception { FileUtils . forceMkdir ( dir ) ; MkdirJob test = new MkdirJob ( ) ; test . setDir ( dir ) ; test . run ( ) ; assertTrue ( dir . isDirectory ( ) ) ; } public void testMissingParents ( ) throws Exception { File create = new File ( dir , ""<STR_LIT>"" ) ; MkdirJob test = new MkdirJob ( ) ; test . setDir ( create ) ; test . run ( ) ; assertTrue ( create . exists ( ) ) ; } public void testInOddjob ( ) { Oddjob oj = new Oddjob ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>""'}]",") ); oj. setProperty ( ""mkdir.dir"", dir.getAbsolutePath() ); oj.run(); assertTrue(dir.exists()); } }",5.552883785419386e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . flow . join ; import java . io . IOException ; import java . util . List ; public interface LookUpTable < T > { List < T > get'}]",( T key ) throws IOException ; },2.547682227416434e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . search ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . WorkingCopyOwner ; import org . rubypeople . rdt . internal . core . search . BasicSearchEngine ; public class SearchEngine { private BasicSearchEngine basicEngine ; public SearchEngine ( ) { this . basicEngine = new BasicSearchEngine ( ) ; } public SearchEngine ( WorkingCopyOwner workingCopyOwner ) { this . basicEngine = new BasicSearchEngine ( workingCopyOwner ) ; } public static IRubySearchScope createWorkspaceScope ( ) { return BasicSearchEngine . createWorkspaceScope ( ) ; } public void searchAllTypeNames ( final char [ ] namespace , final char [ ] typeName , final int matchRule , int searchFor , IRubySearchScope scope , final TypeNameRequestor nameRequestor , int'}]","maxResults, IProgressMonitor monitor) throws CoreException, RubyModelException;",3.970968006018602e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . parser . warnings ; import org . jruby . ast . ConstDeclNode ; import org . jruby . lexer . yacc . IDESourcePosition ; import org . jruby . lexer . yacc . ISourcePosition ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import com . aptana . rdt . AptanaRDTPlugin ; import com . aptana . rdt . IProblem ; public class ConstantNamingConvention extends RubyLintVisitor { public ConstantNamingConvention ( String contents ) { super ( AptanaRDTPlugin . getDefault ( ) . getOptions ( ) , contents ) ; } @ Override protected String getOptionKey ( ) { return AptanaRDTPlugin . COMPILER_PB_CONSTANT_NAMING_CONVENTION ; } @ Override public Object visitConstDeclNode ( ConstDeclNode iVisited ) { String name = iVisited . getName ( ) ; if ( ! name . toUpperCase ( ) . equals ( name ) ) { ISourcePosition pos = iVisited . getPosition ( ) ; IDESourcePosition duh = new IDESourcePosition ('}]","pos. getLine ( ), pos. getCol ( ) ) ; IProblem problem = new IProblem ( ""Constant name should be in uppercase: "" + name, duh ) ; return problem ; } @ Override public Object visitConstDeclNode ( ConstDeclNode iVisited, int iChildIndex ) { return visitConstDeclNode ( iVisited ) ; } }",0.00011666915676990186
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package og . android . tether . system ; import android . util . Log ; public class NativeTask { public'}]",static native void init(String[] args);,2.889464046091317e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . mergeclasspartsinfile ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . refactoring . core . RubyRefactoring ; import org . rubypeople . rdt . refactoring . ui . pages . MergeClassPartsInFilePage ; public class MergeClassPartsInFileRefactoring extends RubyRefactoring { public static final String NAME = Messages . MergeClassPartsInFileRefactoring_Name ; public MergeClassPartsInFileRefactoring ( ) throws CoreException { super ( NAME ) ;'}]",init(MergeClassPartsInFilePage.class);,2.9992722901142908e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import org . eclipse . jface . text . ITextSelection ; import org . eclipse'}]",".jdt.ui.ITextSelection; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.part.ViewPart; import org.eclipse.swt.widgets.Text; import org.eclipse.swt.layout.FormLayout; import org.eclipse.swt.layout.FormData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.widgets.Button; public class ViewSupport extends ViewPart { @Override public void createControl ( Shell shell ) { super. createControl ( shell ) ; Text text = new Text ( shell, SWT. BORDER ) ; text. setLayoutData ( new FormData ( ) { { setHorizontalRatio ( 1.0 ) ; } } ) ; text. setLayoutData ( new GridData ( ) { { setHorizontalAlignment ( SWT. LEFT ) ; } } ) ; Button button = new Button ( shell, SWT. PUSH ) ; button. setText ( ""Click me!"" ) ; button. addSelectionListener ( new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { System. out. println ( """,0.0003406762448523675
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . directio . csv . driver ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . math . BigDecimal ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . List ; import java . util . Random ; import org . apache . hadoop . io . Text ; import org . junit . Before ; import org . junit . Test ; import com . asakusafw . dmdl . directio . common . driver . GeneratorTesterRoot ; import com . asakusafw . dmdl . java . emitter . driver . ObjectDriver ; import com . asakusafw . runtime . directio . BinaryStreamFormat ; import com . asakusafw . runtime . directio . util . DelimiterRangeInputStream ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . csv . CsvConfiguration ; import com . asakusafw . runtime . io . csv . CsvFormatException ; import com . asakusafw . runtime . io . csv . CsvParser ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . utils . collections . Lists ; public class CsvFormatEmitterTest extends GeneratorTesterRoot { @ Before public void setUp ( ) throws Exception { emitDrivers . add ( new CsvFormatEmitter ( ) ) ; emitDrivers . add ( new ObjectDriver ( ) ) ; } @ Test public void simple ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < ? > support = ( BinaryStreamFormat < ? > ) loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertThat ( support . getSupportedType ( ) , is ( ( Object ) model . unwrap ( ) . getClass ( ) ) ) ; BinaryStreamFormat < Object > unsafe = unsafe ( support ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = unsafe . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; Object buffer = loaded . newModel ( ""<STR_LIT>"" ) . unwrap ( ) ; ModelInput < Object > reader = unsafe . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer ) , is ( true ) ) ; assertThat ( buffer , is ( buffer ) ) ; assertThat ( reader . readTo ( buffer ) , is ( false ) ) ; } @ Test public void types ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < ? > support = ( BinaryStreamFormat < ? > ) loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertThat ( support . getSupportedType ( ) , is ( ( Object ) model . unwrap ( ) . getClass ( ) ) ) ; ModelWrapper empty = loaded . newModel ( ""<STR_LIT>"" ) ; ModelWrapper all = loaded . newModel ( ""<STR_LIT>"" ) ; all . set ( ""<STR_LIT>"" , <NUM_LIT:100> ) ; all . set ( ""<STR_LIT>"" , new Text ( ""<STR_LIT>"" ) ) ; all . set ( ""<STR_LIT>"" , true ) ; all . set ( ""<STR_LIT>"" , ( byte ) <NUM_LIT> ) ; all . set ( ""<STR_LIT>"" , ( short ) <NUM_LIT> ) ; all . set ( ""<STR_LIT>"" , <NUM_LIT> ) ; all . set ( ""<STR_LIT>"" , <NUM_LIT> ) ; all . set ( ""<STR_LIT>"" , <NUM_LIT> ) ; all . set ( ""<STR_LIT>"" , new BigDecimal ( ""<STR_LIT>"" ) ) ; all . set ( ""<STR_LIT>"" , new Date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:1> ) ) ; all . set ( ""<STR_LIT>"" , new DateTime ( <NUM_LIT> , <NUM_LIT:12> , <NUM_LIT:31> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; BinaryStreamFormat < Object > unsafe = unsafe ( support ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = unsafe . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( empty . unwrap ( ) ) ; writer . write ( all . unwrap ( ) ) ; writer . close ( ) ; Object buffer = loaded . newModel ( ""<STR_LIT>"" ) . unwrap ( ) ; ModelInput < Object > reader = unsafe . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer ) , is ( true ) ) ; assertThat ( buffer , is ( empty . unwrap ( ) ) ) ; assertThat ( reader . readTo ( buffer ) , is ( true ) ) ; assertThat ( buffer , is ( all . unwrap ( ) ) ) ; assertThat ( reader . readTo ( buffer ) , is ( false ) ) ; } @ Test public void attributes ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; model . set ( ""<STR_LIT>"" , new Text ( ""<STR_LIT>"" ) ) ; model . set ( ""<STR_LIT>"" , true ) ; model . set ( ""<STR_LIT>"" , false ) ; model . set ( ""<STR_LIT>"" , new Date ( <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT:11> ) ) ; model . set ( ""<STR_LIT>"" , new DateTime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:15> ) ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; String [ ] [ ] results = parse ( <NUM_LIT:5> , new String ( output . toByteArray ( ) , ""<STR_LIT>"" ) ) ; assertThat ( results , is ( new String [ ] [ ] { { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , { ""<STR_LIT>"" , ""<STR_LIT:T>"" , ""<STR_LIT:F>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , } ) ) ; } @ Test public void header ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; String [ ] [ ] results = parse ( <NUM_LIT:1> , new String ( output . toByteArray ( ) , ""<STR_LIT:UTF-8>"" ) ) ; assertThat ( results , is ( new String [ ] [ ] { { ""<STR_LIT:title>"" } , { ""<STR_LIT>"" } , } ) ) ; } @ Test public void implicit_field_name ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; String [ ] [ ] results = parse ( <NUM_LIT:1> , new String ( output . toByteArray ( ) , ""<STR_LIT:UTF-8>"" ) ) ; assertThat ( results , is ( new String [ ] [ ] { { ""<STR_LIT:value>"" } , { ""<STR_LIT>"" } , } ) ) ; } @ Test public void file_name ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; ModelWrapper buffer = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; assertThat ( support . getMinimumFragmentSize ( ) , is ( greaterThan ( <NUM_LIT> ) ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; ModelInput < Object > reader = support . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:path>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( false ) ) ; } @ Test public void line_number ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; ModelWrapper buffer = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( model . unwrap ( ) ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; ModelInput < Object > reader = support . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:number>"" ) , is ( ( Object ) new IntOption ( <NUM_LIT:1> ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:number>"" ) , is ( ( Object ) new IntOption ( <NUM_LIT:3> ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( false ) ) ; } @ Test public void record_number ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; ModelWrapper buffer = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( model . unwrap ( ) ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; ModelInput < Object > reader = support . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:number>"" ) , is ( ( Object ) new LongOption ( <NUM_LIT:1> ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:number>"" ) , is ( ( Object ) new LongOption ( <NUM_LIT:2> ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( false ) ) ; } @ Test public void ignore ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; ModelWrapper model = loaded . newModel ( ""<STR_LIT>"" ) ; model . set ( ""<STR_LIT:value>"" , new Text ( ""<STR_LIT>"" ) ) ; model . set ( ""<STR_LIT>"" , new Text ( ""<STR_LIT>"" ) ) ; ModelWrapper buffer = loaded . newModel ( ""<STR_LIT>"" ) ; BinaryStreamFormat < Object > support = unsafe ( loaded . newObject ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ModelOutput < Object > writer = support . createOutput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT:hello>"" , output ) ; writer . write ( model . unwrap ( ) ) ; writer . close ( ) ; ModelInput < Object > reader = support . createInput ( model . unwrap ( ) . getClass ( ) , ""<STR_LIT>"" , in ( output ) , <NUM_LIT:0> , size ( output ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( true ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT:value>"" ) , is ( ( Object ) new StringOption ( ""<STR_LIT>"" ) ) ) ; assertThat ( buffer . getOption ( ""<STR_LIT>"" ) , is ( ( Object ) new StringOption ( ) ) ) ; assertThat ( reader . readTo ( buffer . unwrap ( ) ) , is ( false ) ) ; } @ Test public void fragmentation ( ) throws Exception { ModelLoader loaded = generateJava ( ""<STR_LIT>"" ) ; Random random = new Random ( <NUM_LIT> ) ; for ( int i = <NUM_LIT:0> ; i < <NUM_LIT:5> ; i ++ ) { fragmentation_attempt ( loaded , random ) ; } }'}]",private static BinaryStreamFormat<Object> unsafe(BinaryStreamFormat<?> support) { return new DelimiterRangeInputStream(support); },0.00012310702392216298
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . testunit . wizards ; import org . eclipse . osgi . util . NLS ; public class WizardMessages extends NLS { private static final String BUNDLE_NAME = ""<STR_LIT>"" ; public static String NewTestCaseWizardPage_title ; public static String NewTestCaseWizardPage_description ; public static String'}]",NewTestCaseWizardPage_nextButton ; public static String NewTestCaseWizardPage_previousButton ; public static String NewTestCaseWizardPage_cancelButton ; public static String NewTestCaseWizardPage_finishButton ; public static String NewTestCaseWizardPage_selection ; public static String NewTestCaseWizardPage_selectionDescription ; public static String NewTestCaseWizardPage_selectionErrorMessage ; public static String NewTestCaseWizardPage_selectionErrorMessageDetails ; public static String NewTestCaseWizardPage_selectionErrorMessageTitle ; public static String NewTestCaseWizardPage_selectionErrorMessageLink ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabel ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltipTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltipTooltipTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltipTooltipTooltipTooltipTooltipTooltipTooltip ; public static String NewTestCaseWizardPage_selectionErrorMessageLinkLabelTooltipTooltip,0.0003365918689827454
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . io ; import java . io . IOException ; import com . asakusafw . compiler . fileio . model . ExSummarized ; import com . asakusafw'}]",compiler.fileio.model.ExSummary;,2.438739522578138e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . directio ; public class ResourceInfo { private final String id ; private final String path ; private final boolean directory ; public ResourceInfo ( String id , String path ) { this ( id , path , false ) ; } public ResourceInfo ( String id , String path , boolean directory ) { if ( id'}]","== null || path == null ) { throw new NullPointerException ( ""id or path must not be null"" ) ; } this. id = id ; this. path = path ; this. directory = directory ; } public String getId ( ) { return id ; } public String getPath ( ) { return path ; } public boolean isDirectory ( ) { return directory ; } }",0.00011020270453476493
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . phobos . script . util ; import javax . script . * ; public abstract class ScriptEngineFactoryBase implements ScriptEngineFactory { public String getName ( ) { return ( String ) getParameter ( ScriptEngine'}]",.PARAMETER_NAME); },2.2892547064843737e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . wizards ; import net . sf . sveditor . core . srcgen . NewModuleGenerator ; import net . sf . sveditor . ui . SVUiPlugin ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . IProgressMonitor ; public class NewSVModuleWizard'}]",extends org.eclipse.ui.wizards.newresource.NewResourceWizard { @Override protected boolean performFinish ( IProgressMonitor pm ) { IFile file = getNewFile ( ) ; NewModuleGenerator generator = new NewModuleGenerator ( file ) ; SVUiPlugin.getDefault ( ). getSVModuleGeneratorService ( ). generate ( generator ) ; return true ; } },0.0001065499527491914
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . samples . petclinic . web ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . core . convert . converter . Converter ;'}]",import org.springframework.stereotype.Controller;,2.3673492687900367e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; public class SVDBModIfcDecl extends SVDBScopeItem { public List < SVDBModIfcClassParam > fParams ; public List < SVDBParamPortDecl > fPorts ; protected SVDBModIfcDecl ( String name , SVDBItemType type ) { super ( name , type ) ; fParams = new ArrayList < SVDBModIfcClassParam > ( ) ; fPorts = new ArrayList < SVDBParamPortDecl > ( ) ; } public List < SVDBModIfcClassParam > getParameters ( ) { return fParams ; } public List < SVDBParamPortDecl > getPorts ( ) { return fPorts ; } public boolean isParameterized ( ) { return ( fParams != null && fParams . size'}]",> 0 ); } public SVDBModIfcDecl ( ) { super ( ) ; fParams = new ArrayList < SVDBModIfcClassParam > ( ) ; fPorts = new ArrayList < SVDBParamPortDecl > ( ) ; } },8.948825052570726e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . model ; import com . asakusafw . dmdl . Region ; public class AstBasicType extends AbstractAstNode implements AstType { private final Region region ; public final BasicTypeKind kind ; public AstBasicType ( Region region , BasicTypeKind kind ) { if ( kind == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . region ='}]",region; this.kind = kind; } public Region getRegion() { return region; } public BasicTypeKind getKind() { return kind; } },5.6047424488231926e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . indent ; import junit . framework . TestCase ; import net . sf . sveditor . core . indent . SVIndentScanner ; import net . sf . sveditor . core . indent . SVIndentToken ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . scanutils . StringTextScanner ; public class TestIndentScanner extends TestCase { public void testIsStartLine ( ) { String content = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" ; boolean start_line [ ] = { true , true , false , true , false , true , true , false , false , false , false , } ; boolean end_line [ ] = { true , false , true , false , true , true , false , false , false , false , true , } ; LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; SVIndentScanner scanner = new SVIndentScanner ( new StringTextScanner ( new StringBuilder ( content ) ) ) ; for ( int i = <NUM_LIT:0> ; i < start_line . length ; i ++ ) { SVIndentToken tok = scanner . next ( ) ; log . debug ( ""<STR_LIT>"" + tok . isStartLine ( ) +'}]",""", "" + tok + ""<STR_LIT>"" ) ; if ( start_line [ i ]!= tok. isStartLine ( ) ) { fail ( ""<STR_LIT>"" + i + ""<STR_LIT>"" ) ; } } }",8.286801995502676e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . parser . javadoc . ir ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . List ; public final class IrDocSimpleName extends IrDocName { private static final long serialVersionUID = <NUM_LIT:1L> ; private String identifier ; public IrDocSimpleName ( String identifier ) { super ( ) ; setIdentifier0 ( identifier ) ; } @ Override public IrDocElementKind getKind ( ) { return IrDocElementKind . SIMPLE_NAME ; } public String getIdentifier ( ) { return this . identifier ; } public void setIdentifier ( String identifier ) { setIdentifier0 ( identifier ) ; } private void setIdentifier0 ( String id ) { if ( id == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( id . length ( ) == <NUM_LIT:0> ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( ! Character . isJavaIdentifierStart ( id . charAt ( <NUM_LIT:0> ) ) ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , id . charAt ( <NUM_LIT:0> ) ) ) ; } for ( int i = <NUM_LIT:1> , n = id . length ( ) ;'}]","i < n; i++) { if (!Character.isJavaIdentifierPart(id.charAt(i))) { throw new IllegalArgumentException(MessageFormat.format(""<STR_LIT>"", id.charAt(i))); } } this.identifier = id; } @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass()!= obj.getClass()) { return false; } IrDocSimpleName other = (IrDocSimpleName) obj; return this.identifier.equals(other.identifier); } @Override public int hashCode() { return this.identifier.hashCode(); } }",0.00016525438779937742
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . widgets ; import java . io . File ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ; import net . ggtools . grand . ui . RecentFilesManager ; import net . ggtools . grand . ui . widgets . OpenFileWizard . SelectedFileListener ; import net . ggtools . grand . ui . widgets . OpenFileWizard . SelectedFileProvider ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jface . wizard . WizardPage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . FileDialog ; public class FileSelectionPage extends WizardPage implements SelectedFileProvider { private static final Log log = LogFactory . getLog ( FileSelectionPage . class ) ; private static final String [ ] FILTER_EXTENSIONS = new String [ ] { ""<STR_LIT>"" , ""<STR_LIT:*>"" } ; private String selectedFileName ; private File selectedFile ; private final Collection < SelectedFileListener > subscribers ; public FileSelectionPage ( ) { super ( ""<STR_LIT>"" , ""<STR_LIT>"" , null ) ; setDescription ( ""<STR_LIT>"" ) ; subscribers = new HashSet < SelectedFileListener > ( ) ; } public void createControl ( final Composite parent ) { final Composite composite = new Composite ( parent , SWT . NONE ) ; final GridLayout layout = new GridLayout ( ) ; layout . numColumns = <NUM_LIT:2> ; composite . setLayout ( layout ) ; setControl ( composite ) ; final CCombo combo = new CCombo ( composite , SWT . NONE ) ; combo . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; combo . add ( ""<STR_LIT>"" ) ; for ( final Iterator < String > iter = RecentFilesManager . getInstance ( ) . getRecentFiles ( )'}]",".iterator() that iterates over the recent files) { combo.add(iter.next()); } combo.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { final String selected = combo.getText(); if (selected.equals(""<STR_LIT>"")) { return; } final File file = new File(selected); if (file.exists()) { selectedFile = file; selectedFileName = file.getName(); } } }); final Button browseButton = new Button(composite, SWT.PUSH); browseButton.setText(""<STR_LIT>""); browseButton.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { final FileDialog dialog = new FileDialog(parent.getShell(), SWT.OPEN); dialog.setFilterExtensions(FILTER_EXTENSIONS); dialog.setText(""<STR_LIT>""); final String[] fileNames = dialog.open(); if (fileNames!= null && fileNames.length > 0) { final String selected = fileNames[0]; final File file = new File(selected); selectedFile = file; selectedFileName = file.getName(); } } }); } public String getSelectedFile() { return selectedFileName; } public File getSelectedFileObject() { return selectedFile; } public void addSubscriber(SelectedFileListener listener) { subscribers",0.0003584303348396244
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . nodewrapper ; import junit . framework . TestCase ; import org . jruby . ast . ArgsNode ; import org . jruby . ast . ArgumentNode ; import org . jruby . ast . ArrayNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . NewlineNode ; import org . jruby . ast . RootNode ; import org . jruby . lexer . yacc . IDESourcePosition ; import org . jruby . lexer . yacc . ISourcePosition ; import org . jruby . parser . LocalStaticScope ; import org . rubypeople . rdt . refactoring . documentprovider . StringDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . RealClassNodeWrapper ; public class TC_MethodNodeWrapper extends TestCase { private static final ISourcePosition EMPTY_POSITION = new IDESourcePosition ( ) ; ClassNodeWrapper klass ; public void setUp ( ) { RootNode rootNode = new StringDocumentProvider ( ""<STR_LIT>"" , ""<STR_LIT>"" ) . getRootNode ( ""<STR_LIT>"" ) ; klass = new ClassNodeWrapper ( new RealClassNodeWrapper ( ( ( NewlineNode ) rootNode . getBodyNode ( ) ) . getNextNode ( ) ) ) ; } private MethodNodeWrapper createReaderMethod ( String name ) { MethodNodeWrapper wrapper = new MethodNodeWrapper ( new DefnNode ( EMPTY_POSITION , new ArgumentNode ( EMPTY_POSITION , name ) , new ArgsNode ( EMPTY_POSITION , null , null , null , null , null ) , new LocalStaticScope ( null ) , null ) , klass ) ; return wrapper ; } private MethodNodeWrapper createWriterMethod ( String name ) { MethodNodeWrapper wrapper = new MethodNodeWrapper ( new DefnNode ( EMPTY_POSITION'}]",", new ArgumentNode ( EMPTY_POSITION, name ), new ArgsNode ( EMPTY_POSITION, null, null, null, null, null ), new LocalStaticScope ( null ), null ), klass ) ; return wrapper ; } public void testMethodNodeWrapper ( ) { MethodNodeWrapper reader = createReaderMethod ( ""read"" ) ; MethodNodeWrapper writer = createWriterMethod ( ""write"" ) ; // TODO: test the wrapper }",0.0001420288075581344
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . preproc ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; public class PreProcTests extends TestCase { public static Test'}]",suite() { return new TestSuite(PreProcTests.class); },3.352700102310803e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; import java . util . List ; import net . sf . sveditor . core . db . stmt . SVDBVarDimItem ; public class SVDBTypeInfoBuiltin extends SVDBTypeInfo { public static final int TypeAttr_Signed = ( <NUM_LIT:1> << <NUM_LIT:7> ) ; public static final int TypeAttr_Unsigned = ( <NUM_LIT:1> << <NUM_LIT:8> ) ; public int fAttr ; public List < SVDBVarDimItem > fVectorDim ; public SVDBTypeInfoBuiltin ( ) { this ( ""<STR_LIT>"" ) ; } public SVDBTypeInfoBuiltin ( String typename ) { super ( typename , SVDBItemType . TypeInfoBuiltin ) ; } public SVDBTypeInfoBuiltin ( String typename , SVDBItemType type ) { super ( typename , type ) ; } public int getAttr ( ) { return'}]",fAttr; } public void setAttr ( int attr ) { fAttr = attr; } public List<SVDBVarDimItem> getVectorDim() { return fVectorDim; } public void setVectorDim(List<SVDBVarDimItem> vectorDim) { fVectorDim = vectorDim; } },0.00010075420386077992
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . handlers ; import javax . management . MBeanAttributeInfo ; import javax . management . MBeanException ; import javax . management . MBeanNotificationInfo ; import javax . management . MBeanOperationInfo ; import javax . management . ReflectionException ; import org . oddjob . jmx . RemoteOperation ; import org . oddjob . jmx . client . ClientHandlerResolver ; import org . oddjob . jmx . client . HandlerVersion ; import org . oddjob . jmx . client . VanillaHandlerResolver ; import org . oddjob . jmx . server . JMXOperationPlus ; import org . oddjob . jmx . server . ServerInterfaceHandler ; import org . oddjob . jmx . server . ServerInterfaceHandlerFactory ; import org . oddjob . jmx . server . ServerSideToolkit ; public class RunnableHandlerFactory implements ServerInterfaceHandlerFactory < Runnable , Runnable > { public static final HandlerVersion VERSION = new HandlerVersion ( <NUM_LIT:1> , <NUM_LIT:0> ) ; private static final JMXOperationPlus < Void > RUN = new JMXOperationPlus < Void > ( ""<STR_LIT>"" , ""<STR_LIT>"" , Void . TYPE , MBeanOperationInfo . ACTION ) ; public Class < Runnable > interfaceClass ( ) { return Runnable . class ; } public MBeanAttributeInfo [ ] getMBeanAttributeInfo ( ) { return new MBeanAttributeInfo [ <NUM_LIT:0> ] ; } public MBeanOperationInfo [ ] getMBeanOperationInfo ( ) { return new MBeanOperationInfo [ ] { RUN . getOpInfo ( ) } ; } public MBeanNotificationInfo [ ] getMBeanNotificationInfo ( ) { return new MBeanNotificationInfo [ <NUM_LIT:0> ] ; } public ServerInterfaceHandler createServerHandler ( Runnable target , ServerSideToolkit ojmb ) { return new RunnableServerHandler ( target , ojmb ) ; } public ClientHandlerResolver < Runnable > clientHandlerFactory ( ) { return new VanillaHandlerResolver < Runnable > ( Runnable . class . getName ( ) ) ; } class RunnableServerHandler'}]","extends ServerInterfaceHandler<Runnable> { private final Runnable target; private final ServerSideToolkit ojmb; public RunnableServerHandler(Runnable target, ServerSideToolkit ojmb) { super(); this.target = target; this.ojmb = ojmb; } @Override public Object invoke(Object name, Object[] params, String actionName, InvocationTargetException iet) throws MBeanException, ReflectionException { if (actionName.equals(RUN.getName())) { return target.run(); } else { throw new MBeanException(new ReflectionException(""Unknown action: "" + actionName)); } } } }",0.00018296428366180344
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . hibernate ; import static org . junit . Assert . assertFalse ; import java . lang . reflect . Method ; import java . util . Calendar ; import org . junit . Test ; import br . com . caelum . vraptor . dash . hibernate . stats . OpenRequest ; public class OpenRequestTest { @ Test public void openRequestIdsMustBeDifferent ( ) throws Exception { Class < ? > clazz = Class . class ; Method method = clazz . getDeclaredMethods ( ) [ <NUM_LIT:0> ] ; Calendar now = Calendar . getInstance ( ) ; OpenRequest request1 = new OpenRequest'}]","( ""request1"", now. getTimeInMillis ( ) ) ; OpenRequest request2 = new OpenRequest ( ""request2"", now. getTimeInMillis ( ) ) ; assertFalse ( request1. getId ( ) == request2. getId ( ) ) ; } }",8.508502547196193e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . windgate ; import java . util . HashMap ; import java . util . Map ; import com . asakusafw . windgate . core . DriverScript ; import com . asakusafw . windgate . core . vocabulary . DataModelStreamSupport ;'}]",import com.asakusafw.windgate.core.vocabulary.DataModelStreamSupport;,3.726033508173143e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow . graph ; import java . text . MessageFormat ; public enum ObservationCount implements FlowElementAttribute { DONT_CARE ( false , false ) { @ Override public ObservationCount and ( ObservationCount other ) { if ( other == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return other ; } } , AT_MOST_ONCE ( true , false ) { @ Override public ObservationCount and ( ObservationCount other ) { if ( other == null ) { throw new'}]","IllegalArgumentException ( ""<STR_LIT>"" ) ; if ( other == this ) { return this ; } return other ; } }, EXACTLY_ONCE ( true, true ) { @ Override public ObservationCount and ( ObservationCount other ) { if ( other == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( other == this ) { return this ; } return other ; } } ; private final boolean isAtLeastOnce ; private final boolean isExactlyOnce ; ObservationCount ( boolean isAtLeastOnce, boolean isExactlyOnce ) { this. isAtLeastOnce = isAtLeastOnce ; this. isExactlyOnce = isExactlyOnce ; } public boolean isAtLeastOnce ( ) { return isAtLeastOnce ; } public boolean isExactlyOnce ( ) { return isExactlyOnce ; } public static ObservationCount valueOf ( String id ) throws IllegalArgumentException { if ( id == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } if ( id. equals ( ""DONT_CARE"" ) ) { return DONT_CARE ; } if ( id. equals ( ""AT_MOST_ONCE"" ) ) { return AT_MOST_ONCE ; } if ( id. equals ( ""EXACTLY_ONCE"" )",0.00034304400826328646
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . directio . csv . driver ; import com . asakusafw . dmdl . directio . csv . driver . CsvFieldTrait . Kind ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . dmdl . spi . PropertyAttributeDriver ; import com . asakusafw'}]",".dmdl.directio.csv.driver.CsvFieldTrait;public class CsvPropertyAttributeDriver implements PropertyAttributeDriver<AstAttribute, Kind> { @Override public void setProperty(DmdlSemantics dmdl, PropertyDeclaration prop, AstAttribute attr, Kind kind, String value) throws Exception { // implementation } }",9.46356541770042e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui ; import'}]","javax.swing.border.Border; import org.rubypeople.rdt.refactoring.ui.model.RefactoringModel; import org.rubypeople.rdt.refactoring.ui.view.RefactoringView; public class RefactoringController { private RefactoringModel model; private RefactoringView view; public RefactoringController(RefactoringModel model, RefactoringView view) { this.model = model; this.view = view; } public void setModel(RefactoringModel model) { this.model = model; } public void setView(RefactoringView view) { this.view = view; } public void updateView() { view.update(model); } }",0.00017668789481720373
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . oddjob . Resetable ;'}]",@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Resetable public @interface Reset;,4.749485834889266e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . modelgen . util ; import com . asakusafw . modelgen . model . ModelDescription ; import com . asakusafw . modelgen . model . ModelReference ; public abstract class ModelBuilder < T extends ModelBuilder < T > > { private String namespace ; private String simpleName ; public ModelBuilder ( String simpleName ) { if ( simpleName == null ) {'}]","throw new IllegalArgumentException(""simpleName must not be null"");this.simpleName = simpleName;}public abstract T addDescription(ModelDescription description);public T setNamespace(String namespace){if (namespace == null){throw new IllegalArgumentException(""namespace must not be null"");}this.namespace = namespace;return this;}",8.99820607177434e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamelocal ; import org . jruby . ast . MethodDefNode ; import org . jruby . ast . Node ; import org . jruby . ast . types . INameNode ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; public class RenameLocalConfig implements IRefactoringConfig { private IDocumentProvider docProvider ; private int caretPosition ; private Node selectedNode ; private Node selectedMethod ; private String [ ] localNames ; private RenameLocalEditProvider editProvider ; public RenameLocalConfig ( IDocumentProvider docProvider , int caretPosition ) { this'}]",".docProvider = docProvider; this.caretPosition = caretPosition; this.localNames = findLocalNames(selectedMethod); } public RenameLocalConfig ( IDocumentProvider docProvider, int caretPosition, Node selectedNode, Node selectedMethod ) { this. docProvider = docProvider ; this. caretPosition = caretPosition ; this. selectedNode = selectedNode ; this. selectedMethod = selectedMethod ; this. localNames = findLocalNames ( selectedMethod ) ; this. editProvider = new RenameLocalEditProvider ( this ) ; } // getters and setters... private String [ ] findLocalNames ( Node methodNode ) { // implementation } }",0.00018724130592186964
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . visualizer ; import java . util . UUID ; import com . asakusafw . compiler . common . Precondition ; public class VisualLabel implements VisualNode { private final UUID id = UUID . randomUUID ( ) ; private String label ; public VisualLabel ( String label ) { this . label = label ; } @ Override public Kind getKind ( ) { return Kind . LABEL ; } @ Override public UUID getId ( ) { return id ; } public String getLabel ( ) { return label ; } @ Override public < R'}]","> R result, VisualVisitor < R > visitor ) { Precondition. checkNotNull ( visitor ) ; return visitor. visitLabel ( this ) ; } }",5.79014776949755e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . bulkloader . testing . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Writable ; import com . asakusafw . compiler . bulkloader . testing . io . SystemColumnsInput ; import com . asakusafw . compiler . bulkloader . testing . io . SystemColumnsOutput ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . model . PropertyOrder ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . vocabulary . bulkloader . ColumnOrder ; import com . asakusafw . vocabulary . bulkloader . OriginalName ; @ ColumnOrder ( value = { ""<STR_LIT>"" } ) @ DataModelKind ( ""<STR_LIT>"" ) @ ModelInputLocation ( SystemColumnsInput . class ) @ ModelOutputLocation ( SystemColumnsOutput . class ) @ OriginalName ( value = ""<STR_LIT>"" ) @ PropertyOrder ( { ""<STR_LIT>"" } ) public class SystemColumns implements DataModel < SystemColumns >'}]",", Writable { private LongOption id; private LongOption name; private LongOption created; private LongOption updated; // getters and setters for the above fields }",6.376888919595449e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . testing ; import java . text . MessageFormat ; import java . util . Set ; import com . asakusafw . vocabulary . external . ImporterDescription ; public abstract class TemporaryInputDescription implements ImporterDescription { @ Override public DataSize getDataSize ( ) { return DataSize . UNKNOWN ; } public abstract Set < String > getPaths ('}]",) throws IOException;,2.1969954093741562e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages ; public class ConverterPageParameters { private boolean inCurrentMethodRadioEnabled = true ; private boolean inClassConstructorRadioEnabled = true ; private boolean deaclareAsClassFieldEnabled = true ; public ConverterPageParameters ( boolean inCurrentMethodRadioEnabled , boolean inClassConstructorRadioEnabled , boolean deaclareAsClassField ) { this . inCurrentMethodRadioEnabled = inCurrentMethodRadioEnabled ; this . inClassConstructorRadioEnabled = inClassConstructorRadioEnabled ; this . deaclareAsClassFieldEnabled = deaclareAsClassField ; } public ConverterPageParameters ( ) { } public boolean isDeaclareAsClassField ( ) { return deaclareAsClassFieldEnabled ; } public void setDeaclareAsClassField ( boolean deaclareAsClassField ) { this . deaclareAsClassFieldEnabled = deaclareAsClassField ; } public boolean isInClassConstructorRadioEnabled ( ) { return inClassConstructorRadioEnabled ; } public void'}]",setInClassConstructorRadioEnabled(boolean inClassConstructorRadioEnabled) { this.inClassConstructorRadioEnabled = inClassConstructorRadioEnabled; } public boolean isInCurrentMethodRadioEnabled() { return inCurrentMethodRadioEnabled; } public void setInCurrentMethodRadioEnabled(boolean inCurrentMethodRadioEnabled) { this.inCurrentMethodRadioEnabled = inCurrentMethodRadioEnabled; },0.00011596977846895826
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . core . gems ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . List ; import java . util . SortedSet ; import java . util . StringTokenizer ; import java . util . TreeSet ; public class LogicalGem extends Gem { private Collection < Gem > gems ; private LogicalGem ( Collection < Gem > gems , String name , String version , String description ) { super ( name , version , description ) ; this . gems = gems ; } public static LogicalGem create ( Collection < Gem > gems ) { if ( gems == null || gems . isEmpty ( ) ) throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; String name = null ; String description = null ; String version = ""<STR_LIT:(>"" ; for ( Gem gem : gems ) { if ( name == null ) name = gem . getName ( ) ; if ( description == null ) description = gem . getDescription ( ) ; version += gem . getVersion ( ) + ""<STR_LIT:U+002CU+0020>"" ; } version = new String ( version . substring ( <NUM_LIT:0> , version . length ( ) - <NUM_LIT:2> ) ) ; version += \'<CHAR_LIT:)>\' ; return new LogicalGem ( gems , name , version , description ) ; } public SortedSet < String > getVersions ( ) { String raw = new String ( getVersion ( ) . substring ( <NUM_LIT:1> , getVersion ( ) . length ( ) - <NUM_LIT:1> ) ) ; SortedSet < String > version = new TreeSet < String > ( new VersionComparator ( ) ) ; StringTokenizer tokenizer = new StringTokenizer ( raw , ""<STR_LIT:U+002C>"" ) ; while ( tokenizer . hasMoreTokens ( ) ) { version . add ( tokenizer . nextToken ( ) . trim ( ) ) ; } return version ; } private class VersionComparator implements Comparator < String > { public int compare ( String v1 , String v2 ) { List < Integer > v1Parts = getParts ( v1 ) ; List < Integer > v2Parts = getParts ( v2 ) ; int blah = Math . min ( v1Parts . size ( ) , v2Parts . size'}]",") ; for ( int i = 0 ; i < blah ; i ++ ) { int part1 = v1Parts. get ( i ) ; int part2 = v2Parts. get ( i ) ; if ( part1!= part2 ) { return part1 - part2 ; } } return v1Parts. size ( ) - v2Parts. size ( ) ; } private List < Integer > getParts ( String version ) { List < Integer > parts = new ArrayList < Integer > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( version, ""<STR_LIT:U+002E>"" ) ; while ( tokenizer. hasMoreTokens ( ) ) { parts. add ( Integer. valueOf ( tokenizer. nextToken ( ) ) ) ; } return parts ; } }",0.00023864544586058074
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package hudson . jbpm ; import hudson . model . Hudson ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . HashMap ; import java . util . Map ; import org . apache . commons . io . IOUtils ; import org . jbpm . file . def . FileDefinition ; import org . jbpm . graph . def . ProcessDefinition ; public class ProcessClassLoaderCache { public static final ProcessClassLoaderCache INSTANCE = new ProcessClassLoaderCache ( ) ; private Map < Long , ClassLoader > cache = new HashMap < Long , ClassLoader > ( ) ; private File cacheRoot = new File ( Hudson . getInstance ( ) . getRootDir ( ) , ""<STR_LIT>"" ) ; private ProcessClassLoaderCache ( ) { } public synchronized ClassLoader getClassLoader ( ProcessDefinition def ) throws IOException { ClassLoader cl = cache . get ( def . getId ( ) ) ;'}]","if (cl == null) { URL url = new URL(def.getURL()); URLClassLoader loader = URLClassLoader.newInstance(url.toURI().toURL(), this.getClass().getClassLoader()); IOUtils.copy(loader.getResourceAsStream(def.getFileName()), new FileOutputStream(new File(cacheRoot, def.getFileName()))); cl = URLClassLoader.newInstance(new URL[]{new URL(cacheRoot.toURI().toURL(), def.getFileName())}, this.getClass().getClassLoader()); cache.put(def.getId(), cl); } return cl; } }",0.000142670810679857
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . project ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; public class SVDBSourceCollection { private String fBaseLocation ; private List < String > fIncludes ; private List < String > fExcludes ; private boolean fDefaultIncExcl ; public SVDBSourceCollection ( String base_location , boolean dflt_inc_excl ) { fBaseLocation = base_location ; fIncludes = new ArrayList < String > ( ) ; fExcludes = new ArrayList < String > ( ) ; setDefaultIncExcl ( dflt_inc_excl ) ; } public String getBaseLocation ( ) { return fBaseLocation ; } public boolean getDefaultIncExcl ( ) { return fDefaultIncExcl ; } public void setDefaultIncExcl ( boolean dflt_inc_excl ) { if ( fDefaultIncExcl != dflt_inc_excl ) { if ( dflt_inc_excl ) { fIncludes . clear ( ) ; fExcludes . clear ( ) ; fIncludes . addAll ( SVDBSourceCollection . parsePatternList ( SVCorePlugin . getDefault ( ) . getDefaultSourceCollectionIncludes ( ) ) ) ; fExcludes . addAll ( SVDBSourceCollection . parsePatternList ( SVCorePlugin'}]",".getDefault ( ). getDefaultSourceCollectionExcludes ( ) ) ; } else { fIncludes. clear ( ) ; fExcludes. clear ( ) ; fIncludes. addAll ( SVDBSourceCollection. parsePatternList ( SVCorePlugin. getDefault ( ). getDefaultSourceCollectionIncludes ( ) ) ) ; fExcludes. addAll ( SVDBSourceCollection. parsePatternList ( SVCorePlugin. getDefault ( ). getDefaultSourceCollectionExcludes ( ) ) ) ; } fDefaultIncExcl = dflt_inc_excl ; } public void setBaseLocation ( String base_location ) { fBaseLocation = base_location ; } public void addInclude ( String include ) { fIncludes. add ( include ) ; } public void addExclude ( String exclude ) { fExcludes. add ( exclude ) ; } public List < String > getIncludes ( ) { return fIncludes ; } public List < String > getExcludes ( ) { return fExcludes ; } private static List < String > parsePatternList ( String patterns ) { if ( patterns == null ) { return new ArrayList < String > ( ) ; } String [ ] parts = patterns. split ( "","" ) ; List < String > result = new ArrayList < String > ( ) ;",0.0003456960381515112
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . IParameterValues ; public final class ContentAssistComputerParameter implements IParameterValues { public Map getParameterValues ( ) { Collection descriptors = CompletionProposalComputerRegistry . getDefault ( ) . getProposalCategories'}]","(); Map<String, Collection<String>> map = new HashMap<>(); for (Iterator it = descriptors.iterator(); it.hasNext();) { String descriptor = (String) it.next(); map.put(descriptor, new ArrayList<>()); } return map; } }",2.771537259686233e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; public class SVDBInterfaceDecl extends SVDBModIfcDecl { public SVDBInterfaceDecl ( ) { super ( ""<STR_LIT>"" , SVDBItemType .'}]","INTERFACE, new String [ ] { }, new String [ ] { }, new String [ ] { }, new String [ ] { } ) ; }",5.76266372673458e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . model ; public class HackJavaValue extends JavaValue { private final String value ; private final int size ; public HackJavaValue ( String value , int size ) { this . value = value ;'}]",this.size = size; } public String getValue() { return value; } public int getSize() { return size; } },4.728034973202065e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . io ; import java . io . IOException ; import test . modelgen . model . Bar ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class BarModelInput implements ModelInput < Bar > { private final RecordParser parser ; public BarModelInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ) ; } this . parser = parser ; } @ Override public boolean readTo ( Bar model ) throws IOException { if ( parser . next ( ) == false ) { return false ; } parser . fill ( model . getPkOption ( ) ) ; parser . fill ( model . getDetailGroupIdOption ( ) ) ; parser . fill ( model . getDetailTypeOption ( ) ) ; parser . fill ( model . getDetailSenderIdOption ( ) ) ; parser . fill ( model . getDetailReceiverIdOption ( ) ) ; parser . fill ( model . getDetailTestTypeOption ( ) ) ; parser . fill ( model . getDetailStatusOption ( ) ) ;'}]",return true; } @Override public void close() throws IOException { parser.close(); } },4.33385048335174e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . beanbus ; import java . util . EventObject ; public class BusEvent extends EventObject {'}]","private String source; public BusEvent(Object source) { super(source); } public BusEvent(Object source, String message) { super(source); this.source = message; } }",6.0223547585000234e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . prop_pages ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . project . SVDBPath ; import net . sf . sveditor . core . db . project . SVProjectFileWrapper ; import net . sf . sveditor . ui . SVUiPlugin ; import org . eclipse . core . resources . IProject ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ListViewer ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; public class IncludePathsPage implements ISVProjectPropsPage , IStructuredContentProvider , ILabelProvider { private ListViewer fIncludePathViewer ; private SVProjectFileWrapper fProjectWrapper ; private List < SVDBPath > fIncludePaths ; private Button fAdd ; private Button fRemove ; private Button fEdit ; private IProject fProject ; public IncludePathsPage ( IProject p ) { fIncludePaths = new ArrayList < SVDBPath > ( ) ; fProject = p ; } public void init ( SVProjectFileWrapper project_wrapper ) { fProjectWrapper = project_wrapper ; fIncludePaths . clear ( ) ; for ( SVDBPath p : fProjectWrapper . getIncludePaths ( ) ) { fIncludePaths . add ( p . duplicate ( ) ) ; } } public Control createContents ( Composite parent ) { Composite frame = new Composite ( parent , SWT . NONE ) ; frame . setLayout ( new GridLayout ( <NUM_LIT:2> , false ) ) ; fIncludePathViewer = new ListViewer ( frame , SWT . BORDER ) ; fIncludePathViewer . getControl ( ) . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; fIncludePathViewer . setContentProvider ( this ) ; fIncludePathViewer . setLabelProvider ( this ) ; fIncludePathViewer . setInput ( fIncludePaths ) ; fIncludePathViewer . addSelectionChangedListener ( new ISelectionChangedListener ( ) { public void selectionChanged ( SelectionChangedEvent event ) { updateSelection ( ) ; } } ) ; Composite button_bar = new Composite ( frame , SWT . NONE ) ; button_bar . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , false , true ) ) ; button_bar . setLayout ( new GridLayout ( <NUM_LIT:1> , true ) ) ; fAdd = new Button ( button_bar , SWT .'}]","BUTTON);fAdd.setText(SVUiPlugin.messages.getString(""Add""));fAdd.addSelectionListener(new SelectionListener(){public void widgetSelected(SelectionEvent event){addIncludePath();}public void widgetDefaultSelected(SelectionEvent event){} });fRemove=new Button(button_bar, SWT.BUTTON);fRemove.setText(SVUiPlugin.messages.getString(""Remove""));fRemove.addSelectionListener(new SelectionListener(){public void widgetSelected(SelectionEvent event){removeIncludePath();}public void widgetDefaultSelected(SelectionEvent event){} });fEdit=new Button(button_bar, SWT.BUTTON);fEdit.setText(SVUiPlugin.messages.getString(""Edit""));fEdit.addSelectionListener(new SelectionListener(){public void widgetSelected(SelectionEvent event){editIncludePath();}public void widgetDefaultSelected(SelectionEvent event){} });return frame;}",0.00025338415347469866
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . testing . jobflow ; import com . asakusafw . testdriver . testing . flowpart . SimpleFlowPartFactory ; import com . asakusafw . testdriver . testing . flowpart . SimpleFlowPartFactory . SimpleFlowPart ; import com . asakusafw . testdriver . testing . model . Simple ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com .'}]",.asakusafw.vocabulary.flow.Out; public class SimpleFlowPartFactoryTest extends SimpleFlowPartFactoryTestBase { @Test public void test() throws Exception { SimpleFlowPartFactory factory = new SimpleFlowPartFactory(); FlowDescription description = factory.create(new Simple()); Export export = description.getExport(); Import import1 = description.getImport(In.class); Import import2 = description.getImport(In.class); // Add the following line to the test method Out out = description.getOut(); } },0.00014318482659141367
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . buildpath ; import java . lang . reflect . InvocationTargetException ; import java . util . List ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . DialogPackageExplorerActionGroup ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage . LoadpathModifierOperation ; public class ExcludeOperation extends LoadpathModifierOperation { public ExcludeOperation ( ILoadpathModifierListener listener , ILoadpathInformationProvider informationProvider ) { super ( listener , informationProvider , NewWizardMessages . NewSourceContainerWorkbookPage_ToolBar_Exclude_tooltip , ILoadpathInformationProvider . EXCLUDE ) ; }'}]","@Override public void createLoadpath ( IProgressMonitor monitor ) throws CoreException, InvocationTargetException, InterruptedException { super. createLoadpath ( monitor ) ; }",5.901564935994943e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ;'}]",import org.eclipse.swt.widgets.Display;,2.5030058355354948e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import org . oddjob . arooa . design . DesignFactory ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignProperty ; import org . oddjob . arooa . design . SimpleTextAttribute ; import org . oddjob . arooa . design . screem . BorderedGroup ; import org . oddjob . arooa . design . screem . Form ; import org .'}]","oddjob.arooa.design.screem.Text; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class FormComponent extends BorderedGroup { private static final Logger LOG = LoggerFactory.getLogger(FormComponent.class); private Form form; public FormComponent(DesignFactory factory, DesignInstance instance) { super(factory, instance); form = factory.create(Form.class, instance); } public void setCaption(SimpleTextAttribute caption) { form.setCaption(caption); } public void setCaption(String caption) { form.setCaption(new SimpleTextAttribute(caption)); } public void setForm(Form form) { this.form = form; } public Form getForm() { return form; } }",0.00019546339251069189
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . client ; import java . io . Serializable ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import javax . management . Attribute ; import javax . management . AttributeList ; import javax . management . AttributeNotFoundException ; import javax . management . DynamicMBean ; import javax . management . InstanceNotFoundException ; import javax . management . IntrospectionException ; import javax . management . InvalidAttributeValueException ; import javax . management . MBeanAttributeInfo ; import javax . management . MBeanConstructorInfo ; import javax . management . MBeanException ; import javax . management . MBeanInfo ; import javax . management . MBeanNotificationInfo ; import javax . management . MBeanOperationInfo ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . NotificationBroadcasterSupport ; import javax . management . ObjectName ; import javax . management . ReflectionException ; import junit . framework . TestCase ; import org . apache . commons . beanutils . DynaBean ; import org . apache . commons . beanutils . DynaClass ; import org . apache . commons . beanutils . DynaProperty ; import org . apache . log4j . Logger ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ClassResolver ; import org . oddjob . arooa . MockArooaDescriptor ; import org . oddjob . arooa . MockArooaSession ; import org . oddjob . arooa . MockClassResolver ; import org . oddjob . arooa . beanutils . BeanUtilsPropertyAccessor ; import org . oddjob . arooa . registry . Address ; import org . oddjob . arooa . registry . BeanRegistry ; import org . oddjob . arooa . registry . MockBeanRegistry ; import org . oddjob . arooa . registry . Path ; import org . oddjob . arooa . registry . ServerId ; import org . oddjob . arooa . registry . SimpleBeanRegistry ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . describe . UniversalDescriber ; import org . oddjob . jmx . RemoteOddjobBean ; import org . oddjob . jmx . handlers . DynaBeanHandlerFactory ; import org . oddjob . jmx . handlers . LogPollableHandlerFactory ; import org . oddjob . jmx . handlers . ObjectInterfaceHandlerFactory ; import org . oddjob . jmx . handlers . RemoteOddjobHandlerFactory ; import org . oddjob . jmx . handlers . RunnableHandlerFactory ; import org . oddjob . jmx . server . MockServerSession ; import org . oddjob . jmx . server . OddjobMBean ; import org . oddjob . jmx . server . OddjobMBeanFactory ; import org . oddjob . jmx . server . ServerContext ; import org . oddjob . jmx . server . ServerContextImpl ; import org . oddjob . jmx . server . ServerInfo ; import org . oddjob . jmx . server . ServerInterfaceManagerFactoryImpl ; import org . oddjob . jmx . server . ServerModel ; import org . oddjob . jmx . server . ServerModelImpl ; import org . oddjob . logging . LogEnabled ; import org . oddjob . logging . LogEvent ; import org . oddjob . logging . LogLevel ; import org . oddjob . util . MockThreadManager ; public class ClientNodeTest extends TestCase { public static final Logger logger = Logger . getLogger ( ClientNodeTest . class ) ; public interface OJMBeanInternals extends RemoteOddjobBean { public String toString ( ) ; } int unique ; public abstract class BaseMockOJMBean extends NotificationBroadcasterSupport implements OJMBeanInternals { int instance = unique ++ ; protected final Set < ClientHandlerResolver < ? > > handlerFactories = new HashSet < ClientHandlerResolver < ? > > ( ) ; { handlerFactories . add ( new RemoteOddjobHandlerFactory ( ) . clientHandlerFactory ( ) ) ; handlerFactories . add ( new ObjectInterfaceHandlerFactory ( ) . clientHandlerFactory ( ) ) ; } public ServerInfo serverInfo ( ) { return new ServerInfo ( new Address ( new ServerId ( url ( ) ) , new Path ( id ( ) ) ) , ( ClientHandlerResolver [ ] ) handlerFactories . toArray ( new ClientHandlerResolver [ <NUM_LIT:0> ] ) ) ; } public void noop ( ) { } protected String url ( ) { return ""<STR_LIT>"" ; } protected String id ( ) { return ""<STR_LIT:x>"" + instance ; } public String toString ( ) { return ""<STR_LIT>"" ; } public String loggerName ( ) { return ""<STR_LIT>"" ; } } public interface SimpleMBean extends OJMBeanInternals { } public class Simple extends BaseMockOJMBean implements SimpleMBean { public String toString ( ) { return ""<STR_LIT:test>"" ; } } private class OurArooaSession extends MockArooaSession { @ Override public ArooaDescriptor getArooaDescriptor ( ) { return new MockArooaDescriptor ( ) { @ Override public ClassResolver getClassResolver ( ) { return new MockClassResolver ( ) { @ Override public Class < ? > findClass ( String className ) { try { return Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } } } ; } } ; } } public void testSimple ( ) throws Exception { Simple mb = new Simple ( ) ; MBeanServer mbs = MBeanServerFactory . createMBeanServer ( ) ; ObjectName on = new ObjectName ( ""<STR_LIT>"" ) ; mbs . registerMBean ( mb , on ) ; ClientSessionImpl clientSession = new ClientSessionImpl ( mbs , new DummyNotificationProcessor ( ) , new OurArooaSession ( ) , logger ) ; Object proxy = clientSession . create ( on ) ; assertEquals ( ""<STR_LIT:test>"" , proxy . toString ( ) ) ; } public void testEquals ( ) throws Exception { Simple mb = new Simple ( ) ; MBeanServer mbs = MBeanServerFactory . createMBeanServer ( ) ; ObjectName on = new ObjectName ( ""<STR_LIT>"" ) ; mbs . registerMBean ( mb , on ) ; ClientSessionImpl clientSession = new ClientSessionImpl ( mbs , new DummyNotificationProcessor ( ) , new OurArooaSession ( ) , logger ) ; Object proxy = clientSession . create ( on ) ; assertEquals ( proxy , proxy ) ; assertEquals ( proxy . hashCode ( ) , proxy . hashCode ( ) ) ; } public interface MockRunnableMBean extends Runnable , OJMBeanInternals { } public class MockRunnable extends BaseMockOJMBean implements MockRunnableMBean { boolean ran ; public MockRunnable ( ) { handlerFactories . add ( new RunnableHandlerFactory ( ) . clientHandlerFactory ( ) ) ; } public void run ( ) { ran = true ; } } private BeanRegistry cr ; public void setUp ( ) { logger . debug ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; System . setProperty ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; cr = new SimpleBeanRegistry ( ) ; cr . register ( ""<STR_LIT>"" , this ) ; } public void testRunnable ( ) throws Exception { MockRunnable mb = new MockRunnable ( ) ; MBeanServer mbs = MBeanServerFactory . createMBeanServer ( ) ; ObjectName on = new ObjectName ( ""<STR_LIT>"" ) ; mbs . registerMBean ( mb , on ) ; ClientSessionImpl clientSession = new ClientSessionImpl ( mbs , new DummyNotificationProcessor ( ) , new OurArooaSession ( ) , logger ) ; Object proxy = clientSession . create ( on ) ; assertTrue ( ""<STR_LIT>"" , proxy instanceof Runnable ) ; ( ( Runnable ) proxy ) . run ( ) ; assertTrue ( ""<STR_LIT>"" , mb . ran ) ; } public static class Fred implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public String getFruit ( ) { return ""<STR_LIT>"" ; } } public class MyDC implements DynaClass , Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DynaProperty [ ] getDynaProperties ( ) { return new DynaProperty [ ] { new DynaProperty ( ""<STR_LIT>"" , Fred . class ) , } ; } public DynaProperty getDynaProperty ( String arg0 ) { return new DynaProperty ( arg0 ) ; } public String getName ( ) { return ""<STR_LIT>"" ; } public DynaBean newInstance ( ) throws IllegalAccessException , InstantiationException { throw new UnsupportedOperationException ( ""<STR_LIT>"" ) ; } } public class Bean implements DynaBean , LogEnabled { public boolean contains ( String name , String key ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + key + ""<STR_LIT:)>"" ) ; return false ; } public Object get ( String name ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:)>"" ) ; if ( ""<STR_LIT>"" . equals ( name ) ) { return new Fred ( ) ; } else if ( ""<STR_LIT:description>"" . equals ( name ) ) { Map < Object , Object > m = new HashMap < Object , Object > ( ) ; m . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; return m ; } return null ; } public Object get ( String name , int index ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + index + ""<STR_LIT:)>"" ) ; return null ; } public Object get ( String name , String key ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + key + ""<STR_LIT:)>"" ) ; return null ; } public DynaClass getDynaClass ( ) { logger . debug ( ""<STR_LIT>"" ) ; return new MyDC ( ) ; } public void remove ( String name , String key ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + key + ""<STR_LIT:)>"" ) ; } public void set ( String name , int index , Object value ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + index + ""<STR_LIT:U+002CU+0020>"" + value + ""<STR_LIT:)>"" ) ; } public void set ( String name , Object value ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + value + ""<STR_LIT:)>"" ) ; } public void set ( String name , String key , Object value ) { logger . debug ( ""<STR_LIT>"" + name + ""<STR_LIT:U+002CU+0020>"" + key + ""<STR_LIT:U+002CU+0020>"" + value + ""<STR_LIT:)>"" ) ; } public String loggerName ( ) { return ""<STR_LIT>"" ; } } public class MyDynamicMBean extends NotificationBroadcasterSupport implements DynamicMBean { public Object getAttribute ( String attribute ) throws AttributeNotFoundException , MBeanException , ReflectionException { logger . debug ( ""<STR_LIT>"" + attribute + ""<STR_LIT:]>"" ) ; throw new UnsupportedOperationException ( ) ; } public AttributeList getAttributes ( String [ ] attributes ) { return null ; } public MBeanInfo getMBeanInfo ( ) { return new MBeanInfo ( this . getClass ( ) . getName ( ) , ""<STR_LIT>"" , new MBeanAttributeInfo [ <NUM_LIT:0> ] , new MBeanConstructorInfo [ <NUM_LIT:0> ] , new MBeanOperationInfo [ <NUM_LIT:0> ] , new MBeanNotificationInfo [ <NUM_LIT:0> ] ) ; } public Object invoke ( String actionName , Object [ ] arguments , String [ ] signature ) throws MBeanException , ReflectionException { logger . debug ( ""<STR_LIT>"" + actionName + ""<STR_LIT:]>"" ) ; if ( ""<STR_LIT>"" . equals ( actionName ) ) { return ""<STR_LIT>"" ; } else if ( ""<STR_LIT>"" . equals ( actionName ) ) { return new ServerInfo ( new Address ( new ServerId ( ""<STR_LIT>"" ) , new Path ( ""<STR_LIT>"" ) ) , new ClientHandlerResolver [ ] { new ObjectInterfaceHandlerFactory ( ) . clientHandlerFactory ( ) , new RemoteOddjobHandlerFactory ( ) . clientHandlerFactory ( ) , new DynaBeanHandlerFactory ( ) . clientHandlerFactory ( ) } ) ; } else if ( ""<STR_LIT>"" . equals ( actionName ) ) { return ""<STR_LIT>"" ; } else if ( ""<STR_LIT>"" . equals ( actionName ) ) { return ""<STR_LIT>"" ; } else if ( ""<STR_LIT>"" . equals ( actionName ) ) { return new MyDC ( ) ; } else if ( ""<STR_LIT:get>"" . equals ( actionName ) ) { return new Fred ( ) ; } else { throw new MBeanException ( new UnsupportedOperationException ( ""<STR_LIT>"" + actionName +'}]","""<STR_LIT>)"" ) ) ; } public String getImplementationClassName ( ) { return this. getClass ( ). getName ( ) ; } public Object getManagedResource ( ) { return null ; } public Object getNotificationInfo ( ) { return new MBeanNotificationInfo [ <NUM_LIT:0> ] ; } public void setAttribute ( Attribute attribute ) throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException { logger. debug ( ""<STR_LIT>"" + attribute. getName ( ) + ""<STR_LIT:U+002CU+0020>"" + attribute. getValue ( ) + ""<STR_LIT:)>"" ) ; } public void setAttributes ( AttributeList attributes ) throws MBeanException, ReflectionException { logger. debug ( ""<STR_LIT>"" ) ; } } public class MyMBeanFactory implements OddjobMBeanFactory { public DynamicMBean createMBean ( ObjectName name ) throws MBeanException, ReflectionException { return new MyDynamicMBean ( ) ; } } public class MyMBean extends MyDynamicMBean { } public void testMBean ( ) throws Exception { MyMBeanFactory mbeanFactory = new MyMBeanFactory ( ) ; MBeanServer mbs = MBeanServer",0.0005012327331253748
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . driver ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . apache . hadoop . io . Text ; import com . asakusafw . dmdl . java . emitter . EmitContext ; import com . asakusafw . dmdl . java . spi . JavaDataModelDriver ; import com . asakusafw . dmdl . model . AstLiteral ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . dmdl . semantics . PropertySymbol ; import com . asakusafw . dmdl . semantics . type . BasicType ; import com . asakusafw . thundergate . runtime . cache . ThunderGateCacheSupport ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . FieldDeclaration ; import com . asakusafw . utils . java . model . syntax . FormalParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . util . AttributeBuilder ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . Models ; import com . asakusafw . utils . java . model . util . TypeBuilder ; public class CacheSupportEmitter extends JavaDataModelDriver { private static final String FIELD_DELETE_FLAG_VALUE = ""<STR_LIT>"" ; @ Override public List < Type > getInterfaces ( EmitContext context , ModelDeclaration model ) throws IOException { if ( isTarget ( model ) == false ) { return Collections . emptyList ( ) ; } return Arrays . asList ( context . resolve ( ThunderGateCacheSupport . class ) ) ; } @ Override public List < FieldDeclaration > getFields ( EmitContext context , ModelDeclaration model ) throws IOException { if ( isTarget ( model ) == false ) { return Collections . emptyList ( ) ; } CacheSupportTrait trait = model . getTrait ( CacheSupportTrait . class ) ; assert trait != null ; List < FieldDeclaration > results = Lists . create ( ) ; if ( trait . getDeleteFlagValue ( ) != null ) { results . add ( createDeleteFlagValueField ( context , model , trait . getDeleteFlagValue ( ) ) ) ; } return results ; } @ Override public List < MethodDeclaration > getMethods ( EmitContext context , ModelDeclaration model ) throws IOException { if ( isTarget ( model ) == false ) { return Collections . emptyList ( ) ; } CacheSupportTrait trait = model . getTrait ( CacheSupportTrait . class ) ; assert trait != null ; List < MethodDeclaration > results = Lists . create ( ) ; results . add ( createModelVersionMethod ( context , model , trait ) ) ; results . add ( createTimestampColumnMethod ( context , model , trait . getTimestamp ( ) ) ) ; results . add ( createSystemIdMethod ( context , model , trait . getSid ( ) ) ) ; results . add ( createDeletedMethod ( context , model , trait . getDeleteFlag ( ) ) ) ; return results ; } private FieldDeclaration createDeleteFlagValueField ( EmitContext context , ModelDeclaration model , AstLiteral deleteFlagValue ) { assert context != null ; assert model != null ; assert deleteFlagValue != null ; ModelFactory f = context . getModelFactory ( ) ; Type type ; Expression value ; switch ( deleteFlagValue . kind ) { case BOOLEAN : type = context . resolve ( boolean . class ) ; value = Models . toLiteral ( f , deleteFlagValue . toBooleanValue ( ) ) ; break ; case INTEGER : type = context . resolve ( int . class ) ; value = Models . toLiteral ( f , deleteFlagValue . toIntegerValue ( ) . intValue ( ) ) ; break ; case STRING : type = context . resolve ( Text . class ) ; value = new TypeBuilder ( f , context . resolve ( Text . class ) ) . newObject ( Models . toLiteral ( f , deleteFlagValue . toStringValue ( ) ) ) . toExpression ( ) ; break ; default : throw new AssertionError ( deleteFlagValue ) ; } return f . newFieldDeclaration ( null , new AttributeBuilder ( f ) . Private ( ) . Static ( ) . Final ( ) . toAttributes ( ) , type , f . newSimpleName ( FIELD_DELETE_FLAG_VALUE ) , value ) ; } private MethodDeclaration createModelVersionMethod ( EmitContext context , ModelDeclaration model , CacheSupportTrait trait ) { assert context != null ; assert model != null ; assert trait != null ; ModelFactory f = context . getModelFactory ( ) ; List < Statement > statements = Lists . create ( ) ; statements . add ( new ExpressionBuilder ( f , Models . toLiteral ( f , computeModelVersion ( context , model , trait ) ) ) . toReturnStatement ( ) ) ; return f . newMethodDeclaration ( null , new AttributeBuilder ( f ) . annotation ( context . resolve ( Override . class ) ) . Public ( ) . toAttributes ( ) , context . resolve ( long . class ) , f . newSimpleName ( ""<STR_LIT>"" ) , Collections . < FormalParameterDeclaration > emptyList ( ) , statements ) ; } private long computeModelVersion ( EmitContext context , ModelDeclaration model , CacheSupportTrait trait ) { assert context != null ; assert model != null ; assert trait != null ; long hash = <NUM_LIT:1> ; final long prime = <NUM_LIT:31> ; hash = hash * prime + context . getQualifiedTypeName ( ) . toNameString ( ) . hashCode ( ) ; hash = hash * prime + trait . getSid ( ) . getName ( ) . identifier . hashCode ( ) ; hash = hash * prime + trait . getTimestamp ( ) . getName ( ) . identifier . hashCode ( ) ; for ( PropertyDeclaration property : model . getDeclaredProperties ( ) ) { hash = hash * prime + property . getName ( ) . identifier . hashCode ( ) ; com . asakusafw . dmdl . semantics . Type type = property . getType ( ) ; assert type instanceof BasicType ; hash = hash * prime + ( ( BasicType ) type ) . getKind ( ) . name ( ) . hashCode ( ) ; } return hash ; } private MethodDeclaration createTimestampColumnMethod ( EmitContext context , ModelDeclaration model , PropertySymbol timestamp ) { assert context != null ; assert model != null ; assert timestamp != null ; ModelFactory f = context . getModelFactory ( ) ; String name = OriginalNameEmitter . getOriginalName ( timestamp . findDeclaration ( ) ) ; List < Statement >'}]","statements = Lists. create ( ) ; statements. add ( new ExpressionBuilder ( f, context. resolve ( timestamp. getName ( ) ) ). toFieldAccess ( ) ) ; return f. newMethodDeclaration ( null, new AttributeBuilder ( f ). annotation ( context. resolve ( Override. class ) ). Public ( ). toAttributes ( ), context. resolve ( long. class ), f. newSimpleName ( ""<STR_LIT>"" ), Collections. < FormalParameterDeclaration > emptyList ( ), statements ) ; } private MethodDeclaration createSystemIdMethod ( EmitContext context, ModelDeclaration model, PropertySymbol sid ) { assert context!= null ; assert model!= null ; assert sid!= null ; ModelFactory f = context. getModelFactory ( ) ; String name = OriginalNameEmitter. getOriginalName ( sid. findDeclaration ( ) ) ; List < Statement > statements = Lists. create ( ) ; statements. add ( new ExpressionBuilder ( f, context. resolve ( sid. getName ( ) ) ). toFieldAccess ( ) ) ; return f. newMethodDeclaration ( null, new AttributeBuilder ( f ). annotation ( context. resolve ( Override. class ) ). Public ( ). toAttributes ( ), context",0.00041228469859513087
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . ui . text . correction ; import org . eclipse . core . runtime . CoreException ; import org . rubypeople . rdt . ui . text . ruby . IInvocationContext ; import org . rubypeople . rdt . ui . text . ruby . IProblemLocation ; import org . rubypeople . rdt . ui . text . ruby . IQuickAssistProcessor ; import org . rubypeople . rdt . ui . text . ruby . IRubyCompletionProposal ; public class QuickAssistProcessor implements IQuickAssistProcessor { public IRubyCompletionProposal [ ] getAssists ( IInvocationContext context , IProblemLocation [ ] locations ) throws CoreException { if ( ! hasAssists ( context ) ) return new IRubyCompletionProposal [ <NUM_LIT:0> ] ;'}]","IRubyCompletionProposal[] assists = getAssists(context, locations); return assists;",1.4167918685979656e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . debug . core . model ; import org . eclipse . debug . core . model . IStackFrame ; import org . rubypeople . rdt . internal . debug . core .'}]",model.ISharedStackFrame;,2.495133725047215e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . movemethod ; import org . jruby . ast . Node ; import org . jruby . ast . SelfNode ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . editprovider . ReplaceEditProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . CallArgsNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodCallNodeWrapper ; public class ReplaceMethodCallEditProvider extends ReplaceEditProvider { private MethodCallNodeWrapper methodCallNode ; private MoveMethodConfig config ; public ReplaceMethodCallEditProvider ( MethodCallNodeWrapper methodCallNode , MoveMethodConfig config ) { super ( false ) ; this . config = config ; this . methodCallNode'}]","= methodCallNode; } @Override protected Node createReplacementNode ( Node node ) { CallArgsNodeWrapper callArgs = CallArgsNodeWrapper. wrap ( node ) ; Node newMethod = NodeFactory. createMethodCall ( config. getNewMethodName ( ), callArgs. getArgs ( ) ) ; return newMethod ; } }",0.00010634621330302192
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . preferences . IWorkbenchPreferenceContainer ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . dialogs . StatusInfo ; import org . rubypeople . rdt . internal . ui . util . PixelConverter ; import org . rubypeople . rdt . internal . ui . wizards . IStatusChangeListener ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . DialogField ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IDialogFieldListener ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IListAdapter ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . ListDialogField ; import org . rubypeople . rdt . ui . PreferenceConstants ; public class KeywordConfigurationBlock extends OptionsConfigurationBlock { private static final Key PREF_COMPILER_TASK_TAGS = getRDTUIKey ( PreferenceConstants . EDITOR_USER_KEYWORDS ) ; private static final String ENABLED = RubyCore . ENABLED ; private static final String DISABLED = RubyCore . DISABLED ; public static class Keyword { public String name ; } private class KeywordLabelProvider extends LabelProvider implements ITableLabelProvider , IFontProvider { public KeywordLabelProvider ( ) { } public Image getImage ( Object element ) { return null ; } public String getText ( Object element ) { return getColumnText ( element , <NUM_LIT:0> ) ; } public Image getColumnImage ( Object element , int columnIndex ) { return null ; } public String getColumnText ( Object element , int columnIndex ) { Keyword task = ( Keyword ) element ; if ( columnIndex == <NUM_LIT:0> ) { return task . name ; } return ""<STR_LIT>"" ; } public Font getFont ( Object element ) { return null ; } } private static class TodoTaskSorter extends ViewerSorter { public int compare ( Viewer viewer , Object e1 , Object e2 ) { return collator . compare ( ( ( Keyword ) e1 ) . name , ( ( Keyword ) e2 ) . name ) ; } } private static final int IDX_ADD = <NUM_LIT:0> ; private static final int IDX_EDIT = <NUM_LIT:1> ; private static final int IDX_REMOVE = <NUM_LIT:2> ; private IStatus fTaskTagsStatus ; private ListDialogField fTodoTasksList ; public KeywordConfigurationBlock ( IStatusChangeListener context , IProject project , IWorkbenchPreferenceContainer container ) { super ( context , project , getKeys ( ) , container ) ; KeywordAdapter adapter = new KeywordAdapter ( ) ; String [ ] buttons = new String [ ] { PreferencesMessages . TodoTaskConfigurationBlock_markers_tasks_add_button , PreferencesMessages . TodoTaskConfigurationBlock_markers_tasks_edit_button , PreferencesMessages . TodoTaskConfigurationBlock_markers_tasks_remove_button } ; fTodoTasksList = new ListDialogField ( adapter , buttons , new KeywordLabelProvider ( ) ) ; fTodoTasksList . setDialogFieldListener ( adapter ) ; fTodoTasksList . setRemoveButtonIndex ( IDX_REMOVE ) ; String [ ] columnsHeaders = new String [ ] { PreferencesMessages . TodoTaskConfigurationBlock_markers_tasks_name_column } ; fTodoTasksList . setTableColumns ( new ListDialogField . ColumnsDescription ( columnsHeaders , true ) ) ; fTodoTasksList . setViewerSorter ( new TodoTaskSorter ( ) ) ; unpackTodoTasks ( ) ; if ( fTodoTasksList . getSize ( ) > <NUM_LIT:0> ) { fTodoTasksList . selectFirstElement ( ) ; } else { fTodoTasksList . enableButton ( IDX_EDIT , false ) ; } fTaskTagsStatus = new StatusInfo ( ) ; } public void setEnabled ( boolean isEnabled ) { fTodoTasksList . setEnabled ( isEnabled ) ; } private static Key [ ] getKeys ( ) { return new Key [ ] { PREF_COMPILER_TASK_TAGS } ; } public class KeywordAdapter implements IListAdapter , IDialogFieldListener { private boolean canEdit ( List selectedElements ) { return selectedElements . size ( ) == <NUM_LIT:1> ; } public void customButtonPressed ( ListDialogField field , int index ) { doTodoButtonPressed ( index ) ; } public void selectionChanged ( ListDialogField field ) { List selectedElements = field . getSelectedElements ( ) ; field . enableButton ( IDX_EDIT , canEdit ( selectedElements ) ) ; } public void doubleClicked ( ListDialogField field ) { if ( canEdit ( field . getSelectedElements ( ) ) ) { doTodoButtonPressed ( IDX_EDIT ) ; } } public void dialogFieldChanged ( DialogField field ) { updateModel ( field ) ; } } protected Control createContents ( Composite parent ) { setShell ( parent . getShell ('}]",") ); GridData data = new GridData ( GridData. GRAB_HORIZONTAL | GridData. GRAB_VERTICAL ) ; data. horizontalSpan = 1 ; data. verticalSpan = 1 ; parent. setLayoutData ( data ) ; Composite composite = new Composite ( parent, SWT. NULL ) ; composite. setBackground ( SWT. COLOR_WHITE ) ; GridLayout layout = new GridLayout ( 1, true ) ; composite. setLayout ( layout ) ; fTodoTasksList. setLayoutData ( new GridData ( GridData. GRAB_HORIZONTAL | GridData. GRAB_VERTICAL ) ) ; composite. add ( fTodoTasksList ) ; fTaskTagsStatus. setLayoutData ( new GridData ( GridData. GRAB_HORIZONTAL | GridData. GRAB_VERTICAL ) ) ; composite. add ( fTaskTagsStatus ) ; return composite ; } private void doTodoButtonPressed ( int index ) { Keyword keyword = null ; List selectedElements = fTodoTasksList. getSelectedElements ( ) ; if ( index == IDX_ADD ) { keyword = new Keyword ( ) ; } else if ( index == IDX_EDIT ) { keyword = ( Keyword ) selectedElements. get ( <NUM_LIT:0> ) ; } else if ( index ==",0.0004084064361953535
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . editor ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text'}]",.IDocumentExtension4; public class SVDBEditor extends TextEditor { private ISVDBIndexIterator iterator; private SVDBFile file; public SVDBEditor ( SVDBFile file ) { super ( file. getPath ( ) ) ; this. file = file ; } @Override public void init ( ) { super. init ( ) ; iterator = new SVDBIndexIterator ( file ) ; } @Override public void createDocument ( ) { IDocument document = super. createDocument ( ) ; document. setContents ( file. getContents ( ) ) ; document. setDocumentAboutToBeChanged ( true ) ; iterator. setDocument ( document ) ; document. setDocumentAboutToBeChanged ( false ) ; return document ; } @Override public void dispose ( ) { super. dispose ( ) ; iterator. close ( ) ; } @Override public void setDocument ( IDocument document ) { super. setDocument ( document ) ; iterator. setDocument ( document ) ; } },0.00026298494784955065
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages . movemethod ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS {'}]",public static class Messages extends NLS { public static String MoveMethodPage_title; public static String MoveMethodPage_description; public static String MoveMethodPage_method; public static String MoveMethodPage_destination; //... },6.758398441533121e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . processor ; import java . util . List ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . common . TargetOperator ; import com . asakusafw . compiler . operator . AbstractOperatorProcessor ; import com . asakusafw . compiler . operator . ExecutableAnalyzer ; import com . asakusafw . compiler . operator . OperatorMethodDescriptor ; import com . asakusafw . compiler . operator . OperatorMethodDescriptor . Builder ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . DocElement ; import com . asakusafw . vocabulary . flow . graph . Connectivity ; import com . asakusafw . vocabulary . flow . graph . ObservationCount ; import com . asakusafw . vocabulary . operator . Logging ; @ TargetOperator ( Logging . class ) public class'}]","LoggingOperatorProcessor extends AbstractOperatorProcessor<Logging> { @Override public List<OperatorMethodDescriptor> analyze(ExecutableAnalyzer analyzer, DocElement doc) { Precondition.checkMustNotBeNull(doc, ""doc""); Precondition.checkMustNotBeNull(analyzer, ""analyzer""); //... } }",9.072194388134834e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java'}]",".model.syntax.SyntaxElement;public class SyntaxTree extends SyntaxElement { private final ModelKind kind; private final Type type; private final SyntaxElement parent; private final SyntaxElement[] children; public SyntaxTree(ModelKind kind, Type type, SyntaxElement parent, SyntaxElement... children) { this.kind = kind; this.type = type; this.parent = parent; this.children = children; } public ModelKind getKind() { return kind; } public Type getType() { return type; } public SyntaxElement getParent() { return parent; } public SyntaxElement[] getChildren() { return children; } }",0.0001688693932108529
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . samples . whathow . data ; public abstract class BinaryTree < T > { private BinaryTree ( ) { } public static final < T > BinaryTree < T > _Node ( T value , BinaryTree < T > left , BinaryTree < T > right ) { return new Node < T > ( value , left , right ) ; } @ SuppressWarnings ( ""<STR_LIT:rawtypes>"" ) private static final BinaryTree _EmptyTree = new EmptyTree ( ) ; @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) public static final < T > BinaryTree < T > _EmptyTree ( ) { return _EmptyTree ; } public static interface MatchBlock < T , ResultType > { ResultType _case ( Node < T > x ) ; ResultType _case ( EmptyTree < T > x ) ; } public static abstract class MatchBlockWithDefault < T , ResultType > implements MatchBlock < T , ResultType > { @ Override public ResultType _case ( Node < T > x ) { return _default ( x ) ; } @ Override public ResultType _case ( EmptyTree < T > x ) { return _default ( x ) ; } protected abstract ResultType _default ( BinaryTree < T > x ) ; } public static interface SwitchBlock < T > { void _case ( Node < T > x ) ; void _case ( EmptyTree < T > x ) ; } public static abstract class SwitchBlockWithDefault < T > implements SwitchBlock < T > { @ Override public void _case ( Node < T > x ) { _default ( x ) ; } @ Override public void _case ( EmptyTree < T > x ) { _default ( x ) ; } protected abstract void _default ( BinaryTree < T > x ) ; } public static final class Node < T > extends BinaryTree < T > { public T value ; public BinaryTree < T > left ; public BinaryTree < T > right ; public Node ( T value , BinaryTree < T > left , BinaryTree < T > right ) { this . value = value ; this . left = left ; this . right = right ; } @ Override public < ResultType > ResultType match ( MatchBlock < T , ResultType > matchBlock ) { return matchBlock . _case ( this ) ; } @ Override public void _switch ( SwitchBlock < T > switchBlock ) { switchBlock . _case ( this ) ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT:31> ; int result = <NUM_LIT:1> ; result = prime * result + ( ( value == null ) ? <NUM_LIT:0> : value . hashCode ( ) ) ; result = prime * result + ( ( left == null ) ? <NUM_LIT:0> : left . hashCode ( )'}]",") ) ; result = prime * result + ( ( right == null )? <NUM_LIT:0> : right. hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null || getClass ( )!= obj. getClass ( ) ) return false ; BinaryTree <? > other = ( BinaryTree <? > ) obj ; if ( value == null ) { if ( other. value!= null ) return false ; } else if (! value. equals ( other. value ) ) return false ; if ( left == null ) { if ( other. left!= null ) return false ; } else if (! left. equals ( other. left ) ) return false ; if ( right == null ) { if ( other. right!= null ) return false ; } else if (! right. equals ( other. right ) ) return false ; return true ; } @ Override public String toString ( ) { return ""Node [value="" + value + "", left="" + left + "", right="" + right + ""]"" ; } } public static final class EmptyTree < T > extends BinaryTree < T > { @ Override public < ResultType > ResultType match ( Match",0.00036631079953963167
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . structural ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import org . oddjob . FailedToStopException ; import org . oddjob . Resetable ; import org . oddjob . Stoppable ; import org . oddjob . Structural ; public class ChildHelper < E > implements Structural , Iterable < E > , ChildList < E > { private final List < E > jobList = new ArrayList < E > ( ) ; private final List < StructuralListener > listeners = new ArrayList < StructuralListener > ( ) ; private final Set < List < ChildAction > > missed = new HashSet < List < ChildAction > > ( ) ; private final Structural source ; public ChildHelper ( Structural source ) { this . source = source ; } @ Override public void insertChild ( int index , E child ) { if ( child == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } StructuralEvent event = null ; synchronized ( missed ) { jobList . add ( index , child ) ; event = new StructuralEvent ( source , child , index ) ; for ( List < ChildAction > missing : missed ) { missing . add ( new ChildAdded ( event ) ) ; } } notifyChildAdded ( event ) ; } @ Override public int addChild ( E child ) { if ( child == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } int index = - <NUM_LIT:1> ; StructuralEvent event = null ; synchronized ( missed ) { index = jobList . size ( ) ; jobList . add ( index , child ) ; event = new StructuralEvent ( source , child , index ) ; for ( List < ChildAction > missing : missed ) { missing . add ( new ChildAdded ( event ) ) ; } } notifyChildAdded ( event ) ; return index ; } @ Override public E removeChildAt ( int index ) throws IndexOutOfBoundsException { E child = null ; StructuralEvent event ; synchronized ( missed ) { child = jobList . remove ( index ) ; event = new StructuralEvent ( source , child , index ) ; for ( List < ChildAction > missing : missed ) { missing . add ( new ChildRemoved ( event ) ) ; } } notifyChildRemoved ( event ) ; return child ; } @ Override public int removeChild ( Object child ) throws IllegalStateException { int index = - <NUM_LIT:1> ; StructuralEvent event ; synchronized ( missed ) { index = jobList . indexOf ( child ) ; if ( index < <NUM_LIT:0> ) { throw new IllegalStateException ( ""<STR_LIT>"" + child + ""<STR_LIT>"" ) ; } jobList . remove ( child ) ; event = new StructuralEvent ( source , child , index ) ; for ( List < ChildAction > missing : missed ) { missing . add ( new ChildRemoved ( event ) ) ; } } notifyChildRemoved ( event ) ; return index ; } public void removeAllChildren ( ) { while ( true ) { int size = jobList . size ( ) ; if ( size == <NUM_LIT:0> ) { break ; } removeChildAt ( size - <NUM_LIT:1> ) ; } } public void stopChildren ( ) throws FailedToStopException { Object [ ] children = getChildren ( ) ; FailedToStopException failed = null ; for ( int i = children . length - <NUM_LIT:1> ; i > - <NUM_LIT:1> ; -- i ) { Object child = children [ i ] ; if ( child instanceof Stoppable ) { try { ( ( Stoppable ) child ) . stop ( ) ; } catch ( FailedToStopException e ) { failed = e ; } catch ( RuntimeException e ) { failed = new FailedToStopException ( child , ""<STR_LIT:[>"" + child + ""<STR_LIT>"" , e ) ; } } } if ( failed != null ) { throw failed ; } } public void softResetChildren ( ) { Object [ ] children = getChildren ( ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; ++ i ) { if ( children [ i ] instanceof Resetable ) { ( ( Resetable ) children [ i ] ) . softReset ( ) ; } } } public void hardResetChildren ( ) { Object [ ] children = getChildren ( ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; ++ i ) { if ( children [ i ] instanceof Resetable ) { ( ( Resetable ) children [ i ] ) . hardReset ( ) ; } } } public Object [ ] getChildren ( ) { synchronized ( missed ) { return jobList . toArray ( new Object [ jobList . size ( ) ] ) ; } } public E [ ] getChildren ( E [ ] array ) { synchronized ( missed ) { return jobList . toArray ( array ) ; } } public E getChildAt ( int index ) { synchronized ( missed ) { return jobList . get ( index ) ; } } public E getChild ( ) { synchronized ( missed ) { if ( jobList . size ( ) == <NUM_LIT:0> ) { return null ; } if ( jobList . size ( ) > <NUM_LIT:1> ) { throw new IllegalStateException ( ""<STR_LIT>"" ) ; } return jobList . get ( <NUM_LIT:0> ) ; } } public boolean contains ( E child ) { synchronized ( missed ) { return jobList . contains ( child ) ; } } @ Override public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { int index ; E next ; @ Override public boolean hasNext ( ) { synchronized ( missed ) { if ( next != null ) { int last = jobList . indexOf ( next ) ; if ( last >= <NUM_LIT:0> ) { index = last + <NUM_LIT:1> ; } } if ( index < jobList . size ( ) ) { next = jobList . get ( index ) ; } else { next = null ; } } return next != null ; } @ Override public E next ( ) { synchronized ( missed ) { return next ; } } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public void addStructuralListener ( StructuralListener listener ) { List < ChildAction > ours = new ArrayList < ChildAction > ( ) ; synchronized ( missed ) { for ( int i = <NUM_LIT:0> ; i < jobList . size ( ) ; ++ i ) { StructuralEvent event = new StructuralEvent ( source , jobList . get ( i ) , i ) ; ours . add ( new ChildAdded ( event ) ) ; } missed . add ( ours ) ; } while ( true ) { ChildAction action = null ;'}]","} listener. structuralAdded ( ours ) ; } public void removeStructuralListener ( StructuralListener listener ) { synchronized ( missed ) { for ( List < ChildAction > list : missed ) { if ( list. contains ( new ChildAdded ( new StructuralEvent ( source, listener, <NUM_LIT:0> ) ) ) ) { list. remove ( new ChildAdded ( new StructuralEvent ( source, listener, <NUM_LIT:0> ) ) ) ; } } } } }",0.0001832664202297937
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . apache . log4j . Logger ; import org . oddjob . Structural ; import org . oddjob . structural . StructuralEvent ; import org . oddjob . structural . StructuralListener ; public class WaitForChildren implements StructuralListener { private static final Logger logger = Logger . getLogger ( WaitForChildren . class ) ; private final Structural structural ; private List < Object > children ; private final int retry = <NUM_LIT:3> ; public WaitForChildren ( Object o ) { structural = ( Structural ) o ; } public void waitFor ( int count ) { children = new ArrayList < Object > ( ) ; structural . addStructuralListener ( this ) ; try { synchronized ( this ) { for ( int i = <NUM_LIT:0> ; i < retry && children . size ( ) != count ; ++ i ) { logger . debug ( ""<STR_LIT>"" + structural + ""<STR_LIT>"" + count + ""<STR_LIT>"" + children . size ( ) + ""<STR_LIT:)>"" ) ; wait ( <NUM_LIT> ) ; } if ( children . size ( ) != count ) { throw new RuntimeException ( ""<STR_LIT>"" + structural + ""<STR_LIT>"" + count + ""<STR_LIT>"" + Arrays . toString ( children . toArray ( new Object [ children . size ( ) ] ) ) ) ; } } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } finally { structural . removeStructuralListener ( this ) ; } } synchronized public Object [ ] children ( ) { return children .'}]",toArray ( new Object [ children. size ( ) ] ) ; } @Override public void structuralChanged ( StructuralEvent event ) { children. add ( event. getStructural ( ) ) ; } @Override public void structuralRemoved ( StructuralEvent event ) { children. remove ( event. getStructural ( ) ) ; } },0.0001046343386567688
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . jface . text . Position ; import org . rubypeople . rdt . internal . core . parser . RubyParser ; import org . rubypeople . rdt . internal . ui . search . OccurrencesFinder ; public class MarkOccurrencesTest extends TestCase { private IOccurrencesFinder occurrencesFinder ; public void setUp ( ) { occurrencesFinder = new OccurrencesFinder ( ) ; occurrencesFinder . setFMarkConstantOccurrences ( true ) ; occurrencesFinder . setFMarkFieldOccurrences ( true ) ; occurrencesFinder . setFMarkLocalVariableOccurrences ( true ) ; occurrencesFinder . setFMarkMethodExitPoints ( true ) ; occurrencesFinder . setFMarkMethodOccurrences ( true ) ; occurrencesFinder . setFMarkOccurrenceAnnotations ( true ) ; occurrencesFinder . setFMarkTypeOccurrences ( true ) ; occurrencesFinder . setFStickyOccurrenceAnnotations ( true ) ; } private void assertOccurrencesEqual ( String source , int offset , String matchName , int [ ] [ ] offsets ) { RubyParser parser = new RubyParser ( ) ; occurrencesFinder . initialize ( parser . parse ( source ) . getAST ( ) , offset , <NUM_LIT:0> ) ; List < Position > occurrences = occurrencesFinder . perform ( ) ; assertEquals ( offsets . length , occurrences . size ( ) ) ; for ( int i = <NUM_LIT:0> ; i < offsets . length ; i ++ ) { int start = occurrences . get ( i ) . getOffset ( ) ; int length = occurrences . get ( i ) . getLength ( ) ; int end = occurrences . get ( i ) . getOffset ( ) + length ; Position testPosition = new Position ( start , length ) ; assertTrue ( occurrences . contains ( testPosition ) ) ; assertEquals ( matchName , source . substring ( start , end ) ) ; } } public void testLocalVariableMatches ( ) { String source = ""<STR_LIT>"" ; int [ ] [ ] offsets = { { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } } ; assertOccurrencesEqual ( source , <NUM_LIT> , ""<STR_LIT>"" , offsets ) ; } public void testArgMatches ( ) { String source = ""<STR_LIT>"" ; int [ ] [ ] offsets = { { <NUM_LIT:20> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } } ; assertOccurrencesEqual ( source , <NUM_LIT> , ""<STR_LIT>"" , offsets ) ; } public void testLocalVariablesInKernelDefnScope ( ) { String source = ""<STR_LIT>"" ; int [ ] [ ] offsets = { { <NUM_LIT:8> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } } ; assertOccurrencesEqual ( source , <NUM_LIT:10> , ""<STR_LIT>"" , offsets ) ; } public void testLocalVariablesInKernelScope ( ) { String source = ""<STR_LIT>"" ; int [ ] [ ] offsets = { { <NUM_LIT:0> , <NUM_LIT:6> } , { <NUM_LIT:16> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } } ; assertOccurrencesEqual ( source , <NUM_LIT:1> , ""<STR_LIT>"" , offsets ) ; } public void testInstanceVariableMatches ( ) { String source = ""<STR_LIT>"" ; int [ ] [ ] offsets = { { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } , { <NUM_LIT> , <NUM_LIT> } } ; assertOccurrencesEqual ( source , <NUM_LIT> , ""<STR_LIT>"" , offsets ) ; } public void testInstanceVariableMatchInReopenedClass ( ) { String source = ""<STR_LIT>"" ; int ['}]","] [ ] offsets = { { <NUM_LIT:0>, <NUM_LIT> }, { <NUM_LIT>, <NUM_LIT> }, { <NUM_LIT>, <NUM_LIT> } } ; assertOccurrencesEqual ( source, <NUM_LIT>, ""<STR_LIT>"", offsets ) ; }",0.00013075798521154143
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . emitter ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstExpression ; import com . asakusafw . dmdl . model . AstModelDefinition ; import com . asakusafw . dmdl . model . AstPropertyDefinition ; import com . asakusafw . dmdl . model . AstRecord ; import com . asakusafw . dmdl . model . AstRecordDefinition ; import com . asakusafw . dmdl . model . ModelDefinitionKind ; import com . asakusafw . dmdl . thundergate . Constants ; import com . asakusafw . dmdl . thundergate . model . ModelProperty ; import com . asakusafw . dmdl . thundergate . model . TableModelDescription ; import com . asakusafw . utils . collections . Lists ; public final class RecordModelGenerator { private final'}]",AstRecordDefinition definition; private final List<ModelProperty> properties = Lists.newArrayList(); private final List<ModelProperty> sortedProperties = Lists.newArrayList(); private final List<AstAttribute> attributes = Lists.newArrayList(); public RecordModelGenerator(AstRecordDefinition definition) { this.definition = definition; } public void addProperty(ModelProperty property) { this.properties.add(property); } public List<ModelProperty> getProperties() { return this.properties; } public List<ModelProperty> getSortedProperties() { Collections.sort(this.sortedProperties = this.properties); return this.sortedProperties; } public void addAttribute(AstAttribute attribute) { this.attributes.add(attribute); } public List<AstAttribute> getAttributes() { return this.attributes; } public TableModelDescription createTableModelDescription() { TableModelDescription description = new TableModelDescription(); description.setModelKind(ModelDefinitionKind.RECORD); description.setTableName(definition.getName()); description.setRecordClassname(definition.getName()); description.setFields(getSortedProperties()); description.setAttributes(getAttributes()); return description; } },0.0002874444310750817
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . view . model ; public class Name { public final String token ; public Name ( String token ) { if ( token == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . token = token ; } public Name ( Name qualifier , Name rest ) { if ( qualifier == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( rest == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . token = qualifier . token + ""<STR_LIT:.>"" + rest . token ; } public Name getLastSegment ( ) { int last = token . lastIndexOf ( \'<CHAR_LIT:.>\' ) ; if ( last >= <NUM_LIT:0> ) { return new Name ( token .'}]","substring ( last + <NUM_LIT:3> ), this ); } return this ; }",4.07726996343123e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import java . util . ArrayList ; import org . eclipse . core . resources . IStorage ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . ListenerList ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . ILabelDecorator ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Image ; import org . rubypeople . rdt . ui . RubyElementLabels ; public class RubyUILabelProvider implements ILabelProvider , IColorProvider { protected ListenerList fListeners = new ListenerList ( <NUM_LIT:1> ) ; protected RubyElementImageProvider fImageLabelProvider ; protected StorageLabelProvider fStorageLabelProvider ; private ArrayList fLabelDecorators ; private int fImageFlags ; private long fTextFlags ; public RubyUILabelProvider ( ) { this ( RubyElementLabels . ALL_DEFAULT , RubyElementImageProvider . OVERLAY_ICONS ) ; } public RubyUILabelProvider ( long textFlags , int imageFlags ) { fImageLabelProvider = new RubyElementImageProvider ( ) ; fLabelDecorators = null ; fStorageLabelProvider = new StorageLabelProvider ( ) ; fImageFlags = imageFlags ; fTextFlags = textFlags ; }'}]",protected ArrayList fLabelDecorators = new ArrayList ( ) ;,3.444116874531315e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . directio . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . directio . testing . model . Line ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class LineInput implements ModelInput < Line > { private final RecordParser parser ; public LineInput ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . parser = parser ; } @ Override public boolean readTo ( Line model ) throws IOException { if ( parser . next ( ) == false ) { return false ; } parser . fill ( model . getValueOption ( ) ) ; parser . fill ( model . getFirstOption ( ) ) ;'}]","return true; } @Override public Line read() throws IOException { Line model = new Line(); if (!readTo(model)) { throw new IOException(""No more data""); } return model; } }",7.146610583704262e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . hibernate . stats ; import org . hibernate . stat . EntityStatistics ; public class EntityStatsWrapper { private final String entityName ; private final EntityStatistics entityStatistics ; public EntityStatsWrapper ( String entityName ,'}]",EntityStatistics entityStatistics ) { this. entityName = entityName ; this. entityStatistics = entityStatistics ; } public String getEntityName ( ) { return entityName ; } public EntityStatistics getEntityStatistics ( ) { return entityStatistics ; } },7.995252239030214e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . codeassist ; import org . eclipse . core . resources . IFile ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . tests . ModifyingResourceTest ; public class CompletionContextTest extends ModifyingResourceTest { private IRubyProject rubyProject ; public CompletionContextTest ( String name ) { super ( name ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; rubyProject = createRubyProject ( ""<STR_LIT>"" ) ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; deleteProject ( rubyProject . getElementName ( ) ) ; rubyProject = null ; } public void testCorrectsSourceAndOffsetofCodeCompletionAfterArrayLiteral ( ) throws Exception { IFile file = createFile ( rubyProject . getPath ( ) . append ( ""<STR_LIT>"" ) . toPortableString ( ) , ""<STR_LIT>"" ) ; IRubyScript script = RubyCore . create ( file ) ; CompletionContext context = new CompletionContext ( script , <NUM_LIT:9> ) ; assertEquals ( ""<STR_LIT>"" , context . getCorrectedSource ( ) ) ; assertEquals ( <NUM_LIT:8> , context . getOffset ( ) ) ; } public void testCompletionOnStringLiteral ( ) throws Exception { IFile file = createFile ( rubyProject . getPath ( ) . append ( ""<STR_LIT>"" ) . toPortableString ( ) , ""<STR_LIT>"" ) ; IRubyScript script = RubyCore . create ( file ) ; CompletionContext context = new CompletionContext ( script , <NUM_LIT> ) ; assertEquals ( ""<STR_LIT>"" , context . getCorrectedSource ( ) ) ; assertEquals ( <NUM_LIT> , context . getOffset ( ) ) ; assertFalse ( context . isConstant ( ) ) ; assertFalse ( context . fullPrefixIsConstant ( ) ) ; assertEquals ( ""<STR_LIT>"" , context . getPartialPrefix ( ) ) ; } public void testCompletionOnNamespacedConstants ( ) throws Exception { IFile file = createFile ( rubyProject . getPath ( ) . append ( ""<STR_LIT>"" ) . toPortableString ( ) , ""<STR_LIT>"" ) ; IRubyScript script = RubyCore . create ( file ) ; CompletionContext context = new CompletionContext ( script , <NUM_LIT> ) ; assertEquals ( ""<STR_LIT>"" , context . getCorrectedSource ( ) ) ; assertEquals ( <NUM_LIT> , context . getOffset ( ) ) ; assertTrue ( context . isDoubleSemiColon ( ) ) ; assertFalse ( context . isConstant ( ) ) ; assertTrue ( context . fullPrefixIsConstant ( ) ) ; assertEquals ( ""<STR_LIT>"" , context . getFullPrefix ( ) ) ; assertEquals ( ""<STR_LIT>"" , context . getPartialPrefix ( ) ) ; } public void testCompletionOnNamespacedConstantsSecondPortionStarted ( ) throws Exception { IFile file = createFile ( rubyProject . getPath ( ) . append ( ""<STR_LIT>"" ) . toPortableString ( ) , ""<STR_LIT>"" ) ; IRubyScript script = RubyCore . create ('}]","(file));CompletionContext context = new CompletionContext(script, <NUM_LIT>);assertEquals(""<STR_LIT>"", context.getCorrectedSource());assertEquals(<NUM_LIT>, context.getOffset());assertTrue(context.isDoubleSemiColon());assertTrue(context.isConstant());assertTrue(context.fullPrefixIsConstant());assertEquals(""<STR_LIT>"", context.getFullPrefix());assertEquals(""<STR_LIT>"", context.getPartialPrefix());}",0.00013849523138100776
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . graph ; import net . ggtools . grand . ant . AntTargetNode . SourceElement ; import net . ggtools . grand . ui . graph . draw2d . Draw2dGraph ; import org . eclipse . swt . widgets . Menu ; public interface GraphDisplayer extends GraphControlerProvider { Menu getContextMenu ( ) ; void jumpToNode ( final'}]",SourceElement node); },2.3211020089762792e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . frontend . panels ; import com . team1160 . scouting . frontend . elements . JumpMenuItem ; import java . awt . BorderLayout ; import java . awt . Dimension ; import javax . swing . ImageIcon ; import javax . swing . JLabel ; import javax . swing . JPanel ; import com . team1160 . scouting . frontend . resourcePackets . CardLayoutPacket ; import java . awt . event . KeyEvent ; import javax . swing . JMenu ; import javax . swing . JMenuBar ; public class InitialPanel extends JPanel {'}]",private static final String DEFAULT_LAYOUT = BorderLayout.class.getName(); public InitialPanel() { super(new BorderLayout()); // Initialize components and add them to the panel } },5.594915109463818e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . rubypeople . rdt . internal . compiler . parser ; public abstract class ScannerHelper { public final static int MAX_OBVIOUS = <NUM_LIT> ; public final static int [ ] OBVIOUS_IDENT_CHAR_NATURES = new int [ MAX_OBVIOUS ] ; public final static int C_JLS_SPACE = <NUM_LIT> ; public final static int C_SPECIAL = <NUM_LIT> ; public final static int C_IDENT_START = <NUM_LIT> ; public final static int C_UPPER_LETTER = <NUM_LIT> ; public final static int C_LOWER_LETTER = <NUM_LIT> ; public final static int C_IDENT_PART = <NUM_LIT> ; public final static int C_DIGIT = <NUM_LIT> ; public final static int C_SEPARATOR = <NUM_LIT> ; public final static int C_SPACE = <NUM_LIT> ; static { OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:0> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:1> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:2> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:3> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:4> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:5> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:6> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:7> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:8> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:15> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:16> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:20> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:24> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_IDENT_PART ; for ( int i = '<CHAR_LIT:0>' ; i <= '<CHAR_LIT:9>' ; i ++ ) OBVIOUS_IDENT_CHAR_NATURES [ i ] = C_DIGIT | C_IDENT_PART ; for ( int i = '<CHAR_LIT:a>' ; i <= '<CHAR_LIT>' ; i ++ ) OBVIOUS_IDENT_CHAR_NATURES [ i ] = C_LOWER_LETTER | C_IDENT_PART | C_IDENT_START ; for ( int i = '<CHAR_LIT:A>' ; i <= '<CHAR_LIT:Z>' ; i ++ ) OBVIOUS_IDENT_CHAR_NATURES [ i ] = C_UPPER_LETTER | C_IDENT_PART | C_IDENT_START ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:_>' ] = C_SPECIAL | C_IDENT_PART | C_IDENT_START ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT>' ] = C_SPECIAL | C_IDENT_PART | C_IDENT_START ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:9> ] = C_SPACE | C_JLS_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:10> ] = C_SPACE | C_JLS_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:11> ] = C_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:12> ] = C_SPACE | C_JLS_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_SPACE | C_JLS_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT> ] = C_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:30> ] = C_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:31> ] = C_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ <NUM_LIT:32> ] = C_SPACE | C_JLS_SPACE ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:.>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT::>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:;>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:U+002C>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:[>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:]>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:(>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:)>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:}>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:->' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:/>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [ '<CHAR_LIT:=>' ] = C_SEPARATOR ; OBVIOUS_IDENT_CHAR_NATURES [""}]",'<CHAR_LIT:?>' ] = C_SEPARATOR ; } },5.925250191602039e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . helpers ; import java . util . HashSet ; import java . util . Set ; import junit . framework . TestCase ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . hp . hpl . jena . rdf . model . RDFNode ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; import de . fuberlin . wiwiss . d2rq . D2RQTestSuite ; import de . fuberlin . wiwiss . d2rq . jena . GraphD2RQ ; import de . fuberlin . wiwiss . d2rq . jena . ModelD2RQ ; import de . fuberlin . wiwiss . d2rq . pp . PrettyPrinter ; public class FindTestFramework extends TestCase { protected static final Model m = ModelFactory . createDefaultModel ( ) ; private GraphD2RQ graph ; private Set < Triple > resultTriples ; protected void setUp ( ) throws Exception { this . graph = ( GraphD2RQ ) new ModelD2RQ ( D2RQTestSuite . ISWC_MAP , ""<STR_LIT>"" , ""<STR_LIT>"" ) . getGraph ( ) ; } protected void tearDown ( ) throws Exception { this . graph . close ( ) ; } protected void find ( RDFNode s , RDFNode p , RDFNode o ) { this . resultTriples = new HashSet < Triple > ( ) ; ExtendedIterator < Triple > it = this . graph . find ( toNode ( s ) , toNode ( p ) , toNode ( o ) ) ; while ( it . hasNext ( ) ) { this . resultTriples . add ( it . next ( ) ) ; } } protected RDFNode resource ( String relativeURI ) { return m . createResource ( ""<STR_LIT>"" + relativeURI ) ; } protected void dump ( ) { int count = <NUM_LIT:0> ; for ( Triple t : resultTriples ) { count ++ ; System . out . println ('}]","""  "" + PrettyPrinter.printTriple(t) + ""  "" + count); }",4.959403881351115e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . algebra ; import java . util . List ; import java . util . Set ; import de . fuberlin . wiwiss . d2rq . expr . Expression ; public class MutableRelation implements RelationalOperators { private Relation relation ; public MutableRelation ( Relation initialState ) { this . relation = initialState ; } public Relation immutableSnapshot ( ) { return this . relation ; } public Relation renameColumns ( ColumnRenamer renamer ) { return this . relation = this . relation . renameColumns ( renamer ) ; } public Relation empty ( ) {'}]",return this.relation = this.relation.empty();,3.119617173652408e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . java . emitter . driver ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . List ; import com . asakusafw . dmdl . java . emitter . EmitContext ; import com . asakusafw . dmdl . java . spi . JavaDataModelDriver ; import com . asakusafw . dmdl . model . ModelDefinitionKind ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . model . syntax . FormalParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . InfixOperator ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Statement ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . util . AttributeBuilder ; import com . asakusafw . utils . java . model . util . ExpressionBuilder ; import com . asakusafw . utils . java . model . util . Models ; import com . asakusafw . utils . java . model . util . TypeBuilder ; public class ObjectDriver extends JavaDataModelDriver { @ Override public List < MethodDeclaration > getMethods ( EmitContext context , ModelDeclaration model ) { if ( model . getOriginalAst ( ) . kind == ModelDefinitionKind . PROJECTIVE ) { return Collections . emptyList ( ) ; } List < MethodDeclaration > results = Lists . create ( ) ; results . add ( createToString ( context , model ) ) ; results . add ( createHashCode ( context , model ) ) ; results . add ( createEquals ( context , model ) ) ; return results ; } private MethodDeclaration createToString ( EmitContext context , ModelDeclaration model ) { assert context != null ; assert model != null ; ModelFactory f = context . getModelFactory ( ) ; List < Statement > statements = Lists . create ( ) ; SimpleName buffer = context . createVariableName ( ""<STR_LIT:result>"" ) ; statements . add ( new TypeBuilder ( f , context . resolve ( StringBuilder . class ) ) . newObject ( ) . toLocalVariableDeclaration ( context . resolve ( StringBuilder . class ) , buffer ) ) ; statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" , Models . toLiteral ( f , ""<STR_LIT:{>"" ) ) . toStatement ( ) ) ; statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" , Models . toLiteral ( f , ""<STR_LIT>"" + model . getName ( ) . identifier ) ) . toStatement ( ) ) ; for ( PropertyDeclaration property : model . getDeclaredProperties ( ) ) { statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" , Models . toLiteral ( f , MessageFormat . format ( ""<STR_LIT>"" , context . getFieldName ( property ) ) ) ) . toStatement ( ) ) ; statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" , new ExpressionBuilder ( f , f . newThis ( ) ) . field ( context . getFieldName ( property ) ) . toExpression ( ) ) . toStatement ( ) ) ; } statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" , Models . toLiteral ( f , ""<STR_LIT:}>"" ) ) . toStatement ( ) ) ; statements . add ( new ExpressionBuilder ( f , buffer ) . method ( ""<STR_LIT>"" ) . toReturnStatement ( ) ) ; return f . newMethodDeclaration ( null , new AttributeBuilder ( f ) . annotation ( context . resolve ( Override . class ) ) . Public ( ) . toAttributes ( ) , context . resolve ( String . class ) , f . newSimpleName ( ""<STR_LIT>"" ) , Collections . < FormalParameterDeclaration > emptyList ( ) , statements ) ; } private MethodDeclaration createHashCode ( EmitContext context , ModelDeclaration model ) { assert context != null ; assert model != null ; ModelFactory f = context . getModelFactory ( ) ; List < Statement > statements = Lists . create ( ) ; SimpleName prime = context . createVariableName ( ""<STR_LIT>"" ) ; SimpleName result = context . createVariableName ( ""<STR_LIT:result>"" ) ; statements . add ( new ExpressionBuilder ( f , Models . toLiteral ( f , <NUM_LIT:31> ) ) . toLocalVariableDeclaration ( Models . toType ( f , int . class ) , prime ) ) ; statements . add ( new ExpressionBuilder ( f , Models . toLiteral ( f , <NUM_LIT:1> ) ) . toLocalVariableDeclaration ( Models . toType ( f , int .'}]","class ), result ) ) ; statements. add ( new ExpressionBuilder ( f, f. newThis ( ) ). method ( ""<STR_LIT>"", new ExpressionBuilder ( f, result ). field ( context. getFieldName ( model. getDeclaredProperties ( ). get ( 0 ) ) ). toExpression ( ) ). toStatement ( ) ) ; for ( int i = 1 ; i < model. getDeclaredProperties ( ). size ( ) ; i ++ ) { PropertyDeclaration property = model. getDeclaredProperties ( ). get ( i ) ; statements. add ( new ExpressionBuilder ( f, f. newThis ( ) ). method ( ""<STR_LIT>"", new ExpressionBuilder ( f, result ). method ( ""<STR_LIT>"", new ExpressionBuilder ( f, result ). field ( context. getFieldName ( property ) ). toExpression ( ) ). toExpression ( ) ). toStatement ( ) ) ; } statements. add ( new ExpressionBuilder ( f, Models. toLiteral ( f, <NUM_LIT:31> ) ). toLocalVariableDeclaration ( Models. toType ( f, int. class ), prime ) ) ; statements. add ( new Expression",0.0003974903410865765
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import junit . framework . TestCase ; import org . apache . commons . beanutils . DynaBean ; import org . apache . commons . beanutils . PropertyUtils ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; import org . oddjob . Describeable ; import org . oddjob . FailedToStopException ; import org . oddjob . Forceable ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . Resetable ; import org . oddjob . StateSteps ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ArooaTools ; import org . oddjob . arooa . MockArooaSession ; import org . oddjob . arooa . life . ArooaContextAware ; import org . oddjob . arooa . life . ArooaLifeAware ; import org . oddjob . arooa . life . ArooaSessionAware ; import org . oddjob . arooa . parsing . MockArooaContext ; import org . oddjob . arooa . registry . ComponentPool ; import org . oddjob . arooa . registry . MockComponentPool ; import org . oddjob . arooa . runtime . MockRuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeConfiguration ; import org . oddjob . arooa . runtime . RuntimeListener ; import org . oddjob . arooa . standard . StandardArooaDescriptor ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . standard . StandardTools ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . describe . UniversalDescriber ; import org . oddjob . logging . LogEnabled ; import org . oddjob . logging . LogEvent ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . logging . log4j . Log4jArchiver ; import org . oddjob . state . JobState ; import org . oddjob . state . ParentState ; import org . oddjob . state . StateEvent ; import org . oddjob . state . StateListener ; public class RunnableWrapperTest extends TestCase { private class OurContext extends MockArooaContext { OurSession session ; @ Override public ArooaSession getSession ( ) { return session ; } @ Override public RuntimeConfiguration getRuntime ( ) { return new MockRuntimeConfiguration ( ) { @ Override public void addRuntimeListener ( RuntimeListener listener ) { } } ; } } private class OurSession extends MockArooaSession { Object configured ; Object saved ; ArooaDescriptor descriptor = new StandardArooaDescriptor ( ) ; @ Override public ArooaDescriptor getArooaDescriptor ( ) { return descriptor ; } @ Override public ComponentPool getComponentPool ( ) { return new MockComponentPool ( ) { @ Override public void configure ( Object component ) { configured = component ; } @ Override public void save ( Object component ) { saved = component ; } } ; } @ Override public ArooaTools getTools ( ) { return new StandardTools ( ) ; } } public static class OurRunnable implements Runnable { boolean ran ; public void run ( ) { ran = true ; } public boolean isRan ( ) { return ran ; } public String toString ( ) { return ""<STR_LIT>"" ; } } public void testGoodRunnable ( ) { OurSession session = new OurSession ( ) ; OurContext context = new OurContext ( ) ; context . session = session ; OurRunnable test = new OurRunnable ( ) ; Object proxy = new RunnableProxyGenerator ( ) . generate ( ( Runnable ) test , getClass ( ) . getClassLoader ( ) ) ; ( ( ArooaSessionAware ) proxy ) . setArooaSession ( session ) ; ( ( ArooaContextAware ) proxy ) . setArooaContext ( context ) ; MyStateListener stateListener = new MyStateListener ( ) ; ( ( Stateful ) proxy ) . addStateListener ( stateListener ) ; assertSame ( proxy , stateListener . lastEvent . getSource ( ) ) ; ( ( Runnable ) proxy ) . run ( ) ; assertEquals ( proxy , session . configured ) ; assertEquals ( proxy , session . saved ) ; assertTrue ( test . ran ) ; assertEquals ( ""<STR_LIT>"" , JobState . COMPLETE , stateListener . lastEvent . getState ( ) ) ; session . saved = null ; ( ( Resetable ) proxy ) . hardReset ( ) ; assertEquals ( ""<STR_LIT>"" , JobState . READY , stateListener . lastEvent . getState ( ) ) ; assertEquals ( proxy , session . saved ) ; ( ( Forceable ) proxy ) . force ( ) ; assertEquals ( ""<STR_LIT>"" , JobState . COMPLETE , stateListener . lastEvent . getState ( ) ) ; } public void testBadRunnable ( ) { Runnable test = new Runnable ( ) { public void run ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } } ; Object proxy = new RunnableProxyGenerator ( ) . generate ( ( Runnable ) test , getClass ( ) . getClassLoader ( ) ) ; ArooaSession session = new StandardArooaSession ( ) ; ( ( ArooaSessionAware ) proxy ) . setArooaSession ( session ) ; MyStateListener l = new MyStateListener ( ) ; ( ( Stateful ) proxy ) . addStateListener ( l ) ; ( ( Runnable ) proxy ) . run ( ) ; assertEquals ( ""<STR_LIT>"" , JobState . EXCEPTION , l . lastEvent . getState ( ) ) ; ( ( Resetable ) proxy ) . softReset ( ) ; assertEquals ( ""<STR_LIT>"" , JobState . READY , l . lastEvent . getState ( ) ) ; } private class MyStateListener implements StateListener { StateEvent lastEvent ; public void jobStateChange ( StateEvent event ) { lastEvent = event ; } } public void testStop ( ) throws InterruptedException , FailedToStopException { Runnable test = new Runnable ( ) { @ Override public void run ( ) { synchronized ( this ) { try { wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @ Override public String toString ( ) { return ""<STR_LIT>"" ; } } ; Runnable wrapper = ( Runnable ) new RunnableProxyGenerator ( ) . generate ( ( Runnable ) test , getClass ( ) . getClassLoader ( ) ) ; Stateful stateful = ( Stateful ) wrapper ; StateSteps states = new StateSteps ( stateful ) ; states . startCheck ( JobState . READY , JobState . EXECUTING ) ; Thread t = new Thread ( wrapper ) ; t . start ( ) ; states . checkWait ( ) ; Stoppable stoppable = ( Stoppable ) wrapper ; states . startCheck ( JobState . EXECUTING , JobState . COMPLETE ) ; stoppable . stop ( ) ; states . checkWait ( ) ; } public void testHashCode ( ) { Runnable wrapped = new Runnable ( ) { public void run ( ) { } } ; Runnable test = ( Runnable ) new RunnableProxyGenerator ( ) . generate ( ( Runnable ) wrapped , getClass ( ) . getClassLoader ( ) ) ; HashMap < Object , String > hashMap = new HashMap < Object , String > ( ) ; hashMap . put ( test , ""<STR_LIT:Hello>"" ) ; String result = hashMap . get ( test ) ; assertEquals ( ""<STR_LIT:Hello>"" , result ) ; } public void testEquals ( ) { Runnable wrapped = new Runnable ( ) { public void run ( ) { } } ; Runnable test = ( Runnable ) new RunnableProxyGenerator ( ) . generate ( ( Runnable ) wrapped , getClass ( ) . getClassLoader ( ) ) ; assertTrue ( test . equals ( test ) ) ; assertEquals ( test , test ) ; } public static class Bean { String greeting ; public void setGreeting ( String greeting ) { this . greeting = greeting ; } public String getGreeting ( ) { return greeting ; } } public static class Job implements Runnable { public String result ; public void run ( ) { } public void setResult ( String result ) { this . result = result ; } public String getResult ( ) { return result ; } } public void testInOddjob ( ) throws Exception { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + OurRunnable . class . getName ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . run ( ) ; Object r = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT:r>"" ) ; assertEquals ( JobState . COMPLETE , Helper . getJobState ( r ) ) ; Object ran = PropertyUtils . getProperty ( r , ""<STR_LIT>"" ) ; assertEquals ( Boolean . class , ran . getClass ( ) ) ; assertEquals ( new Boolean ( true ) , ran ) ; Map < String , String > description = ( ( Describeable ) r ) . describe ( ) ; assertEquals ( ""<STR_LIT:true>"" , description . get ( ""<STR_LIT>"" ) ) ; oddjob . destroy ( ) ; } public static class LotsOfProperties implements Runnable { private Map < String , Object > map = new HashMap < String , Object > ('}]",">()); public void run() throws Exception { Properties props = new Properties(); props.put(""one"", ""1""); props.put(""two"", ""2""); props.put(""three"", ""3""); props.put(""four"", ""4""); props.put(""five"", ""5""); props.put(""six"", ""6""); props.put(""seven"", ""7""); props.put(""eight"", ""8""); props.put(""nine"", ""9""); props.put(""ten"", ""10""); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession(new StandardArooaSession()); ((ArooaSessionAware) this).setArooaSession",0.0004418441554972866
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . parser ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . fail ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . util . List ; import org . junit . Test ; import com . pogofish . jadt . ast . ASTConstants ; import com . pogofish . jadt . ast . DataType ; import com . pogofish . jadt . ast . Doc ; import com . pogofish . jadt . ast . Imprt ; import com . pogofish . jadt . ast . ParseResult ; import com . pogofish . jadt . errors . SyntaxError ; import com . pogofish . jadt . source . Source ; import com . pogofish . jadt . source . StringSource ; import com . pogofish . jadt . util . Util ; public class ParserTest { @ Test public void testErrorClosing ( ) { final IOException thrown = new IOException ( ""<STR_LIT>"" ) ; final Source source = new Source ( ) { @ Override public String getSrcInfo ( ) { return ""<STR_LIT>"" ; } @ Override public BufferedReader createReader ( ) { return new BufferedReader ( new Reader ( ) { @ Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } @ Override public void close ( ) throws IOException { throw thrown ; } } ) ; } } ; final Parser parser = new StandardParser ( new ParserImplFactory ( ) { @ Override public ParserImpl create ( String srcInfo , Reader reader ) { return new BaseTestParserImpl ( ) { @ Override public Doc doc ( ) throws Exception { return Doc . _Doc ( ""<STR_LIT>"" , ASTConstants . EMPTY_PKG , Util . < Imprt > list ( ) , Util . < DataType > list ( ) ) ; } @ Override public List < SyntaxError > errors ( ) { return Util . < SyntaxError > list ( ) ; } } ; } } ) ; try { final ParseResult parseResult = parser . parse ( source ) ; fail ( ""<STR_LIT>"" + parseResult ) ; } catch ( RuntimeException caught ) { assertEquals ( ""<STR_LIT>"" , thrown , caught . getCause ( ) ) ; } } @ Test public void testExceptionHandling ( ) { final Throwable thrown1 = new RuntimeException ( ""<STR_LIT>"" ) ; try { final Parser parser = new StandardParser ( new ThrowingParserImplFactory ( thrown1 ) ) ; final ParseResult result = parser . parse ( new StringSource ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; fail ( ""<STR_LIT>"" + result ) ; } catch ( RuntimeException caught ) { assertSame ( ""<STR_LIT>"" , thrown1 , caught ) ; } final Throwable thrown2 = new Error ( ""<STR_LIT>"" ) ; try { final Parser parser = new StandardParser ( new ThrowingParserImplFactory ( thrown2 ) ) ;'}]","final ParseResult result = parser.parse(new StringSource(""<STR_LIT>"", ""<STR_LIT>"")); fail(""<STR_LIT>"" + result); } catch (RuntimeException caught) { assertSame(""<STR_LIT>"", thrown2, caught); } } @Test public void testExceptionHandlingWithSource ( ) { final Throwable thrown1 = new RuntimeException ( ""<STR_LIT>"" ) ; try { final Parser parser = new StandardParser ( new ThrowingParserImplFactory ( thrown1 ) ) ; final ParseResult result = parser. parse ( new StringSource ( ""<STR_LIT>"", ""<STR_LIT>"" ) ) ; fail ( ""<STR_LIT>"" + result ) ; } catch ( RuntimeException caught ) { assertSame ( ""<STR_LIT>"", thrown1, caught ) ; } final Throwable thrown2 = new Error ( ""<STR_LIT>"" ) ; try { final Parser parser = new StandardParser ( new ThrowingParserImplFactory ( thrown2 ) ) ; final ParseResult result = parser. parse ( new StringSource ( ""<STR_LIT>"", ""<STR_LIT>"" ) ) ; fail ( ""<STR_LIT>"" + result ) ; } catch ( RuntimeException caught ) { assertSame ( ""<STR_LIT>"", thrown2, caught",0.0003654141918693473
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Pattern ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ExecutionContext { static final Logger LOG = LoggerFactory . getLogger ( ExecutionContext . class ) ; private final String batchId ; private final String flowId ; private final String executionId ; private final ExecutionPhase phase ; private final Map < String , String > arguments ; private final Map < String , String > environmentVariables ; public ExecutionContext ( String batchId , String flowId , String executionId , ExecutionPhase phase , Map < String , String > arguments ) { this ( batchId , flowId , executionId , phase , arguments , Collections . < String , String > emptyMap ( ) ) ; } public ExecutionContext ( String batchId , String flowId , String executionId , ExecutionPhase phase , Map < String , String > arguments , Map < String , String > environmentVariables ) { if ( batchId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; }'}]","if ( flowId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( executionId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( phase == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this. batchId = batchId ; this. flowId = flowId ; this. executionId = executionId ; this. phase = phase ; this. arguments = arguments ; this. environmentVariables = environmentVariables ; } public String getBatchId ( ) { return batchId ; } public String getFlowId ( ) { return flowId ; } public String getExecutionId ( ) { return executionId ; } public ExecutionPhase getPhase ( ) { return phase ; } public Map < String, String > getArguments ( ) { return Collections. unmodifiableMap ( arguments ) ; } public Map < String, String > getEnvironmentVariables ( ) { return Collections. unmodifiableMap ( environmentVariables ) ; } public static String format ( String pattern, Object... args ) { MessageFormat messageFormat = MessageFormat. getInstance ( pattern ) ; return messageFormat. format ( args ) ; } public static ExecutionContext of ( String batchId, String flowId, String executionId, Execution",0.00034699057042315574
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . text ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . ui . editor . SVEditor ; import net . sf . sveditor . ui . svcp . SVDBDecoratingLabelProvider ; import net . sf . sveditor . ui . svcp . SVTreeContentProvider ; import net . sf . sveditor . ui . svcp . SVTreeLabelProvider ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . IElementComparer ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . ui . dialogs . FilteredTree ; import org . eclipse . ui . dialogs . PatternFilter ; public class OutlineInformationControl'}]","extends org.eclipse.ui.part.EditorPart implements org.eclipse.ui.part.IPartInitializer<SVEditor>, org.eclipse.ui.part.IPartListener, org.eclipse.ui.forms.IFormPart, org.eclipse.ui.forms.IFormPartFactory, org.eclipse.ui.forms.IFormPartFactory2, org.eclipse.ui.forms.IFormPartFactory3, org.eclipse.ui.forms.IFormPartFactory4, org.eclipse.ui.forms.IFormPartFactory5, org.eclipse.ui.forms.IFormPartFactory6, org.eclipse.ui.forms.IFormPartFactory7, org.eclipse.ui.forms.IFormPartFactory8, org.eclipse.ui.forms.IFormPartFactory9, org.eclipse.ui.forms.IFormPartFactory10, org.eclipse.ui.forms.IFormPartFactory11, org.eclipse.ui.forms.IFormPartFactory12, org.eclipse.ui.forms.IFormPartFactory13, org.eclipse.ui.forms.IFormPartFactory14, org.eclipse.ui.forms.IFormPartFactory15, org.eclipse.ui.forms.IFormPartFactory16, org.eclipse.ui.forms.IFormPartFactory17, org.eclipse.ui.forms.IFormPartFactory18, org.eclipse.ui.forms.IFormPartFactory19, org.eclipse.ui.forms.IFormPartFactory20, org.eclipse.ui.forms.IFormPartFactory21, org.eclipse.ui.forms.IFormPartFactory22, org.eclipse",0.0003489619292623491
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules . schedules ; import java . text . ParseException ; import java . util . Date ; import junit . framework . TestCase ; import org . oddjob . OddjobSessionFactory ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . standard . StandardFragmentParser ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . schedules . Interval ; import org . oddjob . schedules . IntervalTo ; import org . oddjob . schedules . Schedule ; import org . oddjob . schedules . ScheduleContext ; import org . oddjob . schedules . ScheduleList ; import org . oddjob . schedules . ScheduleResult ; import org . oddjob . schedules . ScheduleRoller ; import org . oddjob . schedules . SimpleInterval ; import org . oddjob . schedules . SimpleScheduleResult ; import org . oddjob . schedules . units . DayOfWeek ; import org . oddjob . schedules . units . Month ; public class DayAfterScheduleTest extends TestCase { public void testDayAfterInterval ( ) throws ParseException { DayAfterSchedule test = new DayAfterSchedule ( ) ; ScheduleContext context = new ScheduleContext ( new Date ( ) ) ; context = context . spawn ( new Date ( ) , new IntervalTo ( DateHelper . parseDate ( ""<STR_LIT>"" ) , DateHelper . parseDate ( ""<STR_LIT>"" ) ) ) ; Interval result = test . nextDue ( context ) ; IntervalTo expected = new IntervalTo ( DateHelper . parseDate ( ""<STR_LIT>"" ) , DateHelper . parseDate ( ""<STR_LIT>"" ) ) ; assertEquals ( expected , result ) ; } public void testDayAfterWithRefinement ( ) throws ParseException { WeeklySchedule weekly = new WeeklySchedule ( ) ; weekly . setOn ( DayOfWeek . Days . WEDNESDAY ) ; DayAfterSchedule test = new DayAfterSchedule ( ) ; weekly . setRefinement ( test ) ; DailySchedule time = new DailySchedule ( ) ; time . setFrom ( ""<STR_LIT>"" ) ; test . setRefinement ( time ) ; Interval [ ] results = new ScheduleRoller ( weekly ) . resultsFrom ( DateHelper . parseDate ( ""<STR_LIT>"" ) ) ; IntervalTo expected = new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDate ('}]","""<STR_LIT>"" ) ) ; IntervalTo expected2 = new IntervalTo ( DateHelper. parseDate ( ""<STR_LIT>"" ), DateHelper. parseDate ( ""<STR_LIT>"" ) ) ; IntervalTo expected3 = new IntervalTo ( DateHelper. parseDate ( ""<STR_LIT>"" ), DateHelper. parseDate ( ""<STR_LIT>"" ) ) ; for ( IntervalTo result : results ) { if ( result. getStart ( ). equals ( expected. getStart ( ) ) ) { assertEquals ( expected2, result. getNext ( ) ) ; } else if ( result. getStart ( ). equals ( expected2. getStart ( ) ) ) { assertEquals ( expected3, result. getNext ( ) ) ; } else { fail ( ""Unexpected result "" + result ) ; } } }",0.0002489508510060265
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . model ; public abstract class JavaValue extends JavaThing {'}]",private static final long serialVersionUID = 1L;,2.892004192111682e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . pref ; public class SVEditorPrefsConstants { private static final String EDIT_SETTINGS = ""<STR_LIT>"" ; private static final String OUTLINE_SETTINGS = ""<STR_LIT>"" ; private static final String TEMPLATE_SETTINGS = ""<STR_LIT>"" ; private static final String INDEX_SETTINGS = ""<STR_LIT>"" ; public static final String P_DEFAULT_C = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_COMMENT_C = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_KEYWORD_C = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_STRING_C = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_DEFAULT_S = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_KEYWORD_S = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_COMMENT_S = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_STRING_S = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_SV_FILE_EXTENSIONS_S = ""<STR_LIT>"" ; public static final String P_AUTO_INDENT_ENABLED_S = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_AUTO_REBUILD_INDEX = ""<STR_LIT>"" ; public static final String P_ENABLE_SHADOW_INDEX = ""<STR_LIT>"" ; public static final String P_DEBUG_LEVEL_S = ""<STR_LIT>"" ; public static final String P_DEBUG_CONSOLE_S = ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_TIMEOUT = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_TF_NAMED_PORTS_EN = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_TF_LINE_WRAP_LIMIT = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_TF_MAX_PARAMS_PER_LINE = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_MODIFCINST_NAMED_PORTS_EN = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_MODIFCINST_LINE_WRAP_LIMIT = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String P_CONTENT_ASSIST_MODIFCINST_MAX_PORTS_PER_LINE = EDIT_SETTINGS + ""<STR_LIT>"" ; public static final String'}]","P_CONTENT_ASSIST_MODIFCINST_MAX_PARAMS_PER_LINE = EDIT_SETTINGS + ""<STR_LIT>"" ;",5.0405088396262894e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs . structural ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import junit . framework . TestCase ; import org . oddjob . FailedToStopException ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . StateSteps ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . jobs . WaitJob ; import org . oddjob . state . JobState ; import org . oddjob . state . ParentState ; public class OverridingExecutorServiceTest extends TestCase { public static class ExecutorProvider { private int threads = <NUM_LIT:1> ; private ExecutorService service ; public void start ( ) { if ( service != null ) { throw new IllegalStateException ( ""<STR_LIT>"" ) ; } service = Executors . newFixedThreadPool ( threads ) ; } public void stop ( ) throws InterruptedException , FailedToStopException { if ( service == null ) { throw new IllegalStateException ( ""<STR_LIT>"" ) ; } service . shutdownNow ( ) ; if ( ! service . awaitTermination ( <NUM_LIT:10> , TimeUnit . SECONDS ) ) { throw new FailedToStopException ( this , ""<STR_LIT>"" ) ; } service = null ; } public int getThreads ( ) { return threads ; } public void setThreads ( int threads ) { this . threads = threads ; } public ExecutorService getService ( ) { return service ; } } public void testExample ( ) throws ArooaPropertyException , ArooaConversionException , InterruptedException , FailedToStopException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . load ( ) ; StateSteps oddjobStates = new StateSteps ( oddjob ) ; oddjobStates . startCheck ( ParentState . READY , ParentState . EXECUTING ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; WaitJob wait1 = lookup . lookup ( ""<STR_LIT>"" , WaitJob . class ) ; WaitJob wait2 = lookup . lookup ( ""<STR_LIT>"" , WaitJob . class ) ; WaitJob wait3 = lookup . lookup ( ""<STR_LIT>"" , WaitJob . class ) ; WaitJob wait4 = lookup . lookup ( ""<STR_LIT>"" , WaitJob . class ) ; StateSteps states1 = new StateSteps ( wait1 ) ; StateSteps states2 = new StateSteps ( wait2 ) ; StateSteps states3 ='}]","new StateSteps( wait3 ); StateSteps states4 = new StateSteps( wait4 ); ExecutorProvider provider = new ExecutorProvider(); oddjobStates.setProvider(provider); ExecutorService service = provider.getService(); ExecutorService service2 = Executors.newFixedThreadPool(2); service = service2; oddjobStates.startCheck(ParentState.READY, ParentState.EXECUTING); oddjobStates.start(); oddjobStates.stop(); } }",0.00014027955216295245
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . testing ; import java . io . IOException ; import java . util . LinkedList ; import java . util . List ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . runtime . io . ModelInput ; public class MultipleModelInput < T > implements ModelInput < T > { private LinkedList < ModelInput < T > > inputs ; public MultipleModelInput ( List < ? extends ModelInput < T > > inputs ) { Precondition . checkMustNotBeNull ( inputs , ""<STR_LIT>"" ) ; this . inputs = new LinkedList < ModelInput < T > > ( inputs ) ; } @ Override public boolean readTo ( T model ) throws IOException { while ( inputs . isEmpty ( ) == false ) { ModelInput < T > input = inputs . getFirst ( ) ; if ( input . readTo ( model ) ) { return true ; } inputs . removeFirst ( ) . close ('}]",) ; } return false ; } @Override public void close() throws IOException { while (inputs.isEmpty() == false) { ModelInput<T> input = inputs.removeFirst(); input.close(); } } },7.389898275775746e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . structural ; import java . util . Arrays ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . life . ArooaSessionAware ; import org . oddjob . arooa . registry . BeanDirectory ; import org . oddjob . arooa . registry . BeanDirectoryOwner ; public class DumpRegistryJob implements Runnable , ArooaSessionAware { private ArooaSession session ; public void setArooaSession ( ArooaSession session ) { this . session = session ; } public void run ( ) { BeanDirectory reg = session . getBeanRegistry ( ) ; dump ( <NUM_LIT:0> , reg ) ; } void dump ( int level , BeanDirectory reg ) { for ( Object component :'}]","reg.getComponents()) { if (component instanceof BeanDirectoryOwner) { BeanDirectory subReg = ((BeanDirectoryOwner) component).getBeanRegistry(); dump(level + 1, subReg); } else { System.out.println(String.format(""%s%s"", ""  "".repeat(level), component)); } } } }",9.803940576798428e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . log ; import java . util . Collections ; import java . util . LinkedList ; import java . util . List ; import net . ggtools . grand . ui . log . LogEvent . Level ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LogEventBufferImpl implements LogEventBuffer { private static LogEventBufferImpl instance ; private static final Log log = LogFactory . getLog ( LogEventBufferImpl . class ) ; private static final long serialVersionUID = <NUM_LIT> ; public static LogEventBufferImpl getInstance ( ) { if ( instance == null ) { instance = new LogEventBufferImpl ( ) ; } return instance ; } private final LinkedList < LogEvent > eventList = new LinkedList < LogEvent > ( ) ; private transient LogEventListener listener ; private LogEventBufferImpl ( ) { super ( ) ; } public void addListener ( final'}]",LogEventListener listener ) { this. listener = listener ; } public synchronized void addEvent ( LogEvent event ) { eventList. addFirst ( event ) ; if ( listener!= null ) { listener. onEvent ( event ) ; } } public synchronized void removeListener ( ) { listener = null ; } public synchronized List < LogEvent > getEvents ( ) { return Collections. unmodifiableList ( eventList ) ; } public synchronized void clear ( ) { eventList. clear ( ) ; } },0.00014885553637595045
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . apache . camel . example . reportincident . internal ; import org . apache . camel . Exchange ; import org . apache . camel . example . reportincident . InputReportIncident ; import org . apache . camel . example . reportincident . model . Incident ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . * ; public class WebService { private static final transient Log LOG = LogFactory . getLog ( WebService . class ) ; public void process ( Exchange exchange ) throws ParseException { InputReportIncident webincident = ( InputReportIncident ) exchange . getIn ( ) . getBody ( ) ; LOG . debug ( ""<STR_LIT>"" + webincident . getFamilyName ( ) + ""<STR_LIT:U+002CU+0020>"" + webincident . getGivenName ( ) ) ; LOG . debug ( ""<STR_LIT>"" + webincident . getIncidentId ( ) + ""<STR_LIT>"" + webincident . getIncidentDate ( ) ) ; LOG . debug ( ""<STR_LIT>"" + webincident . getDetails ( ) + ""<STR_LIT>"" + webincident . getSummary ( ) ) ; List < Map < String , Incident > > models = new ArrayList < Map < String , Incident > > ( ) ; Map < String , Incident > model = new HashMap < String , Incident > ('}]","> ( ) ; model. put ( ""incidentId"", webincident. getIncidentId ( ) ) ; model. put ( ""incidentDate"", webincident. getIncidentDate ( ) ) ; model. put ( ""familyName"", webincident. getFamilyName ( ) ) ; model. put ( ""givenName"", webincident. getGivenName ( ) ) ; model. put ( ""summary"", webincident. getSummary ( ) ) ; model. put ( ""details"", webincident. getDetails ( ) ) ; models. add ( model ) ; // assuming a method exists to process the model exchange. getOut ( ). setBody ( models ) ; } }",0.00020974704325464643
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . spi ; import com . asakusafw . dmdl . Diagnostic ; import com . asakusafw . dmdl . Diagnostic . Level ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . semantics . Declaration ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; public abstract class ModelAttributeDriver extends AttributeDriver { @ Override public final void process ( DmdlSemantics environment , Declaration declaration , AstAttribute attribute ) { assert attribute . name . toString ( ) . equals ( getTargetName ( ) ) ; if ( ('}]","environment. getDiagnosticLevel ( ). isHigherOrEqual ( Level. ERROR ) ) { Diagnostic. error ( environment, ""Unexpected attribute "" + getTargetName ( ) + "" at "" + declaration. getPosition ( ) ) ; } else { Diagnostic. info ( environment, ""Ignoring attribute "" + getTargetName ( ) + "" at "" + declaration. getPosition ( ) ) ; } super. process ( environment, declaration, attribute ) ; }",0.0001358760949624903
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . server ; import javax . management . Notification ; import org . oddjob . jmx . RemoteOddjobBean ; public class MockServerSideToolkit implements ServerSideToolkit { public ServerContext getContext ( ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public Notification createNotification ( String type ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public void runSynchronized ( Runnable runnable ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public void sendNotification ( Notification notification ) { throw new RuntimeException ( ""<STR_LIT>"" +'}]","getClass ( ) ) ; } public RemoteOddjobBean getRemoteOddjobBean ( ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } }",6.186762719015397e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . testing . flow ; import com . asakusafw . compiler . flow . processor . operator . LoggingFlowFactory ; import com . asakusafw . compiler . flow . processor . operator . UpdateFlowFactory ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . In ;'}]",import com.asakusafw.compiler.flow.testing.model.Ex2;,3.356442243468896e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . vaadin . teemu . clara . inflater ; @ SuppressWarnings ( ""<STR_LIT:serial>"" ) public class ComponentInstantiationException extends RuntimeException { public ComponentInstantiationException ( ) { super ( ) ; } public'}]","ComponentInstantiationException ( String message, Throwable cause ) { super ( message, cause ) ; }",3.7698332111690895e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . math . BigDecimal ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ TableModel ( name = ""<STR_LIT:bar>"" , primary = { } ) @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class Bar implements Writable { @ Property ( name = ""<STR_LIT>"" ) private LongOption pk = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailGroupId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailSenderId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailReceiverId = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailTestType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption detailStatus = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private IntOption detailLineNo = new IntOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption deleteFlg = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption insertDatetime = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption updateDatetime = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private ByteOption lineNo = new ByteOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption deliveryDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption storeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption buyerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption salesTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption sellerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tenantCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption netPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption sellingPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentStoreCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentSalesTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption deductionCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption accountCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DecimalOption decCol = new DecimalOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption ownershipDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption cutoffDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption payoutDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption ownershipFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cutoffFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption payoutFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption disposeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption disposeDate = new DateOption ( ) ; public long getPk ( ) { return this . pk . get ( ) ; } public void setPk ( long pk ) { this . pk . modify ( pk ) ; } public LongOption getPkOption ( ) { return this . pk ; } public void setPkOption ( LongOption pk ) { this . pk . copyFrom ( pk ) ; } public Text getDetailGroupId ( ) { return this . detailGroupId . get ( ) ; } public void setDetailGroupId ( Text detailGroupId ) { this . detailGroupId . modify ( detailGroupId ) ; } public String getDetailGroupIdAsString ( ) { return this . detailGroupId . getAsString ( ) ; } public void setDetailGroupIdAsString ( String detailGroupId ) { this . detailGroupId . modify ( detailGroupId ) ; } public StringOption getDetailGroupIdOption ( ) { return this . detailGroupId ; } public void setDetailGroupIdOption ( StringOption detailGroupId ) { this . detailGroupId . copyFrom ( detailGroupId ) ; } public Text getDetailType ( ) { return this . detailType . get ( ) ; } public void setDetailType ( Text detailType ) { this . detailType . modify ( detailType ) ; } public String getDetailTypeAsString ( ) { return this . detailType . getAsString ( ) ; } public void setDetailTypeAsString ( String detailType ) { this . detailType . modify ( detailType ) ; } public StringOption getDetailTypeOption ( ) { return this . detailType ; } public void setDetailTypeOption ( StringOption detailType ) { this . detailType . copyFrom ( detailType ) ; } public Text getDetailSenderId ( ) { return this . detailSenderId . get ( ) ; } public void setDetailSenderId ( Text detailSenderId ) { this . detailSenderId . modify ( detailSenderId ) ; } public String getDetailSenderIdAsString ( ) { return this . detailSenderId . getAsString ( ) ; } public void setDetailSenderIdAsString ( String detailSenderId ) { this . detailSenderId . modify ( detailSenderId ) ; } public StringOption getDetailSenderIdOption ( ) { return this . detailSenderId ; } public void setDetailSenderIdOption ( StringOption detailSenderId ) { this . detailSenderId . copyFrom ( detailSenderId ) ; } public Text getDetailReceiverId ( ) { return this . detailReceiverId . get ( ) ; } public void setDetailReceiverId ( Text detailReceiverId ) { this . detailReceiverId . modify ( detailReceiverId ) ; } public String getDetailReceiverIdAsString ( ) { return this . detailReceiverId . getAsString ( ) ; } public void setDetailReceiverIdAsString ( String detailReceiverId ) { this . detailReceiverId . modify ( detailReceiverId ) ; } public StringOption getDetailReceiverIdOption ( ) { return this . detailReceiverId ; } public void setDetailReceiverIdOption ( StringOption detailReceiverId ) { this . detailReceiverId . copyFrom ( detailReceiverId ) ; } public Text getDetailTestType ( ) { return this . detailTestType . get ( ) ; } public void setDetailTestType ( Text detailTestType ) { this . detailTestType . modify ( detailTestType ) ; } public String getDetailTestTypeAsString ( ) { return this . detailTestType . getAsString ( ) ; } public void setDetailTestTypeAsString ( String detailTestType ) { this . detailTestType . modify ( detailTestType ) ; } public StringOption getDetailTestTypeOption ( ) { return this . detailTestType ; } public void setDetailTestTypeOption ( StringOption detailTestType ) { this . detailTestType . copyFrom ( detailTestType ) ; } public Text getDetailStatus ( ) { return this . detailStatus . get ( ) ; } public void setDetailStatus ( Text detailStatus ) { this . detailStatus . modify ( detailStatus ) ; } public String getDetailStatusAsString ( ) { return this . detailStatus . getAsString ( ) ; } public void setDetailStatusAsString ( String detailStatus ) { this . detailStatus . modify ( detailStatus ) ; } public StringOption getDetailStatusOption ( ) { return this . detailStatus ; } public void setDetailStatusOption ( StringOption detailStatus ) { this . detailStatus . copyFrom ( detailStatus ) ; } public int getDetailLineNo ( ) { return this . detailLineNo . get ( ) ; } public void setDetailLineNo ( int detailLineNo ) { this . detailLineNo . modify ( detailLineNo ) ; } public IntOption getDetailLineNoOption ( ) { return this . detailLineNo ; } public void setDetailLineNoOption ( IntOption detailLineNo ) { this . detailLineNo . copyFrom ( detailLineNo ) ; } public Text getDeleteFlg ( ) { return this . deleteFlg . get ( ) ; } public void setDeleteFlg ( Text deleteFlg ) { this . deleteFlg . modify ( deleteFlg ) ; } public String getDeleteFlgAsString ( ) { return this . deleteFlg . getAsString ( ) ; } public void setDeleteFlgAsString ( String deleteFlg ) { this . deleteFlg . modify ( deleteFlg ) ; } public StringOption getDeleteFlgOption ( ) { return this . deleteFlg ; } public void setDeleteFlgOption ( StringOption deleteFlg ) { this . deleteFlg . copyFrom ( deleteFlg ) ; } public Date getInsertDatetime ( ) { return this . insertDatetime . get ( ) ; } public void setInsertDatetime ( Date insertDatetime ) { this . insertDatetime . modify ( insertDatetime ) ; } public DateOption getInsertDatetimeOption ( ) { return this . insertDatetime ; } public void setInsertDatetimeOption ( DateOption insertDatetime ) { this . insertDatetime . copyFrom ( insertDatetime ) ; } public Date getUpdateDatetime ( ) { return this . updateDatetime . get ( ) ; } public void setUpdateDatetime ( Date updateDatetime ) { this . updateDatetime . modify ( updateDatetime ) ; } public DateOption getUpdateDatetimeOption ( ) { return this . updateDatetime ; } public void setUpdateDatetimeOption ( DateOption updateDatetime ) { this . updateDatetime . copyFrom ( updateDatetime ) ; } public Text getPurchaseNo ( ) { return this . purchaseNo . get ( ) ; } public void setPurchaseNo ( Text purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public String getPurchaseNoAsString ( ) { return this . purchaseNo . getAsString ( ) ; } public void setPurchaseNoAsString ( String purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public StringOption getPurchaseNoOption ( ) { return this . purchaseNo ; } public void setPurchaseNoOption ( StringOption purchaseNo ) { this . purchaseNo . copyFrom ( purchaseNo ) ; }'}]",public Text getPurchaseType ( ) { return this. purchaseType. get ( ) ; },9.385555579519985e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . excel ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . io . InputStream ; import java . math . BigDecimal ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . Calendar ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . ss . usermodel . Sheet ; import org . junit . Test ; import com . asakusafw . testdriver . core . DataModelDefinition ; import com . asakusafw . testdriver . core . DataModelReflection ; import com . asakusafw . testdriver . model . SimpleDataModelDefinition ; public class ExcelSheetDataModelSourceTest { static final DataModelDefinition < Simple > SIMPLE = new SimpleDataModelDefinition < Simple > ( Simple . class ) ; @ Test public void simple ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple simple = next ( source ) ; assertThat ( simple . number , is ( <NUM_LIT:100> ) ) ; assertThat ( simple . text , is ( ""<STR_LIT>"" ) ) ; end ( source ) ; } @ Test public void multiple ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . number , is ( <NUM_LIT:10> ) ) ; assertThat ( r1 . text , is ( ""<STR_LIT>"" ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . number , is ( <NUM_LIT:20> ) ) ; assertThat ( r2 . text , is ( ""<STR_LIT>"" ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . number , is ( <NUM_LIT:30> ) ) ; assertThat ( r3 . text , is ( ""<STR_LIT>"" ) ) ; end ( source ) ; } @ Test public void blank_cell ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . number , is ( <NUM_LIT:10> ) ) ; assertThat ( r1 . text , is ( nullValue ( ) ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . number , is ( nullValue ( ) ) ) ; assertThat ( r2 . text , is ( ""<STR_LIT:a>"" ) ) ; end ( source ) ; } @ Test public void stringify ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . number , is ( <NUM_LIT:100> ) ) ; assertThat ( r1 . text , is ( ""<STR_LIT>"" ) ) ; end ( source ) ; } @ Test public void empty_string ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . text , is ( ""<STR_LIT>"" ) ) ; end ( source ) ; } @ Test public void boolean_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . booleanValue , is ( true ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . booleanValue , is ( false ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . booleanValue , is ( true ) ) ; Simple r4 = next ( source ) ; assertThat ( r4 . booleanValue , is ( false ) ) ; end ( source ) ; } @ Test public void byte_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . byteValue , is ( Byte . MIN_VALUE ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . byteValue , is ( Byte . MAX_VALUE ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . byteValue , is ( ( byte ) - <NUM_LIT> ) ) ; Simple r4 = next ( source ) ; assertThat ( r4 . byteValue , is ( ( byte ) + <NUM_LIT:2> ) ) ; end ( source ) ; } @ Test public void short_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . shortValue , is ( Short . MIN_VALUE ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . shortValue , is ( Short . MAX_VALUE ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . shortValue , is ( ( short ) - <NUM_LIT> ) ) ; Simple r4 = next ( source ) ; assertThat ( r4 . shortValue , is ( ( short ) + <NUM_LIT> ) ) ; end ( source ) ; } @ Test public void int_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . number , is ( Integer . MIN_VALUE ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . number , is ( Integer . MAX_VALUE ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . number , is ( - <NUM_LIT> ) ) ; Simple r4 = next ( source ) ; assertThat ( r4 . number , is ( + <NUM_LIT> ) ) ; end ( source ) ; } @ Test public void long_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . longValue , is ( - <NUM_LIT> ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . longValue , is ( + <NUM_LIT> ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . longValue , is ( Long . MIN_VALUE ) ) ; Simple r4 = next ( source ) ; assertThat ( r4 . longValue , is ( Long . MAX_VALUE ) ) ; end ( source ) ; } @ Test public void float_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1 . floatValue , is ( - <NUM_LIT:1.0f> ) ) ; Simple r2 = next ( source ) ; assertThat ( r2 . floatValue , is ( + <NUM_LIT> ) ) ; Simple r3 = next ( source ) ; assertThat ( r3 . floatValue , is'}]","( Float. MIN_VALUE ) ); Simple r4 = next ( source ) ; assertThat ( r4. floatValue, is ( Float. MAX_VALUE ) ); end ( source ) ; } @ Test public void double_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1. doubleValue, is ( - <NUM_LIT:1.0> ) ) ; Simple r2 = next ( source ) ; assertThat ( r2. doubleValue, is ( + <NUM_LIT> ) ) ; Simple r3 = next ( source ) ; assertThat ( r3. doubleValue, is ( Double. MIN_VALUE ) ) ; Simple r4 = next ( source ) ; assertThat ( r4. doubleValue, is ( Double. MAX_VALUE ) ) ; end ( source ) ; } @ Test public void big_decimal_values ( ) throws Exception { ExcelSheetDataModelSource source = open ( ""<STR_LIT>"" ) ; Simple r1 = next ( source ) ; assertThat ( r1. bigDecimal, is ( new BigDecimal ( - <NUM_LIT> ) ) ) ; Simple r2 = next ( source ) ; assertThat ( r2.",0.00042134072396845824
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . tests . editor ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . StringInputStream ; import net . sf . sveditor . core . db . ISVDBFileFactory ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBMarker ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . tests . FileIndexIterator ; import net . sf . sveditor . ui . editor . ISVEditor ; import net . sf . sveditor . ui . tests . UiReleaseTests ; import net . sf . sveditor . ui . tests . editor . utils . AutoEditTester ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . ITextSelection ; public class SVEditorTester implements ISVEditor { private IDocument fDoc ; private AutoEditTester fAutoEditTester ; private ISVDBIndexIterator fIndexIt ; private SVDBFile fSVDBFile ; private ITextSelection fTextSel ; public SVEditorTester ( AutoEditTester auto_ed , ISVDBIndexIterator index_it , SVDBFile file ) { fAutoEditTester = auto_ed ; fIndexIt = index_it ; fSVDBFile = file ; fTextSel = null ; } public SVEditorTester ( String doc , String filename ) throws BadLocationException { fAutoEditTester = UiReleaseTests . createAutoEditTester ( ) ; fAutoEditTester . setContent ( doc ) ; ISVDBFileFactory factory ='}]",SVCorePlugin.getDefault().getDBFileFactory(); fIndexIt = factory.createIndexIterator(filename); fSVDBFile = factory.createDBFile(filename); fTextSel = fAutoEditTester.getSelection(); } public void setDocument ( IDocument doc ) { fDoc = doc ; } public void setSelection ( ITextSelection sel ) { fTextSel = sel ; } public IDocument getDocument ( ) { return fDoc ; } public ITextSelection getSelection ( ) { return fTextSel ; } public void setAutoEditTester ( AutoEditTester autoEditTester ) { fAutoEditTester = autoEditTester ; } public AutoEditTester getAutoEditTester ( ) { return fAutoEditTester ; } public void setIndexIterator ( ISVDBIndexIterator indexIt ) { fIndexIt = indexIt ; } public ISVDBIndexIterator getIndexIterator ( ) { return fIndexIt ; } public void setSVDBFile ( SVDBFile file ) { fSVDBFile = file ; } public SVDBFile getSVDBFile ( ) { return fSVDBFile ; } },0.00031233219351766
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . common . kahva ; import java . net . URL ; import javax . xml . namespace . QName ; import javax . xml . ws . BindingProvider ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import fi . arcusys . tampere . hrsoa . ws . ldap . LdapService ; import fi . arcusys . tampere . hrsoa . ws . ldap . LdapService_Service ; public class LdapServiceFactory { private String epAddr ; private final URL wsdlLocation = getClass ( ) . getClassLoader ( ) . getResource ( ""<STR_LIT>"" ) ; private static Logger log = LoggerFactory . getLogger ( LdapServiceFactory . class ) ; public LdapServiceFactory ( String endpointAddr ) { this . epAddr = endpointAddr ; } public LdapService getOrganizationService ( ) { if ( wsdlLocation == null ) log . error ( ""<STR_LIT>"" ) ; LdapService_Service service = new LdapService_Service ('}]","wsdlLocation);LdapService port = service.getOrganizationService();BindingProvider binding = (BindingProvider) port;binding.getRequestContext().put(QName.WS_SECURITY_USERNAME, ""username"");binding.getRequestContext().put(QName.WS_SECURITY_PASSWORD, ""password"");return port;}public LdapService getLdapService() {if (wsdlLocation == null) log.error(""<STR_LIT>"");LdapService_Service service = new LdapService_Service(wsdlLocation);LdapService port = service.getLdapService();BindingProvider binding = (BindingProvider) port;binding.getRequestContext().put(QName.WS_SECURITY_USERNAME, ""username"");binding.getRequestContext().put(QName.WS_SECURITY_PASSWORD, ""password"");return port;}",0.00021245257609506083
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory . CogroupAdd ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory . FoldAdd ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . FlowPart ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; @ SuppressWarnings ( ""<STR_LIT:all>"" ) @ FlowPart public class CombineStage extends FlowDescription { private In < Ex1 > in1 ; private Out < Ex1 > out1 ;'}]","private In<Ex1> in2; private Out<Ex1> out2; public CombineStage(In<Ex1> in1, In<Ex1> in2) { this.in1 = in1; this.in2 = in2; } @Override public void build(FlowBuilder builder) { out1 = builder.add(in1, new FoldAdd<>()); out2 = builder.add(in2, new CogroupAdd<>()); builder.connect(out1, out2); } }",0.00015042274999030794
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . net . URI ; import org . junit . Test ; public class SpiVerifyRuleProviderTest extends SpiTestRoot { @ Test public void open ( ) throws Exception { ClassLoader cl = register ( VerifyRuleProvider . class , MockVerifyRuleProvider . class ) ; SpiVerifyRuleProvider target = new SpiVerifyRuleProvider ( cl ) ; VerifyContext context = new VerifyContext ( new TestContext . Empty ( ) ) ; context . testFinished ( ) ; VerifyRule rule = target . get ( ValueDefinition . of ( String . class ) , context , new URI ( ""<STR_LIT>"" ) ) ; assertThat ( rule , not ( nullValue ( ) ) ) ; DataModelReflection ref = ValueDefinition . of ( String . class ) . toReflection ( ""<STR_LIT>"" ) ; assertThat ( rule . getKey ( ref ) , is ( ( Object ) ref ) ) ; } @ Test public void open_notfound ( )'}]","throws Exception { ClassLoader cl = register ( VerifyRuleProvider. class, MockVerifyRuleProvider. class ) ; SpiVerifyRuleProvider target = new SpiVerifyRuleProvider ( cl ) ; VerifyContext context = new VerifyContext ( new TestContext. Empty ( ) ) ; context. testFinished ( ) ; VerifyRule rule = target. get ( ValueDefinition. of ( String. class ), context, new URI ( ""<STR_LIT>"" ) ) ; assertThat ( rule, nullValue ( ) ) ; }",0.00015183702667478585
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . common ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . runtime . util . VariableTable ; public final class FileNameUtil { private static final Class < ? > CLASS = FileNameUtil . class ; private FileNameUtil ( ) { return ; } public static File createImportFilePath ( String targetName , String jobflowId , String executionId , String tableName ) throws BulkLoaderSystemException { File fileDirectry = new File ( ConfigurationLoader . getProperty ( Constants . PROP_KEY_IMP_FILE_DIR ) ) ; if ( ! fileDirectry . exists ( ) ) { throw new BulkLoaderSystemException ( CLASS , ""<STR_LIT>"" , fileDirectry . getAbsolutePath ( ) ) ; } StringBuilder strFileName = new StringBuilder ( Constants . IMPORT_FILE_PREFIX ) ; strFileName . append ( Constants . IMPORT_FILE_DELIMITER ) ; strFileName . append ( targetName ) ; strFileName . append ( Constants . IMPORT_FILE_DELIMITER ) ; strFileName . append ( jobflowId ) ; strFileName . append ( Constants .'}]","IMPORT_FILE_DELIMITER ) ; strFileName. append ( executionId ) ; strFileName. append ( Constants. IMPORT_FILE_DELIMITER ) ; strFileName. append ( tableName ) ; strFileName. append ( Constants. IMPORT_FILE_SUFFIX ) ; File importFilePath = new File ( fileDirectry, strFileName. toString ( ) ) ; if ( importFilePath. exists ( ) ) { throw new BulkLoaderSystemException ( CLASS, ""<STR_LIT>"", importFilePath. getAbsolutePath ( ) ) ; } return importFilePath ; } }",0.00015880848048203453
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . file . resource ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . text . MessageFormat ; import com . asakusafw . windgate . core . resource . DrainDriver ; class FileDrainDriver < T > implements DrainDriver < T > { private final File file ; private ObjectOutputStream output ; public FileDrainDriver ( Class < T > type , File file ) { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( file == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . file = file ; } @ Override public void prepare ( ) throws IOException { if ( file . exists ( ) &&'}]","! file. canWrite ( ) ) { throw new IOException ( MessageFormat. format ( ""<STR_LIT> {0}"", file. getAbsolutePath ( ) ) ) ; } output = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; } @ Override public void drain ( T data ) throws IOException { output. writeObject ( data ) ; } @ Override public void close ( ) throws IOException { if ( output!= null ) { output. close ( ) ; } } }",0.00013745375017046053
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . java ; import static com . asakusafw . dmdl . util . CommandLineUtils . * ; import java . io . File ; import java . nio . charset . Charset ; import java . text . MessageFormat ; import java . util . Locale ; import org . apache . commons . cli . BasicParser ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . cli . CommandLineParser ; import org . apache . commons . cli . HelpFormatter ; import org . apache . commons . cli . Option ; import org . apache . commons . cli . Options ; import org . apache . commons . cli . ParseException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . dmdl . source . DmdlSourceRepository ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . util . Filer ; import com . asakusafw . utils . java . model . util . Models ; public final class Main { static final Logger LOG = LoggerFactory . getLogger ( Main . class ) ; private static final Option OPT_OUTPUT ; private static final Option OPT_PACKAGE ; private static final Option OPT_SOURCE_ENCODING ; private static final Option OPT_TARGET_ENCODING ; private static final Option OPT_SOURCE_PATH ; private static final Option OPT_PLUGIN ; private static final Options OPTIONS ; static { OPT_OUTPUT = new Option ( ""<STR_LIT>"" , true , ""<STR_LIT>"" ) ; OPT_OUTPUT . setArgName ( ""<STR_LIT>"" ) ; OPT_OUTPUT . setRequired ( true ) ; OPT_SOURCE_PATH = new Option ( ""<STR_LIT:source>"" , true , ""<STR_LIT>"" ) ; OPT_SOURCE_PATH . setArgName ( ""<STR_LIT>"" + File . pathSeparatorChar + ""<STR_LIT>"" ) ; OPT_SOURCE_PATH . setRequired ( true ) ; OPT_PACKAGE = new Option ( ""<STR_LIT>"" , true , ""<STR_LIT>"" ) ; OPT_PACKAGE . setArgName ( ""<STR_LIT>"" ) ; OPT_PACKAGE . setRequired ( true ) ; OPT_SOURCE_ENCODING = new Option ( ""<STR_LIT>"" , true , ""<STR_LIT>"" ) ; OPT_SOURCE_ENCODING . setArgName ( ""<STR_LIT>"" ) ; OPT_SOURCE_ENCODING . setRequired ( false ) ; OPT_TARGET_ENCODING = new Option ( ""<STR_LIT>"" , true , ""<STR_LIT>"" ) ; OPT_TARGET_ENCODING . setArgName ( ""<STR_LIT>"" ) ; OPT_TARGET_ENCODING . setRequired ( false ) ; OPT_PLUGIN = new Option ( ""<STR_LIT>"" , true , ""<STR_LIT>"" ) ; OPT_PLUGIN . setArgName ( ""<STR_LIT>"" + File . pathSeparatorChar + ""<STR_LIT>"" ) ; OPT_PLUGIN . setValueSeparator ( File . pathSeparatorChar ) ; OPT_PLUGIN . setRequired ( false ) ; OPTIONS = new Options ( ) ; OPTIONS . addOption ( OPT_OUTPUT ) ; OPTIONS . addOption ( OPT_PACKAGE ) ; OPTIONS . addOption ( OPT_SOURCE_ENCODING ) ; OPTIONS . addOption ( OPT_TARGET_ENCODING ) ; OPTIONS . addOption ( OPT_SOURCE_PATH ) ; OPTIONS . addOption ( OPT_PLUGIN ) ; } private Main ( ) { return ; } public static void main ( String ... args ) { GenerateTask task ; try { Configuration conf = configure ( args ) ; task = new GenerateTask ( conf ) ; } catch ( Exception e ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . setWidth ( Integer . MAX_VALUE ) ; formatter . printHelp ( MessageFormat . format ( ""<STR_LIT>"" , Main . class . getName ( )'}]","), OPTIONS, e.getMessage() ) ; return; } finally { if ( task!= null ) { task.close(); } } task.execute(); } private static Configuration configure ( String... args ) throws ParseException, IOException { CommandLineParser parser = new BasicParser(); CommandLine line = parser.parse(OPTIONS, args); Locale locale = Locale.getDefault(); String sourceEncoding = line.getValue(OPT_SOURCE_ENCODING); String targetEncoding = line.getValue(OPT_TARGET_ENCODING); if (sourceEncoding == null) { sourceEncoding = Charset.defaultCharset().name(); } if (targetEncoding == null) { targetEncoding = Charset.defaultCharset().name(); } String sourcePath = line.getValue(OPT_SOURCE_PATH); if (sourcePath == null) { sourcePath = Filer.getCurrentDirectory().getPath(); } String package_ = line.getValue(OPT_PACKAGE); if (package_ == null) { package_ = ModelFactory.getDefaultPackage(); } String output = line.getValue(OPT_OUTPUT); if (output == null) { output = Filer.getCurrentDirectory().getPath(); } String plugin = line.getValue(OPT_PLUGIN); DmdlSourceRepository repository = new DmdlSourceRepository(locale, sourceEncoding, targetEncoding, new File(sourcePath)); Models.setRepository(repository); ModelFactory.setPackage(package_); Model",0.0003771473095636052
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . handlers ; import java . lang . reflect . Proxy ; import org . oddjob . framework . Exportable ; import org . oddjob . framework . Transportable ; import org . oddjob . jmx . client . ClientInterfaceHandlerFactory ; import org . oddjob . jmx . client . ClientSideToolkit ; import org . oddjob . jmx . client . HandlerVersion ; public class ExportableHandlerFactory implements ClientInterfaceHandlerFactory < Exportable > { public static final HandlerVersion VERSION = new HandlerVersion ( <NUM_LIT:1> , <NUM_LIT:0> ) ; public Class < Exportable > interfaceClass ( ) { return Exportable . class ; } public HandlerVersion getVersion ( ) {'}]","return VERSION; } public ClientSideToolkit createToolkit ( Exportable instance, ClassLoader classLoader ) { return new ClientSideToolkit ( Proxy. newProxyInstance ( classLoader, new Class [ ] { instance. getInterface ( ) }, new ClientInterfaceHandler ( instance ) ) ) ; } }",9.257776571916523e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . elements . schedule ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org .'}]","oddjob.arooa.design.DesignInstanceFactory;public class ScheduleElementTestCase extends TestCase { private static final Logger logger = Logger.getLogger(ScheduleElementTestCase.class); public void testScheduleElement() throws ArooaParseException { DesignInstance instance = DesignInstanceFactory.create(OddjobDescriptorFactory.create(""schedule.xml"")); logger.info(instance.toString()); } }",0.00010556467923514475
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ti . data ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . rubypeople . rdt . internal . ti . BasicTypeGuess ; import org . rubypeople . rdt . internal . ti . ITypeGuess ; public abstract class TypicalMethodReturnNames { public static Collection < ITypeGuess > get ( String method ) { if ( method . endsWith ( ""<STR_LIT:?>"" ) ) { return createSet ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } Collection < ITypeGuess > result = TYPICAL_METHOD_RETURN_TYPE_NAMES . get ( method ) ; if ( result == null ) return Collections . emptySet ( ) ; return result ; } private static final Map < String , Collection < ITypeGuess > > TYPICAL_METHOD_RETURN_TYPE_NAMES = new HashMap < String , Collection < ITypeGuess > > ( ) ; static { TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT:count>"" , createSet ( ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" , ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT:index>"" , createSet ( ""<STR_LIT>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet ( ""<STR_LIT:String>"" ) ) ; TYPICAL_METHOD_RETURN_TYPE_NAMES . put ( ""<STR_LIT>"" , createSet'}]","ITypeGuess basic = new BasicTypeGuess(""<STR_LIT>"", ""<STR_LIT:String>"");",5.637134673788475e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . monitor ; import static org . junit . Assert . assertEquals ; import static org . mockito . Mockito . when ; import java . util . EnumSet ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . Mock ; import org . mockito . runners . MockitoJUnitRunner ; import br . com . caelum . vraptor . http . route . Route ; import br . com . caelum . vraptor . resource . HttpMethod ; @ RunWith ( MockitoJUnitRunner . class ) public class FreemarkerRouteTest { private @ Mock Route routeMock ; private FreemarkerRoute route ; @ Before public void setUp ( ) throws Exception { route = new FreemarkerRoute ( routeMock ) ; } @ Test public void returnsGETandPOSTWhenHttpMethodsGETAndPOSTAllowed ( ) { when ( routeMock . allowedMethods ( ) ) . thenReturn ( EnumSet . of ( HttpMethod . GET , HttpMethod . POST ) ) ; assertEquals ( ""<STR_LIT>"" , route . getAllowedMethods ( ) ) ; } @ Test public void returnsPUTandDeleteWhenHttpMethodsPutAndDeleteAllowed ( ) {'}]","when(routeMock.allowedMethods()).thenReturn(EnumSet.of(HttpMethod.PUT, HttpMethod.DELETE)); assertEquals(EnumSet.of(HttpMethod.PUT, HttpMethod.DELETE), route.getAllowedMethods()); } @Test public void returnsAllowedMethodsWhenRouteAllowedMethodsIsNotNull() { when(routeMock.allowedMethods()).thenReturn(EnumSet.of(HttpMethod.GET, HttpMethod.POST)); assertEquals(EnumSet.of(HttpMethod.GET, HttpMethod.POST), route.getAllowedMethods()); }",0.00012888691318508513
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Path ; import org . rubypeople . rdt . core . ILoadpathAttribute ; import org . rubypeople . rdt . core . ILoadpathContainer ; import org . rubypeople . rdt . core . ILoadpathEntry ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . LoadpathContainerInitializer ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . util . RubyModelUtil ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . launching . RubyRuntime ; public class CPListElement { public static final String EXCLUSION = ""<STR_LIT>"" ; public static final String INCLUSION = ""<STR_LIT>"" ; private IRubyProject fProject ; private int fEntryKind ; private IPath fPath , fOrginalPath ; private IResource fResource ; private boolean fIsExported ; private boolean fIsMissing ; private Object fParentContainer ; private ILoadpathEntry fCachedEntry ; private ArrayList fChildren ; private IPath fLinkTarget , fOrginalLinkTarget ; public CPListElement ( IRubyProject project , int entryKind , IPath path , IResource res ) { this ( null , project , entryKind , path , res ) ; } public CPListElement ( Object parent , IRubyProject project , int entryKind , IPath path , IResource res ) { this ( parent , project , entryKind , path , res , null ) ; } public CPListElement ( IRubyProject project , int entryKind ) { this ( null , project , entryKind , null , null ) ; } public CPListElement ( Object parent , IRubyProject project , int entryKind , IPath path , IResource res , IPath linkTarget ) { fProject = project ; fEntryKind = entryKind ; fPath = path ; fOrginalPath = path ; fLinkTarget = linkTarget ; fOrginalLinkTarget = linkTarget ; fChildren = new ArrayList ( ) ; fResource = res ; fIsExported = false ; fIsMissing = false ; fCachedEntry = null ; fParentContainer = parent ; switch ( entryKind ) { case ILoadpathEntry . CPE_SOURCE : createAttributeElement ( INCLUSION , new Path [ <NUM_LIT:0> ] , true ) ; createAttributeElement ( EXCLUSION , new Path [ <NUM_LIT:0> ] , true ) ; break ; case ILoadpathEntry . CPE_LIBRARY : case ILoadpathEntry . CPE_VARIABLE : break ; case ILoadpathEntry . CPE_PROJECT : break ; case ILoadpathEntry . CPE_CONTAINER : try { ILoadpathContainer container = RubyCore . getLoadpathContainer ( fPath , fProject ) ; if ( container != null ) { ILoadpathEntry [ ] entries = container . getLoadpathEntries ( ) ; for ( int i = <NUM_LIT:0> ; i < entries . length ; i ++ ) { ILoadpathEntry entry = entries [ i ] ; if ( entry != null ) { CPListElement curr = createFromExisting ( this , entry , fProject ) ; fChildren . add ( curr ) ; } else { RubyPlugin . logErrorMessage ( ""<STR_LIT>"" + fPath + ""<STR_LIT:\'>"" ) ; } } } } catch ( RubyModelException e ) { } break ; default : } } public ILoadpathEntry getLoadpathEntry ( ) { if ( fCachedEntry == null ) { fCachedEntry = newLoadpathEntry ( ) ; } return fCachedEntry ; } private ILoadpathAttribute [ ] getLoadpathAttributes ( ) { ArrayList res = new ArrayList ( ) ; for ( int i = <NUM_LIT:0> ; i < fChildren . size ( ) ; i ++ ) { Object curr = fChildren . get ( i ) ; if ( curr instanceof CPListElementAttribute ) { CPListElementAttribute elem = ( CPListElementAttribute ) curr ; if ( ! elem . isBuiltIn ( ) && elem . getValue ( ) != null ) { res . add ( elem . newLoadpathAttribute ( ) ) ; } } } return ( ILoadpathAttribute [ ] ) res . toArray ( new ILoadpathAttribute [ res . size ( ) ] ) ; } private ILoadpathEntry newLoadpathEntry ( ) { ILoadpathAttribute [ ] extraAttributes = getLoadpathAttributes ( ) ; switch ( fEntryKind ) { case ILoadpathEntry . CPE_SOURCE : IPath [ ] inclusionPattern = ( IPath [ ] ) getAttribute ( INCLUSION ) ; IPath [ ] exclusionPattern = ( IPath [ ] ) getAttribute ( EXCLUSION ) ; return RubyCore . newSourceEntry ( fPath , inclusionPattern , exclusionPattern , extraAttributes ) ; case ILoadpathEntry . CPE_LIBRARY : { return RubyCore . newLibraryEntry ( fPath , extraAttributes , isExported ( ) ) ; } case ILoadpathEntry . CPE_PROJECT : { return RubyCore . newProjectEntry ( fPath , extraAttributes , isExported ( ) ) ; } case ILoadpathEntry . CPE_CONTAINER : { return RubyCore . newContainerEntry ( fPath , extraAttributes , isExported ( ) ) ; } case ILoadpathEntry . CPE_VARIABLE : { return RubyCore . newVariableEntry ( fPath , extraAttributes , isExported ( ) ) ; } default : return null ; } } public IPath getPath ( ) { return fPath ; } public int getEntryKind ( ) { return fEntryKind ; } public IResource getResource ( ) { return fResource ; } public CPListElementAttribute setAttribute ( String key , Object value ) { CPListElementAttribute attribute = findAttributeElement ( key ) ; if ( attribute == null ) { return null ; } if ( key . equals ( EXCLUSION ) || key . equals ( INCLUSION ) ) { Assert . isTrue ( value != null || fEntryKind != ILoadpathEntry . CPE_SOURCE ) ; } attribute . setValue ( value ) ; attributeChanged ( key ) ; return attribute ; } public boolean addToExclusions ( IPath path ) { String key = CPListElement . EXCLUSION ; return addFilter ( path , key ) ; } public boolean addToInclusion ( IPath path ) { String key = CPListElement . INCLUSION ; return addFilter ( path , key ) ; } public boolean removeFromExclusions ( IPath path ) { String key = CPListElement . EXCLUSION ; return removeFilter ( path , key ) ; } public boolean removeFromInclusion ( IPath path ) { String key = CPListElement . INCLUSION ; return removeFilter ( path , key ) ; } private boolean addFilter ( IPath path , String key ) { IPath [ ] exclusionFilters = ( IPath [ ] ) getAttribute ( key ) ; if ( ! RubyModelUtil . isExcludedPath ( path , exclusionFilters ) ) { IPath pathToExclude = path . removeFirstSegments ( getPath ( ) . segmentCount ( ) ) . addTrailingSeparator ( ) ; IPath [ ] newExclusionFilters = new IPath [ exclusionFilters . length + <NUM_LIT:1> ] ; System . arraycopy ( exclusionFilters , <NUM_LIT:0> , newExclusionFilters , <NUM_LIT:0> , exclusionFilters . length ) ; newExclusionFilters [ exclusionFilters . length ] = pathToExclude ; setAttribute ( key , newExclusionFilters ) ; return true ; } return false ; } private boolean removeFilter ( IPath path , String key ) { IPath [ ] exclusionFilters = ( IPath [ ] ) getAttribute ( key ) ; IPath pathToExclude = path . removeFirstSegments ( getPath ( ) . segmentCount ( ) ) . addTrailingSeparator ( ) ; if ( RubyModelUtil . isExcludedPath ( pathToExclude , exclusionFilters ) ) { List l = new ArrayList ( Arrays . asList ( exclusionFilters ) ) ; l . remove ( pathToExclude ) ; IPath [ ] newExclusionFilters = ( IPath [ ] ) l . toArray ( new IPath [ l . size ( ) ] ) ; setAttribute ( key , newExclusionFilters ) ; return true ; } return false ; } public CPListElementAttribute findAttributeElement ( String key ) { for ( int i = <NUM_LIT:0> ; i < fChildren . size ( ) ; i ++ ) { Object curr = fChildren . get ( i ) ; if ( curr instanceof CPListElementAttribute ) { CPListElementAttribute elem = ( CPListElementAttribute ) curr ; if ( key . equals ( elem . getKey ( ) ) ) { return elem ; } } } return null ; } public Object getAttribute ( String key ) { CPListElementAttribute attrib = findAttributeElement ( key ) ; if ( attrib != null ) { return attrib . getValue ( ) ; } return null ; } private void createAttributeElement ( String key , Object value , boolean builtIn ) { fChildren . add ( new CPListElementAttribute ( this , key , value , builtIn ) ) ; } private static boolean isFiltered ( Object entry , String [ ] filteredKeys ) { if ( entry instanceof CPListElementAttribute ) { String key = ( ( CPListElementAttribute ) entry ) . getKey ( ) ; for ( int i = <NUM_LIT:0> ; i < filteredKeys . length ; i ++ ) { if ( key . equals ( filteredKeys [ i ] ) ) { return true ; } } } return false ; } private Object [ ] getFilteredChildren ( String [ ] filteredKeys ) { int nChildren = fChildren . size ( ) ; ArrayList res = new ArrayList ( nChildren ) ; for ( int i = <NUM_LIT:0> ; i < nChildren ; i ++ ) { Object curr = fChildren . get ( i ) ; if ( ! isFiltered ( curr , filteredKeys ) ) { res . add ( curr ) ; } } return res . toArray ( ) ; } public Object [ ] getChildren ( boolean hideOutputFolder ) { if ( hideOutputFolder && fEntryKind == ILoadpathEntry . CPE_SOURCE ) { return getFilteredChildren ( new String [ ] { } ) ; } if ( fParentContainer instanceof CPListElement ) { IPath jreContainerPath = new Path ( RubyRuntime . RUBY_CONTAINER ) ; if ( jreContainerPath . isPrefixOf ( ( ( CPListElement ) fParentContainer ) . getPath ( ) ) ) { return getFilteredChildren ( new String [ ] { } ) ; } } if ( fEntryKind == ILoadpathEntry . CPE_PROJECT ) { return getFilteredChildren ( new String [ ] { } ) ; } return fChildren . toArray ( ) ; } public Object getParentContainer ( ) { return fParentContainer ; } private void attributeChanged ( String key ) { fCachedEntry = null ; } private boolean canUpdateContainer ( ) { if ( fEntryKind == ILoadpathEntry . CPE_CONTAINER && fProject != null ) { LoadpathContainerInitializer initializer = RubyCore . getLoadpathContainerInitializer ( fPath . segment ( <NUM_LIT:0> ) ) ; return ( initializer != null && initializer . canUpdateLoadpathContainer ( fPath , fProject ) ) ; } return false ; } public boolean isInNonModifiableContainer ( ) { if ( fParentContainer instanceof CPListElement ) { return ! ( ( CPListElement ) fParentContainer ) . canUpdateContainer ( ) ; } return false ; } public boolean equals ( Object other ) { if ( other != null && other . getClass ( ) . equals ( getClass ( ) ) ) { CPListElement elem = ( CPListElement ) other ; return getLoadpathEntry ( ) . equals ( elem . getLoadpathEntry ( ) ) ; } return false ; } public int hashCode ( ) { return fPath . hashCode ( ) + fEntryKind ; } public String toString ( ) { return getLoadpathEntry ( ) . toString ( ) ; } public boolean isMissing ( ) { return fIsMissing ; } public void setIsMissing ( boolean isMissing ) { fIsMissing = isMissing ; } public boolean isExported ( ) { return fIsExported ; } public void setExported ( boolean isExported ) { if ( isExported != fIsExported ) { fIsExported = isExported ; attributeChanged ( null ) ; } } public IRubyProject getRubyProject ( ) { return fProject ; } public static CPListElement createFromExisting ( ILoadpathEntry curr , IRubyProject project ) { return createFromExisting ( null , curr , project ) ; } public static CPListElement createFromExisting ( Object parent , ILoadpathEntry curr , IRubyProject project ) { IPath path = curr . getPath ( ) ; IWorkspaceRoot root = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; IResource res = null ; boolean isMissing = false ; IPath linkTarget = null ; switch ( curr . getEntryKind ( ) ) { case ILoadpathEntry . CPE_CONTAINER : res = null ; try { isMissing = project != null && ( RubyCore . getLoadpathContainer ( path , project ) == null ) ; } catch ( RubyModelException e ) { isMissing = true ; } break ; case ILoadpathEntry . CPE_VARIABLE : IPath resolvedPath = RubyCore . getResolvedVariablePath ( path ) ; res = null ; if ( resolvedPath == null ) { isMissing = true ; } else { isMissing = ! resolvedPath . toFile ( ) . isDirectory ( ) ; } break ; case ILoadpathEntry . CPE_LIBRARY : res = root . findMember ('}]","path); break; case ILoadpathEntry.CPE_PROJECT: res = root.findMember(path); break; default: return null; } return new CPListElement(parent, project, curr.getEntryKind(), path, res, linkTarget); } public static CPListElement createFromExisting(IPath path, IRubyProject project) { return createFromExisting(null, project, path, project); } public static CPListElement createFromExisting(Object parent, IRubyProject project, IPath path, IRubyProject project) { return createFromExisting(parent, RubyCore.getLoadpathEntry(path, project), project); } }",0.0002863829800592014
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . swt . widgets . Composite ; public class ConstructorGenerationTree extends CheckboxTreeViewer { public ConstructorGenerationTree ( Composite parent , ITreeContentProvider contentProvider ) { super ( parent ) ; this . setAutoExpandLevel ( <NUM_LIT:3> ) ; setContentProvider ( contentProvider ) ; setInput ( ""<STR_LIT>"" ) ; addCheckStateListener ( new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { handleItemChecked ( event . getChecked ( ) , event . getElement ( ) ) ; } } ) ; } protected void handleItemChecked ( boolean checked , Object element ) { if ( element instanceof CheckableItem ) { CheckableItem checkableItem = ( CheckableItem ) element ; setItemChecked ( checkableItem , checked ) ; if ( checkableItem . autoCheckParentOnCheck ( ) && checkableItem instanceof IParentProvider ) setParentChecked ( ( IParentProvider ) checkableItem ) ; if ( checkableItem . autoUncheckChildsOnUncheck ( )'}]",&& checkableItem instanceof IChildProvider ) uncheckChildren ( ( IChildProvider ) checkableItem ) ; } } },5.447267785254693e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core .'}]",import org.eclipse.core.runtime.preferences.IPreferenceStore;,2.7882715702848232e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences . formatter ; import java . util . Map ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . text . Document ; import org . eclipse . jface . text . MarginPainter ; import org . eclipse . jface . text . source . SourceViewer ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . texteditor . AbstractDecoratedTextEditorPreferenceConstants ; import org . eclipse . ui . texteditor . ChainedPreferenceStore ; import org . rubypeople . rdt . core . formatter . DefaultCodeFormatterConstants ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubySourceViewer ; import org . rubypeople . rdt . internal . ui . text . IRubyPartitions ; import org . rubypeople . rdt . internal . ui . text . SimpleRubySourceViewerConfiguration ; import org . rubypeople . rdt . ui . PreferenceConstants ; import org . rubypeople . rdt . ui . text . RubyTextTools ; public abstract class RubyPreview { private final class RubySourcePreviewerUpdater { final IPropertyChangeListener fontListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( PreferenceConstants . EDITOR_TEXT_FONT ) ) { final Font font = JFaceResources . getFont ( PreferenceConstants . EDITOR_TEXT_FONT ) ; fSourceViewer . getTextWidget ( ) . setFont ( font ) ; if ( fMarginPainter != null ) { fMarginPainter . initialize ( ) ; } } } } ; final IPropertyChangeListener propertyListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( fViewerConfiguration . affectsTextPresentation ( event ) ) { fViewerConfiguration . handlePropertyChangeEvent ( event ) ; fSourceViewer . invalidateTextPresentation ( ) ; } } } ; public RubySourcePreviewerUpdater ( ) { JFaceResources . getFontRegistry ( ) . addListener ( fontListener ) ; fPreferenceStore . addPropertyChangeListener ( propertyListener ) ; fSourceViewer . getTextWidget ( ) . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed'}]","( DisposeEvent e ) { fontListener. propertyChange ( new PropertyChangeEvent ( null, null, null, null ) ) ; } } ; } private final SourceViewer fSourceViewer ; private final PreferenceConverter fPreferenceConverter ; private final IPreferenceStore fPreferenceStore ; private final SimpleRubySourceViewerConfiguration fViewerConfiguration ; private final IRubyPartitions fPartitions ; private final RubyTextTools fRubyTools ; private final RubySourceViewer fRubySourceViewer ; private final RubyPreview fRubyPreview ; private MarginPainter fMarginPainter ; private final RubyPlugin fRubyPlugin ; public RubyPreview ( RubyPlugin rubyPlugin, RubySourceViewer rubySourceViewer, RubyTextTools rubyTextTools, SimpleRubySourceViewerConfiguration viewerConfiguration, IRubyPartitions rubyPartitions, PreferenceConverter preferenceConverter, IPreferenceStore preferenceStore ) { fRubyPlugin = rubyPlugin ; fRubySourceViewer = rubySourceViewer ; fRubyTools = rubyTextTools ; fViewerConfiguration = viewerConfiguration ; fPartitions = rubyPartitions ; fPreferenceConverter = preferenceConverter ; fPreferenceStore = preferenceStore ; fRubyPreview = this ; fSourceViewer = rubySourceViewer ; fMarginPainter = new MarginPainter ( rubySourceViewer. getTextWidget ( ) ) ; new Ruby",0.00037077402618757515
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . svcp ; import org . eclipse . jface . preference . JFacePreferences ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ColumnViewer ; import org . eclipse . jface . viewers . DecoratingStyledCellLabelProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . StyledString ; import org . eclipse . jface . viewers . StyledString . Styler ; import org . eclipse . jface . viewers . ViewerColumn ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . StyleRange ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; public class SVDBDecoratingLabelProvider extends DecoratingStyledCellLabelProvider implements ILabelProvider , IPropertyChangeListener { private static final String HIGHLIGHT_BG_COLOR_NAME = ""<STR_LIT>"" ; public static final Styler HIGHLIGHT_STYLE = StyledString . createColorRegistryStyler ( null , HIGHLIGHT_BG_COLOR_NAME ) ; public SVDBDecoratingLabelProvider ( SVTreeLabelProvider provider ) { super ( provider , PlatformUI . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) , null ) ; }'}]",JFaceResources. getPreferenceStore ( ). addPropertyChangeListener ( this );,3.993396275393685e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . eclipse . shams . debug . core ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchDelegate ; public class ShamLaunchConfiguration implements ILaunchConfiguration { public ShamLaunchConfiguration ( ) { super ( ) ; } public ILaunch launch ( String mode , IProgressMonitor monitor ) throws CoreException { return null ; } public boolean supportsMode ( String mode ) throws CoreException { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public String getName ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IPath getLocation ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean exists ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public int getAttribute ( String attributeName , int defaultValue ) throws CoreException { throw'}]","new RuntimeException(""<STR_LIT>"");",2.946074506870358e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . values ; import java . util . Arrays ; import java . util . Collections ; import junit . framework . TestCase ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . expr . Expression ; public class ValueMakerTest extends TestCase { private final static Attribute foo_col1 = new Attribute ( null , ""<STR_LIT:foo>"" , ""<STR_LIT>"" ) ; private final static Attribute foo_col2 = new Attribute ( null , ""<STR_LIT:foo>"" , ""<STR_LIT>"" ) ; public void testBlankNodeIDToString ( ) { BlankNodeID b = new BlankNodeID ( ""<STR_LIT>"" , Arrays . asList ( new Attribute [ ] { foo_col1 , foo_col2 } ) ) ; assertEquals ( ""<STR_LIT>"" , b . toString ( ) ) ; } public void testColumnToString ( ) { assertEquals ( ""<STR_LIT>"" , new Column ( foo_col1 ) . toString ( ) ) ; } public void testPatternToString ( ) { assertEquals ( ""<STR_LIT>"" , new Pattern ( ""<STR_LIT>"" ) . toString ( ) ) ; } public void testValueDecoratorWithoutTranslatorToString ( ) { assertEquals ( ""<STR_LIT>"" , new ValueDecorator ( new Column ( foo_col1 ) , Collections . singletonList ( ValueDecorator . maxLengthConstraint ( <NUM_LIT:10> ) ) ) . toString ( ) ) ; } public void testMaxLengthConstraint ( ) {'}]","assertEquals ( ""<STR_LIT:10>"", ValueDecorator.maxLengthConstraint ( new <NUM_LIT:10> ( ) ). toString ( ) ) ;",6.503856210632563e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . html ; import java . math . BigDecimal ; import java . math . BigInteger ; import'}]",java.util.regex.Pattern;,2.3461035452224192e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . common ; import java . net . URL ; import java . net . URLStreamHandlerFactory ; import org . apache . hadoop . fs . FsUrlStreamHandlerFactory ; public final class UrlStreamHandlerFactoryRegisterer { private static volatile boolean registered ; public static synchronized void register ( ) { if ('}]",registered == false ) { URL. setURLStreamHandlerFactory ( new FsUrlStreamHandlerFactory ( ) ) ; registered = true ; } } },5.545222278713841e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . source ; import java . io . IOException ; import java . io . Reader ; import java . net . URI ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import com . asakusafw . utils . collections . Lists ; public class CompositeSourceRepository implements DmdlSourceRepository { private final List < DmdlSourceRepository > repositories ; public CompositeSourceRepository ( List < ? extends DmdlSourceRepository > repositories ) { if ( repositories == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . repositories = Lists . freeze ( repositories ) ; } @ Override public Cursor createCursor ( ) throws IOException { return new CompositeCursor ( repositories . iterator ( ) ) ; } private static class CompositeCursor implements Cursor { private final Iterator < DmdlSourceRepository > rest ; private Cursor current ; CompositeCursor ( Iterator < DmdlSourceRepository > iterator ) { assert iterator != null ; this . rest = iterator ; this . current = null ; } @ Override public boolean next ( ) throws IOException { if ( current == null ) { if ( rest . hasNext ( ) ) { current = rest . next ( ) . createCursor ( ) ; } else { return false ; } } assert current != null ; while ( true ) { if ( current . next ( ) ) { return true ; } if ( rest . hasNext ( ) ) {'}]","current = rest. next ( ). createCursor ( ) ; } else { return false ; } } } @ Override public void remove ( ) throws IOException, UnsupportedOperationException { throw new UnsupportedOperationException ( ) ; } } }",7.595446699523866e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . util ; import java . text . MessageFormat ; import org . eclipse . osgi . util . NLS ; public final class Messages extends NLS { private static final String BUNDLE_NAME = ""<STR_LIT>"" ; private Messages ( ) { } public static String element_doesNotExist ; public static String element_notOnClasspath ; public static String element_invalidClassFileName ; public static String element_reconciling ; public static String element_attachingSource ; public static String element_invalidResourceForProject ; public static String element_nullName ; public static String element_nullType ; public static String element_illegalParent ; public static String operation_needElements ; public static String operation_needName ; public static String operation_needPath ; public static String operation_needAbsolutePath ; public static String operation_needString ; public static String operation_notSupported ; public static String operation_cancelled ; public static String operation_nullContainer ; public static String operation_nullName ; public static String operation_copyElementProgress ; public static String operation_moveElementProgress ; public static String operation_renameElementProgress ; public static String operation_copyResourceProgress ; public static String operation_moveResourceProgress ; public static String operation_renameResourceProgress ; public static String operation_createUnitProgress ; public static String operation_createFieldProgress ; public static String operation_createImportsProgress ; public static String operation_createInitializerProgress ; public static String operation_createMethodProgress ; public static String operation_createPackageProgress ; public static String operation_createPackageFragmentProgress ; public static String operation_createTypeProgress ; public static String operation_deleteElementProgress ; public static String operation_deleteResourceProgress ; public static String operation_cannotRenameDefaultPackage ; public static String operation_pathOutsideProject ; public static String operation_sortelements ; public static String workingCopy_commit ; public static String build_cannotSaveState ; public static String build_cannotSaveStates ; public static String build_initializationError ; public static String build_serializationError ; public static String status_cannotUseDeviceOnPath ; public static String status_coreException ; public static String status_evaluationError ; public static String status_JDOMError ; public static String status_IOException ; public static String status_indexOutOfBounds ; public static String status_invalidContents ; public static String status_invalidDestination ; public static String status_invalidName ; public static String status_invalidPackage ; public static String status_invalidPath ; public static String status_invalidProject ; public static String status_invalidResource ; public static String status_invalidResourceType ; public static String status_invalidSibling ; public static String status_nameCollision ; public static String status_noLocalContents ; public static String status_OK ; public static String status_readOnly ; public static String status_targetException ; public static String status_updateConflict ; public static String classpath_buildPath ; public static String classpath_cannotNestEntryInEntry ; public static String classpath_cannotNestEntryInLibrary ; public static String classpath_cannotNestEntryInOutput ; public static String classpath_cannotNestOutputInEntry ; public static String classpath_cannotNestOutputInOutput ; public static String classpath_cannotReadClasspathFile ; public static String classpath_cannotReferToItself ; public static String classpath_cannotUseDistinctSourceFolderAsOutput ; public static String classpath_cannotUseLibraryAsOutput ; public static String classpath_closedProject ; public static String classpath_couldNotWriteClasspathFile ; public static String classpath_cycle ; public static String classpath_duplicateEntryPath ; public static String classpath_illegalContainerPath ; public static String classpath_illegalEntryInClasspathFile ; public static String classpath_illegalLibraryPath ; public static String classpath_illegalLibraryArchive ; public static String classpath_illegalExternalFolder ; public static String classpath_illegalProjectPath ; public static String classpath_illegalSourceFolderPath ; public static String classpath_illegalVariablePath ; public static String classpath_invalidClasspathInClasspathFile ; public static String classpath_invalidContainer ; public static String classpath_mustEndWithSlash ; public static String classpath_unboundContainerPath ; public static String classpath_unboundLibrary ; public static String classpath_unboundProject ; public static String classpath_settingOutputLocationProgress ; public static String classpath_settingProgress ; public static String classpath_unboundSourceAttachment ; public static String classpath_unboundSourceFolder ; public static String classpath_unboundVariablePath ; public static String classpath_unknownKind ; public static String classpath_xmlFormatError ; public static String classpath_disabledInclusionExclusionPatterns ; public static String classpath_disabledMultipleOutputLocations ; public static String classpath_incompatibleLibraryJDKLevel ; public static String classpath_duplicateEntryExtraAttribute ; public static String file_notFound ; public static String file_badFormat ; public static String path_nullPath ; public static String path_mustBeAbsolute ; public static String cache_invalidLoadFactor ; public static String savedState_jobName ; public static String javamodel_initialization ; public static String restrictedAccess_project ;'}]","public static String messageFormat(String pattern, Object... args) throws Exception { return MessageFormat.format(pattern, args); }",6.491355022881258e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBTimeUnitsStmt extends SVDBStmt { public String'}]",getSQLString(SVDBItemType TIME_UNITS);,2.81632607131712e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . statement ; import static org . junit . Assert . assertEquals ; import java . util . Arrays ; import java . util . List ; import org . hibernate . Transaction ; import org . junit . Test ; public class StatementDaoTest extends DatabaseIntegrationTest { @ Test ( expected = IllegalArgumentException . class ) public void throwsExceptionWhenValidatingInvalidHql ( ) { new StatementDao ( session ) . validate ( ""<STR_LIT>"" , null ) ; } @ Test ( expected = IllegalArgumentException . class ) public void throwsExceptionWhenValidatingHqlThatDoesNotExecute ( ) throws Exception { new StatementDao ( session ) . validate ( ""<STR_LIT>"" , null ) ; } @ Test public void returnsAnEmptyListForAStatementWithoutResults ( ) throws Exception { List < Object [ ] > result = new StatementDao ( session ) . execute ( new Statement ( ""<STR_LIT>"" , ""<STR_LIT>"" ) , null , <NUM_LIT:1000> ) ; assertEquals ( <NUM_LIT:0> , result . size ( ) ) ; } @ Test public void assemblesResultListWithLinesFromQueryResultWhenEachLineHasOnlyOneColumn ( ) { Transaction tx = session . beginTransaction ( ) ; session . save ( new Statement ( ""<STR_LIT>"" , ""<STR_LIT>"" )'}]",") ; List < Object [ ] > result = new StatementDao ( session ). execute ( new Statement ( ""<STR_LIT>"", ""<STR_LIT>"" ), null, <NUM_LIT:1000> ) ; List < Object [ ] > expected = Arrays. asList ( new Object [ ] { 1 }, new Object [ ] { 2 }, new Object [ ] { 3 } ) ; assertEquals ( expected, result ) ; tx. commit ( ) ; } @ Test public void assemblesResultListWithLinesFromQueryResultWhenEachLineHasTwoColumns ( ) { Transaction tx = session. beginTransaction ( ) ; session. save ( new Statement ( ""<STR_LIT>"", ""<STR_LIT>"" ) ) ; List < Object [ ] > result = new StatementDao ( session ). execute ( new Statement ( ""<STR_LIT>"", ""<STR_LIT>"" ), null, <NUM_LIT:1000> ) ; List < Object [ ] > expected = Arrays. asList ( new Object [ ] { 1, 2 }, new Object [ ] { 3, 4 }, new Object [ ] { 5, 6 } ) ; assertEquals ( expected, result )",0.000353195485782193
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core . task ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . TreeMap ; import java . util . UUID ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . FutureTask ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ThreadFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . runtime . core . context . RuntimeContext . ExecutionMode ; import com . asakusafw . yaess . core . * ; import com . asakusafw . yaess . core . JobScheduler . ErrorHandler ; public class ExecutionTask { static final String KEY_SKIP_FLOWS = ""<STR_LIT>"" ; static final String KEY_SERIALIZE_FLOWS = ""<STR_LIT>"" ; static final String KEY_VERIFY_APPLICATION = ""<STR_LIT>"" ; static final String KEY_VERIFY_DRYRUN = ""<STR_LIT>"" ; static final YaessLogger YSLOG = new YaessCoreLogger ( ExecutionTask . class ) ; static final Logger LOG = LoggerFactory . getLogger ( ExecutionTask . class ) ; private final ExecutionMonitorProvider monitors ; private final ExecutionLockProvider locks ; private final JobScheduler scheduler ; private final HadoopScriptHandler hadoopHandler ; private final Map < String , CommandScriptHandler > commandHandlers ; private final BatchScript script ; private final Map < String , String > batchArguments ; private final Map < String , String > subprocessEnvironmentVaritables = new ConcurrentHashMap < String , String > ( ) ; private final Set < String > skipFlows = Collections . synchronizedSet ( new HashSet < String > ( ) ) ; private volatile RuntimeContext runtimeContext ; private volatile boolean serializeFlows = false ; public ExecutionTask ( ExecutionMonitorProvider monitors , ExecutionLockProvider locks , JobScheduler scheduler , HadoopScriptHandler hadoopHandler , Map < String , CommandScriptHandler > commandHandlers , BatchScript script , Map < String , String > batchArguments ) { if ( monitors == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( locks == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( scheduler == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( hadoopHandler == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( commandHandlers == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( batchArguments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . monitors = monitors ; this . locks = locks ; this . scheduler = scheduler ; this . hadoopHandler = hadoopHandler ; this . commandHandlers = Collections . unmodifiableMap ( new HashMap < String , CommandScriptHandler > ( commandHandlers ) ) ; this . script = script ; this . batchArguments = Collections . unmodifiableMap ( new LinkedHashMap < String , String > ( batchArguments ) ) ; this . runtimeContext = RuntimeContext . get ( ) ; } public static ExecutionTask load ( YaessProfile profile , Properties script , Map < String , String > batchArguments ) throws InterruptedException , IOException { return load ( profile , script , batchArguments , Collections . < String , String > emptyMap ( ) ) ; } public static ExecutionTask load ( YaessProfile profile , Properties script , Map < String , String > batchArguments , Map < String , String > yaessArguments ) throws InterruptedException , IOException { if ( profile == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( batchArguments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( yaessArguments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" ) ; ExecutionMonitorProvider monitors = profile . getMonitors ( ) . newInstance ( ) ; LOG . debug ( ""<STR_LIT>"" ) ; ExecutionLockProvider locks = profile . getLocks ( ) . newInstance ( ) ; LOG . debug ( ""<STR_LIT>"" ) ; JobScheduler scheduler = profile . getScheduler ( ) . newInstance ( ) ; LOG . debug ( ""<STR_LIT>"" ) ; HadoopScriptHandler hadoopHandler = profile . getHadoopHandler ( ) . newInstance ( ) ; LOG . debug ( ""<STR_LIT>"" ) ; Map < String , CommandScriptHandler > commandHandlers = new HashMap < String , CommandScriptHandler > ( ) ; for ( Map . Entry < String , ServiceProfile < CommandScriptHandler > > entry : profile . getCommandHandlers ( ) . entrySet ( ) ) { commandHandlers . put ( entry . getKey ( ) , entry . getValue ( ) . newInstance ( ) ) ; } LOG . debug ( ""<STR_LIT>"" ) ; BatchScript batch = BatchScript . load ( script ) ; ExecutionTask result = new ExecutionTask ( monitors , locks , scheduler , hadoopHandler , commandHandlers , batch , batchArguments ) ; LOG . debug ( ""<STR_LIT>"" ) ; Map < String , String > copyDefinitions = new TreeMap < String , String > ( yaessArguments ) ; consumeRuntimeContext ( result , copyDefinitions , batch ) ; consumeSkipFlows ( result , copyDefinitions , batch ) ; consumeSerializeFlows ( result , copyDefinitions , batch ) ; checkRest ( copyDefinitions ) ; return result ; } private static void consumeRuntimeContext ( ExecutionTask result , Map < String , String > copyDefinitions , BatchScript script ) { assert result != null ; assert copyDefinitions != null ; assert script != null ; RuntimeContext rc = RuntimeContext . get ( ) . batchId ( script . getId ( ) ) . buildId ( script . getBuildId ( ) ) ; Ternary dryRunResult = consumeBoolean ( copyDefinitions , KEY_VERIFY_DRYRUN ) ; if ( dryRunResult == Ternary . TRUE ) { rc = rc . mode ( ExecutionMode . SIMULATION ) ; } else if ( dryRunResult == Ternary . FALSE ) { rc = rc . mode ( ExecutionMode . PRODUCTION ) ; } Ternary verify = consumeBoolean ( copyDefinitions , KEY_VERIFY_APPLICATION ) ; if ( verify == Ternary . FALSE ) { rc = rc . buildId ( null ) ; } result . runtimeContext = rc ; result . getEnv ( ) . putAll ( rc . unapply ( ) ) ; } private static void consumeSkipFlows ( ExecutionTask task , Map < String , String > copyDefinitions , BatchScript script ) { assert task != null ; assert copyDefinitions != null ; assert script != null ; String flows = copyDefinitions . remove ( KEY_SKIP_FLOWS ) ; if ( flows == null || flows . trim ( ) . isEmpty ( ) ) { return ; } LOG . debug ( ""<STR_LIT>"" , KEY_SKIP_FLOWS , flows ) ; for ( String flowIdCandidate : flows . split ( ""<STR_LIT:U+002C>"" ) ) { String flowId = flowIdCandidate . trim ( ) ; if ( flowId . isEmpty ( ) == false ) { FlowScript flow = script . findFlow ( flowId ) ; if ( flow == null ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , KEY_SKIP_FLOWS , flowId ) ) ; } task . skipFlows . add ( flowId ) ; } } } private static void consumeSerializeFlows ( ExecutionTask task , Map < String , String > copyDefinitions , BatchScript script ) { assert task != null ; assert copyDefinitions != null ; assert script != null ; Ternary serialize = consumeBoolean ( copyDefinitions , KEY_SERIALIZE_FLOWS ) ; if ( serialize == null ) { return ; } task . serializeFlows = serialize == Ternary . TRUE ; } private static Ternary consumeBoolean ( Map < String , String > copyDefinitions , String key ) { assert copyDefinitions != null ; String value = copyDefinitions . remove ( key ) ; if ( value == null ) { return Ternary . UNDEF ; } value = value . trim ( ) ; LOG . debug ( ""<STR_LIT>"" , key , value ) ; if ( value . equalsIgnoreCase ( ""<STR_LIT:true>"" ) ) { return Ternary . TRUE ; } else if ( value . equalsIgnoreCase ( ""<STR_LIT:false>"" ) ) { return Ternary . FALSE ; } else { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , key , value ) ) ; } } private static void checkRest ( Map < String , String > copyDefinitions ) { assert copyDefinitions != null ; if ( copyDefinitions . isEmpty ( ) == false ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , copyDefinitions . keySet ( ) ) ) ; } } Set < String > getSkipFlows ( ) { return skipFlows ; } void setSerializeFlows ( boolean serialize ) { this . serializeFlows = serialize ; } void setRuntimeContext ( RuntimeContext runtimeContext ) { this . runtimeContext = runtimeContext ; } Map < String , String > getEnv ( ) { return this . subprocessEnvironmentVaritables ; } public void executeBatch ( String batchId ) throws InterruptedException , IOException { if ( batchId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ExecutorService executor = createJobflowExecutor ( batchId ) ; YSLOG . info ( ""<STR_LIT>"" , batchId ) ; long start = System . currentTimeMillis ( ) ; try { ExecutionLock lock = acquireExecutionLock ( batchId ) ; try { BatchScheduler batchScheduler = new BatchScheduler ( batchId , script , lock , executor ) ; batchScheduler . run ( ) ; } finally { lock . close ( ) ; } YSLOG . info ( ""<STR_LIT>"" , batchId ) ; } catch ( IOException e ) { YSLOG . error ( e , ""<STR_LIT>"" , batchId ) ; throw e ; } catch ( InterruptedException e ) { YSLOG . warn ( e , ""<STR_LIT>"" , batchId ) ; throw e ; } finally { long end = System . currentTimeMillis ( ) ; YSLOG . info ( ""<STR_LIT>"" , batchId , end - start ) ; } } private ExecutionLock acquireExecutionLock ( String batchId ) throws IOException { assert batchId != null ; if ( runtimeContext . canExecute ( locks ) ) { return locks . newInstance ( batchId ) ; } else { return ExecutionLock . NULL ; } } private PhaseMonitor obtainPhaseMonitor ( ExecutionContext context ) throws InterruptedException , IOException { assert context != null ; if ( runtimeContext . canExecute ( monitors ) ) { return monitors . newInstance ( context ) ; } else { return PhaseMonitor . NULL ; } } private ExecutorService createJobflowExecutor ( final String batchId ) { assert batchId != null ; ThreadFactory threadFactory = new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( MessageFormat . format ( ""<STR_LIT>"" , batchId ) ) ; thread . setDaemon ( true ) ; return thread ; } } ; if ( serializeFlows ) { return Executors . newFixedThreadPool ( <NUM_LIT:1> , threadFactory ) ; } else { return Executors . newCachedThreadPool ( threadFactory ) ; } } public void executeFlow ( String batchId , String flowId , String executionId ) throws InterruptedException , IOException { if ( batchId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( flowId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( executionId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } FlowScript flow = script . findFlow ( flowId ) ; if ( flow == null ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , batchId , flowId , executionId ) ) ; } ExecutionLock lock = acquireExecutionLock ( batchId ) ; try { lock . beginFlow ( flowId , executionId ) ; executeFlow ( batchId , flow , executionId ) ; lock . endFlow ( flowId , executionId ) ; } finally { lock . close ( ) ; } } public void executePhase ( String batchId , String flowId , String executionId , ExecutionPhase phase ) throws InterruptedException , IOException { if ( batchId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( flowId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( executionId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( phase == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ExecutionContext context = new ExecutionContext ( batchId , flowId , executionId , phase , batchArguments , subprocessEnvironmentVaritables ) ; executePhase ( context ) ; } public void executePhase ( ExecutionContext context ) throws InterruptedException , IOException { if ( context == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } FlowScript flow = script . findFlow ( context . getFlowId ( ) ) ; if ( flow == null ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , context . getBatchId ( ) , context . getFlowId ( ) , context . getExecutionId ( ) ) ) ; } Set < ExecutionScript > executions = flow . getScripts ( ) . get ( context . getPhase ( ) ) ; ExecutionLock lock = acquireExecutionLock ( context . getBatchId ( ) ) ; try { lock . beginFlow ( context . getFlowId ( ) , context . getExecutionId ( ) ) ; executePhase ( context , executions ) ; lock . endFlow ( context . getFlowId ( ) , context . getExecutionId ( ) ) ; } finally { lock . close ( ) ; } } void executeFlow ( String batchId , FlowScript flow , String executionId ) throws InterruptedException , IOException { assert batchId != null ; assert flow != null ; assert executionId != null ; YSLOG . info ( ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; long start = System . currentTimeMillis ( ) ; try { if ( skipFlows . contains ( flow . getId ( ) ) ) { YSLOG . info ( ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; return ; } executePhase ( batchId , flow , executionId , ExecutionPhase . SETUP ) ; boolean succeed = false ; try { executePhase ( batchId , flow , executionId , ExecutionPhase . INITIALIZE ) ; executePhase ( batchId , flow , executionId , ExecutionPhase . IMPORT ) ; executePhase ( batchId , flow , executionId , ExecutionPhase . PROLOGUE ) ; executePhase ( batchId , flow , executionId , ExecutionPhase . MAIN ) ; executePhase ( batchId , flow , executionId , ExecutionPhase . EPILOGUE ) ; executePhase ( batchId , flow , executionId , ExecutionPhase . EXPORT ) ; succeed = true ; } finally { if ( succeed ) { executePhase ( batchId , flow , executionId , ExecutionPhase . FINALIZE ) ; } else { YSLOG . info ( ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; try { executePhase ( batchId , flow , executionId , ExecutionPhase . FINALIZE ) ; } catch ( Exception e ) { YSLOG . warn ( e , ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; } } } try { executePhase ( batchId , flow , executionId , ExecutionPhase . CLEANUP ) ; } catch ( Exception e ) { YSLOG . warn ( e , ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; } YSLOG . info ( ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; } catch ( IOException e ) { YSLOG . error ( e , ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; throw e ; } catch ( InterruptedException e ) { YSLOG . warn ( e , ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId ) ; throw e ; } finally { long end = System . currentTimeMillis ( ) ; YSLOG . info ( ""<STR_LIT>"" , batchId , flow . getId ( ) , executionId , end - start ) ; } } private void executePhase ( String batchId , FlowScript flow , String executionId , ExecutionPhase phase ) throws InterruptedException , IOException { ExecutionContext context = new ExecutionContext ( batchId , flow . getId ( ) , executionId , phase , batchArguments , subprocessEnvironmentVaritables ) ; Set < ExecutionScript > scripts = flow . getScripts ( ) . get ( phase ) ; assert scripts != null ; executePhase ( context , scripts ) ; } private void executePhase ( ExecutionContext context'}]",", Set<ExecutionScript> scripts) throws InterruptedException, IOException { assert context!= null; assert scripts!= null; ExecutorService executor = createJobflowExecutor(context.getBatchId()); YSLOG.info(""<STR_LIT>"", context.getBatchId(), context.getFlowId(), context.getExecutionId()); long start = System.currentTimeMillis(); try { for (ExecutionScript script : scripts) { executor.submit(new ExecutionTask(context, script)); } } catch (IOException e) { YSLOG.error(e, ""<STR_LIT>"", context.getBatchId(), context.getFlowId(), context.getExecutionId()); throw e; } catch (InterruptedException e) { YSLOG.warn(e, ""<STR_LIT>"", context.getBatchId(), context.getFlowId(), context.getExecutionId()); throw e; } finally { long end = System.currentTimeMillis(); YSLOG.info(""<STR_LIT>"", context.getBatchId(), context.getFlowId(), context.getExecutionId(), end - start); } } }",0.0004377255429190351
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . windgate ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import com . asakusafw . compiler . flow . ExternalIoCommandProvider ; import com . asakusafw . compiler . flow . ExternalIoCommandProvider . Command ; import com . asakusafw . compiler . flow . ExternalIoCommandProvider . CommandContext ; import com . asakusafw . compiler . flow . FlowCompilerOptions ; import com . asakusafw . compiler . flow . FlowDescriptionDriver ; import com . asakusafw . compiler . flow . Location ; import com . asakusafw . compiler . testing . DirectFlowCompiler ; import com . asakusafw . compiler . testing . JobflowInfo ; import com . asakusafw . compiler . windgate . testing . model . Simple ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . windgate . WindGateExporterDescription ; import com . asakusafw . vocabulary . windgate . WindGateImporterDescription ; import com . asakusafw . windgate . core . DriverScript ; public class WindGateIoProcessorTest { @ Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; @ Test public void simple ( ) throws Exception { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Simple > in = flow . createIn ( ""<STR_LIT>"" , new Import ( Simple . class , ""<STR_LIT>"" , dummy ( ) ) ) ; Out < Simple > out = flow . createOut ( ""<STR_LIT>"" , new Export ( Simple . class , ""<STR_LIT>"" , dummy ( ) ) ) ; FlowDescription desc = new IdentityFlow < Simple > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , not ( nullValue ( ) ) ) ; List < ExternalIoCommandProvider > commands = info . getCommandProviders ( ) ; ExternalIoCommandProvider provider = WindGateIoProcessor . findRelated ( commands ) ; assertThat ( provider , not ( nullValue ( ) ) ) ; CommandContext context = new CommandContext ( ""<STR_LIT>"" , ""<STR_LIT:id>"" , ""<STR_LIT>"" ) ; List < Command > importer = provider . getImportCommand ( context ) ; List < Command > exporter = provider . getExportCommand ( context ) ; List < Command > finalizer = provider . getFinalizeCommand ( context ) ; assertThat ( importer . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( exporter . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( finalizer . size ( ) , is ( <NUM_LIT:1> ) ) ; assertThat ( mode ( importer , ""<STR_LIT>"" ) , is ( WindGateIoProcessor . OPT_BEGIN ) ) ; assertThat ( mode ( exporter , ""<STR_LIT>"" ) , is ( WindGateIoProcessor . OPT_END ) ) ; assertThat ( find ( finalizer , ""<STR_LIT>"" ) , is ( notNullValue ( ) ) ) ; } @ Test public void different_profile ( ) throws Exception { FlowDescriptionDriver flow = new FlowDescriptionDriver ( ) ; In < Simple > in = flow . createIn ( ""<STR_LIT>"" , new Import ( Simple . class , ""<STR_LIT>"" , dummy ( ) ) ) ; Out < Simple > out = flow . createOut ( ""<STR_LIT>"" , new Export ( Simple . class , ""<STR_LIT>"" , dummy ( ) ) ) ; FlowDescription desc = new IdentityFlow < Simple > ( in , out ) ; JobflowInfo info = compile ( flow , desc ) ; assertThat ( info , not ( nullValue ( ) ) ) ; List < ExternalIoCommandProvider > commands = info . getCommandProviders ( ) ; ExternalIoCommandProvider provider = WindGateIoProcessor . findRelated ( commands ) ; assertThat ( provider , not ( nullValue ( ) ) ) ; CommandContext context = new CommandContext ( ""<STR_LIT>"" , ""<STR_LIT:id>"" , ""<STR_LIT>"" ) ; List < Command > importer = provider . getImportCommand ( context ) ; List < Command > exporter = provider . getExportCommand ( context ) ; List < Command > finalizer = provider . getFinalizeCommand ( context ) ; assertThat ( importer . size ( ) , is ( <NUM_LIT:1> )'}]",") ; assertThat ( exporter. size ( ), is ( <NUM_LIT:1> ) ) ; assertThat ( finalizer. size ( ), is ( <NUM_LIT:1> ) ) ; assertThat ( mode ( importer, ""<STR_LIT>"" ), is ( WindGateIoProcessor. OPT_BEGIN ) ) ; assertThat ( mode ( exporter, ""<STR_LIT>"" ), is ( WindGateIoProcessor. OPT_END ) ) ; assertThat ( find ( finalizer, ""<STR_LIT>"" ), is ( notNullValue ( ) ) ) ; } private < T > T dummy ( ) { // implementation } private < T > String mode ( List < Command > commands, String profile ) { // implementation } private < T > T find ( List < Command > commands, String profile ) { // implementation } private JobflowInfo compile ( FlowDescriptionDriver flow, FlowDescription desc ) throws Exception { return new DirectFlowCompiler ( flow, desc ). compile ( ) ; } }",0.00031263425742641016
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . Date ; import org . oddjob . FailedToStopException ; import org . oddjob . Resetable ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . Structural ; import org . oddjob . arooa . deploy . annotations . ArooaComponent ; import org . oddjob . arooa . life . ComponentPersistException ; import org . oddjob . framework . BasePrimary ; import org . oddjob . framework . ComponentBoundry ; import org . oddjob . framework . JobDestroyedException ; import org . oddjob . framework . StopWait ; import org . oddjob . images . IconHelper ; import org . oddjob . images . StateIcons ; import org . oddjob . persist . Persistable ; import org . oddjob . scheduling . Keeper ; import org . oddjob . scheduling . LoosingOutcome ; import org . oddjob . scheduling . Outcome ; import org . oddjob . scheduling . WinningOutcome ; import org . oddjob . state . IsAnyState ; import org . oddjob . state . IsDone ; import org . oddjob . state . IsExecutable ; import org . oddjob . state . IsHardResetable ; import org . oddjob . state . IsSoftResetable ; import org . oddjob . state . IsStoppable ; import org . oddjob . state . JobState ; import org . oddjob . state . JobStateChanger ; import org . oddjob . state . JobStateConverter ; import org . oddjob . state . JobStateHandler ; import org . oddjob . state . StateListener ; import org . oddjob . state . OrderedStateChanger ; import org . oddjob . state . State ; import org . oddjob . state . StateChanger ; import org . oddjob . state . StateEvent ; import org . oddjob . structural . ChildHelper ; import org . oddjob . structural . StructuralListener ; public class GrabJob extends BasePrimary implements Runnable , Serializable , Stoppable , Resetable , Stateful , Structural { private static final long serialVersionUID = <NUM_LIT> ; private transient JobStateHandler stateHandler ; private transient JobStateChanger stateChanger ; protected transient volatile boolean stop ; public enum LoosingAction { COMPLETE , INCOMPLETE , WAIT , } private transient LoosingAction onLoosing ; private transient ChildHelper < Runnable > childHelper ; private transient Keeper keeper ; private String identifier ; private Object instance ; private String winner ; private transient GrabListener listener ; public GrabJob ( ) { completeConstruction ( ) ; } private void completeConstruction ( ) { stateHandler = new JobStateHandler ( this ) ; childHelper = new ChildHelper < Runnable > ( this ) ; stateChanger = new JobStateChanger ( stateHandler , iconHelper , new Persistable ( ) { @ Override public void persist ( ) throws ComponentPersistException { save ( ) ; } } ) ; } @ Override protected JobStateHandler stateHandler ( ) { return stateHandler ; } protected StateChanger < JobState > getStateChanger ( ) { return stateChanger ; } public final void run ( ) { ComponentBoundry . push ( loggerName ( ) , this ) ; try { if ( ! stateHandler . waitToWhen ( new IsExecutable ( ) , new Runnable ( ) { public void run ( ) { if ( listener != null ) { listener . stop ( ) ; } getStateChanger ( ) . setState ( JobState . EXECUTING ) ; } } ) ) { return ; } logger ( ) . info ( ""<STR_LIT>"" ) ; try { configure ( ) ; execute ( ) ; } catch ( final Throwable e ) { logger ( ) . error ( ""<STR_LIT>"" , e ) ; stateHandler . waitToWhen ( new IsAnyState ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setStateException ( e ) ; } } ) ; } logger ( ) . info ( ""<STR_LIT>"" ) ; } finally { ComponentBoundry . pop ( ) ; } } private void execute ( ) { Runnable childJob = childHelper . getChild ( ) ; if ( childJob == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } Stateful statefulChild = ( Stateful ) childJob ; if ( keeper == null ) { throw new NullPointerException ( ""<STR_LIT>"" ) ; } final Outcome outcome = keeper . grab ( identifier , instance ) ; winner = outcome . getWinner ( ) ; if ( outcome . isWon ( ) ) { listener = new ChildWatcher ( statefulChild , ( WinningOutcome ) outcome ) ; childJob . run ( ) ; } else { LoosingAction loosingAction = this . onLoosing ; if ( loosingAction == null ) { loosingAction = LoosingAction . COMPLETE ; } switch ( loosingAction ) { case COMPLETE : stateHandler . waitToWhen ( new IsStoppable ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( JobState . COMPLETE ) ; } } ) ; break ; case INCOMPLETE : stateHandler . waitToWhen ( new IsStoppable ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( JobState . INCOMPLETE ) ; } } ) ; break ; case WAIT : listener = new StandBackAndWatch ( ( LoosingOutcome ) outcome ) ; break ; default : throw new IllegalStateException ( ""<STR_LIT>"" ) ; } } } class StandBackAndWatch implements StateListener , GrabListener { private final LoosingOutcome outcome ; StandBackAndWatch ( LoosingOutcome outcome ) { this . outcome = outcome ; outcome . addStateListener ( this ) ; } @ Override public void jobStateChange ( StateEvent event ) { final State state = event . getState ( ) ; if ( new IsDone ( ) . test ( state ) ) { outcome . removeStateListener ( this ) ; listener = null ; stateHandler . waitToWhen ( new IsStoppable ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( new JobStateConverter ( ) . toJobState ( state ) ) ; } } ) ; } } synchronized public void stop ( ) { stopListening ( ) ; stateHandler . waitToWhen ( new IsStoppable ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( JobState . INCOMPLETE ) ; } } ) ; } @ Override public void stopListening ( ) { outcome . removeStateListener ( this ) ; listener = null ; } } interface GrabListener { public void stop ( ) ; public void stopListening ( ) ; } class ChildWatcher implements GrabListener , StateListener { private final StateChanger < JobState > stateChanger = new OrderedStateChanger < JobState > ( getStateChanger ( ) , stateHandler ) ; private final Stateful child ; private final WinningOutcome outcome ; ChildWatcher ( Stateful child , WinningOutcome outcome ) { this . child = child ; this . outcome = outcome ; child . addStateListener ( this ) ; } @ Override public void jobStateChange ( StateEvent event ) { State state = event . getState ( ) ; Date time = event . getTime ( ) ; if ( state . isReady ( ) ) { stateChanger . setState ( JobState . READY , time ) ; checkStop ( ) ; } else if ( state . isStoppable ( ) ) { stateChanger . setState ( JobState . EXECUTING , time ) ; } else if ( state . isComplete ( ) ) { stateChanger . setState ( JobState . COMPLETE , time ) ; outcome . complete ( ) ; checkStop ( ) ; } else if ( state . isIncomplete ( ) ) { stateChanger . setState ( JobState . INCOMPLETE , time ) ; checkStop ( ) ; } else if ( state . isException ( ) ) { stateChanger . setStateException ( event . getException ( ) , time ) ; checkStop ( ) ; } else { stateChanger . setStateException ( new JobDestroyedException ( child ) , time ) ; checkStop ( ) ; } } private void checkStop ( ) { if ( stop ) { stopListening ( ) ; } } @ Override public void stopListening ( ) { child . removeStateListener ( this ) ; listener = null ; } synchronized public void stop ( ) { if ( child instanceof GrabListener ) { ( ( GrabListener ) child ) . stop ( ) ; } } } @ Override public void stop ( ) throws FailedToStopException { stateHandler . assertAlive ( ) ; ComponentBoundry . push ( loggerName ( ) , this ) ; try { logger ( ) .'}]","logger ( ). info ( ""<STR_LIT>"" ) ; if ( listener!= null ) { listener. stop ( ) ; } getStateChanger ( ). setState ( JobState. INCOMPLETE ) ; } finally { ComponentBoundry. pop ( ) ; } } @ Override public void reset ( ) { ComponentBoundry. push ( loggerName ( ), this ) ; try { logger ( ). info ( ""<STR_LIT>"" ) ; stateHandler. reset ( ) ; } finally { ComponentBoundry. pop ( ) ; } } }",0.0002162778392376356
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . windgate ; import java . io . IOException ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . windgate . core . resource . DrainDriver ; public class WindGateOutput < T > implements ModelOutput < T > { private final DrainDriver < T > driver ; public WindGateOutput ( DrainDriver < T > driver ) { if ( driver == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . driver'}]",= driver; } @Override public void close() throws IOException { driver.close(); } @Override public void flush() throws IOException { driver.flush(); } @Override public void write(T t) throws IOException { driver.write(t); } @Override public void write(T[] ts) throws IOException { for (T t : ts) { driver.write(t); } } @Override public void write(int n) throws IOException { for (int i = 0; i < n; i++) { driver.write((T) null); } } @Override public void write(long n) throws IOException { for (int i = 0; i < n; i++) { driver.write((T) null); } } },0.00019584445203295372
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . script ; import java . io . File ; import java . text . ParseException ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . convert . ArooaConverter ; import org . oddjob . arooa . convert . DefaultConversionRegistry ; import org . oddjob . arooa . convert . DefaultConverter ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . types . ArooaObject ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . ParentState ; public class InvokeTypeTest extends TestCase { private static final Logger logger = Logger . getLogger ( InvokeTypeTest . class ) ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; logger . info ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } public static class Thing { public String simpleStuff ( ) { return ""<STR_LIT>"" ; } public Object complexStuff ( String s ) { return s ; } public Object complexStuff ( File f , File y ) { return f . toString ( ) + y . toString ( ) ; } public Object complexStuff ( int i , double d ) { return new Double ( d + i ) ; } public void nothing ( ) { } public static String staticThing ( String'}]","s ) { return s ; } } public void testInvokeSimple ( ) throws Exception { Oddjob oddjob = new Oddjob ( ) ; oddjob. setConfig ( new XMLConfiguration ( new File ( ""invoke.xml"" ) ) ) ; oddjob. setProperty ( ""simpleStuff"", new Thing ( ) ) ; oddjob. start ( ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Thing thing = lookup. lookup ( Thing. class ) ; assertEquals ( ""<STR_LIT>"", thing. simpleStuff ( ) ) ; } public void testInvokeComplex ( ) throws Exception { Oddjob oddjob = new Oddjob ( ) ; oddjob. setConfig ( new XMLConfiguration ( new File ( ""invoke.xml"" ) ) ) ; oddjob. setProperty ( ""complexStuff"", new Thing ( ) ) ; oddjob. start ( ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Thing thing = lookup. lookup ( Thing. class ) ; assertEquals ( ""test"", thing. complexStuff ( ""test"" ) ) ; assertEquals ( ""file:/test/file"", thing. complexStuff ( new File ( ""test/file"" ), new File ( ""test/file""",0.00035623805419889167
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipOutputStream ; import org . apache . hadoop . fs . FileStatus ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . DataInputBuffer ; import org . apache . hadoop . io . DataOutputBuffer ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . windgate . core . WindGateLogger ; import com . asakusafw . windgate . hadoopfs . HadoopFsLogger ; public final class FileList { static final WindGateLogger WGLOG = new HadoopFsLogger ( FileList . class ) ; static final Logger LOG = LoggerFactory . getLogger ( FileList . class ) ; static final String FIRST_ENTRY_NAME = ""<STR_LIT>"" ; static final String LAST_ENTRY_NAME = ""<STR_LIT>"" ; public static FileStatus createFileStatus ( Path path ) { if ( path == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return new FileStatus ( <NUM_LIT:0> , false , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , null , null , null , path ) ; } public static FileList . Reader createReader ( InputStream input ) throws IOException { if ( input == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" ) ; return new Reader ( input ) ; } public static FileList . Writer createWriter ( OutputStream output ) throws IOException { if ( output == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" ) ; return new Writer ( output ) ; } private FileList ( ) { return ; } public static class Reader implements Closeable { private final InputStream original ; private final ZipInputStream input ; private final FileStatus current = new FileStatus ( ) ; private final DataInputBuffer buffer = new DataInputBuffer ( ) ; private boolean sawNext ; private boolean sawEof ; Reader ( InputStream input ) throws IOException { assert input != null ; this . original = input ; this . input = new ZipInputStream ( input ) ; ZipEntry first = this . input . getNextEntry ( ) ; if ( first == null || first . getName ( ) . equals ( FIRST_ENTRY_NAME ) == false ) { throw new IOException ( ""<STR_LIT>"" ) ; } } public boolean next ( ) throws IOException { while ( sawEof == false ) { ZipEntry entry = input . getNextEntry ( ) ; if ( entry == null ) { throw new IOException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , entry . getName ( ) ) ; if ( entry . getName ( ) . equals ( LAST_ENTRY_NAME ) ) { sawEof = true ; sawNext = false ; consume ( ) ; return false ; } if ( entry . isDirectory ( ) ) { continue ; } LOG . debug ( ""<STR_LIT>"" , entry . getName ( ) ) ; if ( restoreExtra ( entry ) == false ) { throw new IOException ( MessageFormat . format ( ""<STR_LIT>"" , entry . getName ( ) ) ) ; } sawNext = true ; return true ; } return false ; } private void consume ( ) throws IOException { byte [ ] buf = new byte [ <NUM_LIT> ] ; int rest = <NUM_LIT:0> ; while ( true ) { int read = original . read ( buf ) ; if ( read < <NUM_LIT:0> ) { break ; } rest += read ; } LOG . debug ( ""<STR_LIT>"" , rest ) ; } private boolean restoreExtra ( ZipEntry entry ) { assert entry != null ; byte [ ] extra = entry . getExtra ( ) ; if ( extra == null ) { return false ; } buffer . reset ( extra , extra . length ) ; try { current . readFields ( buffer ) ; } catch ( Exception e ) { WGLOG . warn ( e , ""<STR_LIT>"" , entry . getName ( ) ) ; return false ; } return true ; } public FileStatus getCurrentFile ( ) throws IOException { checkCurrent ( ) ;'}]","return current; } public void checkCurrent() throws IOException { if (sawNext == false) { throw new IOException(""<STR_LIT>""); } } @Override public void close() throws IOException { if (sawEof == false) { input.close(); } original.close(); } } public static class Writer implements Closeable { private final OutputStream original; private final ZipOutputStream output; private final FileStatus current = new FileStatus(); private boolean sawNext; private boolean sawEof; Writer(OutputStream output) throws IOException { assert output!= null; this.original = output; this.output = new ZipOutputStream(output); } public boolean next(FileStatus fileStatus) throws IOException { if (sawEof == true) { throw new IOException(""<STR_LIT>""); } if (fileStatus == null) { throw new IllegalArgumentException(""<STR_LIT>""); } output.putNextEntry(new ZipEntry(fileStatus.getPath().getName())); output.setExtra(fileStatus.readFields(new DataOutputBuffer())); sawNext = true; return true; } public void finish() throws IOException { output.close(); } @Override public void close() throws IOException { if (sawEof == false) { output.close(); } original.close(); } } }",0.0003749041374510046
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . vocabulary . external . ImporterDescription ; public class InvalidTypeImporterDescription implements ImporterDescription { @ Override public Class < ? > getModelType ( ) { return null ; }'}]",@Deprecated public Class <?> getModelClass();,2.6162059302628544e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . importer ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import com . asakusafw . bulkloader . bean . ImportBean ; import com . asakusafw . bulkloader . bean . ImportTargetTableBean ; import com . asakusafw . bulkloader . common . DBAccessUtil ; import com . asakusafw . bulkloader . common . DBConnection ; import com . asakusafw . bulkloader . common . ImportTableLockType ; import com . asakusafw . bulkloader . common . ImportTableLockedOperation ; import com . asakusafw . bulkloader . exception . BulkLoaderReRunnableException ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; public class TargetDataLock { static final Log LOG = new Log ( TargetDataLock . class ) ; private static final String NOT_EXISTS_JOBFLOW_SID = ""<STR_LIT:-1>"" ; private String jobflowSid ; public boolean lock ( ImportBean bean ) throws BulkLoaderReRunnableException { int retryCount = bean . getRetryCount ( ) ; int retryInterval = bean . getRetryInterval ( ) ; int retry = <NUM_LIT:0> ; Connection conn = null ; try { conn = DBConnection . getConnection ( ) ; jobflowSid = checkExecutionId ( conn , bean . getExecutionId ( ) ) ; if ( ! jobflowSid . equals ( NOT_EXISTS_JOBFLOW_SID ) ) { LOG . info ( ""<STR_LIT>"" , bean . getTargetName ( ) , bean . getExecutionId ( ) , jobflowSid ) ; return true ; } while ( true ) { retry ++ ; try { LOG . info ( ""<STR_LIT>"" , bean . getTargetName ( ) , bean . getExecutionId ( ) ) ; execTran ( conn , bean ) ; DBConnection . commit ( conn ) ; LOG . info ( ""<STR_LIT>"" , bean . getTargetName ( ) , bean . getExecutionId ( ) ) ; return true ; } catch ( BulkLoaderReRunnableException e ) { LOG . log ( e ) ; if ( retry <= retryCount ) { try { DBConnection . rollback ( conn ) ; Thread . sleep ( TimeUnit . SECONDS . toMillis ( retryInterval ) ) ; continue ; } catch ( InterruptedException e2 ) { throw new BulkLoaderSystemException ( e2 , getClass ( ) , ""<STR_LIT>"" ) ; } } else { throw new BulkLoaderReRunnableException ( e , getClass ( ) , ""<STR_LIT>"" ) ; } } } } catch ( BulkLoaderSystemException e ) { LOG . log ( e ) ; try { DBConnection . rollback ( conn ) ; } catch ( BulkLoaderSystemException e1 ) { e1 . printStackTrace ( ) ; } return false ; } finally { DBConnection . closeConn ( conn ) ; } } private void execTran ( Connection conn , ImportBean bean ) throws BulkLoaderReRunnableException , BulkLoaderSystemException { jobflowSid = insertRunningJobFlow ( conn , bean . getTargetName ( ) , bean . getBatchId ( ) , bean . getJobflowId ( ) , bean . getExecutionId ( ) , bean . getJobnetEndTime ( ) ) ; Map < String , String > tableLock ; try { tableLock = getImportTableLock ( conn , bean . getImportTargetTableList ( ) . iterator ( ) ) ; } catch ( BulkLoaderSystemException e ) { throw new BulkLoaderReRunnableException ( e . getCause ( ) , getClass ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } List < String > list = bean . getImportTargetTableList ( ) ; for ( String tableName : list ) { ImportTargetTableBean targetTable = bean . getTargetTable ( tableName ) ; ImportTableLockType lockType = targetTable . getLockType ( ) ; ImportTableLockedOperation operation = targetTable . getLockedOperation ( ) ; String serchCondition = targetTable . getSearchCondition ( ) ; LOG . info ( ""<STR_LIT>"" , tableName , lockType , operation , serchCondition ) ; if ( ImportTableLockType . NONE . equals ( lockType ) && ImportTableLockedOperation . FORCE . equals ( operation ) ) { LOG . info ( ""<STR_LIT>"" , tableName ) ; continue ; } String targetSid = tableLock . get ( tableName ) ; if ( targetSid != null && ! targetSid . isEmpty ( ) ) { if ( ImportTableLockType . RECORD . equals ( lockType ) && ImportTableLockedOperation . OFF . equals ( operation ) ) { LOG . info ( ""<STR_LIT>"" , tableName ) ; continue ; } else { throw new BulkLoaderReRunnableException ( getClass ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ,'}]","tableName, targetSid); } } } private String checkExecutionId(Connection conn, String executionId) throws BulkLoaderSystemException { String sid = getExecutionId(conn, executionId); if (sid == null || sid.isEmpty()) { return NOT_EXISTS_JOBFLOW_SID; } return sid; } private String insertRunningJobFlow(Connection conn, String targetName, String batchId, String jobflowId, String executionId, Date jobnetEndTime) throws BulkLoaderReRunnableException, BulkLoaderSystemException { String sql = DBAccessUtil.getSql(""INSERT_RUNNING_JOBFLOW"", targetName, batchId, jobflowId, executionId, jobnetEndTime); try (PreparedStatement pstmt = conn.prepareStatement(sql)) { pstmt.setString(1, targetName); pstmt.setString(2, batchId); pstmt.setString(3, jobflowId); pstmt.setString(4, executionId); pstmt.setDate(5, jobnetEndTime); pstmt.executeUpdate(); } catch (SQLException e) { throw new BulkLoaderReRunnableException(e, getClass(), ""<STR_LIT>"", targetName, e.getMessage()); } return executionId; } private Map<String, String> getImportTableLock(Connection conn, Iterator<ImportTargetTableBean> it) throws BulkLoaderSystemException { String sql = DB",0.0003914227385952356
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . flow . testing . model . Part2 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class Part2Output implements ModelOutput < Part2 > { private final RecordEmitter emitter ; public'}]",Part2Output ( RecordEmitter emitter ) { this. emitter = emitter ; } @ Override public void emit ( Part2 model ) throws IOException { emitter. emit ( model. getRecord ( ) ) ; } @ Override public void close ( ) throws IOException { emitter. close ( ) ; } },9.273451003523636e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . concurrent . atomic . AtomicInteger ; public class ExecutionWatcher { private final Runnable action ; private final AtomicInteger added = new AtomicInteger ( ) ; private final AtomicInteger executed = new AtomicInteger ( ) ; private boolean started ; public ExecutionWatcher ( Runnable action ) { this . action = action ; } public Runnable addJob ( final Runnable job ) { added . incrementAndGet ( ) ; return new Runnable ( ) { @ Override public void run ( ) { job . run ( ) ; executed . incrementAndGet ( ) ; boolean perform ; synchronized'}]",(this) { perform = started; } if (perform) { action.run(); } } }; } public void start() { started = true; } },5.463678047749267e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . core . model ; import java . util . Vector ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IStackFrame ; import org . rubypeople . rdt . debug . core . RdtDebugCorePlugin ; import org . rubypeople . rdt . debug . core . model . IRubyThread ; import org . rubypeople . rdt . internal . debug . core . RubyDebuggerProxy ; import org . rubypeople . rdt . internal . debug . core . SuspensionPoint ; public class RubyThread extends RubyDebugElement implements IRubyThread { private RubyStackFrame [ ] frames ; private boolean isSuspended = false ; private boolean isTerminated = false ; private boolean isStepping = false ; private String name ; private String status ; private int id ; private ThreadJob fRunningAsyncJob ; private ThreadJob fAsyncJob ; public RubyThread ( IDebugTarget target , int id , String status ) { super ( target ) ; this . setId ( id ) ; this . status = status ; this . updateName ( ) ; } public IStackFrame [ ] getStackFrames ( ) { if ( frames == null ) { createStackFrames ( ) ; } return frames ; } private synchronized void createStackFrames ( ) { if ( isSuspended ( ) ) { getRubyDebuggerProxy ( ) . readFrames ( this ) ; } else { frames = new RubyStackFrame [ ] { } ; } } public int getStackFramesSize ( ) { return frames . length ; } public boolean hasStackFrames ( ) { return isSuspended ; } public int getPriority ( ) throws DebugException { return <NUM_LIT:0> ; } public IStackFrame getTopStackFrame ( ) throws DebugException { IStackFrame [ ] frames = getStackFrames ( ) ; if ( frames == null || frames . length == <NUM_LIT:0> ) return null ; return frames [ <NUM_LIT:0> ] ; } public IBreakpoint [ ] getBreakpoints ( ) { return new IBreakpoint [ ] { DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) [ <NUM_LIT:0> ] } ; } public boolean canResume ( ) { return isSuspended ; } public boolean canSuspend ( ) { return false ; } public boolean isSuspended ( ) { return isSuspended ; } protected void setSuspended ( boolean isSuspended ) { this . isSuspended = isSuspended ; } protected void resume ( boolean isStep ) { isStepping = isStep ; isSuspended = false ; this . updateName ( ) ; this . frames = new RubyStackFrame [ ] { } ; } public void resume ( ) throws DebugException { resume ( false ) ; ( ( RubyDebugTarget ) this . getDebugTarget ( ) ) . getRubyDebuggerProxy ( ) . resume ( this ) ; DebugEvent ev = new DebugEvent ( this , DebugEvent . RESUME , DebugEvent . CLIENT_REQUEST ) ; DebugPlugin . getDefault ( ) . fireDebugEventSet ( new DebugEvent [ ] { ev } ) ; } public void doSuspend ( SuspensionPoint suspensionPoint ) { int suspensionReason = <NUM_LIT:0> ; if ( suspensionPoint . isStep ( ) ) { suspensionReason = DebugEvent . STEP_END ; } else { suspensionReason = DebugEvent . BREAKPOINT ; } frames = null ; isSuspended = true ; isStepping = false ; this . createName ( suspensionPoint ) ; DebugEvent ev = new DebugEvent ( this , DebugEvent . SUSPEND , suspensionReason ) ; DebugPlugin . getDefault ( ) . fireDebugEventSet ( new DebugEvent [ ] { ev } ) ; } public void suspend ( ) { frames = null ; isStepping = false ; isSuspended = true ; getRubyDebuggerProxy ( ) . sendThreadStop ( this ) ; } public boolean canStepInto ( ) { return isSuspended && this . hasStackFrames ( ) ; } public boolean canStepOver ( ) { return isSuspended && this . hasStackFrames ( ) ; } public boolean canStepReturn ( ) { return false ; } public boolean isStepping ( ) { return isStepping ; } public void stepInto ( ) throws DebugException { isStepping = true ; this . updateName ( ) ; if ( frames != null && frames . length > <NUM_LIT:0> ) { frames [ <NUM_LIT:0> ] . stepInto ( ) ; } } public void stepOver ( ) throws DebugException { if ( frames != null && frames . length > <NUM_LIT:0> ) { frames [ <NUM_LIT:0> ] . stepOver ( ) ; } } public void stepReturn ( ) throws DebugException { } public boolean canTerminate ( ) { return ! isTerminated ; } public boolean isTerminated ( ) { return isTerminated ; } public void terminate ( ) throws DebugException { this . getDebugTarget ( ) . terminate ( ) ; isTerminated = true ; this . frames = null ; } public RubyDebuggerProxy getRubyDebuggerProxy ( ) { return ( ( RubyDebugTarget ) this . getDebugTarget ( ) ) . getRubyDebuggerProxy ( ) ; } public void setStackFrames ( RubyStackFrame [ ] frames ) { this . frames ='}]",frames; } },3.994352168055474e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules . units ; import java . util . Arrays ; import org . oddjob . arooa . convert . ConversionProvider ; import org . oddjob . arooa . convert . ConversionRegistry ; import org . oddjob . arooa . convert . Convertlet ; import org . oddjob . arooa . convert . ConvertletException ; public interface DayOfWeek { enum Days implements DayOfWeek { MONDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:1> ; } } , TUESDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:2> ; } } , WEDNESDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:3> ; } } , THURSDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:4> ; } } , FRIDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:5> ; } } , SATURDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:6> ; } } , SUNDAY { @ Override public int getDayNumber ( ) { return <NUM_LIT:7> ; } } } public static class Conversions implements ConversionProvider { @ Override public void registerWith ( ConversionRegistry registry ) { registry . register ( String . class , DayOfWeek . class , new Convertlet < String , DayOfWeek > ( ) { @ Override public DayOfWeek convert ( String from ) throws ConvertletException { try { final int day = Integer . parseInt ( from ) ; return Days . values'}]","()[].stream().filter(d -> d.getDayNumber() == day).findFirst().orElseThrow(ConvertletException::new); } @Override public String convert(DayOfWeek to) throws ConvertletException { return String.format(""%d"", to.getDayNumber()); } } ); } }",9.005303103043691e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . wizards . templates ; import net . sf . sveditor . core . templates . TemplateCategory ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; public class TemplateCategoriesContentProvider implements ITreeContentProvider { private TemplateCategoriesNode fRoot ; public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput ,'}]",Object newInput ) { if ( newInput instanceof TemplateCategory ) { fRoot = new TemplateCategoriesNode ((TemplateCategory) newInput); } } public Object [] getElements ( Object element ) { return new Object [] { fRoot }; } public Object getKeyObject ( Object anElement ) { return anElement; } public Object getParent ( Object element ) { return null; } public boolean hasChildren ( Object element ) { return true; } public Object [] getChildren ( Object element ) { return new Object [] { fRoot }; } },0.00015681451554111866
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . handlers ; public class OddjobTransportableException extends Exception { private static final long serialVersionUID = <NUM_LIT> ; private final String originalExcpetionClassName ; public OddjobTransportableException ( Throwable t ) { super ( t . getMessage ( ) ) ; this . originalExcpetionClassName = t . getClass ( ) . getName ( ) ; setStackTrace ( t . getStackTrace ( ) ) ; if ( t . getCause ( ) != null ) { initCause ( new OddjobTransportableException'}]","(t.getCause())); } } public OddjobTransportableException(String message, Throwable t) { super(message); this.originalExcpetionClassName = t.getClass().getName(); setStackTrace(t.getStackTrace()); if (t.getCause()!= null) { initCause(new OddjobTransportableException(t.getCause())); } } public String getOriginalExceptionClassName() { return originalExcpetionClassName; } }",0.00011916641996898166
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . values ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . algebra . ColumnRenamer ; import de . fuberlin . wiwiss . d2rq . algebra . OrderSpec ; import de . fuberlin . wiwiss . d2rq . algebra . ProjectionSpec ; import de . fuberlin . wiwiss . d2rq . expr . AttributeExpr ; import de . fuberlin . wiwiss . d2rq . expr . Concatenation ; import de . fuberlin . wiwiss . d2rq . expr . Conjunction ; import de . fuberlin . wiwiss . d2rq . expr . Constant ; import de . fuberlin . wiwiss . d2rq . expr . Equality ; import de . fuberlin . wiwiss . d2rq . expr . Expression ; import de . fuberlin . wiwiss . d2rq . nodes . NodeSetFilter ; import de . fuberlin . wiwiss . d2rq . sql . ResultRow ; public class BlankNodeID implements ValueMaker { private final static String DELIMITER = ""<STR_LIT>"" ; private String classMapID ; private List < Attribute > attributes ; public BlankNodeID ( String classMapID , List < Attribute > attributes ) { this . classMapID = classMapID ; this . attributes = attributes ; } public List < Attribute > attributes ( ) { return this . attributes ; } public String classMapID ( ) { return this . classMapID ; } public void describeSelf ( NodeSetFilter c ) { c . limitValuesToBlankNodeID ( this ) ; } public boolean matches ( String value ) { return ! valueExpression ( value ) . isFalse ( ) ; } public Expression valueExpression ( String value ) { if ( value == null ) { return Expression . FALSE ; } String [ ] parts = value . split ( DELIMITER ) ; if ( parts . length != this . attributes . size ( ) + <NUM_LIT:1> || ! this . classMapID . equals ( parts [ <NUM_LIT:0> ] ) ) { return Expression . FALSE ; } int i = <NUM_LIT:1> ; Collection < Expression > expressions = new ArrayList < Expression > ( attributes . size ( ) ) ; for ( Attribute attribute : attributes ) { expressions . add ( Equality . createAttributeValue ( attribute , parts [ i ] ) ) ; i ++ ; } return Conjunction . create ( expressions ) ; } public Set < ProjectionSpec >'}]","projectionSpecs () { Set<ProjectionSpec> specs = new HashSet<ProjectionSpec>(); Iterator<Attribute> iterator = attributes.iterator(); for (int i = 1; i <= attributes.size(); i++) { specs.add(ColumnRenamer.create(attribute, parts[i])); } return specs; } }",0.00010261998754294725
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . oql ; class OQLQuery { OQLQuery ( String selectExpr , boolean isInstanceOf , String className , String identifier , String whereExpr ) { this . selectExpr = selectExpr ;'}]",this.isInstanceOf = isInstanceOf; this.className = className; this.identifier = identifier; this.whereExpr = whereExpr; } String selectExpr; boolean isInstanceOf; String className; String identifier; String whereExpr; },7.058823948449155e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . job_mgr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . job_mgr . JobMgrWorkerThread . ThreadState ; public class JobMgr implements IJobMgr { private List < IJobListener > fJobListeners ; private List < JobMgrWorkerThread > fThreadPool ; private List < IJob > fJobQueue ; private int fMaxThreads ; private boolean fDisposed ; public JobMgr ( ) { fJobListeners = new ArrayList < IJobListener > ( ) ; fThreadPool = new ArrayList < JobMgrWorkerThread > ( ) ; fJobQueue = new ArrayList < IJob > ( ) ; fMaxThreads = <NUM_LIT:4> ; } public void dispose ( ) { fDisposed = true ; synchronized ( fThreadPool ) { while ( fThreadPool . size ( ) > <NUM_LIT:0> ) { try { fThreadPool . wait ( ) ; } catch ( InterruptedException e ) { break ; } } } } public void addJobListener ( IJobListener l ) { synchronized ( fJobListeners ) { fJobListeners . add ( l ) ; } } public void removeJobListener ( IJobListener l ) { synchronized ( fJobListeners ) { fJobListeners . remove ( l ) ; } } public IJob createJob ( ) { return new JobMgrJob ( ) ; } public void queueJob ( IJob job ) { checkWorkerThreads ( ) ; synchronized ( fJobQueue ) { if ( fJobQueue . size ( ) == <NUM_LIT:0> || fJobQueue . get ( fJobQueue . size ( ) - <NUM_LIT:1> ) . getPriority ( ) <= job . getPriority ( ) ) { fJobQueue . add ( job ) ; } else { boolean added = false ; for ( int i = <NUM_LIT:0> ; i < fJobQueue . size ( ) ; i ++ ) { if ( fJobQueue . get ( i ) . getPriority ( ) > job . getPriority ( ) ) { fJobQueue . add ( i , job ) ; added = true ; break ; } } if ( ! added ) { fJobQueue . add ( job ) ; } }'}]",} } public void checkWorkerThreads ( ) { if ( fThreadPool. isEmpty ( ) || fThreadPool. size ( ) < fMaxThreads ) { JobMgrWorkerThread thread = new JobMgrWorkerThread ( this ) ; fThreadPool. add ( thread ) ; thread. start ( ) ; } } public void notifyJobListeners ( IJobEvent event ) { synchronized ( fJobListeners ) { for ( IJobListener listener : fJobListeners ) { listener. jobEventOccurred ( event ) ; } } } },6.113132778735226e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . filters ; import org . rubypeople . rdt . internal . ui . viewsupport . MemberFilter ; public class FieldsFilter extends MemberFilter {'}]",public FieldsFilter(String... fieldNames) { super(fieldNames); },3.255840302206737e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . server ; import java . util . Collection ; import java . util . List ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . sun . tools . hat . internal . model . * ; import com . sun . tools . hat . internal . util . Misc ; class InstancesQuery extends QueryHandler { private final boolean includeSubclasses ; private final boolean newObjects ; public InstancesQuery ( boolean includeSubclasses ) { this ( includeSubclasses , false ) ; } public InstancesQuery ( boolean includeSubclasses , boolean newObjects ) { this . includeSubclasses = includeSubclasses ; this . newObjects = newObjects ; } public void run ( ) { ClassResolver resolver = new ClassResolver ( snapshot , true ) ; JavaClass clazz = resolver . apply ( query ) ; List < JavaClass > referrers = Lists . transform ( params . get ( ""<STR_LIT>"" ) , resolver ) ; boolean referee = Boolean . parseBoolean ( Iterables . getOnlyElement ( params .'}]","get(""<STR_LIT>"")).toString()); if (referee) { referrers = Lists.filter(referrers, new Predicate<JavaClass>() { @Override public boolean apply(JavaClass input) { return input.isLoaded(); } }); } List<JavaClass> instances = Lists.newArrayList(); if (includeSubclasses) { instances = Lists.newArrayList(resolver.apply(clazz, true)); } else { instances = Lists.newArrayList(resolver.apply(clazz)); } instances = Lists.filter(instances, new Predicate<JavaClass>() { @Override public boolean apply(JavaClass input) { return input.isLoaded() && (newObjects ||!input.isLoaded()); } }); instances = Lists.filter(instances, new Predicate<JavaClass>() { @Override public boolean apply(JavaClass input) { return input.isLoaded() && input.isLoaded(); } }); instances = Lists.filter(instances, new Predicate<JavaClass>() { @Override public boolean apply(JavaClass input) { return input.isLoaded() &&!input.isLoaded(); } }); instances = Lists.filter(instances, new Predicate<JavaClass>() { @Override public boolean apply(JavaClass input) { return input.isLoaded() && input.isLoaded(); } }); instances = Lists.filter(instances, new Predicate<",0.0003430316034769637
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResourceChangeEvent ; import org . eclipse . core . resources . IResourceChangeListener ; import org . eclipse . core . resources . IResourceDelta ; import org . eclipse . core . resources . IWorkspaceRunnable ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . window . Window ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . OpenResourceAction ; import org . eclipse . ui . dialogs . ElementListSelectionDialog ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . actions . ActionMessages ; import org . rubypeople . rdt . internal . ui . actions . WorkbenchRunnableAdapter ; import org . rubypeople . rdt . internal . ui . util . ExceptionHandler ; import org . rubypeople . rdt . ui . RubyElementLabelProvider ; public class OpenProjectAction extends SelectionDispatchAction implements IResourceChangeListener { private static final int EMPTY_SELECTION = <NUM_LIT:1> ; private static final int ELEMENT_SELECTION = <NUM_LIT:2> ; private int fMode ; private OpenResourceAction fWorkbenchAction ; public OpenProjectAction ( IWorkbenchSite site ) { super ( site ) ; fWorkbenchAction = new OpenResourceAction ( site . getShell ( ) ) ; setText ( fWorkbenchAction . getText ( ) ) ; setToolTipText ( fWorkbenchAction . getToolTipText ( ) ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IRubyHelpContextIds . OPEN_PROJECT_ACTION ) ; } public void resourceChanged ( IResourceChangeEvent event ) { fWorkbenchAction . resourceChanged ( event ) ; switch ( fMode ) { case ELEMENT_SELECTION : setEnabled ( fWorkbenchAction . isEnabled ( ) ) ; break ; case EMPTY_SELECTION : internalResourceChanged ( event ) ; break ; } } private void internalResourceChanged ( IResourceChangeEvent event ) { IResourceDelta delta = event . getDelta ( ) ; if ( delta != null ) {'}]","IResourceDeltaVisitor visitor = new IResourceDeltaVisitor ( ) { public boolean visit ( IResourceDelta delta ) { if ( delta. kind == IResourceDelta. REMOVED ) { return true ; } return false ; } } ; ResourcesPlugin. getWorkspace ( ). getResourceDeltaVisitor ( ). accept ( delta, visitor ) ; } @Override public void selectionChanged ( IWorkbenchPart part, IStructuredSelection selection ) { ISelection selection1 = selection. getFirstElement ( ) ; if ( selection1!= null && selection1 instanceof IStructuredSelection ) { IStructuredSelection selection2 = ( IStructuredSelection ) selection1 ; if ( selection2. size ( ) > 0 ) { fMode = ELEMENT_SELECTION ; } else { fMode = EMPTY_SELECTION ; } } else { fMode = EMPTY_SELECTION ; } setEnabled ( fWorkbenchAction. isEnabled ( ) ) ; } }",0.0002734306468790073
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import java . util . Collection ; import java . util . List ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . Position ; import org . jruby . ast . Node ; import org . rubypeople . rdt . core . IRubyElement ; public interface IOccurrencesFinder { public String initialize ( Node root , int offset , int length ) ; public List < Position > perform ( ) ; public String getJobLabel ( ) ; public String getUnformattedPluralLabel ( ) ; public String getUnformattedSingularLabel ( ) ; public String getElementName ( ) ; public void collectOccurrenceMatches ( IRubyElement'}]","element, Collection<Position> matches);",2.7562007449261133e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package net . sf . sveditor . core . preproc ; import java . util . List ; import net . sf . sveditor . core . scanutils . AbstractTextScanner ; import net . sf . sveditor . core . scanutils . ScanLocation ; public class SVPreProcOutput extends AbstractTextScanner { private StringBuilder fText ; private List < Integer > fLineMap ; private int fLineIdx ; private int fNextLinePos ; private int fIdx ; private int fUngetCh1 , fUngetCh2 ; public SVPreProcOutput ( StringBuilder text , List < Integer > line_map ) { fText = text ; fIdx = <NUM_LIT:0> ; fLineIdx = <NUM_LIT:0> ; fLineMap = line_map ; if ( line_map . size ( ) > <NUM_LIT:1> ) { fNextLinePos = line_map . get ( <NUM_LIT:1> ) ; } else { fNextLinePos = Integer . MAX_VALUE ; } fLineno = <NUM_LIT:1> ; int length = fText . length ( ) ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { if ( fText . charAt ( i ) == '<STR_LIT>' ) { fText . setCharAt ( i , '<STR_LIT:\\n>' ) ; } } fUngetCh1 = - <NUM_LIT:1> ; fUngetCh2 = - <NUM_LIT:1> ; } public int get_ch ( ) { int ch = -""}]",1; if ( fIdx < fText. length ( ) ) { ch = fText. charAt ( fIdx ) ; } return ch ; },5.992729385670263e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . testing . flow ; import com . asakusafw'}]",.compiler.api.JobFlowTest; import org.junit.Test; public class JobFlowTest extends JobFlowTest { @Test public void testSimpleJobFlow ( ) { // test code } },6.098138753943911e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby . hover ; import java . text . MessageFormat ; import org . eclipse . osgi . util . NLS ; class RubyHoverMessages extends NLS { private static final String BUNDLE_NAME = RubyHoverMessages . class . getName ( ) ; private RubyHoverMessages ( ) { } public static'}]","String RubyHoverMessage_format ; public static String RubyHoverMessage_formatKey ( ) { return MessageFormat. format ( NLS. bind ( BUNDLE_NAME, ""format"" ) ) ; } }",6.697610090297538e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . swt . events . FocusEvent ; import org . eclipse . swt . events . FocusListener ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . viewers . IPostSelectionProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; public class SelectionProviderMediator implements IPostSelectionProvider { private class InternalListener implements ISelectionChangedListener , FocusListener { public void selectionChanged ( SelectionChangedEvent event ) { doSelectionChanged ( event ) ; } public void focusGained ( FocusEvent e ) { doFocusChanged ( e . widget ) ; } public void focusLost ( FocusEvent e ) { } } private class InternalPostSelectionListener implements ISelectionChangedListener { public void selectionChanged ( SelectionChangedEvent event ) { doPostSelectionChanged ( event ) ; } } private StructuredViewer [ ] fViewers ; private StructuredViewer fViewerInFocus ; private ListenerList fSelectionChangedListeners ; private ListenerList fPostSelectionChangedListeners ; public SelectionProviderMediator ( StructuredViewer [ ] viewers , StructuredViewer viewerInFocus ) { Assert . isNotNull ( viewers ) ; fViewers = viewers ; InternalListener listener = new InternalListener ( ) ; fSelectionChangedListeners = new ListenerList ( ) ; fPostSelectionChangedListeners = new ListenerList ( ) ; fViewerInFocus = viewerInFocus ; for ( int i = <NUM_LIT:0> ; i < fViewers . length ; i ++ ) { StructuredViewer viewer = fViewers [ i ] ; viewer . addSelectionChangedListener ( listener ) ; viewer . addPostSelectionChangedListener ( new InternalPostSelectionListener ( ) ) ; Control control = viewer . getControl ( ) ; control . addFocusListener ( listener ) ; } } private void doFocusChanged ( Widget control ) { for ( int i = <NUM_LIT:0> ; i < fViewers . length ; i ++ ) { if ( fViewers [ i ] . getControl ( ) == control ) { propagateFocusChanged ( fViewers [ i ] ) ; return ; } } } final void doPostSelectionChanged ( SelectionChangedEvent event ) { ISelectionProvider provider = event . getSelectionProvider ( ) ; if ( provider == fViewerInFocus ) { firePostSelectionChanged ( ) ; } } final void doSelectionChanged ( SelectionChangedEvent event ) { ISelectionProvider provider = event . getSelectionProvider ( ) ; if ( provider == fViewerInFocus ) { fireSelectionChanged ( ) ; } } final void propagateFocusChanged ( StructuredViewer viewer ) { if ( viewer != fViewerInFocus ) { fViewerInFocus = viewer ; fireSelectionChanged ( ) ; firePostSelectionChanged ( ) ; } } private void fireSelectionChanged ( ) { if ( fSelectionChangedListeners != null ) { SelectionChangedEvent event = new SelectionChangedEvent ( this , getSelection ( ) ) ; Object [ ] listeners = fSelectionChangedListeners . getListeners ( ) ; for ( int i = <NUM_LIT:0> ; i < listeners . length ; i ++ ) { ISelectionChangedListener listener = ( ISelectionChangedListener ) listeners [ i ] ; listener . selectionChanged ( event ) ; } } } private void firePostSelectionChanged ( ) { if ( fPostSelectionChangedListeners != null ) { SelectionChangedEvent event = new SelectionChangedEvent ( this , getSelection ( ) ) ; Object [ ] listeners'}]",= fPostSelectionChangedListeners. getListeners ( ) ; for ( int i = <NUM_LIT:0> ; i < listeners. length ; i ++ ) { ISelectionChangedListener listener = ( ISelectionChangedListener ) listeners [ i ] ; listener. selectionChanged ( event ) ; } } private ISelection getSelection ( ) { if ( fViewers == null || fViewers. length == 0 ) { return null ; } return fViewers [ 0 ]. getSelection ( ) ; } },0.0001785621940553426
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . logging . cache ; import java . util . HashMap ; import java . util . Map ; import org . apache . log4j . Logger ; import org . oddjob . Stateful ; import org . oddjob . logging . ArchiveNameResolver ; import org . oddjob . logging . LogArchive ; import org . oddjob . logging . LogArchiver ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . state . StateListener ; import org . oddjob . state . StateEvent ; abstract public class AbstractArchiverCache implements LogArchiverCache { private static final Logger logger = Logger . getLogger ( AbstractArchiverCache . class ) ; private final Map < String , LogArchiveImpl > archives = new HashMap < String , LogArchiveImpl > ( ) ; private final SimpleCounter counter = new SimpleCounter ( ) ; private final int maxHistory ; private final ArchiveNameResolver resolver ; private final StateListener stateListener = new StateListener ( ) { @ Override public void jobStateChange ( StateEvent event ) { if ( event . getState ( ) . isDestroyed ( ) ) { removeArchive ( event . getSource ( ) ) ; } } } ; public AbstractArchiverCache ( ArchiveNameResolver resolver ) { this ( resolver , LogArchiver . MAX_HISTORY ) ; } public AbstractArchiverCache ( ArchiveNameResolver resolver , int maxHistory ) { this . resolver = resolver ; this . maxHistory = maxHistory ; } public int getMaxHistory ( ) {'}]",return maxHistory;,2.51838120741523e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . text . Assert ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; public class GotoMatchingBracketAction extends Action {'}]","private GotoMatchingBracketAction() { super(""Goto Matching Bracket""); } public GotoMatchingBracketAction(String text) { super(text); } @Override public void run() { ITextEditor editor = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor(); if (editor!= null && editor.getAdapter(ITextEditor.class) instanceof ITextEditor) { ITextEditor textEditor = (ITextEditor) editor.getAdapter(ITextEditor.class); Assert.isNotNull(textEditor, ""No active text editor""); } } }",0.00015913930775740697
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . ISVDBScopeItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBLocation ; import net . sf . sveditor . core . db . attr . SVDBParentAttr ; public class SVDBBlockStmt extends SVDBStmt implements ISVDBScopeItem { @ SVDBParentAttr public ISVDBChildItem fParent ; public List < ISVDBItemBase > fItems ; public SVDBLocation fEndLocation ; public String fBlockName ; public SVDBBlockStmt ( ) { super ( SVDBItemType . BlockStmt ) ; fBlockName = ""<STR_LIT>"" ; fItems = new ArrayList < ISVDBItemBase > ( ) ; } public SVDBBlockStmt ( SVDBItemType type ) { super ( type ) ; fBlockName = ""<STR_LIT>"" ; fItems = new ArrayList < ISVDBItemBase > ( ) ; } public void addChildItem ( ISVDBChildItem item ) { fItems . add ( item ) ; if ( item != null ) { item . setParent ( this ) ; } } @ SuppressWarnings ( { ""<STR_LIT:unchecked>"" , ""<STR_LIT:rawtypes>"" } ) public Iterable < ISVDBChildItem > getChildren ( ) { return new Iterable < ISVDBChildItem > ( ) { public Iterator < ISVDBChildItem > iterator ( ) { return ( Iterator ) fItems . iterator ( ) ; } } ; } public void addItem ( ISVDBItemBase item ) { fItems . add ( item ) ; if ( item != null && item instanceof ISVDBChildItem ) { ( ( ISVDBChildItem ) item ) . setParent ( this ) ; } } public String getBlockName ( ) { return fBlockName ; } public void setBlockName ( String name ) { fBlockName = name ; } public ISVDBChildItem getParent ( ) { return fParent ; } public void setParent ( ISVDBChildItem parent ) { fParent = parent ; } public SVDBLocation getEndLocation ( ) { return fEndLocation ; }'}]",public void setEndLocation(SVDBLocation location),3.95893019650263e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core ; import org . eclipse . core . runtime . IPath ; public interface ILoadpathEntry { int CPE_LIBRARY = <NUM_LIT:1> ; int CPE_PROJECT = <NUM_LIT:2> ; int CPE_SOURCE ='}]",<NUM_LIT:3>; },2.718216491201436e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . util ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . util . Assert ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . WorkbenchException ; import org . rubypeople . rdt . core . IImportDeclaration ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyUIMessages ; import org . rubypeople . rdt'}]",".core.IRubyElement; public class RubyUIUtil { public static void activateEditor( IWorkbenchPage page, IRubyElement element ) throws CoreException, PartInitException, WorkbenchException { Assert. isNotNull( page ); Assert. isNotNull( element ); IEditorPart editor = page. findEditor( element ); if ( editor!= null ) { page. activateEditor( editor ); } else { RubyPlugin. logError( RubyUIMessages. ERROR_EDITOR_NOT_FOUND ); } } }",0.0001496643489399134
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . overridemethod ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . Collection ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . text . edits . MalformedTreeException ; import org . rubypeople . rdt . refactoring . core . overridemethod . MethodsOverrider ; import org . rubypeople . rdt . refactoring . documentprovider . StringDocumentProvider ; import org . rubypeople . rdt . refactoring . tests . FilePropertyData ; import org . rubypeople . rdt . refactoring . tests . FileTestData ; import org . rubypeople . rdt . refactoring . tests . TwoLayerTreeEditProviderTester ; public class'}]","OverridemethodTest extends TwoLayerTreeEditProviderTester { @Override protected void createTestData ( FileTestData testData ) throws MalformedTreeException, BadLocationException, FileNotFoundException { super. createTestData ( testData ) ; FilePropertyData filePropertyData = new FilePropertyData ( testData. getTestDataFile ( ), testData. getTestData ( ) ) ; MethodsOverrider methodsOverrider = new MethodsOverrider ( filePropertyData ) ; methodsOverrider. createTestData ( testData ) ; } }",0.00015402830162976314
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . ArrayAccessExpression ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com .'}]","asakusafw.utils.java.model.syntax.ArrayAccessExpression; public class ArrayAccessExpressionImpl implements ArrayAccessExpression { private final Expression base ; private final Expression index ; public ArrayAccessExpressionImpl ( Expression base, Expression index ) { super ; this. base = base ; this. index = index ; } @ Override public Expression getBase ( ) { return base ; } @ Override public Expression getIndex ( ) { return index ; } @ Override public ModelKind kind ( ) { return ModelKind. ARRAY_ACCESS_EXPRESSION ; } }",0.0001456174760890238
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . operator ; import com . asakusafw . compiler . flow . processor . SummarizeFlowProcessor ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . ExSummarized ; import com . asakusafw . compiler . flow . testing . model . ExSummarized2 ; import com . asakusafw . compiler . flow . testing . model . KeyConflict ; import com . asakusafw . vocabulary . operator . Summarize ; public abstract class SummarizeFlow { @ Summarize public abstract ExSummarized simple'}]","SummarizeFlowProcessor<Ex1, ExSummarized>(Ex1.class, ExSummarized.class);",4.7724116592100265e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . search ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBChildParent ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . ISVDBNamedItem ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBModIfcClassParam ; import net . sf . sveditor . core . db . SVDBModIfcDecl ; import net . sf . sveditor . core . db . SVDBModIfcInst ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . db . SVDBTypeInfoEnum ; import net . sf . sveditor . core . db . SVDBTypeInfoEnumerator ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . stmt . SVDBParamPortDecl ; import net . sf . sveditor . core . db . stmt . SVDBTypedefStmt ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclItem ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclStmt ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; public class SVDBFindByNameInScopes { private ISVDBFindNameMatcher fMatcher ; private LogHandle fLog ; public SVDBFindByNameInScopes ( ISVDBIndexIterator index_it ) { fMatcher = SVDBFindDefaultNameMatcher . getDefault ( ) ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; } public SVDBFindByNameInScopes ( ISVDBIndexIterator index_it , ISVDBFindNameMatcher matcher ) { fMatcher = matcher ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; } public List < ISVDBItemBase > find ( ISVDBChildItem context , String name , boolean stop_on_first_match , SVDBItemType ... types ) { List < ISVDBItemBase > ret = new ArrayList < ISVDBItemBase > ( ) ; fLog . debug ( ""<STR_LIT>"" + ( ( context != null ) ? SVDBItem . getName ( context ) : ""<STR_LIT:null>"" ) + ""<STR_LIT>"" + ( ( context != null ) ? context . getType ( ) : ""<STR_LIT:null>"" ) + ""<STR_LIT>"" + name ) ; while ( context != null && context instanceof ISVDBChildParent ) { if ( context . getType ( ) == SVDBItemType . ClassDecl ) { SVDBClassDecl cls = ( SVDBClassDecl ) context ; if ( cls . getParameters ( ) != null ) { for ( SVDBModIfcClassParam p : cls . getParameters ( ) ) { if ( fMatcher . match ( p , name ) ) { ret . add ( p ) ; } } } } for ( ISVDBItemBase it : ( ( ISVDBChildParent ) context ) . getChildren ( ) ) { fLog . debug ( ""<STR_LIT>"" + SVDBItem . getName ( context ) + ""<STR_LIT>"" + SVDBItem . getName ( it ) ) ; if ( it instanceof SVDBVarDeclStmt ) { for ( ISVDBItemBase it_t : ( ( SVDBVarDeclStmt ) it ) . getChildren ( ) ) { fLog . debug ( ""<STR_LIT>"" + SVDBItem . getName ( it_t ) + ""<STR_LIT>"" + name + ""<STR_LIT:)>"" ) ; if ( it_t instanceof ISVDBNamedItem && fMatcher . match ( ( ISVDBNamedItem ) it_t , name ) ) { boolean match = ( types . length == <NUM_LIT:0> || it_t . getType ( ) . isElemOf ( types ) ) ; if ( match ) { fLog . debug ( ""<STR_LIT>"" + SVDBItem . getName ( it_t ) ) ; ret . add ( it_t ) ; if ( stop_on_first_match ) { break ; } } } } } else if ( it instanceof SVDBModIfcInst ) { for ( ISVDBItemBase it_t : ( ( SVDBModIfcInst ) it ) . getChildren ( ) ) { if ( it_t instanceof ISVDBNamedItem && fMatcher . match ( ( ISVDBNamedItem ) it_t , name ) ) { boolean match = ( types . length == <NUM_LIT:0> ) ; for ( SVDBItemType t : types ) { if ( it_t . getType ( ) == t ) { match = true ; break ; } } if ( match ) { ret . add ( it_t ) ; if ( stop_on_first_match ) { break ; } } } } } else if ( it . getType ( ) == SVDBItemType . TypedefStmt && ( ( SVDBTypedefStmt ) it ) . getTypeInfo'}]","() == SVDBTypeInfoEnumerator) { for (ISVDBItemBase it_t : ((SVDBTypedefStmt) it).getChildren()) { if (it_t instanceof ISVDBNamedItem && fMatcher.match((ISVDBNamedItem) it_t, name)) { boolean match = (types.length == 0 || it_t.getType().isElemOf(types)); if (match) { ret.add(it_t); if (stop_on_first_match) { break; } } } } } context = (ISVDBChildParent) context.getParent(); } return ret; }",0.00020106116673738883
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . view ; import org . oddjob . arooa . design . actions . EditActionsContributor ; import org . oddjob . arooa . parsing . DragPoint ; import org . oddjob . monitor . context . ExplorerContext ; import org . oddjob . monitor . model . ConfigContextSearch ; import org . oddjob . monitor . model . SelectedContextAware ; public class ExplorerEditActions extends EditActionsContributor implements SelectedContextAware { private ExplorerContext context ; public void setSelectedContext ( ExplorerContext context ) { this . context = context ; if ( context == null ) { setCutEnabled ( false ) ; setCopyEnabled ( false ) ; setPasteEnabled ( false ) ; setDeleteEnabled ( false ) ; } } @ Override public void prepare ( ) { DragPoint dragPoint = null ;'}]",// check if there's a drag point selected if ( getSelectedContextAware ( )!= null && getSelectedContextAware ( ). getSelectedContext ( )!= null && getSelectedContextAware ( ). getSelectedContext ( ). getDragPoint ( )!= null ) { dragPoint = getSelectedContextAware ( ). getSelectedContext ( ). getDragPoint ( ) ; } //... rest of the method remains the same },0.0001354289666749867
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . postmark . java ; public class Attachment { private String name ; private String contentType ; private String content ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getContentType ( ) { return contentType ; } public void setContentType ( String contentType ) { this . contentType = contentType ; } public String getContent ( ) { return content ; } public void setContent ( String content ) { this . content = content ; } @ Override public String toString ( ) { return ""<STR_LIT>"" + name + ""<STR_LIT>"" + contentType + ""<STR_LIT>"" + content + ""<STR_LIT:]>"" ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT:31> ; int result = <NUM_LIT:1> ; result = prime * result + ( ( content == null ) ? <NUM_LIT:0> : content . hashCode ( ) ) ; result = prime * result + ( ( contentType == null ) ? <NUM_LIT:0> : contentType . hashCode ( ) ) ; result = prime * result + ( ( name == null ) ? <NUM_LIT:0> : name . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Attachment other = ( Attachment ) obj ; if ( content == null ) { if ( other . content != null ) return false ; } else if ( ! content . equals ( other'}]",.content) return false; if (contentType == null) { if (other.contentType!= null) return false; } else if (!contentType.equals(other.contentType)) return false; if (name == null) { if (other.name!= null) return false; } else if (!name.equals(other.name)) return false; return true; } },0.00010510159018049861
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . generateconstructor ; import org . eclipse . osgi .'}]",services. org. eclipse. osgi.util. PropertiesUtil; import org.eclipse.jdt.core.dom.AST; import org.eclipse.jdt.core.dom.ASTParser; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.CompilationUnit; import org.eclipse.jdt.core.dom.MethodDeclaration; import org.eclipse.jdt.core.dom.Type; import org.eclipse.jdt.core.dom.VariableDeclarationFragment; import org.eclipse.jdt.core.dom.VisibilityModifier; import org.eclipse.jdt.core.dom.Modifier; import org.eclipse.jdt.core.dom.MethodInvocation; import org.eclipse.jdt.core.dom.SimpleType; import org.eclipse.jdt.core.dom.ArrayType; import org.eclipse.jdt.core.dom.Modifier.ModifierKeyword; import org.eclipse.jdt.core.dom.FieldDeclaration; import org.eclipse.jdt.core.dom.FieldAccessor; import org.eclipse.jdt.core.dom.MethodInvocation.Argument; import org.eclipse.jdt.core.dom.SimpleName; import org.eclipse.jdt.core.dom.ArrayAccess; import org.eclipse.jdt.core.dom.Modifier.ModifierType; import org.eclipse.jdt.core.dom.ArrayInitializer; import org.eclipse.jdt.core.dom.ArrayType.ArrayDimension; import org.eclipse.jdt.core.dom.ASTVisitor; import org.eclipse.jdt.core.dom.ASTVisitor,0.00033466883530037183
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . launching ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . swt . widgets . Display ; abstract class Sudo { synchronized static final String getPassword ( final String msg ) { final String [ ] password = new String [ <NUM_LIT:1> ] ; Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { PasswordDialog dialog = new PasswordDialog ( null , ""<STR_LIT>"" , msg , null , null ) ; if ( dialog . open'}]",()!= Dialog.OK) { return null; } password[0] = dialog.getPassword(); } ); return password[0]; } },5.0575317383302795e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . describe ; import java . lang . reflect . Method ; import java . util . Map ; import org . oddjob . arooa . ArooaBeanDescriptor ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . reflect . PropertyAccessor ; public class AnnotationDescriber implements Describer {'}]","private static final Map<Class<?>, Method> DESCRIBER_METHODS = new HashMap<>();",4.4346834576017085e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . DataModel ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ Generated ( ""<STR_LIT>"" ) @ DataModel @ TableModel ( name = ""<STR_LIT>"" , columns = { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , primary = { ""<STR_LIT>"" } ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class TempImportTarget2 implements Writable { @ Property ( name = ""<STR_LIT>"" ) private LongOption tempSid = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption sid = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption versionNo = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption textdata2 = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private IntOption intdata2 = new IntOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption datedata2 = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption rgstDate = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption updtDate = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption duplicateFlg = new StringOption ( ) ; public long getTempSid ( ) { return this . tempSid . get ( ) ; } public void setTempSid ( long tempSid ) { this . tempSid . modify ( tempSid ) ; } public LongOption getTempSidOption ( ) { return this . tempSid ; } public void setTempSidOption ( LongOption tempSid ) { this . tempSid . copyFrom ( tempSid ) ; } public long getSid ( ) { return this . sid . get ( ) ; } public void setSid ( long sid ) { this . sid . modify ( sid ) ; } public LongOption getSidOption ( ) { return this . sid ; } public void setSidOption ( LongOption sid ) { this . sid . copyFrom ( sid ) ; } public long getVersionNo ( ) { return this . versionNo . get ( ) ; } public void setVersionNo ( long versionNo ) { this . versionNo . modify ( versionNo ) ; } public LongOption getVersionNoOption ( ) { return this . versionNo ; } public void setVersionNoOption ( LongOption versionNo ) { this . versionNo . copyFrom ( versionNo ) ; } public Text getTextdata2 ( ) { return this . textdata2 . get ( ) ; } public void setTextdata2 ( Text textdata2 ) { this . textdata2 . modify ( textdata2 ) ; } public String getTextdata2AsString ( ) { return this . textdata2 . getAsString ( ) ; } public void setTextdata2AsString ( String textdata2 ) { this . textdata2 . modify ( textdata2 ) ; } public StringOption getTextdata2Option ( ) { return this . textdata2 ; } public void setTextdata2Option ( StringOption textdata2 ) { this . textdata2 . copyFrom ( textdata2 ) ; } public int getIntdata2 ( ) { return this . intdata2 . get ( ) ; } public void setIntdata2 ( int intdata2 ) { this . intdata2 . modify ( intdata2 ) ; } public IntOption getIntdata2Option ( ) { return this . intdata2 ; } public void setIntdata2Option ( IntOption intdata2 ) { this . intdata2 . copyFrom ( intdata2 ) ; } public DateTime getDatedata2 ( ) { return this . datedata2 . get ( ) ; } public void setDatedata2 ( DateTime datedata2 ) { this . datedata2 . modify ( datedata2 ) ; } public DateTimeOption getDatedata2Option ( ) { return this . datedata2 ; } public void setDatedata2Option ( DateTimeOption datedata2 ) { this . datedata2 . copyFrom ( datedata2 ) ; } public DateTime getRgstDate ( ) { return this . rgstDate . get ( ) ; } public void setRgstDate ( DateTime rgstDate ) { this . rgstDate . modify ( rgstDate ) ; } public DateTimeOption getRgstDateOption ( ) { return this . rgstDate ; } public void setRgstDateOption ( DateTimeOption rgstDate ) { this . rgstDate . copyFrom ( rgstDate ) ; } public DateTime getUpdtDate ( ) { return this . updtDate . get ( ) ; } public void setUpdtDate ( DateTime updtDate ) { this . updtDate . modify ( updtDate ) ; } public DateTimeOption getUpdtDateOption ( ) { return this . updtDate ; } public void setUpdtDateOption ( DateTimeOption updtDate ) { this . updtDate . copyFrom ( updtDate ) ; } public Text getDuplicateFlg ( ) { return this . duplicateFlg . get ( ) ; } public void setDuplicateFlg ( Text duplicateFlg ) { this . duplicateFlg . modify ( duplicateFlg ) ; } public String getDuplicateFlgAsString ( ) { return this . duplicateFlg . getAsString ( ) ; } public void setDuplicateFlgAsString ( String duplicateFlg ) { this . duplicateFlg . modify ( duplicateFlg ) ; } public StringOption getDuplicateFlgOption ( ) { return this . duplicateFlg ; } public void setDuplicateFlgOption ( StringOption duplicateFlg ) { this . duplicateFlg . copyFrom ( duplicateFlg ) ; } public void copyFrom ( TempImportTarget2 source ) { this . tempSid . copyFrom ( source . tempSid ) ; this . sid . copyFrom ( source . sid ) ; this . versionNo . copyFrom'}]",(source.versionNo); this.textdata2.copyFrom(source.textdata2); this.intdata2.copyFrom(source.intdata2); this.datedata2.copyFrom(source.datedata2); this.rgstDate.copyFrom(source.rgstDate); this.updtDate.copyFrom(source.updtDate); this.duplicateFlg.copyFrom(source.duplicateFlg); } @Override public void write(DataOutput out) throws IOException { this.tempSid.write(out); this.sid.write(out); this.versionNo.write(out); this.textdata2.write(out); this.intdata2.write(out); this.datedata2.write(out); this.rgstDate.write(out); this.updtDate.write(out); this.duplicateFlg.write(out); } @Override public void readFields(DataInput in) throws IOException { this.tempSid.readFields(in); this.sid.readFields(in); this.versionNo.readFields(in); this.textdata2.readFields(in); this.intdata2.readFields(in); this.datedata2.readFields(in); this.rgstDate.readFields(in); this.updtDate.readFields(in); this.duplicateFlg.readFields(in); } },0.00038718164546529894
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . packageview ; import org . eclipse . core . resources . IFolder ; import org . eclipse . jface . util . Assert ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . internal . ui . viewsupport . AppearanceAwareLabelProvider ; public class PackageExplorerLabelProvider extends AppearanceAwareLabelProvider { private PackageExplorerContentProvider fContentProvider ; private boolean fIsFlatLayout ; private PackageExplorerProblemsDecorator fProblemDecorator ; public PackageExplorerLabelProvider ( long textFlags , int imageFlags , PackageExplorerContentProvider cp ) { super ( textFlags , imageFlags'}]",); fContentProvider = cp; fIsFlatLayout = false; fProblemDecorator = new PackageExplorerProblemsDecorator(); },4.989136195231871e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . math . BigDecimal ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . List ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . reflect . ArooaClass ; import org . oddjob . arooa . reflect . BeanOverview ; import org . oddjob . arooa . reflect . PropertyAccessor ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . types . ArooaObject ; import org . oddjob . arooa . types . ValueType ; import org . oddjob . beanbus . BadBeanException ; import org . oddjob . beanbus . CrashBusException ; public class ParameterisedExecutorText extends TestCase { public void testHSQLDataTypes ( ) throws SQLException , ClassNotFoundException , ArooaConversionException { ConnectionType ct = new ConnectionType ( ) ; ct . setDriver ( ""<STR_LIT>"" ) ; ct . setUrl ( ""<STR_LIT>"" ) ; ct . setUsername ( ""<STR_LIT>"" ) ; ct . setPassword ( ""<STR_LIT>"" ) ; Statement stmt = ct . toValue ( ) . createStatement ( ) ; String create = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; stmt . execute ( create ) ; String insert = ""<STR_LIT>"" ; stmt . execute ( insert ) ; String select = ""<STR_LIT>"" ; ResultSet rs = stmt . executeQuery ( select ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int c = md . getColumnCount ( ) ; rs . next ( ) ; try { for ( int i = <NUM_LIT:1> ; i <= c ; ++ i ) { assertEquals ( md . getColumnName ( i ) , Class . forName ( md . getColumnClassName ( i ) ) , rs . getObject ( i ) . getClass ( ) ) ; } } catch ( AssertionFailedError e ) { } stmt . execute ( ""<STR_LIT>"" ) ; } private class Results implements SQLResultsProcessor { Object last ; @ Override public void accept ( Object bean ) throws BadBeanException , CrashBusException { last = bean ; } } @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) public void testBeanTypes ( ) throws BadBeanException , ArooaConversionException { ConnectionType ct = new ConnectionType ( ) ; ct . setDriver ( ""<STR_LIT>"" ) ; ct . setUrl ( ""<STR_LIT>"" ) ; ct . setUsername ( ""<STR_LIT>"" ) ; ct . setPassword ( ""<STR_LIT>"" ) ; ParameterisedExecutor test = new ParameterisedExecutor ( ) ; test . setConnection ( ct . toValue ( ) ) ; StandardArooaSession session = new StandardArooaSession ( ) ; test . setArooaSession ( session ) ; Results results = new Results ( ) ; test . setResultProcessor ( results ) ; String create = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; test . accept ( create ) ; ValueType v1 = new ValueType ( ) ; v1 . setValue ( new ArooaObject ( ""<STR_LIT:1>"" ) ) ; ValueType v2 = new ValueType ( ) ; v2 . setValue ( new ArooaObject ( ""<STR_LIT:2>"" ) ) ; ValueType v3 = new ValueType ( ) ; v3 . setValue ( new ArooaObject ( ""<STR_LIT:3>"" ) ) ; ValueType v4 = new ValueType ( ) ; v4 . setValue ( new ArooaObject ( ""<STR_LIT:4>"" ) ) ; ValueType v5 = new ValueType ( ) ; v5 . setValue ( new ArooaObject ( ""<STR_LIT:5>"" ) ) ; ValueType v6 = new ValueType ( ) ; v6 . setValue ( new ArooaObject ( ""<STR_LIT:6>"" ) ) ; test . setParameters ( <NUM_LIT:0> , v1'}]",", v2, v3, v4, v5, v6); String insert = ""<STR_LIT>"" ; test. accept ( insert ) ; String select = ""<STR_LIT>"" ; ResultSet rs = test. executeQuery ( select ) ; ResultSetMetaData md = rs. getMetaData ( ) ; int c = md. getColumnCount ( ) ; rs. next ( ) ; try { for ( int i = <NUM_LIT:1> ; i <= c ; ++ i ) { assertEquals ( md. getColumnName ( i ), Class. forName ( md. getColumnClassName ( i ) ), rs. getObject ( i ). getClass ( ) ) ; } } catch ( AssertionFailedError e ) { } }",0.0002347200158301433
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . asakusafw . vocabulary . external . ImporterDescription ; @ Target ( ElementType . PARAMETER ) @ Retention ( RetentionPolicy .'}]",RUNTIME) @ Documented public @interface Importer { ImporterDescription value ( ) ; },4.160420948196356e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests ; import java . util . ArrayList ; import java . util . List ; import junit . framework . Test ; import junit . framework . TestResult ; import junit . framework . TestSuite ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . log . ILogHandle ; import net . sf . sveditor . core . log . ILogListener ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . tests . content_assist . ContentAssistTests ; import net . sf . sveditor . core . tests . docs . DocsTests ; import net . sf . sveditor . core . tests . fileset . FileSetTests ; import net . sf . sveditor . core . tests . hierarchy . HierarchyTests ; import net . sf . sveditor . core . tests . indent . IndentTests ; import net . sf . sveditor . core . tests . index . IndexTests ; import net . sf . sveditor . core . tests . index . cache . IndexCacheTests ; import net . sf . sveditor . core . tests . index . persistence . PersistenceTests ; import net . sf . sveditor . core . tests . job_mgr . JobMgrTests ; import net . sf . sveditor . core . tests . open_decl . OpenDeclTests ; import net . sf . sveditor . core . tests . parser . ParserTests ; import net'}]",".sf.sveditor.core.tests.search.SearchTests;public class SVCoreTestSuite extends TestSuite { public static void main ( String [ ] args ) { SVCoreTestSuite suite = new SVCoreTestSuite ( ) ; TestResult result = suite. run ( new JUnitCore ( ), args ) ; System. out. println ( ""Tests completed: "" + result. wasSuccessful ( ) ) ; } public SVCoreTestSuite ( ) { addTest ( new ContentAssistTests ( ) ) ; addTest ( new DocsTests ( ) ) ; addTest ( new FileSetTests ( ) ) ; addTest ( new HierarchyTests ( ) ) ; addTest ( new IndentTests ( ) ) ; addTest ( new IndexTests ( ) ) ; addTest ( new IndexCacheTests ( ) ) ; addTest ( new PersistenceTests ( ) ) ; addTest ( new JobMgrTests ( ) ) ; addTest ( new OpenDeclTests ( ) ) ; addTest ( new ParserTests ( ) ) ; addTest ( new SearchTests ( ) ) ; } }",0.00030838666247446717
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ExportTempImportTarget21Df ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; @ Generated ( ""<STR_LIT>"" ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public final class ExportTempImportTarget21DfModelOutput implements ModelOutput < ExportTempImportTarget21Df > { private final RecordEmitter emitter ; public ExportTempImportTarget21DfModelOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( ExportTempImportTarget21Df model ) throws IOException {'}]",emitter. emit ( model ) ; } @ Override public void close ( ) throws IOException { emitter. close ( ) ; } },5.1562689177304484e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . thundergate . runtime . cache . mapreduce ; import java . io . IOException ; import org . apache . hadoop . io . NullWritable ; import'}]",org.apache.hadoop.mapreduce.Job;,2.3902961013950376e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . script ; import java . io . StringReader ; import javax . script . ScriptException ; import junit . framework . TestCase ; public class ScriptRunnerTest extends TestCase { public void testSimpleEval ( ) throws ScriptException , NoSuchMethodException { ScriptCompiler compiler = new ScriptCompiler ( ) ; compiler . setLanguage ( ""<STR_LIT>"" ) ; Evaluatable evaluatable = compiler . compileScript ( new StringReader ( ""<STR_LIT>"" ) ) ;'}]","assertEquals(5, evaluatable.evaluate()); } public void testSimpleEvalWithArg() throws ScriptException, NoSuchMethodException { ScriptCompiler compiler = new ScriptCompiler(); compiler.setLanguage(""js""); Evaluatable evaluatable = compiler.compileScript(new StringReader(""function(x) { return x * 5; }""), new Object[]{""10""}); assertEquals(50, evaluatable.evaluate()); } public void testEvalError() throws ScriptException, NoSuchMethodException { ScriptCompiler compiler = new ScriptCompiler(); compiler.setLanguage(""js""); Evaluatable evaluatable = compiler.compileScript(new StringReader(""function(x) { return x * 5; }""), new Object[]{""abc""}); try { evaluatable.evaluate(); fail(""Expected ScriptException""); } catch (ScriptException e) { assertEquals(""TypeError: 'abc' is not a number"", e.getMessage()); } } public void testEvalErrorWithCustomErrorHandler() throws ScriptException, NoSuchMethodException { ScriptCompiler compiler = new ScriptCompiler(); compiler.setLanguage(""js""); Evaluatable evaluatable = compiler.compileScript(new StringReader(""function(x) { return x * 5; }""), new Object[]{""abc""}, new ScriptExceptionHandler() { @Override public void handleScriptException(ScriptException e) { fail(""Expected ScriptException",0.0003454839648619859
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . text . ParseException ; import java . util . Date ; import junit . framework . TestCase ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . arooa . deploy . annotations . ArooaAttribute ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; public class BeanUtilsProviderTest extends TestCase { public static class DateBean { Date date ; @ ArooaAttribute public void setDate ( Date date ) { this . date = date ; } public Date getDate ( ) { return'}]","date; } } public void test() throws ParseException { OddjobLookup lookup = OddjobLookup.create(); Date date = DateHelper.parse(""20000101"", DateHelper.DATEFORMAT); DateBean bean = new DateBean(); bean.setDate(date); XMLConfiguration config = lookup.createConfiguration(bean); Date parsedDate = DateHelper.parse(config.getStringValue(""date"")); assertEquals(date, parsedDate); } }",0.00011452025818747839
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import java . io . IOException ; import java . io . Reader ; public abstract class SubstitutionTextReader extends SingleCharReader { protected static final String LINE_DELIM = System . getProperty ( ""<STR_LIT>"" , ""<STR_LIT:n>"" ) ; private Reader fReader ; private boolean fWasWhiteSpace ; private int fCharAfterWhiteSpace ; private boolean fSkipWhiteSpace = true ; private boolean fReadFromBuffer ; private StringBuffer fBuffer ; private int fIndex ; protected SubstitutionTextReader ( Reader reader ) { fReader = reader ; fBuffer = new StringBuffer ( ) ; fIndex = <NUM_LIT:0> ; fReadFromBuffer = false ; fCharAfterWhiteSpace = - <NUM_LIT:1> ; fWasWhiteSpace = true ; } protected abstract String computeSubstitution ( int c ) throws IOException ; protected Reader getReader ( ) { return fReader ; } protected int nextChar ( ) throws IOException { fReadFromBuffer = ( fBuffer . length ( ) > <NUM_LIT:0> ) ; if ( fReadFromBuffer ) { char ch = fBuffer . charAt ( fIndex ++ ) ; if ( fIndex >= fBuffer . length ( ) ) { fBuffer . setLength ( <NUM_LIT:0> ) ; fIndex = <NUM_LIT:0> ; } return ch ; } int ch = fCharAfterWhiteSpace ; if ( ch == - <NUM_LIT:1> ) { ch = fReader . read ( ) ; } if ( fSkipWhiteSpace && Character . isWhitespace ( ( char ) ch ) ) { do { ch = fReader . read ( ) ; } while ( Character . isWhitespace ( ( char ) ch ) ) ; if ( ch != - <NUM_LIT:1> ) { fCharAfterWhiteSpace = ch ; return \'<CHAR_LIT:U+0020>\' ; } } else { fCharAfterWhiteSpace = - <NUM_LIT:1> ; } return ch ; } public int read ( ) throws IOException { int c ; do { c = nextChar ( ) ; while ( ! fReadFromBuffer ) { String s = computeSubstitution ( c ) ; if ( s == null ) break ; if ( s . length ( ) > <NUM_LIT:0> ) fBuffer . insert ( <NUM_LIT:0> , s ) ; c = nextChar ( ) ; } }'}]",while ( c!= - <NUM_LIT:1> && Character. isWhitespace ( ( char ) c ) ) ; if ( fReadFromBuffer ) { fIndex = fBuffer. length ( ) ; fReadFromBuffer = false ; } return c ; } },9.884610193084718e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . general ; import java . awt . Image ; import java . io . IOException ; import java . io . Serializable ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import javax . management . Attribute ; import javax . management . InstanceNotFoundException ; import javax . management . IntrospectionException ; import javax . management . MBeanAttributeInfo ; import javax . management . MBeanInfo ; import javax . management . MBeanOperationInfo ; import javax . management . MBeanParameterInfo ; import javax . management . MBeanServerConnection ; import javax . management . ObjectName ; import javax . management . ReflectionException ; import javax . management . openmbean . CompositeData ; import javax . swing . ImageIcon ; import org . apache . commons . beanutils . DynaBean ; import org . apache . commons . beanutils . DynaClass ; import org . apache . commons . beanutils . DynaProperty ; import org . apache . log4j . Logger ; import org . oddjob . Describeable ; import org . oddjob . Iconic ; import org . oddjob . arooa . ClassResolver ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . images . IconEvent ; import org . oddjob . images . IconListener ; import org . oddjob . logging . LogEnabled ; import org . oddjob . script . InvokerArguments ; public class SimpleMBeanNode implements MBeanNode , Describeable , LogEnabled , Iconic { private static final AtomicInteger instanceCount = new AtomicInteger ( ) ; private static final ImageIcon icon = new ImageIcon ( new ImageIcon ( SimpleDomainNode . class . getResource ( ""<STR_LIT>"" ) ) . getImage ( ) . getScaledInstance ( <NUM_LIT:16> , <NUM_LIT:16> , Image . SCALE_SMOOTH ) ) ; private final Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) + ""<STR_LIT:.>"" + instanceCount . incrementAndGet ( ) ) ; private final ObjectName objectName ; private final MBeanServerConnection mBeanServer ; private final ClassResolver classResolver ; private final MBeanInfo info ; private final ThisDynaClass dynaClass ; public SimpleMBeanNode ( ObjectName objectName , MBeanServerConnection mBeanServer , ClassResolver classResolver ) throws IntrospectionException , InstanceNotFoundException , ReflectionException , IOException { this . objectName = objectName ; this . mBeanServer = mBeanServer ; this . classResolver = classResolver ; this . info = mBeanServer . getMBeanInfo ( objectName ) ; dynaClass = new ThisDynaClass ( info . getAttributes ( ) ) ; } @ Override public void initialise ( ) { logger . info ( ""<STR_LIT>"" + objectName ) ; logger . info ( ""<STR_LIT>"" ) ; MBeanAttributeInfo [ ] attributeInfo = info . getAttributes ( ) ; for ( MBeanAttributeInfo attr : attributeInfo ) { logger . info ( ""<STR_LIT:U+0020U+0020>"" + attr . getName ( ) + ""<STR_LIT::U+0020>"" + attr . getType ( ) ) ; } logger . info ( ""<STR_LIT>"" ) ; MBeanOperationInfo [ ] operationInfo = info . getOperations ( ) ; for ( MBeanOperationInfo op : operationInfo ) { StringBuilder params = new StringBuilder ( ) ; for ( MBeanParameterInfo param : op . getSignature ( ) ) { if ( params . length ( ) > <NUM_LIT:0> ) { params . append ( ""<STR_LIT:U+002CU+0020>"" ) ; }'}]","params. append ( param. getName ( ) ) ; } logger. info ( ""<STR_LIT:U+0020>"" + op. getName ( ) + ""<STR_LIT::U+0020>"" + params ) ; } logger. info ( ""<STR_LIT>"" ) ; }",0.00010767713476581098
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . launching ; import java . io . File ; import java . text . MessageFormat ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . osgi . service . environment . Constants ; import org . rubypeople . rdt . core . util . Util ; import org . rubypeople . rdt . launching . AbstractVMInstallType ; import org . rubypeople . rdt . launching . IVMInstall ; public class StandardVMType extends AbstractVMInstallType { private static final String DEFAULT_MAJOR_MINOR_VERSION = ""<STR_LIT>"" ; private static final String DEFAULT_VERSION = ""<STR_LIT>"" ; private static final String USR = ""<STR_LIT>"" ; private static final String USR_BIN_RUBY = USR + ""<STR_LIT>"" ; private static final String USR_LOCAL_BIN_RUBY = ""<STR_LIT>"" ; private static final String OPT_LOCAL_BIN_RUBY = ""<STR_LIT>"" ; private static final String MAC_OSX_LEOPARD_RUBY_PATH = ""<STR_LIT>"" ; private static Map < String , LibraryInfo > fgFailedInstallPath = new HashMap < String , LibraryInfo > ( ) ; private static final char fgSeparator = File . separatorChar ; private static final String [ ] fgCandidateRubyFiles = { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ; private static final String [ ] fgCandidateRubyLocations = { ""<STR_LIT>"" , ""<STR_LIT>"" + fgSeparator } ; @ Override protected IVMInstall doCreateVMInstall ( String id ) { return new StandardVM ( this , id ) ; } public IPath [ ] getDefaultLibraryLocations ( File installLocation ) { File rubyExecutable = findRubyExecutable ( installLocation ) ; LibraryInfo info ; if ( rubyExecutable == null ) { LaunchingPlugin . logInfo ( ""<STR_LIT>"" + installLocation ) ; info = getDefaultLibraryInfo ( installLocation ) ; } else { info = getLibraryInfo ( installLocation , rubyExecutable ) ; } String [ ] loadpath = info . getBootpath ( ) ; IPath [ ] paths = new IPath [ loadpath . length ] ; for ( int i = <NUM_LIT:0> ; i < loadpath . length ; i ++ ) { paths [ i ] = new Path ( loadpath [ i ] ) ; } return paths ; } public String getName ( ) { return LaunchingMessages . StandardVMType_Standard_VM_3 ; } public IStatus validateInstallLocation ( File rubyHome ) { IStatus status = null ; File rubyExecutable = findRubyExecutable ( rubyHome ) ; if ( rubyExecutable == null ) { status = new Status ( IStatus . ERROR , LaunchingPlugin . getUniqueIdentifier ( ) , <NUM_LIT:0> , LaunchingMessages . StandardVMType_Not_a_JDK_Root__Java_executable_was_not_found_1 , null ) ; } else { if ( canDetectDefaultSystemLibraries ( rubyHome , rubyExecutable ) ) { status = new Status ( IStatus . OK , LaunchingPlugin . getUniqueIdentifier ( ) , <NUM_LIT:0> , LaunchingMessages . StandardVMType_ok_2 , null ) ; } else { status = new Status ( IStatus . ERROR , LaunchingPlugin . getUniqueIdentifier ( ) , <NUM_LIT:0> , LaunchingMessages . StandardVMType_Not_a_JDK_root__System_library_was_not_found__1 , null ) ; } } return status ; } public static File findRubyExecutable ( File vmInstallLocation ) { for ( int i = <NUM_LIT:0> ; i < fgCandidateRubyFiles . length ; i ++ ) { for ( int j = <NUM_LIT:0> ; j < fgCandidateRubyLocations . length ; j ++ ) { File rubyFile = new File ( vmInstallLocation , fgCandidateRubyLocations [ j ] + fgCandidateRubyFiles [ i ] ) ; rubyFile = Util . findFileWithOptionalSuffix ( rubyFile . getAbsolutePath ( ) ) ; if ( rubyFile != null && rubyFile . isFile ( ) ) { return rubyFile ; } } } return null ; } protected boolean canDetectDefaultSystemLibraries ( File rubyHome , File rubyExecutable ) { File foundExecutable = findRubyExecutable ( rubyHome ) ; if ( foundExecutable == null || ! foundExecutable . exists ( ) ) return false ; IPath [ ] locations = getDefaultLibraryLocations ( rubyHome ) ; return locations != null && locations . length > <NUM_LIT:0> ; } protected synchronized LibraryInfo getLibraryInfo ( File rubyHome , File rubyExecutable ) { String installPath = rubyHome . getAbsolutePath ( ) ; LibraryInfo info = LaunchingPlugin . getLibraryInfo ( this , installPath ) ; if ( info == null ) { info = fgFailedInstallPath . get ( installPath ) ; if ( info == null ) { info = generateLibraryInfo ( rubyHome , rubyExecutable ) ; if ( info == null ) { info = getDefaultLibraryInfo ( rubyHome ) ; fgFailedInstallPath . put ( installPath , info ) ; } else { LaunchingPlugin . setLibraryInfo ( this , installPath , info ) ; } } } return info ; } protected LibraryInfo getDefaultLibraryInfo ( File installLocation ) { IPath [ ] dflts = getDefaultSystemLibrary ( installLocation ) ; String [ ] strings = new String [ dflts . length ] ; for ( int i = <NUM_LIT:0> ; i < dflts . length ; i ++ ) { strings [ i ] = dflts [ i ] .'}]",".toOSString(); } Map<String, IPath> map = new HashMap<>(); for (int i = <NUM_LIT:0>; i < strings.length; i++) { map.put(strings[i], dflts[i]); } return new LibraryInfo(map); } private static IPath[] getDefaultSystemLibrary(File installLocation) { String javaHome = installLocation.getAbsolutePath(); String javaExecutable = javaHome + File.separator + ""bin"" + File.separator + ""java""; File javaFile = new File(javaExecutable); if (javaFile.exists()) { String os = Platform.getOS(); String version = Platform.getOSVersion(); String architecture = Platform.getOSArchitecture(); String javaHomePath = System.getProperty(""java.home""); String javaHomePath2 = System.getProperty(""java.home""); String javaHomePath3 = System.getProperty(""java.home""); String javaHomePath4 = System.getProperty(""java.home""); String javaHomePath5 = System.getProperty(""java.home""); String javaHomePath6 = System.getProperty(""java.home""); String javaHomePath7 = System.getProperty(""java.home""); String javaHomePath8 = System.getProperty(""java.home""); String javaHomePath9 = System.getProperty(""java.home""); String javaHomePath10 = System.getProperty(""java.home""); String java",0.00040779652694115064
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IResourceChangeEvent ; import org . eclipse . core . resources . IResourceChangeListener ; import org . eclipse . core . resources . IResourceDelta ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . IMenuCreator ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . internal . ui . RubyExplorerTracker . IRubyProjectListener ; import org . rubypeople . rdt . internal . ui . wizards . OpenNewRubyProjectWizardAction ; public class RubyProjectSelectionAction extends Action implements IMenuCreator { private Menu fMenu ; private IRubyProjectListener listener ; public RubyProjectSelectionAction ( ) { this ( ""<STR_LIT>"" ) ; } public RubyProjectSelectionAction ( String tooltip ) { setEnabled ( RubyCore . getRubyProjects ( ) . length > <NUM_LIT:0> ) ; setToolTipText ( tooltip ) ; setImageDescriptor ( RubyPlugin . getImageDescriptor ( ""<STR_LIT>"" ) ) ; setMenuCreator ('}]","this ); } @Override public void run ( ) { Display.getDefault().asyncExec(new Runnable() { @Override public void run ( ) { if (!RubyCore.getRubyProjects().length > 0) { OpenNewRubyProjectWizardAction.openWizard(); } else { if (listener!= null) { listener.rubyProjectSelected(RubyCore.getRubyProjects()[0]); } } } }); } @Override public Menu createControl ( Composite parent ) { if (fMenu == null) { fMenu = new Menu ( parent, SWT. POP_UP ) ; setMenu ( fMenu ) ; } return fMenu ; } @Override public void setListener ( IRubyProjectListener listener ) { this. listener = listener ; } }",0.00021373375530433237
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . astviewer . views ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui'}]",".views.TreeViewer;import org.eclipse.ui.plugin.IPluginWithView;public class ASTViewerLabelProvider implements LabelProvider { @Override public String getText ( Object element ) { // implementation } @Override public Image getImage ( Object element ) { // implementation } @Override public void update ( Object element, String detail ) { // implementation } }",9.655889406033902e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . search ; import org . eclipse . core . runtime . CoreException ; import'}]",org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPage; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.PartInitException; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.actions.OpenWithMenu; import org.eclipse.ui.actions.OpenWithWizardAction; import org.eclipse.ui.dialogs.ElementTreeSelectionDialog; import org.eclipse.ui.part.ViewPart; import org.eclipse.ui.views.contentoutline.IContentOutlinePage; import org.eclipse.ui.views.contentoutline.ContentOutlinePage; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayoutFactory; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayoutFactory; import org.eclipse.ui.views.contentoutline.IContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.IContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayoutFactory; import org.eclipse.ui.views.contentoutline.IContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.IContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.ContentOutlinePageLayout; import org.eclipse.ui.views.contentoutline.IContentOutlinePageLayout; import org.eclipse,0.00033773614328707003
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules ; import java . util . Date ; public class ScheduleRoller { private final Schedule schedule ; private final int howMany ; public ScheduleRoller ( Schedule schedule ) { this ( schedule , <NUM_LIT:10> ) ; } public ScheduleRoller ( Schedule schedule , int howMany ) { this . schedule = schedule ; this . howMany = howMany ; } public ScheduleResult [ ] resultsFrom ( Date date ) { ScheduleResult [ ] results = new ScheduleResult [ howMany ] ; ScheduleContext context = new ScheduleContext ( date ) ; for ( int i = <NUM_LIT:0> ; i < howMany ; ++ i ) { ScheduleResult result = schedule . nextDue ( context ) ; if ( result == null ) { break ; } results [ i ]'}]",= result;context.setDate(context.getDate().getTime() + result.getPeriod().getTime());}return results;} },4.722343487183049e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . io ; import java . io . IOException ; import com . asakusafw . compiler . fileio . model . Ex1 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class Ex1Output implements ModelOutput < Ex1 > { private final RecordEmitter emitter ; public Ex1Output ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( Ex1 model ) throws IOException { emitter . emit ('}]","model. getA ( ), model. getB ( ) ) ; } @ Override public Class <?> getModelClass ( ) { return Ex1. class ; } }",6.434915624527493e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . TimeZone ; public class DateUtils { private DateUtils ( ) { } public static Date startOfDay ( Date inDate , TimeZone timeZone ) { GregorianCalendar c1 = new GregorianCalendar ( ) ; c1 . setTimeZone ( timeZone ) ; c1 . setTime ( inDate ) ; GregorianCalendar c2 = new GregorianCalendar ( c1 . get ( Calendar . YEAR ) , c1 . get ( Calendar . MONTH ) , c1 . get ( Calendar . DATE ) ) ; c2 . setTimeZone ( timeZone ) ; return c2 . getTime ( ) ; } public static Date endOfDay ( Date inDate , TimeZone timeZone ) { Calendar inCalendar = new GregorianCalendar ( ) ; inCalendar . setTimeZone ( timeZone ) ; inCalendar . setTime ( inDate ) ; Calendar nextDay = new GregorianCalendar ( inCalendar . get ( Calendar . YEAR ) , inCalendar . get ( Calendar . MONTH ) , inCalendar . get ( Calendar . DAY_OF_MONTH ) + <NUM_LIT:1> ) ; nextDay . setTimeZone ( timeZone ) ; return new Date ( nextDay . getTime ( ) . getTime ( ) ) ; } public static int dayOfWeek ( Date inDate , TimeZone timeZone ) { Calendar calendar = Calendar . getInstance ( timeZone ) ; calendar . setTime ( inDate ) ; return calendar . get ( Calendar . DAY_OF_WEEK ) ; } public static int month ( Date inDate , TimeZone timeZone ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTimeZone ( timeZone ) ; calendar . setTime ( inDate ) ; return calendar . get ( Calendar . MONTH ) ; } public static int dayOfMonth ( Date inDate , TimeZone timeZone ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTimeZone ( timeZone ) ; calendar . setTime ( inDate ) ; return calendar . get ( Calendar . DAY_OF_MONTH ) ; } public static int dayOfYear ( Date forDate , TimeZone timeZone ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTimeZone ( timeZone ) ; calendar . setTime ( forDate ) ; return calendar . get ( Calendar . DAY_OF_YEAR ) ; } public static Date oneMillisAfter'}]","Date forDate, TimeZone timeZone) { Calendar calendar = Calendar.getInstance(); calendar.setTimeZone(timeZone); calendar.setTime(forDate); calendar.add(Calendar.MILLISECOND, 1); return calendar.getTime(); }",7.293511777137111e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . indexing ; import org . rubypeople . rdt . internal . core . SourceElementParser ; import org . rubypeople . rdt . internal . core . index . Index ; public class InternalSearchDocument { protected Index index ; private String containerRelativePath ; public SourceElementParser parser ; public void addIndexEntry ( char [ ] category , char [ ] key ) { if ( this . index != null ) {'}]","this.index.addEntry(category, key); } }",2.8434244309437416e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . external ; import com . asakusafw . compiler . flow . testing . model . KeyConflict ; import com . asakusafw . compiler . testing . TemporaryOutputDescription ; public class KeyConflictMockExporterDescription extends TemporaryOutputDescription { @ Override public Class < ? > getModelType ( ) { return KeyConflict . class ; } @ Override public String'}]","getName ( ) { return ""KeyConflictMockExporter""; } @Override public Class<? extends KeyConflict> getModelClass() { return KeyConflictMockExporter.class; }",5.69167420672315e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . external ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . Set ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . ExternalIoDescriptionProcessor ; import com . asakusafw . compiler . flow . ExternalIoDescriptionProcessor . Repository ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Maps ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . utils . collections . Tuple2 ; import com . asakusafw . utils . collections . Tuples ; import com . asakusafw . vocabulary . flow . graph . FlowGraph ; import com . asakusafw . vocabulary . flow . graph . FlowIn ; import com . asakusafw . vocabulary . flow . graph . FlowOut ; import com . asakusafw . vocabulary . flow . graph . InputDescription ; import com . asakusafw . vocabulary . flow . graph . OutputDescription ; public class ExternalIoAnalyzer { static final Logger LOG = LoggerFactory . getLogger ( ExternalIoAnalyzer . class ) ; private final FlowCompilingEnvironment environment ; public ExternalIoAnalyzer ( FlowCompilingEnvironment environment ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; this . environment = environment ; } public boolean validate ( FlowGraph graph ) { Precondition . checkMustNotBeNull ( graph , ""<STR_LIT>"" ) ; LOG . info ( ""<STR_LIT>"" , graph . getDescription ( ) . getName ( ) ) ; List < Tuple2 < InputDescription , ExternalIoDescriptionProcessor > > inputs = Lists . create ( ) ; List < Tuple2 < OutputDescription , ExternalIoDescriptionProcessor > > outputs = Lists . create ( ) ; if ( collect ( graph , inputs , outputs ) == false ) { return false ; } boolean valid = true ; Set < ExternalIoDescriptionProcessor > processors = getActiveProcessors ( inputs , outputs ) ; for ( ExternalIoDescriptionProcessor proc : processors ) { List < InputDescription > in = getOnly ( inputs , proc ) ; List < OutputDescription > out = getOnly ( outputs , proc ) ; valid &= proc . validate ( in , out ) ; } return valid ; } private < T > List < T > getOnly ( List < Tuple2 < T , ExternalIoDescriptionProcessor > > inputs , ExternalIoDescriptionProcessor proc ) { assert inputs != null ; assert proc != null ; List < T > results = Lists . create ( ) ; for ( Tuple2 < T , ExternalIoDescriptionProcessor > tuple : inputs ) { if ( tuple . second . equals ( proc ) ) { results . add ( tuple . first ) ; } } return results ; } private Set < ExternalIoDescriptionProcessor > getActiveProcessors ( List < Tuple2 < InputDescription , ExternalIoDescriptionProcessor > > inputs , List < Tuple2 < OutputDescription , ExternalIoDescriptionProcessor > > outputs ) { assert inputs != null ; assert outputs != null ; Map < Class < ? > ,'}]","Set<ExternalIoDescriptionProcessor>> processors = Maps.create();for (Tuple2<InputDescription, ExternalIoDescriptionProcessor> input : inputs) {processors.computeIfAbsent(input.second.getClass(), k -> Sets.create()).add(input.second);}for (Tuple2<OutputDescription, ExternalIoDescriptionProcessor> output : outputs) {processors.computeIfAbsent(output.second.getClass(), k -> Sets.create()).add(output.second);}return processors.values().stream().flatMap(Set::stream).collect(Collectors.toSet());}private boolean collect(FlowGraph graph, List<Tuple2<InputDescription, ExternalIoDescriptionProcessor>> inputs, List<Tuple2<OutputDescription, ExternalIoDescriptionProcessor>> outputs) {assert graph!= null;assert inputs!= null;assert outputs!= null;inputs.clear();outputs.clear();Repository repository = graph.getRepository();Repository.Iterator iterator = repository.iterator();while (iterator.hasNext()) {FlowIn flowIn = iterator.next();FlowOut flowOut = flowIn.getFlowOut();InputDescription inputDescription = flowIn.getInputDescription();ExternalIoDescriptionProcessor processor = flowOut.getExternalIoDescriptionProcessor();inputs.add(Tuples.of(inputDescription, processor));}iterator = repository.iterator();while (iterator.hasNext()) {FlowIn flowIn = iterator.next();FlowOut flowOut = flowIn.getFlow",0.00037446220341310114
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . correction ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . ITextSelection ; import org . eclipse . jface . text . ITextViewer ; import org . eclipse . jface . text . contentassist . ICompletionProposal ; import org . eclipse . jface . text . contentassist . ICompletionProposalExtension ; import org . eclipse . jface . text . contentassist . ICompletionProposalExtension2 ; import org . eclipse . jface . text . source . Annotation ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . keys . IBindingService ; import org . eclipse . ui . texteditor . ITextEditor ; import org . jruby . ast . Node ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . ui . RubyUI ; import org . rubypeople . rdt . ui . text . correction . ICommandAccess ; import org . rubypeople . rdt . ui . text . ruby . IInvocationContext ; public class CorrectionCommandHandler extends AbstractHandler { private final'}]",ICommandAccess commandAccess; public CorrectionCommandHandler(ICommandAccess commandAccess) { this.commandAccess = commandAccess; } @Override public Object execute(ExecutionEvent event) throws ExecutionException { ICommand command = commandAccess.getCommand(event); if (command!= null) { command.execute(event); } return null; } },0.00010754205056697442
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package $ { package } . operator ; import java . util . List ; import $ { package } . modelgen . dmdl . model . CategorySummary ; import $ { package } . modelgen . dmdl . model . ErrorRecord ; import $ { package } . modelgen . dmdl . model . ItemInfo ; import $ { package } . modelgen . dmdl . model . JoinedSalesInfo ; import $ { package } . modelgen . dmdl . model . SalesDetail ; import $ { package } . modelgen . dmdl'}]",".model; public class Operator { public static List<JoinedSalesInfo> joinedSalesInfo(List<ErrorRecord> errorRecords, List<ItemInfo> itemInfos, List<SalesDetail> salesDetails) { // implementation } }",7.314944999948078e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . temporary ; import java . lang . annotation . Annotation ; import java . util . Collection ; import java . util . Collections ; import org . apache . hadoop . io . Text ; import com . asakusafw . testdriver . core . DataModelDefinition ; import com . asakusafw . testdriver . core . DataModelReflection ; import com . asakusafw . testdriver . core . PropertyName ; import com . asakusafw . testdriver . core . PropertyType ; public class MockTextDefinition implements DataModelDefinition < Text > { static final PropertyName VALUE = PropertyName . newInstance ( ""<STR_LIT:value>"" ) ; @ Override public Class < Text > getModelClass ( ) { return Text . class ; } @ Override public < A extends Annotation > A getAnnotation ( Class < A > annotationType ) { return null ; } @ Override public Collection < PropertyName > getProperties ( ) { return Collections . singleton ( VALUE ) ; } @ Override public PropertyType getType ( PropertyName name ) { if ( VALUE . equals ( name ) ) { return PropertyType . STRING ; } return null ; } @ Override public < A extends Annotation > A getAnnotation ('}]","Class < A > annotationType, String annotationKey ) { return null ; } @ Override public PropertyName getProperty ( String name ) { if ( VALUE. getName ( ). equals ( name ) ) { return VALUE ; } return null ; } @ Override public boolean isNullable ( PropertyName name ) { return false ; } @ Override public DataModelReflection getReflection ( ) { return new DataModelReflection ( this ) { @ Override public < T > T getPropertyValue ( Text instance, PropertyName name, Class < T > type ) { if ( VALUE. equals ( name ) ) { return instance. toString ( ) ; } return null ; } @ Override public < T > void setPropertyValue ( Text instance, PropertyName name, T value ) { if ( VALUE. equals ( name ) ) { instance. set ( value. toString ( ) ) ; } } } ; } }",0.0002514109276324597
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core ; public class ProcessScript < T > { public static final String KEY_DATA_CLASS = ""<STR_LIT:class>"" ; public static final String KEY_PROCESS_TYPE = ""<STR_LIT>"" ; private final String name ; private final String processType ; private final Class < T > dataClass ; private final DriverScript sourceScript ; private final DriverScript drainScript ; public ProcessScript ( String name , String processType , Class < T > dataClass , DriverScript sourceScript , DriverScript drainScript ) { if ( name == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( processType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( dataClass == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( sourceScript == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( drainScript == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . name = name ; this . processType = processType ; this . dataClass = dataClass ; this . sourceScript = sourceScript ; this . drainScript = drainScript ; } public String getName ( ) { return name ; } public String getProcessType ( ) { return processType ; } public Class < T > getDataClass ( ) { return dataClass ; } public DriverScript getSourceScript'}]",( ) { return sourceScript ; } public DriverScript getDrainScript ( ) { return drainScript ; } },5.013884713396661e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . editor . actions ; import java . util . HashMap ; import java . util . Map ; import java . util . ResourceBundle ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITextOperationTarget ; import org . eclipse . jface . text . ITextSelection ; import org . eclipse . jface . text . ITypedRegion ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . TextUtilities ; import org . eclipse . jface . text . source . ISourceViewer ; import org . eclipse . jface . text . source . SourceViewerConfiguration ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . texteditor . ITextEditor ; import org . eclipse . ui . texteditor . ResourceAction ; import org . eclipse . ui . texteditor . TextEditorAction ; public class ToggleCommentAction extends TextEditorAction { private ITextOperationTarget fOperationTarget ; private String fDocumentPartitioning ; private Map < String , String [ ] > fPrefixesMap ; public ToggleCommentAction ( ResourceBundle bundle , String prefix , ITextEditor editor ) { super ( bundle , prefix , editor ) ; } public void run ( ) { if ( fOperationTarget == null || fDocumentPartitioning == null || fPrefixesMap == null ) return ; ITextEditor editor = getTextEditor ( ) ; if ( editor == null ) return ; if ( ! validateEditorInputState ( ) ) return ; final int operationCode ; if ( isSelectionCommented ( editor . getSelectionProvider ( ) . getSelection ( ) ) ) operationCode = ITextOperationTarget . STRIP_PREFIX ; else operationCode = ITextOperationTarget . PREFIX ; Shell shell = editor .'}]","getSite().getShell(); BusyIndicator.showWhile(shell.getDisplay(), new Runnable() { public void run() { fOperationTarget.operation(fDocumentPartitioning, operationCode, fPrefixesMap); } }); } private boolean isSelectionCommented(ITextSelection selection) { IRegion region = selection.getRegion(); if (region == null) return false; try { return TextUtilities.isCommented(region.getOffset(), region.getLength(), fOperationTarget.getDocument()); } catch (BadLocationException e) { // Should not happen } return false; } }",0.00016475365344423065
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; @ JobFlow ( name = ""<STR_LIT>"" ) public class NoImportInput extends FlowDescription { private In < MockHoge > in ; private Out'}]","<Export<MockHoge>> out;public NoImportInput() { in = new In<MockHoge>(""in""); out = new Out<Export<MockHoge>>(""out"");}public static void main(String[] args) { NoImportInput flow = new NoImportInput(); //... }}",9.895068493535266e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . parser . warnings ; import java . util . List ; import org . jruby . ast . DefnNode ; import org . jruby . ast . IfNode ; import org . jruby . ast . LocalVarNode ; import org . jruby . ast . NilImplicitNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import org . rubypeople .'}]",.rdt.core.parser.warnings.RubyWarning;public class RubyLintVisitorImpl implements RubyLintVisitor { @Override public void visit ( Node node ) { // existing code } @Override public void visit ( DefnNode defn ) { visit ( node ) ; // existing code } @Override public void visit ( IfNode ifNode ) { visit ( node ) ; // existing code } @Override public void visit ( LocalVarNode localVar ) { visit ( node ) ; // existing code } @Override public void visit ( NilImplicitNode nilImplicit ) { visit ( node ) ; // existing code } @Override public void visit ( RubyWarning warning ) { // existing code } },6.917269434929847e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search ; import org . rubypeople . rdt . internal . core . util . CharOperation ; import junit . framework . TestCase ; public class MethodPatternParserTest extends TestCase { public void testSelectorOnly ( ) { MethodPatternParser parser = new MethodPatternParser ( ) ; parser . parse ( ""<STR_LIT>"" ) ; assertStringEqualsCharArray ( ""<STR_LIT>"" , parser . getSelector ('}]",") ; } public void testSelectorAndParameters ( ) { MethodPatternParser parser = new MethodPatternParser ( ) ; parser. parse ( ""<STR_LIT>"" ) ; assertStringEqualsCharArray ( ""<STR_LIT>"", parser. getSelector ( ) ) ; assertArrayEquals ( new String [ ] { ""<STR_LIT>"", ""<STR_LIT>"" }, parser. getParameters ( ), CharOperation. STRING_ARRAY_EQUALITY_IGNORE_CASE ) ; } }",0.0001349871172133354
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . windgate ; import java . io . IOException ; import java . net . URI ; import java . text . MessageFormat ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . testdriver . core . DataModelDefinition ; import com . asakusafw . testdriver . core . DataModelSource ; import com . asakusafw . testdriver . core . DataModelSourceProvider ; import com . asakusafw . testdriver . core . TestContext ; import com . asakusafw . vocabulary . windgate . WindGateExporterDescription ; import com . asakusafw . vocabulary . windgate . WindGateImporterDescription ; import com . asakusafw . windgate . core . ParameterList ; import com . asakusafw . windgate . core . ProcessScript ; import com . asakusafw . windgate . core . resource . ResourceManipulator ; import com . asakusafw . windgate . core . resource . SourceDriver ; public class WindGateSourceProvider implements DataModelSourceProvider { private static final String SCHEME = ""<STR_LIT>"" ; static final Logger LOG = LoggerFactory . getLogger ( WindGateSourceProvider . class ) ; @ Override public < T > DataModelSource open ( DataModelDefinition < T > definition , URI source , TestContext context ) throws IOException { String scheme = source . getScheme ( ) ; if ( scheme == null || scheme . equals ( SCHEME ) == false ) { LOG . debug ( ""<STR_LIT>"" , source ) ; return null ; }'}]","// Check if the source is a WindGate data source String windgateScheme = WindGateImporterDescription.Scheme.URI_SCHEME; if (!scheme.equals(windgateScheme)) { LOG.debug(MessageFormat.format(""<STR_LIT>{0}</STR_LIT>"", scheme), source); return null; } //... rest of the code",0.00010583092528500898
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . MalformedURLException ; import java . util . Map ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . ObjectName ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . log4j . Logger ; abstract public class ServerStrategy { public static ServerStrategy stratagyFor ( String url ) throws MalformedURLException { if ( url == null ) { return new PlatformMBeanServerStrategy ( ) ; } else { return new ConnectorServerStrategy ( url ) ; } } public abstract MBeanServer findServer ( ) ; public abstract String serverIdText ( ) throws JMException ; public abstract JMXConnectorServer startConnector ( Map < String , ? > environment ) throws IOException ; public abstract String getAddress ( ) ; } class ConnectorServerStrategy extends ServerStrategy { private static final Logger logger = Logger . getLogger ( ConnectorServerStrategy . class ) ; private final JMXServiceURL serviceURL ; private MBeanServer server ; private String address ; public ConnectorServerStrategy ( String url ) throws MalformedURLException { serviceURL = new JMXServiceURL ( url ) ; } @ Override public MBeanServer findServer ( ) { server = MBeanServerFactory . createMBeanServer ( ) ; return server ; } @ Override public String serverIdText ( ) { return serviceURL . getURLPath ( ) ; } @ Override public JMXConnectorServer startConnector ( Map < String ,'}]","? > environment ) throws IOException { JMXConnectorServer connector = JMXConnectorServerFactory. newJMXConnectorServer ( serviceURL, environment ) ; return connector ; } @ Override public String getAddress ( ) { return serviceURL. getURL ( ) ; } }",8.906148613494834e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . actions ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; import org . rubypeople . rdt . internal . ui . search . RubySearchScopeFactory ; import org . rubypeople . rdt . internal . ui . search . SearchMessages ; import org . rubypeople . rdt . ui . search . ElementQuerySpecification ; import org . rubypeople . rdt . ui . search . QuerySpecification ; public class FindReadReferencesInProjectAction extends FindReadReferencesAction { public FindReadReferencesInProjectAction ( IWorkbenchSite site ) { super ( site ) ; } public FindReadReferencesInProjectAction ( RubyEditor editor ) { super ( editor ) ; } void init ( ) { setText ( SearchMessages . Search_FindReadReferencesInProjectAction_label ) ;'}]",setImageDescriptor(RubyPluginImages.DESC_FIND_READ_REFERENCES_IN_PROJECT); setQuerySpecification(new ElementQuerySpecification(new QuerySpecification(IRubySearchScope.PROJECT))); } },6.207555089843109e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . pushdown ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . BlockNode ; import org . jruby . ast . Node ; import org . jruby . lexer . yacc . IDESourcePosition ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . editprovider . InsertEditProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; import org . rubypeople . rdt . refactoring . offsetprovider . IOffsetProvider ; public class DownPushedMethodsClass extends InsertEditProvider { private Collection < MethodNodeWrapper > methodNodes ; private Collection < MethodNodeWrapper > constructorNodes ; private String className ; public DownPushedMethodsClass ( String className , Collection < MethodNodeWrapper > allMethodNodes ) { super ( true ) ; this . className = className ; initConstrucorAndMethodNodes ( allMethodNodes ) ; } private void initConstrucorAndMethodNodes ( Collection < MethodNodeWrapper > allMethodNodes ) { methodNodes = new ArrayList < MethodNodeWrapper > ( ) ; constructorNodes = new ArrayList < MethodNodeWrapper > ( ) ; for ( MethodNodeWrapper node : allMethodNodes ) { if ( node . getSignature ( ) . isConstructor ( ) ) constructorNodes . add ( node ) ; else methodNodes . add ( node ) ; } } @ Override protected BlockNode getInsertNode ( int offset , String document ) { if ( firstEditInGroup ) { setInsertType ( INSERT_AT_BEGIN_OF_LINE ) ; } boolean needsNewLineAtEndOfBlock = lastEditInGroup && ! isNextLineEmpty ( offset , document ) ; Node classNode = getClassNode ( ) ; BlockNode blockNode = NodeFactory . createBlockNode ( ) ; blockNode . add ( classNode ) ; if ( ! firstEditInGroup )'}]",{ blockNode.add(NodeFactory.createLineBreakNode()); } if (needsNewLineAtEndOfBlock) { blockNode.add(NodeFactory.createLineBreakNode()); } return blockNode; },7.251336400450034e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renameclass ; import java . io . FileNotFoundException ; import java . io . IOException ; import junit . framework . TestCase ; import org . rubypeople . rdt . refactoring . core . renameclass . ClassInstanciationFinder ; import org . rubypeople . rdt . refactoring . core . renameclass . ConstructorCall ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentWithIncluding ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . tests . MultiFileTestData ; public class TC_ClassInstanciationFinder extends TestCase { public void testFind1 ( ) throws FileNotFoundException , IOException { ConstructorCall [ ] calls = getConstructorCalls ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:3> , calls . length ) ; for ( ConstructorCall call : calls ) { assertEquals ( ""<STR_LIT>"" , call . getClassName ( ) ) ; assertNull ( call . getArgs ( ) ) ; assertNotNull ( call . getNode ( ) ) ; } } public void testFind2 ( ) throws FileNotFoundException , IOException { ConstructorCall [ ] calls = getConstructorCalls ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:0> , calls . length ) ; } public void testFind3 ( ) throws FileNotFoundException , IOException { ConstructorCall [ ] calls = getConstructorCalls ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:2> , calls . length ) ; for ( ConstructorCall call'}]",": calls ) { assertEquals ( ""<STR_LIT>"", call. getClassName ( ) ) ; assertNotNull ( call. getArgs ( ) ) ; assertNotNull ( call. getNode ( ) ) ; } } private ConstructorCall [ ] getConstructorCalls ( String project, String path ) throws FileNotFoundException, IOException { ClassInstanciationFinder finder = new ClassInstanciationFinder ( project, path ) ; return finder. findConstructorCalls ( ""<STR_LIT>"" ) ; } }",0.00014492477137615772
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package bonsai . app ; import java . util . Date ; import android . app . Activity ; import android . content . Intent ; import android . database . Cursor ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . widget . ImageView ; import android . widget . ImageView . ScaleType ; import android . widget . LinearLayout ; import android . widget . TextView ; import android . widget . Toast ; import java . util . List ; import bonsai . app . weather . Weather ; import bonsai . app . weather . XmlParserSax ; public class BonsaiActivity extends Activity { private BonsaiDbUtil bonsaidb ; private FamilyDbUtil familydb ; private TextView name ; private TextView family ; private ImageView photo ; private TextView age ; private TextView textWater ; private TextView textTransplant ; private TextView textPrune ; private TextView textTemperature ; private TextView textWeather ; private ImageView weatherIcon ; private Weather w ; private boolean weatherAvail ; private String location ; private double temperature ; private String imageWeather ; private final Handler handler = new Handler ( ) ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . bonsai ) ; name = ( TextView ) findViewById ( R . id . textName ) ; family = ( TextView ) findViewById ( R . id . textFamily ) ; photo = ( ImageView ) findViewById ( R . id . bonsaiImage ) ; age = ( TextView ) findViewById ( R . id . textYears ) ; textWater = ( TextView ) findViewById ( R . id . textWater ) ; textTransplant = ( TextView ) findViewById ( R . id . textTransplant ) ; textPrune = ( TextView ) findViewById ( R . id . textPrune ) ; textTemperature = ( TextView ) findViewById ( R . id . textTemperature ) ; textWeather = ( TextView ) findViewById ( R . id . textweather ) ; weatherIcon = ( ImageView ) findViewById ( R . id . imageWeather ) ; textWeather = ( TextView ) findViewById ( R . id . textweather ) ; weatherIcon = ( ImageView ) findViewById ( R . id . imageWeather ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; try { bonsaidb = new BonsaiDbUtil ( this ) ; bonsaidb . open ( ) ; familydb = new FamilyDbUtil ( this ) ; familydb . open ( ) ; Cursor bonsai = bonsaidb . fetchBonsai ( AndroidProjectActivity . bonsaiactual ) ; startManagingCursor ( bonsai ) ; name . setText ( bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_NAME ) ) ) ; family . setText ( bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_FAMILY ) ) ) ; String photouri = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_PHOTO ) ) ; if ( photouri . length ( ) > <NUM_LIT:1> ) { photo . setImageURI ( Uri . parse ( photouri ) ) ; photo . setScaleType ( ScaleType . FIT_CENTER ) ; } else photo . setImageResource ( R . drawable . ic_launcher ) ; long date = new Date ( ) . getTime ( ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; age . setText ( ""<STR_LIT>"" + ( ( date - bonsai . getLong ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_AGE ) ) ) / ( <NUM_LIT> * <NUM_LIT:24> ) ) ) ; checkWeather ( ) ; weatherAction ( ) ; checkWater ( ) ; checkTransplant ( ) ; checkPode ( ) ; } catch ( Exception e ) { Toast . makeText ( this , ""<STR_LIT>"" , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public void onPause ( ) { super . onPause ( ) ; bonsaidb . close ( ) ; familydb . close ( ) ; } private void weatherAction ( ) { handler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { if ( weatherAvail ) { setTempInfo ( ) ; setWeatherInfo ( ) ; setWeatherComment ( ) ; } else { weatherAction ( ) ; } } } , <NUM_LIT:1000> ) ; } public void goEdit ( View v ) { try { Cursor bonsai = bonsaidb . fetchBonsai ( AndroidProjectActivity . bonsaiactual ) ; startManagingCursor ( bonsai ) ; bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_NAME ) ) ; AndroidProjectActivity . iamediting = true ; Intent editAct = new Intent ( ) . setClass ( this , EditBonsaiActivity . class ) ; startActivity ( editAct ) ; } catch ( Exception e ) { Toast . makeText ( this , ""<STR_LIT>"" , Toast . LENGTH_SHORT ) . show ( ) ; } } public void toastImage ( View v ) { Toast ImageToast = new Toast ( getBaseContext ( ) ) ; LinearLayout toastLayout = new LinearLayout ( getBaseContext ( ) ) ; toastLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; ImageView image = new ImageView ( getBaseContext ( ) ) ; Cursor bonsai = bonsaidb . fetchBonsai ( AndroidProjectActivity . bonsaiactual ) ; startManagingCursor ( bonsai ) ; String photouri = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_PHOTO ) ) ; if ( photouri . length ( ) > <NUM_LIT:1> ) image . setImageURI ( Uri . parse ( photouri ) ) ; else image . setImageResource ( R . drawable . ic_launcher ) ; toastLayout . addView ( image ) ; ImageToast . setView ( toastLayout ) ; ImageToast . setDuration ( Toast . LENGTH_SHORT ) ; ImageToast . show ( ) ; } private void checkWater ( ) { String family ; long lastwatered ; long waterfrec ; int height = <NUM_LIT:30> ; long hoursTime = ( new Date ( ) . getTime ( ) ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; try { Cursor bonsai = bonsaidb . fetchBonsai ( AndroidProjectActivity . bonsaiactual ) ; startManagingCursor ( bonsai ) ; family = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_FAMILY ) ) ; lastwatered = bonsai . getInt ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_LAST_WATER ) ) ; height = bonsai . getInt ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_HEIGHT ) ) ; Cursor cfamily = familydb . fetchFamilybyName ( family ) ; startManagingCursor ( cfamily ) ; waterfrec = cfamily . getInt ( cfamily'}]",".getColumnIndexOrThrow(FamilyDbUtil.KEY_WATERFREQUENCY)); if (hoursTime - lastwatered > waterfrec) { textWater.setText(""<STR_LIT>""); } else { textWater.setText(""<STR_LIT>""); } } catch (Exception e) { Toast.makeText(this, ""<STR_LIT>"", Toast.LENGTH_SHORT).show(); } } private void checkTransplant ( ) { String family ; long lasttransplant ; long transplantfrec ; int height = <NUM_LIT:30> ; long hoursTime = ( new Date ( ). getTime ( ) ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; try { Cursor bonsai = bonsaidb. fetchBonsai ( AndroidProjectActivity. bonsaiactual ) ; startManagingCursor ( bonsai ) ; family = bonsai. getString ( bonsai. getColumnIndexOrThrow ( BonsaiDbUtil. KEY_FAMILY ) ) ; lasttransplant = bonsai. getInt ( bonsai. getColumnIndexOrThrow ( BonsaiDbUtil. KEY_LAST_TRANSPORT ) ) ; height = bonsai. getInt ( bonsai. getColumnIndexOrThrow ( BonsaiDbUtil. KEY_HEIGHT ) )",0.0004181517662770083
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . FailedToStopException ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . Resetable ; import org . oddjob . StateSteps ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . parsing . DragPoint ; import org . oddjob . arooa . parsing . DragTransaction ; import org . oddjob . arooa . registry . ChangeHow ; import org . oddjob . arooa . xml . XMLConfiguration ; public class StateBehaviourTest extends TestCase { private static final Logger logger = Logger . getLogger ( StateBehaviourTest . class ) ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; logger . info ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } public void testEmptyParentState ( ) throws ArooaParseException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . load ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Object sequential = lookup . lookup ( ""<STR_LIT>"" ) ; Object echo = lookup . lookup ( ""<STR_LIT>"" ) ; StateSteps checker = new StateSteps ( ( Stateful ) sequential ) ; checker . startCheck ( ParentState . READY ) ; DragPoint dp = oddjob . provideConfigurationSession ( ) . dragPointFor ( echo ) ; DragTransaction t = dp . beginChange ( ChangeHow . FRESH ) ; dp . cut ( ) ; t . commit ( ) ; checker . checkNow ( ) ; oddjob . destroy ( ) ; } public void testEmptySequential ( ) throws ArooaParseException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . run ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Object echo = lookup . lookup ( ""<STR_LIT>"" ) ; assertEquals ( JobState . COMPLETE , ( ( Stateful ) echo ) . lastStateEvent ( ) . getState ( ) ) ; oddjob . destroy ( ) ; } public void testExecutingSequential ( ) throws ArooaParseException , InterruptedException , FailedToStopException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . load ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Object sequential = lookup . lookup ( ""<STR_LIT>"" ) ; Object echo = lookup . lookup ( ""<STR_LIT>"" ) ; StateSteps checker = new StateSteps ( ( Stateful ) sequential ) ; checker . startCheck ( ParentState . READY , ParentState . EXECUTING ) ; new Thread ( ( Runnable ) sequential ) . start ( ) ; checker . checkWait ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; oddjob . run ( ) ; assertEquals ( ParentState . ACTIVE , oddjob . lastStateEvent ( ) . getState ( ) ) ; assertEquals ( JobState . READY , ( ( Stateful ) echo ) . lastStateEvent ( ) . getState ( ) ) ; ( ( Stoppable ) sequential ) . stop ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; oddjob . destroy ( ) ; } public static class OurService { public void start ( ) { } public void stop ( ) { } } public void testActiveSequential ( ) throws ArooaParseException , InterruptedException , FailedToStopException { Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; oddjob . load ( ) ; assertEquals ( ParentState . READY , oddjob . lastStateEvent ( ) . getState ( ) ) ; OddjobLookup lookup = new OddjobLookup ( oddjob ) ; Object sequential = lookup . lookup ( ""<STR_LIT>"" ) ; Object service = lookup . lookup ( ""<STR_LIT>"" ) ; Object echo = lookup . lookup ( ""<STR_LIT>"" ) ; StateSteps checker = new StateSteps ( ( Stateful ) sequential ) ; checker . startCheck ( ParentState . READY , ParentState . EXECUTING , ParentState . ACTIVE ) ; ( ( Runnable ) sequential ) . run ( ) ; checker .'}]","checkWait(); ((Stoppable) sequential).stop(); assertEquals(ParentState.READY, oddjob.lastStateEvent().getState()); oddjob.destroy(); } }",7.631476027960133e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import static com . asakusafw . windgate . core . vocabulary . FileProcess . * ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . TimeUnit ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . util . ReflectionUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . core . context . SimulationSupport ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . stage . temporary . TemporaryStorage ; import com . asakusafw . windgate . core . DriverScript ; import com . asakusafw . windgate . core . GateScript ; import com . asakusafw . windgate . core . ParameterList ; import com . asakusafw . windgate . core . ProcessScript ; import com . asakusafw . windgate . core . WindGateLogger ; import com . asakusafw . windgate . core . resource . DrainDriver ; import com . asakusafw . windgate . core . resource . ResourceMirror ; import com . asakusafw . windgate . core . resource . SourceDriver ; import com . asakusafw . windgate . core . vocabulary . FileProcess ; import com . asakusafw . windgate . hadoopfs . HadoopFsLogger ; import com . asakusafw . windgate . hadoopfs . ssh . FileList . Writer ; import com . asakusafw . windgate . hadoopfs . temporary . ModelInputProvider ; import com . asakusafw . windgate . hadoopfs . temporary . ModelInputSourceDriver ; import com . asakusafw . windgate . hadoopfs . temporary . ModelOutputDrainDriver ; public abstract class AbstractSshHadoopFsMirror extends ResourceMirror { static final WindGateLogger WGLOG = new HadoopFsLogger ( AbstractSshHadoopFsMirror . class ) ; static final Logger LOG = LoggerFactory . getLogger ( AbstractSshHadoopFsMirror . class ) ; private final Configuration configuration ; final SshProfile profile ; private final ParameterList arguments ; public AbstractSshHadoopFsMirror ( Configuration configuration , SshProfile profile , ParameterList arguments ) { if ( configuration == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( profile == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( arguments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . configuration = configuration ; this . profile = profile ; this . arguments = arguments ; } @ Override public String getName ( ) { return profile . getResourceName ( ) ; } @ Override public void prepare ( GateScript script ) throws IOException { if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , getName ( ) ) ; for ( ProcessScript < ? > process : script . getProcesses ( ) ) { if ( process . getSourceScript ( ) . getResourceName ( ) . equals ( getName ( ) ) ) { getPath ( process , DriverScript . Kind . SOURCE ) ; } if ( process . getDrainScript ( ) . getResourceName ( ) . equals ( getName ( ) ) ) { getPath ( process , DriverScript . Kind . DRAIN ) ; } } } @ Override public < T > SourceDriver < T > createSource ( final ProcessScript < T > script ) throws IOException { if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , getName ( ) , script . getName ( ) ) ; final List < String > path = getPath ( script , DriverScript . Kind . SOURCE ) ; T value = newDataModel ( script ) ; final SshConnection connection = openGet ( path ) ; boolean succeeded = false ; try { InputStream output = connection . openStandardOutput ( ) ; connection . connect ( ) ; FileList . Reader fileList = FileList . createReader ( output ) ; ModelInputProvider < T > provider = new FileListModelInputProvider < T > ( configuration , fileList , script . getDataClass ( ) ) ; ModelInputSourceDriver < T > result = new SshSourceDriver < T > ( provider , value , script , connection , path ) ; succeeded = true ; return result ; } finally { if ( succeeded == false ) { try { connection . close ( ) ; } catch ( IOException e ) { WGLOG . warn ( e , ""<STR_LIT>"" , profile . getResourceName ( ) , script . getName ( ) , path ) ; } } } } @ Override public < T > DrainDriver < T > createDrain ( final ProcessScript < T > script ) throws IOException { if ( script == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } LOG . debug ( ""<STR_LIT>"" , getName ( ) , script . getName ( ) ) ; final List < String > path = getPath ( script , DriverScript . Kind . DRAIN ) ; final SshConnection connection = openPut ( ) ; boolean succeeded = false ; try { OutputStream input = connection . openStandardInput ( ) ; connection . connect ( ) ; final FileList . Writer fileList = FileList . createWriter ( input ) ; ModelOutput < T > output = TemporaryStorage . openOutput ( configuration , script . getDataClass ( ) , fileList . openNext ( FileList . createFileStatus ( new Path ( path . get ( <NUM_LIT:0> ) ) ) ) , profile . getCompressionCodec ( ) ) ; ModelOutputDrainDriver < T > result = new SshDrainDriver < T > ( output , connection , path , fileList , script ) ; succeeded = true ; return result ; } finally { if ( succeeded == false ) { try { connection . close ( ) ; } catch ( IOException e ) { WGLOG . warn ( e , ""<STR_LIT>"" , profile . getResourceName ( ) , script . getName ( ) , path ) ; } } } } private SshConnection openGet ( List < String > paths ) throws IOException { assert paths != null ; List < String > tokens = new ArrayList < String > ( ) ; tokens . add ( profile . getGetCommand ( ) ) ; tokens . addAll ( paths ) ; SshConnection connection = openConnection ( profile , tokens ) ; boolean succeed = false ; try { connection . openStandardInput ( ) . close ( ) ; succeed = true ; return connection ; } finally { if ( succeed == false ) { connection . close ( ) ; } } } private SshConnection openPut ( ) throws IOException { SshConnection connection = openConnection ( profile , Collections . singletonList ( profile . getPutCommand ( ) ) ) ; boolean succeed = false ; try { connection . redirectStandardOutput ( System . out , true ) ; succeed = true ; return connection ; } finally { if ( succeed == false ) { connection . close ( ) ; } } } protected abstract SshConnection openConnection ( SshProfile sshProfile , List < String > command ) throws IOException ; private List < String > getPath ( ProcessScript < ? > proc , DriverScript . Kind kind ) throws IOException { assert proc != null ; assert kind != null ; DriverScript script = proc . getDriverScript ( kind ) ; String pathString = script . getConfiguration ( ) .'}]","getRemotePath(); 

List<String> tokens = new ArrayList<String>(); 
tokens.add(profile.getGetCommand()); 
tokens.add(pathString); 

SshConnection connection = openConnection(profile, tokens); 
boolean succeed = false; 
try { 
connection.openStandardInput().close(); 
succeed = true; 
return connection; 
} finally { 
if (succeed == false) { 
connection.close(); 
} 
}",0.00016952110703780205
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import java . util . concurrent . atomic . AtomicReference ; import org . oddjob . Stateful ; import org . oddjob . arooa . deploy . annotations . ArooaComponent ; import org . oddjob . framework . StructuralJob ; import org . oddjob . util . OddjobConfigException ; public class JoinJob extends StructuralJob < Runnable > { private static final'}]","long serialVersionUID = 1L; private final AtomicReference<Runnable> target = new AtomicReference<>(); public JoinJob() {} public JoinJob(Runnable target) { this.target.set(target); } @Override public void setTarget(Runnable target) { this.target.set(target); } @Override public Runnable getTarget() { return target.get(); } @Override public void configure(StructuralJob<Runnable> job, org.oddborg.xml.Xml xml) throws OddjobConfigException { super.configure(job, xml); } }",0.00015403146719956582
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . windgate ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . util . Collections ; import java . util . Properties ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . testdriver . core . DataModelDefinition ; import com . asakusafw . testdriver . core . TestContext ; import'}]","com.asakusafw.testdriver.core.TestDriverRule; public class TestDriverRuleTest extends TestCase { @Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; @Test public void test ( ) throws IOException { File output = folder. newFile ( ""output.txt"" ) ; //... } }",9.670560948473463e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . core ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; public class CommandScriptTest { @ Rule public final TemporaryFolder folder = new TemporaryFolder ( ) ; @ Test public void simple ( ) { CommandScript script = new CommandScript ( ""<STR_LIT>"" , set ( ""<STR_LIT>"" , ""<STR_LIT>"" ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT>"" ) , map ( ""<STR_LIT>"" , folder . getRoot ( ) . getAbsolutePath ( ) ) ) ; assertThat ( script . getKind ( ) , is ( ExecutionScript . Kind . COMMAND ) ) ; assertThat ( script . getId ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( script . getBlockerIds ( ) , is ( set ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ) ; assertThat ( script . getProfileName ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( script . getModuleName ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( script . getCommandLineTokens ( ) , is ( Arrays . asList ( ""<STR_LIT>"" , ""<STR_LIT>"" )'}]",") ); } private Set<String> set(String... elements) { Set<String> result = new TreeSet<>(); for (String element : elements) { result.add(element); } return result; } private Map<String, String> map(String key, String value) { Map<String, String> result = new HashMap<>(); result.put(key, value); return result; } }",0.00011308808845295449
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . rake . actions ; import java . text . MessageFormat ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . action . Action ; import com . aptana . rdt . rake . IRakeHelper ; import com . aptana . rdt . rake . RakePlugin ; public class RunRakeAction extends Action { private IProject project ; private String task ; private String description ; public RunRakeAction ( IProject project , String task , String description ) { this . project = project ; this . task = task ; this . description = description ; } @ Override public'}]","void run ( ) { IRakeHelper helper = RakePlugin. getInstance ( ). getRakeHelper ( ) ; Job job = Job. create ( ""Running Rake: "" + task ) ; job. setRule ( RakePlugin. INSTANCE. getRakeRule ( ) ) ; helper. runRake ( project, task, description, new IProgressMonitor ( ) { @ Override public void beginTask ( String name, int totalTasks ) { super. beginTask ( name, totalTasks ) ; } @ Override public void worked ( int work ) { super. worked ( work ) ; } @ Override public void done ( ) { super. done ( ) ; } @ Override public void setCanceled ( boolean canceled ) { super. setCanceled ( canceled ) ; } }, job ) ; } @ Override public boolean isEnabled ( ) { return project!= null && task!= null ; } }",0.00026077605342394886
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package osgiutils . services ; public abstract class SimpleServiceRunnable < T > implements'}]","ServiceRunnable<T>, ServiceTrackerCustomizer<T> { private final ServiceTracker<T> tracker; protected SimpleServiceRunnable(ServiceTracker<T> tracker) { this.tracker = tracker; } @Override public <S> void addingService(ServiceReference<S> reference) { } @Override public void modifiedService(ServiceReference<T> reference, T service) { } @Override public void removedService(ServiceReference<T> reference) { } @Override public void serviceChanged(ServiceEvent event) { } }",0.0001362950927807193
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . lang . reflect . Field ; public class RubyTokenCategories { protected RubyTokenCategories ( ) { } public static final int UNKNOWN = - <NUM_LIT:1> ; public static final int ERROR = <NUM_LIT:0> ; public static final int WHITESPACE = <NUM_LIT:1> ; public static final int IDENTIFIER'}]",= 2; public static final int KEYWORD = 3; public static final int SYMBOL = 4; public static final int NUMBER = 5; public static final int OPERATOR = 6; public static final int PUNCTUATION = 7; public static final int STRING = 8; public static final int BLOCK_PARAMETER = 9; public static final int BLOCK_ARG = 10; public static final int LINE_COMMENT = 11; public static final int BLOCK_COMMENT = 12; public static final int NEWLINE = 13; public static final int RUBY_MAGIC_COMMENT = 14; public static final int SHEBANG = 15; public static final int RUBY_VERSION_DIRECTIVE = 16; public static final int BLOCK_ARG_SEPARATOR = 17; public static final int RUBY_TOKEN_CATEGORY_COUNT = 18; public static RubyTokenCategory getRubyTokenCategory ( Field field ) { return ( RubyTokenCategory ) field. get ( RubyTokenCategories. class ) ; } },0.00027609973320030513
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . value ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . math . BigDecimal ; import org . junit . Test ; @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class DecimalOptionTest extends ValueOptionTestRoot { @ Test public void init ( ) { DecimalOption option = new DecimalOption ( ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; } @ Test public void get ( ) { DecimalOption option = new DecimalOption ( ) ; option . modify ( decimal ( <NUM_LIT:100> ) ) ; assertThat ( option . get ( ) , is ( decimal ( <NUM_LIT:100> ) ) ) ; assertThat ( option . isNull ( ) , is ( false ) ) ; } @ Test public void or ( ) { DecimalOption option = new DecimalOption ( ) ; assertThat ( option . or ( decimal ( <NUM_LIT:30> ) ) , is ( decimal ( <NUM_LIT:30> ) ) ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; } @ Test public void orNotNull ( ) { DecimalOption option = new DecimalOption ( ) ; option . modify ( decimal ( <NUM_LIT:100> ) ) ; assertThat ( option . or ( decimal ( <NUM_LIT:30> ) ) , is ( decimal ( <NUM_LIT:100> ) ) ) ; } @ Test public void copy ( ) { DecimalOption option = new DecimalOption ( ) ; DecimalOption other = new DecimalOption ( ) ; other . modify ( decimal ( <NUM_LIT> ) ) ; option . copyFrom ( other ) ; assertThat ( option . get ( ) , is ( decimal ( <NUM_LIT> ) ) ) ; option . modify ( decimal ( <NUM_LIT:0> ) ) ; assertThat ( other . get ( ) , is ( decimal ( <NUM_LIT> ) ) ) ; } @ Test public void copyNull ( ) { DecimalOption option = new DecimalOption ( ) ; option . modify ( decimal ( <NUM_LIT:100> ) ) ; DecimalOption other = new DecimalOption ( ) ; option . copyFrom ( other ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; option . modify ( decimal ( <NUM_LIT:100> ) ) ; option . copyFrom ( null ) ; assertThat ( option . isNull ( ) , is ( true ) ) ; } @ Test public void compareTo ( ) { DecimalOption a = new DecimalOption ( ) ; DecimalOption b = new DecimalOption ( ) ; DecimalOption c = new DecimalOption ( ) ; DecimalOption d = new DecimalOption ( ) ; DecimalOption e = new DecimalOption ( ) ; a . modify ( decimal ( - <NUM_LIT:10> ) ) ; b . modify ( decimal ( <NUM_LIT:0> ) ) ; c . modify ( decimal ( <NUM_LIT> ) ) ; d . modify ( decimal ( - <NUM_LIT:10> ) ) ; e . modify ( decimal ( - <NUM_LIT:30> ) ) ; assertThat ( compare ( a , b ) , lessThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b , c ) , lessThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( c , a ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a , c ) , lessThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b , a ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( c , b ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a , d ) , is ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a , e ) , greaterThan ( <NUM_LIT:0> ) ) ; } @ Test public void compareTo_scale ( ) { DecimalOption a1 = new DecimalOption ( ) ; DecimalOption a2 = new DecimalOption ( ) ; DecimalOption b1 = new DecimalOption ( ) ; DecimalOption b2 = new DecimalOption ( ) ; DecimalOption c1 = new DecimalOption ( ) ; DecimalOption c2 = new DecimalOption ( ) ; DecimalOption d1 = new DecimalOption ( ) ; DecimalOption d2 = new DecimalOption ( ) ; a1 . modify ( decimal ( ""<STR_LIT>"" ) ) ; a2 . modify ( decimal ( ""<STR_LIT>"" ) ) ; b1 . modify ( decimal ( ""<STR_LIT>"" ) ) ; b2 . modify ( decimal ( ""<STR_LIT>"" ) ) ; c1 . modify ( decimal ( ""<STR_LIT>"" ) ) ; c2 . modify ( decimal ( ""<STR_LIT>"" ) ) ; d1 . modify ( decimal ( ""<STR_LIT>"" ) ) ; d2 . modify ( decimal ( ""<STR_LIT>"" ) ) ; assertThat ( compare ( a1 , a2 ) , equalTo ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b1 , b2 ) , equalTo ( <NUM_LIT:0> ) ) ; assertThat ( compare ( c1 , c2 ) , equalTo ( <NUM_LIT:0> ) ) ; assertThat ( compare ( d1 , d2 ) , equalTo ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a1 , b1 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a1 , b2 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a1 , c1 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( a1 , c2 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b1 , c1 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b1 , c2 ) , greaterThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b1 , a1 ) , lessThan ( <NUM_LIT:0> ) ) ; assertThat ( compare ( b1 , a2 ) ,'}]",lessThan(<NUM_LIT:0>)); },5.2696929381357055e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary'}]",".flow.Out;import com.asakusafw.compiler.flow.example.MockFlowOperator;public class ExampleFlow extends FlowDescription { @Import private final In<MockHoge> input; @Export private final Out<MockHoge> output; public ExampleFlow(String jobId, String jobName, String flowName) { super(jobId, jobName, flowName); } @Override public void buildFlow() { // TODO: build flow here output = new Out<MockHoge>(input, new MockFlowOperator()); } public static void main(String[] args) { new ExampleFlow(""job1"", ""job1"", ""example"").buildFlow(); } }",0.00018669044188037606
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . handlers ; import javax . management . Notification ; import javax . management . NotificationListener ; import javax . swing . ImageIcon ; import junit . framework . TestCase ; import org . oddjob . Iconic ; import org . oddjob . images . IconEvent ; import org . oddjob . images . IconHelper ; import org . oddjob . images . IconListener ; import org . oddjob . jmx . RemoteOperation ; import org . oddjob . jmx . client . MockClientSideToolkit ; import org . oddjob . jmx . server . MockServerSideToolkit ; import org . oddjob . jmx . server . ServerInterfaceHandler ; public class IconicHandlerFactoryTest extends TestCase { class OurIconic implements Iconic { IconHelper helper = new IconHelper ( this ) ; { helper . changeIcon ( IconHelper . EXECUTING ) ; } public void addIconListener ( IconListener listener ) { helper . addIconListener ( listener ) ; } public void removeIconListener ( IconListener listener ) { helper . removeIconListener ( listener ) ; } public ImageIcon iconForId ( String iconId ) { return helper . iconForId ( iconId ) ; } } class OurClientToolkit extends MockClientSideToolkit { ServerInterfaceHandler server ; @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) @ Override public < T > T invoke ( RemoteOperation < T > remoteOperation , Object ... args ) throws Throwable { return ( T ) server . invoke ( remoteOperation , args ) ; } } class OurServerToolkit extends MockServerSideToolkit { long seq = <NUM_LIT:0> ; @ Override public void runSynchronized ( Runnable runnable ) { runnable . run ( ) ; } @ Override public Notification createNotification ( String type ) { return new Notification ( type , this , seq ++ ) ; } @ Override public void sendNotification ( Notification notification ) { } } public void testClientIconFor ( ) { OurIconic iconic = new OurIconic ( ) ; IconicHandlerFactory test = new IconicHandlerFactory ( ) ; OurServerToolkit serverToolkit = new OurServerToolkit ( ) ; ServerInterfaceHandler serverHandler = test . createServerHandler ( iconic , serverToolkit ) ; OurClientToolkit toolkit = new OurClientToolkit ( ) ; toolkit . server = serverHandler ; Iconic h = new IconicHandlerFactory . ClientIconicHandlerFactory ( ) . createClientHandler ( iconic , toolkit ) ; ImageIcon result = h . iconForId ( IconHelper . EXECUTING ) ; assertEquals ( ""<STR_LIT>"" , result . getDescription ( ) ) ; } class OurClientToolkit2 extends MockClientSideToolkit { ServerInterfaceHandler server ; NotificationListener listener ; @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) @ Override public < T > T invoke ( RemoteOperation < T > remoteOperation , Object ... args ) throws Throwable { return ( T ) server . invoke ( remoteOperation , args ) ; } public void registerNotificationListener ( String eventType , NotificationListener notificationListener ) { if ( listener != null ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } assertEquals ( IconicHandlerFactory . ICON_CHANGED_NOTIF_TYPE , eventType ) ; this .'}]",listener = notificationListener; } },3.5624910952402144e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . general ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . when ; import javax . management . ObjectName ; import junit . framework . TestCase ; import org . apache . commons . beanutils . DynaClass ; import org . apache . commons . beanutils . DynaProperty ; import org . mockito . Mockito ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . ArooaTools ; import org . oddjob . arooa . beanutils . BeanUtilsPropertyAccessor ; public class MBeanDirectoryTest extends TestCase { public static class Vendor { public String getName ( ) { return ""<STR_LIT>"" ; } } public void testLookup ( ) throws Exception { DynaProperty prop = new DynaProperty ( ""<STR_LIT>"" ) ; DynaClass dynaClass = mock ( DynaClass . class ) ; when ( dynaClass . getDynaProperty ( ""<STR_LIT>"" ) ) . thenReturn ( prop ) ; MBeanNode node = mock ( MBeanNode . class ) ; when ( node . get ( ""<STR_LIT>"" ) ) . thenReturn ( new Vendor ( ) ) ; when ( node . getDynaClass ( ) ) . thenReturn ( dynaClass ) ; MBeanCache cache = mock ('}]","MBeanCache.class); ArooaSession session = new ArooaTools().createSession(); when(session.lookup(""Vendor"")).thenReturn(node); when(cache.get(""Vendor"")).thenReturn(node); ObjectName name = mock(ObjectName.class); when(session.lookup(""Vendor"", name)).thenReturn(node); when(cache.get(""Vendor"", name)).thenReturn(node); ArooaTools.getTools().setMBeanCache(cache); try { ArooaTools.getTools().lookup(""Vendor""); } finally { ArooaTools.getTools().setMBeanCache(null); } } }",0.00016310500132294753
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . splitlocal . conditionchecks ; import junit . framework'}]",.TestCase; import org.junit.Test; public class ConditionChecksTest { @Test public void testSomething() { // Add test logic here } },5.098637508390205e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . testunit . wizards ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople .'}]","rdt. core. IRubyFile;public class RubyFileWizard extends org.eclipse.ui.handlers.Handler { @Override public void addPages() { super.addPages(); } @Override public void init(IWorkbench workbench, IStructuredEditor editor, IFile file) throws CoreException { super.init(workbench, editor, file); } public void init(IWorkbench workbench, IStructuredEditor editor, IResource resource) throws CoreException { super.init(workbench, editor, resource); } public void create(IWorkbench workbench, IStructuredEditor editor, IFile file) throws CoreException { super.create(workbench, editor, file); } public void create(IWorkbench workbench, IStructuredEditor editor, IRubyFile rubyFile) throws CoreException { super.create(workbench, editor, rubyFile); } }",0.00022759627409603026
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . util ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources'}]",$IResource;public class FileUtil { public static List<IFile> getFiles(IResource resource) { List<IFile> files = new ArrayList<>(); if (resource.getType() == IResource.FILE) { files.add(resource); } else { files.addAll(org.eclipse.core.resources.ResourcesPlugin.getWorkspace().getRoot().getResources(resource.getFullPath())); } return files; } },0.00010674003754228215
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor ; import com . asakusafw . compiler . common . TargetOperator ; import com . asakusafw . compiler . flow . DataClass ; import com . asakusafw . compiler . flow . DataClass . Property ; import com . asakusafw . compiler . flow . LinePartProcessor ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . vocabulary . flow . graph . FlowElementPortDescription ; import com . asakusafw . vocabulary . operator . Restructure ; @ TargetOperator ( Restructure . class ) public class RestructureFlowProcessor extends LinePartProcessor { @ Override public void emitLinePart ( Context context ) { FlowElementPortDescription input = context . getInputPort ( Restructure . ID_INPUT ) ; FlowElementPortDescription output = context . getOutputPort ( Restructure . ID_OUTPUT ) ; DataObjectMirror cache = context . createModelCache ( output .'}]",".getProperty(Property.KEY_MODEL_CACHE)); context.emitLinePart(""restructure"", input, output, cache); } }",4.58564980153312e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api . plus . activity ; import org . codehaus . jackson . annotate . JsonProperty ; import org . codehaus . jackson . annotate . JsonSubTypes ; import org . codehaus . jackson . annotate . JsonSubTypes . Type ; import org . codehaus . jackson . annotate . JsonTypeInfo ; import org . codehaus . jackson . annotate . JsonTypeInfo . As ; import org . codehaus . jackson . annotate . JsonTypeInfo . Id ; @ JsonTypeInfo ( property = ""<STR_LIT>"" , include = As . PROPERTY , use = Id . NAME )'}]","@JsonSubTypes({ @JsonSubTypes.Type(value = GooglePlusActivity.class, name = ""activity"") })",4.561396122982256e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . prop_pages ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . model . WorkbenchContentProvider ; import org . eclipse . ui . model . WorkbenchLabelProvider ; public class ProjectDirectoryDialog extends Dialog { private String fPathStr ; private TreeViewer fTreeViewer ; private IProject fProject ; public'}]","ProjectDirectoryDialog ( Shell shell, IProject project ) { super ( shell ) ; setShellStyle ( SWT. MODELESS ) ; fProject = project ; } @ Override protected Control createDialogArea ( ) { super. createDialogArea ( ) ; Composite area = ( Composite ) getDialogArea ( ) ; area. setLayout ( new GridLayout ( 1, false ) ) ; Composite comp = new Composite ( area, SWT. NONE ) ; comp. setLayoutData ( new GridData ( SWT. GRAB_HANDLE | SWT. HORIZONTAL ) ) ; fTreeViewer = new TreeViewer ( comp ) ; fTreeViewer. setContentProvider ( new WorkbenchContentProvider ( ) ) ; fTreeViewer. setLabelProvider ( new WorkbenchLabelProvider ( ) ) ; fTreeViewer. addDoubleClickListener ( new IDoubleClickListener ( ) { @ Override public void doubleClick ( DoubleClickEvent event ) { ISelection selection = fTreeViewer. getSelection ( ) ; IResource resource = ( IResource ) selection. getFirstElement ( ) ; fPathStr = resource. getFullPath ( ). toString ( ) ; close ( ) ; } } ) ; IContainer container = fProject. getWorkspace ( ). root ( ) ; fTree",0.0003570409435639756
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . emitter ; import java . util . List ; import com . pogofish . jadt . ast . Constructor ; import com . pogofish . jadt . sink . Sink ; public interface ClassBodyEmitter { public abstract void constructorFactory ( Sink sink , String dataTypeName , String factoryName , List < String >'}]","parameterNames, Constructor constructor ) ; }",2.578600425147148e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor . operator ; import java . util . Arrays ; import java . util . List ; import javax . annotation . Generated ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Ex2 ; import com . asakusafw . vocabulary . flow . Operator ; import com . asakusafw . vocabulary . flow . Source ; import com . asakusafw . vocabulary . flow . graph . FlowBoundary ; import com . asakusafw . vocabulary . flow . graph . FlowElementResolver ; import com . asakusafw . vocabulary . flow . graph . OperatorDescription ; import com . asakusafw . vocabulary . flow . graph . OperatorHelper ; import com . asakusafw . vocabulary . flow . graph . ShuffleKey ; import com . asakusafw . vocabulary . operator . MasterBranch ; @ Generated ( ""<STR_LIT>"" ) public class MasterBranchFlowFactory { public static final class Simple implements Operator { public final Source < Ex1 > high ; public final Source < Ex1 > low ; public final Source < Ex1 > stop ; Simple ( Source < Ex2 > master , Source < Ex1 > model ) { OperatorDescription . Builder builder = new OperatorDescription . Builder ( MasterBranch . class ) ; builder . declare ( MasterBranchFlow . class , MasterBranchFlowImpl . class , ""<STR_LIT>"" ) ; builder . declareParameter ( Ex2 . class ) ; builder . declareParameter ( Ex1 . class ) ; builder . addInput ( ""<STR_LIT>"" , Ex2 . class , new ShuffleKey ( Arrays . asList ( new String [ ] { ""<STR_LIT:string>"" } ) , Arrays . asList ( new ShuffleKey . Order [ ] { } ) ) ) ; builder . addInput ( ""<STR_LIT>"" , Ex1 . class , new ShuffleKey ( Arrays . asList ( new String [ ] { ""<STR_LIT:string>"" } ) , Arrays . asList ( new ShuffleKey . Order [ ] { } ) ) ) ; builder . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder . addAttribute ( FlowBoundary . SHUFFLE ) ; FlowElementResolver resolver = builder . toResolver ( ) ; resolver . resolveInput ( ""<STR_LIT>"" , master ) ; resolver . resolveInput ( ""<STR_LIT>"" , model ) ; this . high = resolver . resolveOutput ( ""<STR_LIT>"" ) ; this . low = resolver . resolveOutput ( ""<STR_LIT>"" ) ; this . stop = resolver . resolveOutput ( ""<STR_LIT>"" ) ; } } public MasterBranchFlowFactory . Simple simple ( Source < Ex2 > master , Source < Ex1 > model ) { return new MasterBranchFlowFactory . Simple ( master , model ) ; } public static final class WithParameter implements Operator { public final Source < Ex1 > high ; public final Source < Ex1 > low ; public final Source < Ex1 > stop ; WithParameter ( Source < Ex2 > master , Source < Ex1 > model , int parameter ) { OperatorDescription . Builder builder0 = new OperatorDescription . Builder ( MasterBranch . class ) ; builder0 . declare ( MasterBranchFlow . class , MasterBranchFlowImpl . class , ""<STR_LIT>"" ) ; builder0 . declareParameter ( Ex2 . class ) ; builder0 . declareParameter ( Ex1 . class ) ; builder0 . declareParameter ( int . class ) ; builder0 . addInput ( ""<STR_LIT>"" , Ex2 . class , new ShuffleKey ( Arrays . asList ( new String [ ] { ""<STR_LIT:string>"" } ) , Arrays . asList ( new ShuffleKey . Order [ ] { } ) ) ) ; builder0 . addInput ( ""<STR_LIT>"" , Ex1 . class , new ShuffleKey ( Arrays . asList ( new String [ ] { ""<STR_LIT:string>"" } ) , Arrays . asList ( new ShuffleKey . Order [ ] { } ) ) ) ; builder0 . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder0 . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder0 . addOutput ( ""<STR_LIT>"" , Ex1 . class ) ; builder0 . addParameter ( ""<STR_LIT>"" , int . class , parameter ) ; builder0 . addAttribute ( FlowBoundary . SHUFFLE ) ; FlowElementResolver resolver0 = builder0 . toResolver ( ) ; resolver0 . resolveInput ( ""<STR_LIT>"" ,'}]","master); resolver0.resolveInput(""<STR_LIT>"", model); this.high = resolver0.resolveOutput(""<STR_LIT>""); this.low = resolver0.resolveOutput(""<STR_LIT>""); this.stop = resolver0.resolveOutput(""<STR_LIT>""); } }",0.00010418473274202284
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . hierarchy ; import java . util . List ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBModIfcDecl ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . search . SVDBFindNamedClass ; import net . sf . sveditor . core . db . search . SVDBFindNamedModIfcClassIfc ; import net . sf . sveditor . core . hierarchy . ClassHierarchyTreeFactory ; import net . sf . sveditor . core . hierarchy . HierarchyTreeNode ; import net . sf . sveditor . core . hierarchy . ModuleHierarchyTreeFactory ; import net . sf . sveditor . core . tests . IndexTestUtils ; public class HierarchyTests extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ""<STR_LIT>"" ) ; suite . addTest ( new TestSuite ( HierarchyTests . class ) ) ; suite . addTest ( new TestSuite ( TestModuleHierarchy . class ) ) ; return suite ; } public void testClassHierarchy ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" ; String testname = ""<STR_LIT>"" ; ISVDBIndexIterator index_it = IndexTestUtils . buildIndex ( doc , testname ) ; ClassHierarchyTreeFactory tf = new ClassHierarchyTreeFactory ( index_it ) ; SVDBFindNamedClass cls_finder = new SVDBFindNamedClass ( index_it ) ; List < SVDBClassDecl > cls_l = cls_finder . find ( ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:1> , cls_l . size ( ) ) ; HierarchyTreeNode h'}]","t = tf. build ( cls_l. get ( 0 ) ) ; List < HierarchyTreeNode > children = h_t. getChildren ( ) ; assertEquals ( <NUM_LIT:2>, children. size ( ) ) ; } public void testModuleHierarchy ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_L",0.0003618993543281706
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . parser . warnings ; import junit . framework . Test ; import junit . framework . TestSuite ; public class TS_ParserWarnings { public static Test suite ( ) { TestSuite suite = new TestSuite ( ""<STR_LIT>"" ) ; suite . addTestSuite ( TC_SimilarVariableNameVisitor . class ) ; suite'}]",.addTestSuite(TC_SingleLineCommentVisitor.class); return suite; } public static void main(String[] args) { TestSuite suite = suite(); junit.textui.TestRunner.run(suite()); } },6.728648229663852e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . io ; import java . io . IOException ; import com . asakusafw . compiler . fileio . model . Part1 ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class Part1Output implements ModelOutput < Part1 > { private final RecordEmitter emitter ; public Part1Output ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; }'}]",@Override public void emit(Part1 part) throws IOException { emitter.emit(part); },3.8160404374956894e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package osgiutils . services ; import java . util . Collection ; import java . util . Collections ; public abstract class DefaultCollectionServiceRunnable < T , R > extends DefaultServiceRunnable < T , Collection < R > > { @'}]",Overridepublic abstract Collection<R> doRun(T... args) throws Exception;,3.410263968481381e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import java . io . IOException ; import org . rubypeople . rdt . core . Flags ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . core . index . EntryResult ; import org . rubypeople . rdt . internal . core . index . Index ; import org . rubypeople . rdt . internal . core . search . indexing . IIndexConstants ; import org . rubypeople . rdt . internal . core . util . CharOperation ; public class TypeDeclarationPattern extends RubySearchPattern implements IIndexConstants { public char [ ] simpleName ; public char [ ] pkg ; public char [ ] [ ] enclosingTypeNames ; public char typeSuffix ; public int modifiers ; public boolean secondary = false ; protected static char [ ] [ ] CATEGORIES = { TYPE_DECL } ; static PackageNameSet internedPackageNames = new PackageNameSet ( <NUM_LIT> ) ; static class PackageNameSet { public char [ ] [ ] names ; public int elementSize ; public int threshold ; PackageNameSet ( int size ) { this . elementSize = <NUM_LIT:0> ; this . threshold = size ; int extraRoom = ( int ) ( size * <NUM_LIT> ) ; if ( this . threshold == extraRoom ) extraRoom ++ ; this . names = new char [ extraRoom ] [ ] ; } char [ ] add ( char [ ] name ) { int length = names . length ; int index = CharOperation . hashCode ( name ) % length ; char [ ] current ; while ( ( current = names [ index ] ) != null ) { if ( CharOperation . equals ( current , name ) ) return current ; if ( ++ index == length ) index = <NUM_LIT:0> ; } names [ index ] = name ; if ( ++ elementSize > threshold ) rehash ( ) ; return name ; } void rehash ( ) { PackageNameSet newSet = new PackageNameSet ( elementSize * <NUM_LIT:2> ) ; char [ ] current ; for ( int i = names . length ; -- i >= <NUM_LIT:0> ; ) if ( ( current = names [ i ] ) != null ) newSet . add ( current ) ; this . names = newSet . names ; this . elementSize = newSet . elementSize ; this . threshold = newSet . threshold ; } } public static char [ ] createIndexKey ( int modifiers , char [ ] typeName , char [ ] packageName , char [ ] [ ] enclosingTypeNames , boolean secondary ) { int typeNameLength = typeName == null ? <NUM_LIT:0> : typeName . length ; int packageLength = packageName == null ? <NUM_LIT:0> : packageName . length ; int enclosingNamesLength = <NUM_LIT:0> ; if ( enclosingTypeNames != null ) { for ( int i = <NUM_LIT:0> , length = enclosingTypeNames . length ; i < length ; ) { enclosingNamesLength += enclosingTypeNames [ i ] . length ; if ( ++ i < length ) enclosingNamesLength += <NUM_LIT:2> ; } } int resultLength = typeNameLength + packageLength + enclosingNamesLength + <NUM_LIT:5> ; if ( secondary ) resultLength += <NUM_LIT:2> ; char [ ] result = new char'}]","[resultLength];if (secondary)result[resultLength - 1] = 'S';int offset = <NUM_LIT:0>;if (typeName!= null) {CharOperation.arraycopy(typeName, <NUM_LIT:0>, result, offset, typeNameLength);offset += typeNameLength;}if (packageName!= null) {CharOperation.arraycopy(packageName, <NUM_LIT:0>, result, offset, packageLength);offset += packageLength;}if (enclosingTypeNames!= null) {for (int i = <NUM_LIT:0>, length = enclosingTypeNames.length; i < length; ) {CharOperation.arraycopy(enclosingTypeNames[i], <NUM_LIT:0>, result, offset, enclosingTypeNames[i].length);offset += enclosingTypeNames[i].length;if (++i < length)offset += <NUM_LIT:2>;}result[offset - 1] = IIndexConstants.TYPE_DECL_SEPARATOR;}result[offset - 1] = (char) modifiers;return result;}",0.0003103869164454882
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . widgets ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . draw2d . Cursors ; import org . eclipse . draw2d . FigureCanvas ; import org . eclipse . draw2d . Viewport ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseMoveListener ; public final class CanvasScroller implements MouseMoveListener { private static final Log log = LogFactory . getLog ( CanvasScroller . class'}]","); private final FigureCanvas canvas; private final Viewport viewport; public CanvasScroller(FigureCanvas canvas, Viewport viewport) { this.canvas = canvas; this.viewport = viewport; } @Override public void mouseMove(MouseEvent e) { Point mousePoint = e.getPoint(); Point scrollTarget = canvas.toScreen(mousePoint); int scrollX = (int) (scrollTarget.x - viewport.getViewLocation().x); int scrollY = (int) (scrollTarget.y - viewport.getViewLocation().y); viewport.scrollHorizontally(scrollX, true); viewport.scrollVertically(scrollY, true); } }",0.00016904147030291115
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import java . io . IOException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . OperationCanceledException ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . core . search . SearchParticipant ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . compiler . util . SimpleSet ; import org . rubypeople . rdt . internal . core . index . EntryResult ; import'}]","org. rubypeople. rdt. internal. core. index. IRubyIndex ; public class RubySearcher { public EntryResult search ( SearchPattern pattern, IRubyIndex index, SearchParticipant participant, IProgressMonitor progressMonitor, IRubySearchScope scope ) throws OperationCanceledException, IOException { if ( pattern == null ) { throw new IllegalArgumentException ( ""Pattern cannot be null"" ) ; } if ( index == null ) { throw new IllegalArgumentException ( ""Index cannot be null"" ) ; } if ( participant == null ) { throw new IllegalArgumentException ( ""Participant cannot be null"" ) ; } if ( scope == null ) { throw new IllegalArgumentException ( ""Scope cannot be null"" ) ; } SimpleSet < SearchParticipant > participants = new SimpleSet <> ( participant ) ; participants. addAll ( participant. getSearchParticipants ( ) ) ; // Add additional participants here participants. addAll ( participant. getSearchParticipants ( ) ) ; // Add additional participants here return index. search ( pattern, participants, progressMonitor, scope ) ; } }",0.00028445485075182924
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . editor . actions ; import java . util . ResourceBundle ; import net . sf . sveditor . core . scanner . SVCharacter ; import net . sf . sveditor . ui . editor . SVEditor ; import org . eclipse . jface . text . source . ISourceViewer ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . graphics . Point ; import org . eclipse . ui . texteditor . TextEditorAction ; public class SelNextWordAction extends TextEditorAction { private SVEditor fEditor ; public SelNextWordAction ( ResourceBundle bundle , String prefix , SVEditor editor ) { super ( bundle , prefix , editor ) ; fEditor = editor ; } @ Override public void run ( ) { ISourceViewer sv = fEditor . sourceViewer ( ) ; StyledText text = fEditor . sourceViewer ( ) . getTextWidget ( ) ; int offset = text . getCaretOffset ( ) ; int start_offset = offset ; if ( text . getSelection ( ) != null ) { Point sel = text . getSelection ( ) ; if ( sel . x == offset ) { start_offset = sel . y ; } else if ( sel . y == offset ) { start_offset = sel . x ; } } String str = text . getText ( ) ; int len = str . length ( ) ; int ch = str . charAt ( offset ) ; if ( SVCharacter . isSVIdentifierPart ( ch ) ) { while ( offset < len ) { ch = str . charAt ( offset ) ; if ( ! SVCharacter . isSVIdentifierPart ( ch ) ) { break ; }'}]","} offset++; } int end_offset = offset; if ( text. getSelection ( )!= null ) { Point sel = text. getSelection ( ) ; if ( sel. x == offset ) { end_offset = sel. y ; } else if ( sel. y == offset ) { end_offset = sel. x ; } } sv. selectAndReveal ( start_offset, end_offset ) ; } }",0.00012704119738649912
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . IProgressMonitor ; public interface IBuffer { public void addBufferChangedListener ( IBufferChangedListener listener ) ; public void append ( char [ ] text ) ; public void append ( String text ) ; public void close ( ) ;'}]",public void removeBufferChangedListener ( IBufferChangedListener listener ) ;,3.48334456910755e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . cache ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . BooleanWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . VLongWritable ; import org . apache . hadoop . io . Writable ; import com . asakusafw . thundergate . runtime . cache . ThunderGateCacheSupport ; public class TestDataModel implements Writable , ThunderGateCacheSupport , Comparable < TestDataModel > { public final VLongWritable systemId = new VLongWritable ( ) ; public final Text value = new Text ( ) ; public final BooleanWritable deleted = new BooleanWritable ( ) ; public TestDataModel copy ( ) { TestDataModel copy = new TestDataModel ( ) ; copy . systemId . set ( systemId . get ( ) ) ; copy . value . set ( value ) ; copy . deleted . set ( deleted . get ( ) ) ; return copy ; } @ Override public long __tgc__DataModelVersion ( ) { return <NUM_LIT:1L> ; } @ Override public String __tgc__TimestampColumn ( ) { return ""<STR_LIT>"" ; } @ Override public long __tgc__SystemId ( ) { return systemId . get ( ) ; } @ Override public boolean __tgc__Deleted ( ) { return deleted . get ( ) ; } @ Override public void write ( DataOutput out ) throws IOException { systemId . write ( out ) ;'}]",value.write(out); deleted.write(out);,3.0414376641519673e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . wizards ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . project . SVDBProjectData ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; public class NewSVClassWizardPage extends AbstractNewSVItemFileWizardPage { public static final String SUPER_CLASS = ""<STR_LIT>"" ; public static final String OVERRIDE_NEW = ""<STR_LIT>"" ; private Text'}]","superClassNameText = new Text(parent, SWT.BUFFER, 10);",3.933354521134219e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Locale ; import org . jruby . ast . ArgsCatNode ; import org . jruby . ast . ArgsNode ; import org . jruby . ast . ArgumentNode ; import org . jruby . ast . ArrayNode ; import org . jruby . ast . BlockArgNode ; import org . jruby . ast . BlockNode ; import org . jruby . ast . CallNode ; import org . jruby . ast . ClassNode ; import org . jruby . ast . ClassVarAsgnNode ; import org . jruby . ast . ClassVarNode ; import org . jruby . ast . Colon2ImplicitNode ; import org . jruby . ast . Colon3Node ; import org . jruby . ast . CommentNode ; import org . jruby . ast . ConstDeclNode ; import org . jruby . ast . ConstNode ; import org . jruby . ast . DVarNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . DefsNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . FCallOneArgNode ; import org . jruby . ast . InstAsgnNode ; import org . jruby . ast . InstVarNode ; import org . jruby . ast . ListNode ; import org . jruby . ast . LocalAsgnNode ; import org . jruby . ast . LocalVarNode ; import org . jruby . ast . MultipleAsgnNode ; import org . jruby . ast . NewlineNode ; import org . jruby . ast . Node ; import org . jruby . ast . RestArgNode ; import org . jruby . ast . SelfNode ; import org . jruby . ast . SuperNode ; import org . jruby . ast . SymbolNode ; import org . jruby . ast . VCallNode ; import org . jruby . ast . ZSuperNode ; import org . jruby . lexer . yacc . IDESourcePosition ; import org . jruby . lexer . yacc . ISourcePosition ; import org . jruby . parser . LocalStaticScope ; import org . jruby . parser . StaticScope ; import org . rubypeople . rdt . refactoring . nodewrapper . ArgsNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . AttrAccessorNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . VisibilityNodeWrapper ; import org . rubypeople . rdt . refactoring . util . Constants ; public class NodeFactory { public static final Node NULL_POSITION_NODE = new NewlineNode ( new IDESourcePosition ( ) , null ) ; public static FCallNode createSimpleAccessorNode ( String definitionName , String attrName ) { ArrayNode argsNode = new ArrayNode ( new IDESourcePosition ( ) ) ; argsNode . add ( new SymbolNode ( new IDESourcePosition ( ) , attrName ) ) ; return new FCallOneArgNode ( new IDESourcePosition ( ) , definitionName , argsNode ) ; } public static DefsNode createStaticMethodNode ( String methodName , Collection < String > args , StaticScope scopeNode , Node body ) { return createStaticMethodNode ( ""<STR_LIT>"" , methodName , createArgsNode ( args . toArray ( new String [ args . size ( ) ] ) ) , scopeNode == null ? new LocalStaticScope ( null ) : scopeNode , body ) ; } public static DefnNode createMethodNode ( String methodName , String [ ] args , Node scopeContentNode ) { ArgsNode argsNode = createArgsNode ( args ) ; return createMethodNode ( methodName , argsNode , scopeContentNode ) ; } public static DefnNode createMethodNode ( String methodName , ArgsNode argsNode , Node body ) { ArgumentNode methodNameNode = new ArgumentNode ( new IDESourcePosition ( ) , methodName ) ; return new DefnNode ( new IDESourcePosition ( ) , methodNameNode , argsNode , new LocalStaticScope ( null ) , body != null ? new NewlineNode ( body . getPosition ( ) , body ) : null ) ; } public static DefnNode createMethodNodeWithoutNewline ( String methodName , ArgsNode argsNode , Node body ) { ArgumentNode methodNameNode = new ArgumentNode ( new IDESourcePosition ( ) , methodName ) ; return new DefnNode ( new IDESourcePosition ( ) , methodNameNode , argsNode , new LocalStaticScope ( null ) , body ) ; } public static DefsNode createStaticMethodNode ( String className , String methodName , ArgsNodeWrapper argsNode , StaticScope scopeNode ) { return createStaticMethodNode ( className , methodName , argsNode . getWrappedNode ( ) , scopeNode , null ) ; } public static DefsNode createStaticMethodNode ( String className , String methodName , ArgsNode argsNode , StaticScope scopeNode , Node body ) { return new DefsNode ( new IDESourcePosition ( ) , createConstNode ( className ) , createArgumentNode ( methodName ) , argsNode , scopeNode , body ) ; } public static ArgsNode createArgsNode ( String ... args ) { return createArgsNode ( args , null , - <NUM_LIT:1> , null , null ) ; } public static ArgsNode createArgsNode ( Collection < String > args ) { return createArgsNode ( args . toArray ( new String [ args . size ( ) ] ) ) ; } public static ArgsNode createArgsNode ( String [ ] args , ListNode optArgs , int restArgs , RestArgNode restArgNode , BlockArgNode blockArg ) { ListNode argumentsList = null ; if ( args . length > <NUM_LIT:0> ) { argumentsList = new ListNode ( new IDESourcePosition ( ) ) ; for ( String arg : args ) argumentsList . add ( new ArgumentNode ( new IDESourcePosition ( ) , arg ) ) ; } ArgsNode argsNode = new ArgsNode ( new IDESourcePosition ( ) , argumentsList , optArgs , restArgNode , null , blockArg ) ; return argsNode ; } public static DefnNode createConstructor ( BlockNode content ) { return createMethodNode ( Constants . CONSTRUCTOR_NAME , new String [ ] { } , content ) ; } public static DefnNode createDefaultConstructor ( ) { return createConstructor ( new BlockNode ( new IDESourcePosition ( ) ) ) ; } public static InstAsgnNode createInstAsgnNode ( String name , Node valueNode ) { return new InstAsgnNode ( new IDESourcePosition ( ) , name , valueNode ) ; } public static InstVarNode createInstVarNode ( String name ) { return new InstVarNode ( new IDESourcePosition ( ) , name ) ; } public static Node createSuperNode ( Collection < String > args ) { if ( args . isEmpty ( ) ) { return new ZSuperNode ( new IDESourcePosition ( ) ) ; } ArrayNode argsNode = createArrayNodeWithLocalVarNodes ( args ) ; return new SuperNode ( new IDESourcePosition ( ) , argsNode ) ; } private static ArrayNode createArrayNodeWithLocalVarNodes ( Collection < String > args ) { ArrayNode arrayNode = new ArrayNode ( new IDESourcePosition ( ) ) ; for ( String name : args ) { arrayNode . add ( new LocalVarNode ( new IDESourcePosition ( ) , <NUM_LIT:0> , name ) ) ; } return arrayNode ; } public static BlockNode createBlockNode ( ) { return new BlockNode ( new IDESourcePosition ( ) ) ; } public static BlockNode createBlockNode ( Node ... content ) { BlockNode blockNode = new BlockNode ( new IDESourcePosition ( ) ) ; for ( Node node : content ) { blockNode . add ( node ) ; } return blockNode ; } public static BlockNode createBlockNode ( boolean needsNewLineAtEndOfBlock , Node ... contentNodes ) { return createBlockNode ( true , needsNewLineAtEndOfBlock , contentNodes ) ; } public static BlockNode createBlockNode ( boolean leadingNewLine , boolean subsequentNewline , Node ... contentNodes ) { return createBlockNode ( leadingNewLine , subsequentNewline , false , contentNodes ) ; } public static BlockNode createBlockNode ( boolean leadingNewLine , boolean subsequentNewline , boolean newLineBetweenNodes , Node ... contentNodes ) { BlockNode blockNode = createBlockNode ( ) ; if ( leadingNewLine ) { blockNode . add ( NodeFactory . createNewLineNode ( null ) ) ; } for ( Node aktContentNode : contentNodes ) { if ( newLineBetweenNodes ) { blockNode . add ( createNewLineNode ( aktContentNode ) ) ; } else { blockNode . add ( aktContentNode ) ; } } if ( subsequentNewline ) { blockNode . add ( NodeFactory . createNewLineNode ( null ) ) ; } return blockNode ; } public static NewlineNode createNewLineNode ( Node nextNode ) { return new NewlineNode ( new IDESourcePosition ( ) , nextNode ) ; } public static ListNode createListNode ( Collection < ? extends Node > nodes ) { ListNode listNode = new ListNode ( new IDESourcePosition ( ) ) ; for ( Node aktNode : nodes ) { listNode . add ( aktNode ) ; } return listNode ; } public static ListNode createListNode ( ) { return new ListNode ( new IDESourcePosition ( ) ) ; } public static ClassNode createClassNode ( String className , Node bodyNode ) { Colon2ImplicitNode classNameNode = new Colon2ImplicitNode ( new IDESourcePosition ( ) , className ) ; return new ClassNode ( new IDESourcePosition ( ) , classNameNode , new LocalStaticScope ( null ) , bodyNode , null ) ; } public static Node createCommentNode ( String commentValue ) { return new CommentNode ( new IDESourcePosition ( ) , commentValue ) ; }'}]","public static ClassVarAsgnNode createClassVarAsgnNode ( String varName, Node valueNode ) { return new ClassVarAsgnNode ( new IDESourcePosition ( ), varName, valueNode ) ; }",0.00013047830907296962
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class XMLTransformUtils { public static Map < String , String > xml2Map ( String content , String root_elem_id , String item_elem_id ) throws Exception { return xml2Map ( new StringInputStream ( content ) , root_elem_id , item_elem_id ) ; } public static Map < String , String > xml2Map ( InputStream content , String root_elem_id , String item_elem_id ) throws Exception { Map < String , String > ret = new HashMap < String , String > ( ) ; DocumentBuilder b = documentBuilder ( ) ;'}]","Document doc = b.parse(content); NodeList nodeList = doc.getElementsByTagName(root_elem_id); for (int i = 0; i < nodeList.getLength(); i++) { Element elem = (Element) nodeList.item(i); NodeList childNodes = elem.getChildNodes(); for (int j = 0; j < childNodes.getLength(); j++) { Element itemElem = (Element) childNodes.item(j); if (itemElem.getTagName().equals(item_elem_id)) { ret.put(itemElem.getAttribute(""id""), itemElem.getTextContent()); } } } return ret; } public static DocumentBuilder documentBuilder() throws ParserConfigurationException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); return factory.newDocumentBuilder(); } }",0.00020741695357550963
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import java . util . List ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse'}]",".core.runtime.IProgressMonitor; import org.eclipse.ui.IWorkbenchPage; import org.eclipse.ui.IEditorPart; import org.eclipse.ui.views.focusedview.FocusedViewPart; import org.eclipse.ui.views.focusedview.RubyView; public class RubyTextViewer { public void createRubyTextViewer( List< String > lines, IWorkbenchPage page, IEditorPart editor, IProgressMonitor monitor ) { //... } }",0.0001231278100441988
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . typehierarchy ; import org . eclipse . jface . action . IMenuListener ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . IOpenListener ; import org . eclipse . jface . viewers . OpenEvent ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . internal . ui . viewsupport . DecoratingRubyLabelProvider ; import org . rubypeople . rdt . internal . ui . viewsupport . ProblemTreeViewer ; import org . rubypeople . rdt . ui . RubyElementLabels ; import org . rubypeople . rdt . ui . actions . OpenAction ; public abstract class TypeHierarchyViewer extends ProblemTreeViewer { private OpenAction fOpen ; private HierarchyLabelProvider fLabelProvider ; public TypeHierarchyViewer ( Composite parent , IContentProvider contentProvider , TypeHierarchyLifeCycle lifeCycle , IWorkbenchPart part ) { super ( new Tree ( parent , SWT . SINGLE ) ) ; fLabelProvider = new HierarchyLabelProvider ( lifeCycle ) ; setLabelProvider ( new DecoratingRubyLabelProvider ( fLabelProvider , true ) ) ; setUseHashlookup ( true ) ; setContentProvider ( contentProvider ) ; setSorter ( new HierarchyViewerSorter ( lifeCycle ) ) ; fOpen = new OpenAction ( part . getSite ( ) ) ; addOpenListener ( new IOpenListener ( ) { public void open ( OpenEvent event ) { fOpen . run ( ) ; } } ) ; } public void setQualifiedTypeName ( boolean on ) { if ( on ) { fLabelProvider .'}]",setQualifiedTypeName(true); } else { fLabelProvider.setQualifiedTypeName(false); } } },4.8280377763259285e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . sink ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotSame ; import static org . junit . Assert . assertSame ; import java . util . List ; import java . util . Map ; import org'}]",".junit.Testpublic class SinkTest { @Test public void testSameObject () throws Exception { List < String > list = new ArrayList <>(); Sink < String > sink = new Sink <>( list ); assertEquals ( list, sink. getSink ()); } @Test public void testSameObjectAsList () throws Exception { List < String > list = new ArrayList <>(); Sink < String > sink = new Sink <>( list ); assertNotSame ( list, sink. getSink ()); } @Test public void testSameObjectAsListAsMap () throws Exception { List < String > list = new ArrayList <>(); Map < String, List < String >> map = new HashMap <>(); Sink < String > sink = new Sink <>( list, map ); assertSame ( map, sink. getSink ()); } }",0.00022680665717363598
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . HashMap ; import java . util . Map ; import'}]",java. security. AllPermission ; public class Marshalled implements java. io. Serializable { private static final long serialVersionUID = 1L ; private transient ByteArrayOutputStream bos ; private transient ObjectInputStream in ; public Marshalled ( ) { bos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream out = new ObjectOutputStream ( bos ) ; out. defaultWriteObject ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public Marshalled ( byte [ ] bytes ) { ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; try { ObjectInputStream in = new ObjectInputStream ( bis ) ; this. in = in ; in. defaultReadObject ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public byte [ ] getBytes ( ) { return bos. toByteArray ( ) ; } },0.0002244388200203409
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . Resetable ; import org . oddjob . Stateful ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . JobState ; import org . oddjob . state . StateEvent ; import org . oddjob . state . StateListener ; import junit . framework . TestCase ; public class StatefulTest extends TestCase { class Result implements StateListener { StateEvent event ; public void jobStateChange ( StateEvent event ) { this . event = event ; synchronized ( this ) { notifyAll ( ) ; } } } public void testState ( ) throws ArooaConversionException , InterruptedException { String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . run'}]",(); Result result = new Result(); oddjob.getState().addListener(result); result.join(); result.event.verify(StateEvent.State.READY));,5.217864953778152e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . renamefield . conditionchecks ; import junit . framework . Test ; import org . rubypeople . rdt . refactoring . tests . FileTestSuite ;'}]",public class TestRenameFieldConditionChecks extends FileTestSuite { @Test public void testRenameFieldConditionChecks() throws Exception { super. test(); } },5.3791323128245644e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBDefParamStmt extends SVDBStmt { public List < SVDBDefParamItem > fParamAssignList ; public SVDBDefParamStmt ( ) { super ( SVDBItemType . DefParamStmt ) ; fParamAssignList = new ArrayList < SVDBDefParamItem > ( ) ; } public'}]",void addParamAssign ( SVDBDefParamItem item ) { fParamAssignList. add ( item ) ; },4.77359309359544e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . fredbrunel . android . twitter ; import oauth . signpost . OAuth ; import oauth . signpost . exception . OAuthCommunicationException ; import oauth . signpost . exception . OAuthExpectationFailedException ; import oauth . signpost .'}]","http. HttpMethod; import twitter4j. APIException; import twitter4j. Twitter; import twitter4j. TwitterFactory; public class TwitterAPI { public static Twitter getTwitterInstance ( String consumerKey, String consumerSecret, String accessToken, String accessSecret ) { OAuth oauth = new OAuth ( consumerKey, consumerSecret, accessToken, accessSecret ) ; Twitter twitter = new TwitterFactory ( oauth ). getInstance ( ) ; return twitter ; } }",0.00013121474078851272
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . ds ; import java . util . List ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { public static final String PLUGIN_ID = ""<STR_LIT>"" ; private static Activator'}]",instance; private BundleContext context; public static Activator getInstance() { return instance; } public void start(BundleContext context) throws Exception { super.start(context); this.context = context; } public void stop(BundleContext context) throws Exception { this.context = null; super.stop(context); } public BundleContext getContext() { return context; } },0.00010642606091375828
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import org . oddjob . arooa . beanutils . MagicBeanDefinition ; import org . oddjob . arooa . beanutils . MagicBeanProperty ; import org . oddjob . arooa . reflect . ArooaClass ; import org . oddjob . arooa . reflect . BeanOverview ; import org . oddjob . arooa . reflect . PropertyAccessor ; public class ResultSetBeanFactory { private static AtomicInteger instance = new AtomicInteger ( ) ; private final ResultSet resultSet ; private final ArooaClass arooaClass ; private final PropertyAccessor accessor ; public'}]","static ResultSetBeanFactory getInstance(ResultSet resultSet, ArooaClass arooaClass, PropertyAccessor accessor) throws SQLException { return getInstance(resultSet, arooaClass, accessor, instance.getAndIncrement()); }",7.496187063857219e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamemethod . methoditems ; import org . jruby . ast . ArgumentNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; public class MethodNameArgumentItem extends MethodItem { private ArgumentNode nameNode ; public MethodNameArgumentItem ( ArgumentNode nameNode ) { this . nameNode ='}]",nameNode; } public ArgumentNode getNameNode() { return nameNode; } public void setNameNode(ArgumentNode nameNode) { this.nameNode = nameNode; } },6.215649869216262e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . compiler . fileio . io . Ex2Input ; import com . asakusafw . compiler . fileio . io . Ex2Output ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; @ DataModelKind ( ""<STR_LIT>"" ) @ ModelInputLocation ( Ex2Input . class ) @ ModelOutputLocation ( Ex2Output . class ) public class Ex2 implements DataModel < Ex2 > , Writable { private final LongOption sid = new LongOption ( ) ; private final IntOption value = new IntOption ( ) ; private final StringOption string = new StringOption ( ) ; @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void reset ( ) { this . sid . setNull ( ) ; this . value . setNull ( ) ; this . string . setNull ( ) ; } @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void copyFrom ( Ex2 other ) { this . sid . copyFrom ( other . sid ) ; this . value . copyFrom ( other . value ) ; this . string . copyFrom ( other . string ) ; } public long getSid ( ) { return this . sid . get ( ) ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setSid ( long value0 ) { this . sid . modify ( value0 ) ; } public LongOption getSidOption ( ) { return this . sid ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setSidOption ( LongOption option ) { this . sid . copyFrom ( option ) ; } public int getValue ( ) { return this . value . get ( ) ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setValue ( int value0 ) { this . value . modify ( value0 ) ; } public IntOption getValueOption ( ) { return this . value ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setValueOption ( IntOption option ) { this . value . copyFrom ( option ) ; } public Text getString ( ) { return this . string . get ( ) ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setString ( Text value0 ) { this . string . modify ( value0 ) ; } public StringOption getStringOption ( ) { return this . string ; } @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void setStringOption ( StringOption option ) { this . string . copyFrom ( option ) ; } @ Override public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( ""<STR_LIT:{>"" ) ; result . append ( ""<STR_LIT>"" ) ; result . append ( ""<STR_LIT>"" ) ; result . append ( this . sid ) ; result . append ( ""<STR_LIT>"" ) ; result . append ( this . value ) ; result . append ( ""<STR_LIT>"" ) ; result . append ( this . string ) ; result . append ( ""<STR_LIT:}>"" ) ;'}]",return result.toString();,3.3864444147329314e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . jface . dialogs . StatusDialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . dialogs . StatusInfo ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . DialogField ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . IDialogFieldListener ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . LayoutUtil ; import org . rubypeople . rdt . internal . ui . wizards . dialogfields . StringDialogField ; public class NewContainerDialog extends StatusDialog { private StringDialogField fContainerDialogField ; private StatusInfo fContainerFieldStatus ; private IFolder fFolder ; private IPath [ ] fExistingFolders ; private IProject fCurrProject ; public NewContainerDialog ( Shell parent , String title , IProject project , IPath [ ] existingFolders , CPListElement entryToEdit ) { super ( parent ) ; setTitle ( title ) ; fContainerFieldStatus = new StatusInfo ( ) ; SourceContainerAdapter adapter = new SourceContainerAdapter ( ) ; fContainerDialogField = new StringDialogField ( ) ; fContainerDialogField . setDialogFieldListener ( adapter ) ; fFolder = null ; fExistingFolders = existingFolders ; fCurrProject = project ; if ( entryToEdit == null ) { fContainerDialogField . setText ( ""<STR_LIT>"" ) ; } else { fContainerDialogField . setText ( entryToEdit . getPath ( ) . removeFirstSegments ( <NUM_LIT:1> ) . toString ( ) ) ; } } public void setMessage ( String message ) { fContainerDialogField . setLabelText ( message ) ; } protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; int widthHint = convertWidthInCharsToPixels ( <NUM_LIT> ) ; Composite inner = new Composite ( composite , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . marginHeight = <NUM_LIT:0> ; layout . marginWidth = <NUM_LIT:0> ; layout . numColumns = <NUM_LIT:1> ; inner . setLayout ( layout ) ; fContainerDialogField . doFillIntoGrid ( inner , <NUM_LIT:2> ) ; LayoutUtil . setWidthHint ( fContainerDialogField . getLabelControl ( null ) , widthHint ) ; LayoutUtil . setWidthHint ( fContainerDialogField . getTextControl ( null ) , widthHint ) ; LayoutUtil . setHorizontalGrabbing ( fContainerDialogField . getTextControl ( null ) ) ; fContainerDialogField . postSetFocusOnDialogField ( parent . getDisplay ( ) ) ; applyDialogFont ( composite ) ; return composite ; } private class SourceContainerAdapter implements IDialogFieldListener { public void dialogFieldChanged ( DialogField field ) { doStatusLineUpdate ( ) ; } } protected void doStatusLineUpdate ( ) { checkIfPathValid ( ) ; updateStatus ( fContainerFieldStatus ) ; } protected void checkIfPathValid ( ) { fFolder = null ; String pathStr = fContainerDialogField . getText ( ) ; if ( pathStr . length ( ) == <NUM_LIT:0> ) { fContainerFieldStatus . setError ( NewWizardMessages . NewContainerDialog_error_enterpath ) ; return ; }'}]",IPath path = fCurrProject. getFolder ( pathStr ) ; if ( path!= null &&! path. isAccessible ( ) ) { fContainerFieldStatus. setError ( NewWizardMessages. NewContainerDialog_error_invalidpath ) ; return ; } if ( fExistingFolders!= null ) { for ( IPath existingFolder : fExistingFolders ) { if ( existingFolder. isPrefixOf ( path ) ) { fContainerFieldStatus. setError ( NewWizardMessages. NewContainerDialog_error_existingfolder ) ; return ; } } } fContainerFieldStatus. setInfo ( NewWizardMessages. NewContainerDialog_info_validpath ) ; },0.000213572452871417
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . util ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import org . rubypeople . rdt . internal .'}]",".corext.util.Charset;public class StreamToReader extends Thread { private final Reader reader; private final InputStream stream; public StreamToReader(InputStream stream, Charset charset) { this.stream = stream; this.reader = new InputStreamReader(stream, charset); } @Override public void run() { try { reader.read(); } catch (IOException e) { e.printStackTrace(); } } }",0.00011099970508638885
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . directio . hadoop ; import org . apache . hadoop . conf . Configurable ; import org . apache . hadoop . conf . Configuration ; import com . asakusafw . runtime . directio . AbstractDirectDataSource ; import com . asakusafw . runtime . directio . MockDirectDataSource ; public class MockHadoopDataSource extends MockDirectDataSource implements Configurable { Configuration'}]",configuration = new Configuration ( ) ;,2.6376408020044163e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io . util ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . Random ; import org . apache . hadoop . io . WritableComparator ; import org . apache . hadoop . mapreduce . Partitioner ; import org . junit . Test ; import com . asakusafw . runtime . value . StringOption ; public class ShuffleKeyTest extends WritableTestRoot { @ Test public void serialize ( ) throws Exception { Mock mock = new Mock ( ""<STR_LIT:Hello>"" , ""<STR_LIT>"" ) ; byte [ ] serialized = ser ( mock ) ; Mock restored = des ( new Mock ( ) , serialized ) ; assertThat ( restored . toString ( ) , restored , is ( mock ) ) ; assertThat ( restored . compareTo ( mock ) , is ( <NUM_LIT:0> ) ) ; assertThat ( restored . getGroupObject ( ) . getAsString ( ) , is ( ""<STR_LIT:Hello>"" ) ) ; assertThat ( restored . getOrderObject ( ) . getAsString ( ) , is ( ""<STR_LIT>"" ) ) ; } @ Test public void compare ( ) throws Exception { Mock o11 = new Mock ( ""<STR_LIT:1>"" , ""<STR_LIT:1>"" ) ; Mock o12 = new Mock ( ""<STR_LIT:1>"" , ""<STR_LIT:2>"" ) ; Mock o21 = new Mock ( ""<STR_LIT:2>"" , ""<STR_LIT:1>"" ) ; Mock o22 = new Mock ( ""<STR_LIT:2>"" , ""<STR_LIT:2>"" ) ; assertThat ( cmp ( o11 , o11 ) , is ( <NUM_LIT:0> ) ) ; assertThat ( cmp ( o11 , o12 ) , is ( lessThan ( <NUM_LIT:0> ) ) ) ; assertThat ( cmp ( o12 , o11 ) , is ( greaterThan ( <NUM_LIT:0> ) ) ) ; assertThat ( cmp ( o12 , o21 ) , is ( lessThan ( <NUM_LIT:0> ) ) ) ; assertThat ( cmp ( o21 , o12 ) , is ( greaterThan ( <NUM_LIT:0> ) ) ) ; assertThat ( cmp ( o21 , o22 ) , is ( lessThan ( <NUM_LIT:0> ) ) ) ; assertThat ( cmp ( o22 , o21 ) , is ( greaterThan ( <NUM_LIT:0> ) ) ) ; } @ SuppressWarnings ( ""<STR_LIT:rawtypes>"" ) @ Test public void partition ( ) throws Exception { Partitioner < ShuffleKey , ? > part = new ShuffleKey . Partitioner ( ) ; Mock o11 = new Mock ( ""<STR_LIT:1>"" , ""<STR_LIT:1>"" ) ; Mock o12 = new Mock ( ""<STR_LIT:1>"" , ""<STR_LIT:2>"" ) ; Mock o21 = new Mock ( ""<STR_LIT:2>"" , ""<STR_LIT:1>"" ) ; Mock o22 = new Mock ( ""<STR_LIT:2>"" , ""<STR_LIT:2>"" ) ; assertThat ( part . getPartition ( o11 , null , <NUM_LIT:10> ) , equalTo ( part . getPartition ( o11 , null , <NUM_LIT:10> ) ) ) ; assertThat ( part . getPartition ( o11 , null , <NUM_LIT:10> ) , equalTo ( part . getPartition ( o12 , null , <NUM_LIT:10> ) ) ) ; assertThat ( part . getPartition ( o21 , null , <NUM_LIT:10> ) , equalTo ( part . getPartition ( o22 , null , <NUM_LIT:10> ) ) ) ; Random random = new Random ( <NUM_LIT> ) ; for ( int i = <NUM_LIT:0> ; i < <NUM_LIT> ; i ++ ) { Mock mock = new Mock ( String . valueOf ( random . nextInt ( ) ) , ""<STR_LIT>"" ) ; int value = part . getPartition ( mock , null ,'}]","<NUM_LIT:10>); if (value == 0) { throw new AssertionError(""Randomly generated shuffle key must be partitioned to 0""); } } }",8.023403274655069e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . db . index . SVDBIndexRegistry ; import net'}]",".sf.sveditor.core.SVDB; public class SVDBIndexTable extends javax.swing.table.AbstractTableModel { private SVDBIndexRegistry registry; public SVDBIndexTable(SVDB svdb, SVCorePlugin plugin) { registry = svdb.getIndexRegistry(); } @Override public int getRowCount() { return registry.getIndexList().size(); } @Override public int getColumnCount() { return 2; } @Override public String getColumnName(int columnIndex) { if (columnIndex == 0) { return ""Index Name""; } else if (columnIndex == 1) { return ""Index Type""; } else { return null; } } @Override public Class<?> getColumnClass(int columnIndex) { if (columnIndex == 0) { return String.class; } else if (columnIndex == 1) { return String.class; } else { return null; } } @Override public Object getValueAt(int rowIndex, int columnIndex) { ISVDBIndex index = registry.getIndexList().get(rowIndex); if (columnIndex == 0) { return index.getName(); } else if (columnIndex == 1) { return index.getType().toString(); } else { return null; } } @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex",0.000341547963514819
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . util ; import java . util . regex . Pattern ; import org . jruby . lexer . yacc . RubyYaccLexer ; public class NameValidator { private static final String localVariableRegexp = ""<STR_LIT>"" ; private static final String methodNameRegexp = ""<STR_LIT>"" ; private static final String classNameRegexp = ""<STR_LIT>"" ; public static boolean isValidLocalVariableName ( String name ) { return validate ( localVariableRegexp , name ) ; }'}]","public static boolean isValidMethodName(String name) { return validate(methodNameRegexp, name); } public static boolean isValidClassName(String name) { return validate(classNameRegexp, name); } private static boolean validate(String regexp, String name) { return Pattern.matches(regexp, name); }",9.165220848517934e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . concurrent . Callable ; public class CallableProxyGenerator extends ProxyGenerator < Callable <'}]",?> { },2.1556128706355054e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamemethod ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . SymbolNode ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . documentprovider . DocumentWithIncluding ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . INodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ;'}]",import org.rubypeople.rdt.refactoring.core.refactoringcontext.IRefactoringContext;,4.0621137940259166e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . io ; import java . io . File ; import junit . framework . TestCase ; import org . apache . commons . io . FileUtils ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OurDirs ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . ParentState ; public class DeleteJobTest extends TestCase { private static final Logger logger = Logger . getLogger ( DeleteJobTest . class ) ; File dir ; public void setUp ( ) throws Exception { logger . debug ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; OurDirs dirs = new OurDirs ( ) ; dir = dirs . relative ( ""<STR_LIT>"" ) ; if ( dir . exists ( ) ) { FileUtils . forceDelete ( dir ) ; } } public void testDeleteFile ( ) throws Exception { FileUtils . forceMkdir ( dir ) ; FileUtils . touch ( new File ( dir , ""<STR_LIT:a>"" ) ) ; WildcardSpec wild = new WildcardSpec ( new File ( dir , ""<STR_LIT:a>"" ) ) ; File [ ] found = wild . findFiles ( ) ; assertEquals ( <NUM_LIT:1> , found . length ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir . getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" +'}]","""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + dir. getPath ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT",0.0003600940134473664
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . testing . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . model . DataModel ; import com . asakusafw . runtime . model . DataModelKind ; import com . asakusafw . runtime . model . ModelInputLocation ; import com . asakusafw . runtime . model . ModelOutputLocation ; import com . asakusafw . runtime . model . PropertyOrder ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . testdriver . testing . io . SimpleInput ; import com . asakusafw . testdriver . testing . io . SimpleOutput ; @ DataModelKind ( ""<STR_LIT>"" ) @ ModelInputLocation ( SimpleInput . class ) @ ModelOutputLocation ( SimpleOutput . class ) @ PropertyOrder ( { ""<STR_LIT:data>"" } ) public class Simple implements DataModel < Simple > , Projection , Writable { private final StringOption data = new StringOption ( ) ; @ Override @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void reset ( ) { this . data . setNull ( ) ; }'}]","@ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public void readFields ( DataInput in ) throws IOException { this. data. readFields ( in ) ; }",6.535021536179863e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui ; import java . text . Collator ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IStorage ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . viewers . ContentViewer ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . ui . model . IWorkbenchAdapter ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . util . RubyModelUtil ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . packageview . LoadPathContainer ; import org . rubypeople . rdt . internal . ui . preferences . MembersOrderPreferenceCache ; public class RubyElementSorter extends ViewerSorter { private static final int PROJECTS = <NUM_LIT:1> ; private static final int SOURCEFOLDERROOTS = <NUM_LIT:2> ; private static final int SOURCEFOLDER = <NUM_LIT:3> ; private static final int RUBYSCRIPTS = <NUM_LIT:4> ; private static final int RESOURCEFOLDERS = <NUM_LIT:7> ; private static final int RESOURCES = <NUM_LIT:8> ; private static final int STORAGE = <NUM_LIT:9> ; private static final int IMPORT_CONTAINER = <NUM_LIT:11> ; private static final int IMPORT_DECLARATION = <NUM_LIT:12> ; private static final int MEMBERSOFFSET = <NUM_LIT:15> ; private static final int RUBYELEMENTS = <NUM_LIT> ; private static final int OTHERS = <NUM_LIT> ; private MembersOrderPreferenceCache fMemberOrderCache ; private Collator fNewCollator ; public RubyElementSorter ( ) { super ( null ) ; fMemberOrderCache = RubyPlugin . getDefault ( ) . getMemberOrderPreferenceCache ( ) ; fNewCollator = null ; } public final Collator getCollator ( ) { if ( collator == null ) { collator = Collator . getInstance ( ) ; } return collator ; } public int category ( Object element ) { if ( element instanceof IRubyElement ) { IRubyElement je'}]",= (IRubyElement) element; if (je.isProject()) { return PROJECTS; } else if (je.isSourceFolderRoot()) { return SOURCEFOLDERROOTS; } else if (je.isSourceFolder()) { return SOURCEFOLDER; } else if (je.isRubyScript()) { return RUBYSCRIPTS; } else if (je.isResourceFolder()) { return RESOURCEFOLDERS; } else if (je.isResource()) { return RESOURCES; } else if (je.isStorage()) { return STORAGE; } else if (je.isImportContainer()) { return IMPORT_CONTAINER; } else if (je.isImportDeclaration()) { return IMPORT_DECLARATION; } else if (je instanceof IMethod) { return MEMBERSOFFSET + ((IMethod) je).getMemberIndex(); } else if (je instanceof IType) { return MEMBERSOFFSET + ((IType) je).getMemberIndex(); } else { return OTHERS; } },0.0002904592895499086
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import java . util . List ; import com . asakusafw . utils . java . model . syntax . Attribute ; import com . asakusafw . utils . java . model . syntax . FieldDeclaration ; import com . asakusafw . utils . java . model . syntax . Javadoc ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . VariableDeclarator ; import com . asakusafw . utils . java . model . syntax . Visitor ; public final class FieldDeclarationImpl extends ModelRoot implements FieldDeclaration { private Javadoc javadoc ; private List < ?'}]","extends Attribute> attributes; private Type type; private String name; private VariableDeclarator variableDeclarator; private ModelKind kind; private List<? extends VariableDeclarator> variableDeclarators; private boolean isStatic; private boolean isFinal; private boolean isVolatile; private boolean isTransient; private boolean isSynchronized; private boolean isMuteable; private boolean isConst; private boolean isEnumConstant; public FieldDeclarationImpl(ModelRoot parent, Javadoc javadoc, List<? extends Attribute> attributes, Type type, String name, VariableDeclarator variableDeclarator, ModelKind kind) { super(parent); this.javadoc = javadoc; this.attributes = attributes; this.type = type; this.name = name; this.variableDeclarator = variableDeclarator; this.kind = kind; } public FieldDeclarationImpl(ModelRoot parent, Javadoc javadoc, List<? extends Attribute> attributes, Type type, String name, List<? extends VariableDeclarator> variableDeclarators, ModelKind kind) { super(parent); this.javadoc = javadoc; this.attributes = attributes; this.type = type; this.name = name; this.variableDeclarators = variableDeclarators; this.kind =",0.00034552216559740207
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . fileio . flow ; import com . asakusafw . compiler'}]",".core.model.File; import com.asakusafw.compiler.core.model.Job; import com.asakusafw.compiler.core.model.JobFlow; import com.asakusafw.compiler.core.model.JobFlowBuilder; import com.asakusafw.compiler.core.model.JobFlowEntry; import com.asakusafw.compiler.core.model.JobFlowEntryBuilder; import com.asakusafw.compiler.core.model.JobFlowEntryType; import com.asakusafw.compiler.core.model.JobFlowOptions; import com.asakusafw.compiler.core.model.JobFlowOptionsBuilder; import com.asakusafw.compiler.core.model.JobFlowSource; import com.asakusafw.compiler.core.model.JobFlowSourceBuilder; import com.asakusafw.compiler.core.model.JobFlowTarget; import com.asakusafw.compiler.core.model.JobFlowTargetBuilder; public class FlowBuilder { public static JobFlow build ( JobFlowBuilder builder ) { return new JobFlowBuilder ( builder ). build ( ) ; } public static JobFlow build ( JobFlowSource source, JobFlowTarget target, JobFlowOptions options ) { return build ( new JobFlowBuilder ( ). setSource ( new JobFlowSourceBuilder ( source ). build ( ) ). setTarget",0.0003328216728400867
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IPath ; import org . rubypeople . rdt . core . ILoadpathEntry ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyElementDelta ; import org . rubypeople . rdt . core . IRubyModel ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . ITypeHierarchy ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . core . WorkingCopyOwner ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . internal . core . RubyElement ; import org . rubypeople . rdt . internal . core . RubyModelManager ; import org . rubypeople . rdt . internal . core . RubyProject ; import org . rubypeople . rdt . internal . core . hierarchy . TypeHierarchy ; public class HierarchyScope implements IRubySearchScope { public IType focusType ; private String focusPath ; private WorkingCopyOwner owner ; private ITypeHierarchy hierarchy ; private IType [ ] types ; private HashSet resourcePaths ; private IPath [ ] enclosingProjectsAndJars ; protected IResource [ ] elements ; protected int elementCount ; public boolean needsRefresh ; public void add ( IResource element ) { if ( this . elementCount == this . elements . length ) { System . arraycopy ( this . elements , <NUM_LIT:0> , this . elements = new IResource [ this . elementCount * <NUM_LIT:2> ] , <NUM_LIT:0> , this . elementCount ) ; } elements [ elementCount ++ ] = element ; } public HierarchyScope ( IType type , WorkingCopyOwner owner ) throws RubyModelException { this . focusType = type ; this . owner = owner ; this . enclosingProjectsAndJars = this . computeProjectsAndJars ( type ) ; ISourceFolderRoot root = ( ISourceFolderRoot ) type . getSourceFolder ( ) . getParent ( ) ; this . focusPath = type . getPath ( ) . toString ( ) ; this . needsRefresh = true ; } private void buildResourceVector ( ) { HashMap resources = new HashMap ( ) ; HashMap paths = new HashMap ( ) ; this . types = this . hierarchy . getAllTypes ( ) ; IWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; for ( int i = <NUM_LIT:0> ; i < this . types . length ; i ++ ) { IType type = this . types [ i ] ; IResource resource = type . getResource ( ) ; if ( resource != null && resources . get ( resource ) == null ) { resources . put ( resource , resource ) ; add ( resource ) ; } ISourceFolderRoot root = ( ISourceFolderRoot ) type . getSourceFolder ( ) . getParent ( ) ; paths . put ( type . getRubyProject ( ) . getProject ( ) . getFullPath ( ) , type ) ; } this . enclosingProjectsAndJars = new IPath [ paths . size ( ) ] ; int i = <NUM_LIT:0> ; for ( Iterator iter = paths . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { this . enclosingProjectsAndJars [ i ++ ] = ( IPath ) iter . next ( ) ; } } private IPath [ ] computeProjectsAndJars ( IType type ) throws RubyModelException { HashSet set = new HashSet'}]",( ( IPath ) type. getRubyProject ( ). getProject ( ). getFullPath ( ) ) ; IPath [ ] enclosingProjectsAndJars = new IPath [ set. size ( ) ] ; int i = <NUM_LIT:0> ; for ( Iterator iter = set. iterator ( ) ; iter. hasNext ( ) ; ) { enclosingProjectsAndJars [ i ++ ] = ( IPath ) iter. next ( ) ; } return enclosingProjectsAndJars ; },0.00016845819045245924
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . refactoring . changes ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . ltk . core . refactoring . MultiStateTextFileChange ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . refactoring . core . Messages ; public final class MultiStateRubyScriptChange extends MultiStateTextFileChange { private final IRubyScript fUnit ; public MultiStateRubyScriptChange ( final String name , final IRubyScript unit ) { super ( name , ( IFile ) unit . getResource ( ) ) ; fUnit = unit ; setTextType ( ""<STR_LIT>"" ) ; } public final Object getAdapter ( final Class adapter ) { if ( IRubyScript . class . equals ( adapter ) ) return fUnit ; return super . getAdapter ( adapter ) ; } public final IRubyScript getRubyScript ( ) { return fUnit ; } public String getName ( ) { return Messages . format ( Messages . MultiStateRubyScriptChange_name_pattern , new String [ ] { fUnit'}]",".getName() }); } @Override public void update ( final IResource delta, final int kind, final int flags) throws CoreException { if (delta instanceof IFile) { super.update(delta, kind, flags); } else { super.update(delta, kind, flags); } } }",9.072325076708794e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import junit . framework . TestCase ; import org . oddjob . Oddjob ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . OddjobLookup ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignParser ; import org . oddjob . arooa . design . DesignSeedContext ; import org . oddjob . arooa . design . view . ViewMainHelper ; import org . oddjob . arooa . parsing . ArooaElement ; import org . oddjob . arooa . parsing . CutAndPasteSupport ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; public class RootDCTest extends TestCase { public void testPasteAndCut ( ) throws ArooaParseException { ArooaDescriptor descriptor = new OddjobDescriptorFactory ( ) . createDescriptor ( null ) ; DesignSeedContext context = new DesignSeedContext ( ArooaType . COMPONENT , ( new StandardArooaSession ( descriptor ) ) ) ; DesignInstance design = new RootDC ( ) . createDesign ( new ArooaElement ( ""<STR_LIT>"" ) , context ) ; String paste = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; CutAndPasteSupport cutAndPaste = new CutAndPasteSupport ( design . getArooaContext ( ) ) ; assertTrue ( cutAndPaste . supportsPaste ( ) ) ; cutAndPaste . paste ('}]","paste, 0, 0); ViewMainHelper.openView(design.getArooaContext()); } public void testCut ( ) throws ArooaParseException { ArooaDescriptor descriptor = new OddjobDescriptorFactory ( ). createDescriptor ( null ) ; DesignSeedContext context = new DesignSeedContext ( ArooaType. COMPONENT, ( new StandardArooaSession ( descriptor ) ) ) ; DesignInstance design = new RootDC ( ). createDesign ( new ArooaElement ( ""<STR_LIT>"" ), context ) ; CutAndPasteSupport cutAndPaste = new CutAndPasteSupport ( design. getArooaContext ( ) ) ; assertTrue ( cutAndPaste. supportsCut ( ) ) ; cutAndPaste. cut ( 0, 0); } }",0.00024147838884848335
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package mc . now . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . LinkedList ; import java . util . List ; import java . util . Queue ; import java . util . Random ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import javax . swing . JProgressBar ; import javax . swing . JTextArea ; import javax . swing . JTextPane ; import org . apache . commons . codec . digest . DigestUtils ; import org . apache . commons . io . FileUtils ; import org . apache . commons . io . FilenameUtils ; import org . apache . log4j . Logger ; public class InstallScript { private static final Logger LOGGER = Logger . getLogger ( InstallScript . class ) ; public static void repackMCJar ( File tmp , File mcjar ) throws IOException { byte [ ] dat = new byte [ <NUM_LIT:4> * <NUM_LIT> ] ; JarOutputStream jarout = new JarOutputStream ( FileUtils . openOutputStream ( mcjar ) ) ; Queue < File > queue = new LinkedList < File > ( ) ; for ( File f : tmp . listFiles ( ) ) { queue . add ( f ) ; } while ( ! queue . isEmpty ( ) ) { File f = queue . poll ( ) ; if ( f . isDirectory ( ) ) { for ( File child : f . listFiles ( ) ) { queue . add ( child ) ; } } else { String name = f . getPath ( ) . substring ( tmp . getPath ( ) . length ( ) + <NUM_LIT:1> ) ; name = name . replace ( ""<STR_LIT:\\\\>"" , ""<STR_LIT:/>"" ) ; if ( f . isDirectory ( ) && ! name . endsWith ( ""<STR_LIT:/>"" ) ) { name = name + ""<STR_LIT:/>"" ; } JarEntry entry = new JarEntry ( name ) ; jarout . putNextEntry ( entry ) ; FileInputStream in = new FileInputStream ( f ) ; int len = - <NUM_LIT:1> ; while ( ( len = in . read ( dat ) ) > <NUM_LIT:0> ) { jarout . write ( dat , <NUM_LIT:0> , len ) ; } in . close ( ) ; } jarout . closeEntry ( ) ; } jarout . close ( ) ; } public static void unpackMCJar ( File tmpdir , File mcjar ) throws IOException { byte [ ] dat = new byte [ <NUM_LIT:4> * <NUM_LIT> ] ; JarFile jar = new JarFile ( mcjar ) ; Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; String name = entry . getName ( ) ; if ( name . startsWith ( ""<STR_LIT>"" ) ) { continue ; } InputStream in = jar . getInputStream ( entry ) ; File dest = new File ( FilenameUtils . concat ( tmpdir . getPath ( ) , name ) ) ; if ( entry . isDirectory ( ) ) { LOGGER . warn ( ""<STR_LIT>"" ) ; dest . mkdirs ( ) ; } else if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { throw new IOException ( ""<STR_LIT>"" + name ) ; } } FileOutputStream out = new FileOutputStream ( dest ) ; int len = - <NUM_LIT:1> ; while ( ( len = in . read ( dat ) ) > <NUM_LIT:0> ) { out . write ( dat , <NUM_LIT:0> , len ) ; } out . flush ( ) ; out . close ( ) ; in . close ( ) ; } } private static File getTempDir ( ) throws IOException { Random rand = new Random ( ) ; String hex = Integer . toHexString ( rand . nextInt ( Integer . MAX_VALUE ) ) ; File tmp = new File ( FilenameUtils . concat ( InstallerConfig . getInstallerDir ( ) , hex + ""<STR_LIT:/>"" ) ) ; int t = <NUM_LIT:0> ; while ( tmp . exists ( ) && t < <NUM_LIT:10> ) { hex = Integer . toHexString ( rand . nextInt ( Integer . MAX_VALUE ) ) ; tmp = new File ( FilenameUtils . normalize ( ""<STR_LIT>"" + hex + ""<STR_LIT:/>"" ) ) ; t ++ ; } if ( tmp . exists ( ) ) { throw new IOException ( ""<STR_LIT>"" ) ; } return tmp ; } public static String preInstallCheck ( ) { try { InputStream mcJarIn = new FileInputStream ( InstallerConfig . getMinecraftJar ( ) ) ; String digest = DigestUtils . md5Hex ( mcJarIn ) ; mcJarIn . close ( ) ; boolean jarValid = InstallerConfig . getMinecraftJarMD5 ( ) . equalsIgnoreCase ( digest ) ; File modsDir = new File ( InstallerConfig . getMinecraftModsFolder ( ) ) ; boolean noMods = ! modsDir . exists ( ) || modsDir . listFiles ( ) . length == <NUM_LIT:0> ; String msg = null ; if ( ! jarValid ) { LOGGER . warn ( ""<STR_LIT>"" ) ; msg = String . format ( ""<STR_LIT>"" , InstallerConfig . getMinecraftVersion ( ) ) ; } if ( ! noMods ) { msg = ( msg == null ? ""<STR_LIT>"" : msg + ""<STR_LIT:n>"" ) + ""<STR_LIT>"" ; } return msg ; } catch ( Exception e ) { LOGGER . error ( ""<STR_LIT>"" , e ) ; return ""<STR_LIT>"" + e . getMessage ( ) ; } } public static void guiInstall ( JTextArea text , JProgressBar progressBar ) { try { createBackup ( ) ; } catch ( IOException e ) { text . append ( ""<STR_LIT>"" ) ; LOGGER . error ( ""<STR_LIT>"" , e ) ; return ; } File tmp ; try { tmp = getTempDir ( ) ; } catch ( IOException e ) { text . append ( ""<STR_LIT>"" ) ; LOGGER . error ( ""<STR_LIT>"" , e ) ; return ; } if ( ! tmp . mkdirs ( ) ) { text . append ( ""<STR_LIT>"" ) ; return ; } File mcDir = new File ( InstallerConfig . getMinecraftFolder ( ) ) ; File mcJar = new File ( InstallerConfig . getMinecraftJar ( ) ) ; File reqDir = new File ( InstallerConfig . getInstallerModsFolder ( ) ) ; int'}]","totalSize = reqDir.listFiles().length; 

( rest of the code remains the same )",6.692813585181388e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . filters ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface .'}]","viewers. ITableLabelProvider; import org.eclipse.jface.viewers.IStructuredSelection; import org.eclipse.jface.viewers.ViewerFilter; public class ColumnFilter implements ViewerFilter { @Override public boolean select(Viewer viewer, Object parentElement, IStructuredSelection selection, Object input) { // completion goes here } }",0.00010132739978032923
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . text ; import java . util . Vector ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . text . AbstractInformationControlManager ; import org . eclipse . jface . text . DefaultInformationControl ; import org . eclipse . jface . text . IAutoEditStrategy ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IInformationControl ; import org . eclipse . jface . text . IInformationControlCreator ; import org . eclipse . jface . text . ITextDoubleClickStrategy ; import org . eclipse . jface . text . ITextHover ; import org . eclipse . jface . text . contentassist . ContentAssistant ; import org . eclipse . jface . text . contentassist . IContentAssistProcessor ; import org . eclipse . jface . text . contentassist . IContentAssistant ; import org . eclipse . jface . text . formatter . IContentFormatter ; import org . eclipse . jface . text . formatter . MultiPassContentFormatter ; import org . eclipse . jface . text . hyperlink . IHyperlinkDetector ; import org . eclipse . jface . text . information . IInformationPresenter ; import org . eclipse . jface . text . information . IInformationProvider ; import org . eclipse . jface . text . information . InformationPresenter ; import org . eclipse . jface . text . presentation . IPresentationReconciler ; import org . eclipse . jface . text . presentation . PresentationReconciler ; import org . eclipse . jface . text . quickassist . IQuickAssistAssistant ; import org . eclipse . jface . text . reconciler . IReconciler ; import org . eclipse . jface . text . rules . DefaultDamagerRepairer ; import org . eclipse . jface . text . rules . ITokenScanner ; import org . eclipse . jface . text . source . IAnnotationHover ; import org . eclipse . jface . text . source . ISourceViewer ; import org . eclipse . jface . util . Assert ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . editors . text . TextSourceViewerConfiguration ; import org . eclipse . ui . texteditor . AbstractDecoratedTextEditorPreferenceConstants ; import org . eclipse . ui . texteditor . IDocumentProvider ; import org . eclipse . ui . texteditor . ITextEditor ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . formatter . DefaultCodeFormatterConstants ; import org . rubypeople . rdt . internal . corext . util . CodeFormatterUtil ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rubyeditor . IRubyScriptDocumentProvider ; import org . rubypeople . rdt . internal . ui . text . ContentAssistPreference ; import org . rubypeople . rdt . internal . ui . text . HTMLTextPresenter ; import org . rubypeople . rdt . internal . ui . text . IRubyColorConstants ; import org . rubypeople . rdt . internal . ui . text . IRubyPartitions ; import org . rubypeople . rdt . internal . ui . text . RubyAnnotationHover ; import org . rubypeople . rdt . internal . ui . text . RubyCompositeReconcilingStrategy ; import org . rubypeople . rdt . internal . ui . text . RubyDoubleClickSelector ; import org . rubypeople . rdt . internal . ui . text . RubyElementProvider ; import org . rubypeople . rdt . internal . ui . text . RubyOutlineInformationControl ; import org . rubypeople . rdt . internal . ui . text . RubyPartitionScanner ; import org . rubypeople . rdt . internal . ui . text . RubyPresentationReconciler ; import org . rubypeople . rdt . internal . ui . text . RubyReconciler ; import org . rubypeople . rdt . internal . ui . text . comment . CommentFormattingStrategy ; import org . rubypeople . rdt . internal . ui . text . comment . RubyCommentAutoIndentStrategy ; import org . rubypeople . rdt . internal . ui . text . correction . RubyCorrectionAssistant ; import org . rubypeople . rdt . internal . ui . text . hyperlinks . RubyHyperLinkDetector ; import org . rubypeople . rdt . internal . ui . text . ruby . AbstractRubyScanner ; import org . rubypeople . rdt . internal . ui . text . ruby . AbstractRubyTokenScanner ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyAutoIndentStrategy ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyColoringTokenScanner ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyCommentScanner ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyCompletionProcessor ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyFormattingStrategy ; import org . rubypeople . rdt . internal . ui . text . ruby . SingleTokenRubyScanner ; import org . rubypeople . rdt . internal . ui . text . ruby . hover . RubyEditorTextHoverDescriptor ; import org . rubypeople . rdt . internal . ui . text . ruby . hover . RubyEditorTextHoverProxy ; import org . rubypeople . rdt . internal . ui . text . ruby . hover . RubyInformationProvider ; import org . rubypeople . rdt . ui . actions . IRubyEditorActionDefinitionIds ; public class RubySourceViewerConfiguration extends TextSourceViewerConfiguration { protected RubyTextTools textTools ; protected ITextEditor fTextEditor ; private String fDocumentPartitioning ; private IColorManager fColorManager ; protected AbstractRubyTokenScanner fCodeScanner ; protected AbstractRubyScanner fMultilineCommentScanner , fSinglelineCommentScanner , fStringScanner , fRegexScanner , fCommandScanner ; private RubyDoubleClickSelector fRubyDoubleClickSelector ; public RubySourceViewerConfiguration ( IColorManager colorManager , IPreferenceStore preferenceStore , ITextEditor editor , String partitioning ) { super ( preferenceStore ) ; fColorManager = colorManager ; fTextEditor = editor ; fDocumentPartitioning = partitioning ; initializeScanners ( ) ; } public IContentFormatter getContentFormatter ( ISourceViewer sourceViewer ) { final MultiPassContentFormatter formatter = new MultiPassContentFormatter ( getConfiguredDocumentPartitioning ( sourceViewer ) , IDocument . DEFAULT_CONTENT_TYPE ) ;'}]","formatter.addFormatter(new CommentFormattingStrategy(), IDocument.COMMENT_CONTENT_TYPE); return formatter; } private void initializeScanners() { fCodeScanner = new RubyColoringTokenScanner(); fMultilineCommentScanner = new RubyCommentScanner(); fSinglelineCommentScanner = new RubyCommentScanner(); fStringScanner = new RubyStringScanner(); fRegexScanner = new RubyRegexScanner(); fCommandScanner = new RubyCommandScanner(); fRubyDoubleClickSelector = new RubyDoubleClickSelector(fCodeScanner); }",0.00018748471942427132
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . open_decl ; import java . util . List ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . Tuple ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . open_decl . OpenDeclUtils ; import net . sf . sveditor . core . scanutils . StringBIDITextScanner ; import net . sf . sveditor . core . tests . FileIndexIterator ; import net . sf . sveditor . core . tests . SVDBTestUtils ; public class TestOpenClass extends TestCase { public void testOpenVariableRef ( ) { String testname = ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; LogHandle log = LogFactory . getLogHandle ( testname ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBFile file = SVDBTestUtils . parse ( doc , ""<STR_LIT>"" ) ; SVDBTestUtils . assertNoErrWarn ( file ) ; SVDBTestUtils . assertFileHasElements ( file , ""<STR_LIT:foo>"" , ""<STR_LIT:bar>"" ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( doc ) ; int idx = doc . indexOf ( ""<STR_LIT>"" ) ; log . debug ( ""<STR_LIT>"" + idx ) ; scanner . seek ( idx + ""<STR_LIT>"" . length ( ) ) ; ISVDBIndexIterator target_index = new FileIndexIterator ( file ) ; List < Tuple < ISVDBItemBase , SVDBFile > > ret = OpenDeclUtils . openDecl_2 ( file , <NUM_LIT:4> , scanner , target_index ) ; log . debug ( ret . size ( ) + ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:1> , ret . size ( ) ) ; assertEquals ( SVDBItemType . VarDeclItem , ret . get ( <NUM_LIT:0> ) . first ( ) . getType ( ) ) ; assertEquals ( ""<STR_LIT>"" , SVDBItem . getName ( ret . get ( <NUM_LIT:0> ) . first ( ) ) ) ; LogFactory . removeLogHandle ( log ) ; } public void testOpenVariableRefTaskScope ( ) { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; String doc = ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVDBFile file = SVDBTestUtils . parse ( doc , ""<STR_LIT>"" ) ; SVDBTestUtils . assertNoErrWarn ( file ) ; SVDBTestUtils . assertFileHasElements ( file , ""<STR_LIT:abc>"" , ""<STR_LIT>"" ) ; StringBIDITextScanner scanner = new StringBIDITextScanner ( doc ) ; int idx = doc . indexOf ( ""<STR_LIT>"" ) ; log . debug ( ""<STR_LIT>"" + idx ) ; scanner . seek ( idx +'}]","""<STR_LIT>"".length());ISVDBIndexIterator target_index = new FileIndexIterator(file);List<Tuple<ISVDBItemBase, SVDBFile>> ret = OpenDeclUtils.openDecl_2(file, <NUM_LIT:4>, scanner, target_index);log.debug(ret.size() + ""<STR_LIT>"");assertEquals(<NUM_LIT:1>, ret.size());assertEquals(SVDBItemType.TaskScopeItem, ret.get(<NUM_LIT:0>).first().getType());assertEquals(""<STR_LIT>"", SVDBItem.getName(ret.get(<NUM_LIT:0>).first()));LogFactory.removeLogHandle(log);",0.00021157372164717247
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . ConstNode ; import org . jruby . ast . ModuleNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . ModuleNodeWrapper ; public abstract class ModuleNodeProvider { private interface IModuleAcceptor { boolean accept ( ModuleNodeWrapper wrapper ) ; } public static ModuleNodeWrapper getSelectedModuleNode ( Node root , int pos ) { ModuleNode module = ( ModuleNode ) SelectionNodeProvider . getSelectedNodeOfType ( root , pos , ModuleNode . class ) ; if ( module == null ) { return null ; } return createModuleNodeWrapper ( root , module ) ; } private static Collection < ModuleNodeWrapper > findModules ( IDocumentProvider doc , IModuleAcceptor acceptor ) { ArrayList < ModuleNodeWrapper > modules = new ArrayList < ModuleNodeWrapper > ( ) ; for ( String file : doc . getFileNames ( ) ) { for ( Node node : NodeProvider . getSubNodes ( doc . getRootNode ( file ) , ModuleNode . class ) ) { ModuleNode moduleNode = ( ModuleNode ) node ; ModuleNodeWrapper wrapper = createModuleNodeWrapper ( doc . getRootNode ( file ) , moduleNode ) ; if ( acceptor . accept'}]","(wrapper)) { modules.add(wrapper); } } return modules; } private static ModuleNodeWrapper createModuleNodeWrapper(Node root, ModuleNode module) { return new ModuleNodeWrapper(root, module); } public abstract void acceptModules(IDocumentProvider doc, IModuleAcceptor acceptor); }",9.424783881020627e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . model . syntax ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . syntax .'}]",Parameter;import com.asakusafw.utils.java.model.syntax.ParameterizedType;import com.asakusafw.utils.java.model.syntax.UnresolvedReference;public class UnresolvedReference extends Reference {... },7.214681293148578e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core ; import net . sf . sveditor . core . db . project . SVDBProjectData ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . IAdapterFactory ; public class SVProjectDataAdapter implements IAdapterFactory { @'}]","Override public Object adapt(Object adaptee, Class adaptableClass) { if (adaptableClass.equals(SVDBProjectData.class)) { IProject project = (IProject) adaptee; return new SVDBProjectDataAdapter(project); } return null; }",8.489080139853074e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . engine ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import junit . framework . TestCase ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . graph . test . NodeCreateUtils ; import com . hp . hpl . jena . sparql . core . Var ; import de . fuberlin . wiwiss . d2rq . algebra . AliasMap ; import de . fuberlin . wiwiss . d2rq . algebra . Attribute ; import de . fuberlin . wiwiss . d2rq . algebra . NodeRelation ; import de . fuberlin . wiwiss . d2rq . algebra . Relation ; import de . fuberlin . wiwiss . d2rq . algebra . RelationName ; import de . fuberlin . wiwiss . d2rq . algebra . TripleRelation ; import de . fuberlin . wiwiss . d2rq . expr . Equality ; import de . fuberlin . wiwiss . d2rq . expr . Expression ; import de . fuberlin . wiwiss . d2rq . sql . SQL ; public class GraphPatternTranslatorTest extends TestCase { private final static RelationName table1 = SQL . parseRelationName ( ""<STR_LIT>"" ) ; private final static Attribute table1id = SQL . parseAttribute ( ""<STR_LIT>"" ) ; private final static Attribute t1table1id = SQL . parseAttribute ( ""<STR_LIT>"" ) ; private final static Attribute t2table1id = SQL . parseAttribute ( ""<STR_LIT>"" ) ; private final static Var foo = Var . alloc ( ""<STR_LIT:foo>"" ) ; private final static Var type = Var . alloc ( ""<STR_LIT:type>"" ) ; private final static Var x = Var . alloc ( ""<STR_LIT:x>"" ) ; public void testEmptyGraphAndBGP ( ) { NodeRelation nodeRel = translate1 ( Collections . < Triple > emptyList ( ) , Collections . < TripleRelation > emptyList ( ) ) ; assertEquals ( Relation . TRUE , nodeRel . baseRelation ( ) ) ; assertEquals ( Collections . EMPTY_SET , nodeRel . variables ( ) ) ; } public void testEmptyGraph ( ) { assertNull ( translate1 ( ""<STR_LIT>"" , Collections . < TripleRelation > emptyList ( ) ) ) ; } public void testEmptyBGP ( ) { NodeRelation nodeRel = translate1 ( Collections . < Triple > emptyList ( ) , ""<STR_LIT>"" ) ; assertEquals ( Relation . TRUE , nodeRel . baseRelation ( ) ) ; assertEquals ( Collections . EMPTY_SET , nodeRel . variables ( ) ) ; } public void testAskNoMatch ( ) { assertNull ( translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; } public void testAskMatch ( ) { NodeRelation nodeRel = translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Relation r = nodeRel . baseRelation ( ) ; assertEquals ( Collections . singleton ( table1 ) , r . tables ( ) ) ; assertEquals ( Collections . EMPTY_SET , r . projections ( ) ) ; assertEquals ( Equality . createAttributeValue ( table1id , ""<STR_LIT:1>"" ) , r . condition ( ) ) ; assertEquals ( AliasMap . NO_ALIASES , r . aliases ( ) ) ; assertEquals ( Collections . EMPTY_SET , nodeRel . variables ( ) ) ; } public void testFindNoMatch ( ) { assertNull ( translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; } public void testFindFixedMatch ( ) { NodeRelation nodeRel = translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Relation r = nodeRel . baseRelation ( ) ; assertEquals ( Collections . singleton ( table1 ) , r . tables ( ) ) ; assertEquals ( Collections . EMPTY_SET , r . projections ( ) ) ; assertEquals ( Equality . createAttributeValue ( table1id , ""<STR_LIT:1>"" ) , r . condition ( ) ) ; assertEquals ( AliasMap . NO_ALIASES , r . aliases ( ) ) ; assertEquals ( Collections . singleton ( type ) , nodeRel . variables ( ) ) ; assertEquals ( ""<STR_LIT>"" , nodeRel . nodeMaker ( type ) . toString ( ) ) ; } public void testFindMatch ( ) { NodeRelation nodeRel = translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Relation r = nodeRel . baseRelation ( ) ; assertEquals ( Collections . singleton ( table1 ) , r . tables ( ) ) ; assertEquals ( Collections . singleton ( table1id ) , r . projections ( ) ) ; assertEquals ( Expression . TRUE , r . condition ( ) ) ; assertEquals ( AliasMap . NO_ALIASES , r . aliases ( ) ) ; assertEquals ( Collections . singleton ( x ) , nodeRel . variables ( ) ) ; assertEquals ( ""<STR_LIT>"" , nodeRel . nodeMaker ( x ) . toString ( ) ) ; } public void testConstraintInTripleNoMatch ( ) { assertNull ( translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ) ; } public void testConstraintInTripleMatch ( ) { NodeRelation nodeRel = translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Relation r = nodeRel . baseRelation ( ) ; assertEquals ( Collections . singleton ( table1 ) , r . tables ( ) ) ; assertTrue ( r . condition ( ) instanceof Equality ) ; assertEquals ( AliasMap . NO_ALIASES , r . aliases ( ) ) ; assertEquals ( Collections . singleton ( x ) , nodeRel . variables ( ) ) ; } public void testReturnMultipleMatchesForSingleTriplePattern ( ) { NodeRelation [ ] rels = translate ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertEquals ( <NUM_LIT:2> , rels . length ) ; } public void testMatchOneOfTwoPropertyBridges ( ) { NodeRelation nodeRel = translate1 ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; Relation r = nodeRel . baseRelation ( ) ; assertEquals ( Collections . EMPTY_SET , r . projections ( ) ) ; assertEquals ('}]","Collections.singletonList(table1id), r.tables());",5.223805859300708e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io . csv ; import java . nio . CharBuffer ; import java . text . ParsePosition ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import com . asakusafw . runtime . value . DateUtil ; abstract class DateFormatter { private static final DateFormatter [ ] BUILTIN = new DateFormatter [ ] { new Direct ( ) , } ; abstract String getPattern ( ) ; abstract int parse ( CharSequence sequence ) ; abstract CharSequence format ( int elapsedDate ) ; static DateFormatter newInstance ( String pattern ) { for ( DateFormatter f : BUILTIN ) { if ( f . getPattern ( ) . equals ( pattern ) ) { return f ; } } return new Default ( new SimpleDateFormat ( pattern ) ) ; } private static final class Default extends DateFormatter { private final SimpleDateFormat format ; private final Calendar calendarBuffer = Calendar . getInstance ( ) ; private final ParsePosition parsePositionBuffer = new ParsePosition ( <NUM_LIT:0> ) ; Default ( SimpleDateFormat format ) { assert format != null ; this . format = format ; } @ Override String getPattern ( ) { return format . toPattern ( ) ; } @ Override int parse ( CharSequence sequence ) { parsePositionBuffer . setIndex ( <NUM_LIT:0> ) ; parsePositionBuffer . setErrorIndex ( - <NUM_LIT:1> ) ; java . util . Date parsed = format . parse ( sequence . toString ( ) , parsePositionBuffer ) ; if ( parsePositionBuffer . getIndex ( ) == <NUM_LIT:0> ) { return - <NUM_LIT:1> ; } calendarBuffer . setTime ( parsed ) ; return DateUtil . getDayFromCalendar ( calendarBuffer ) ; } @ Override String format ( int elapsedDate ) { DateUtil . setDayToCalendar ( elapsedDate , calendarBuffer ) ; return format . format ( calendarBuffer . getTime ( ) ) ; } } private static final class Direct extends DateFormatter { private static final int POS_YEAR = <NUM_LIT:0> ; private static final int POS_MONTH = <NUM_LIT:4> ; private static final int POS_DAY = <NUM_LIT:6> ; private static final int LENGTH = <NUM_LIT:8> ; private final CharBuffer buffer ; Direct ( ) { buffer = CharBuffer . allocate ( LENGTH ) ; } @ Override String getPattern ( ) { return ""<STR_LIT>"" ; } @ Override CharSequence format ( int elapsedDate ) { int year = DateUtil . getYearFromDay ( elapsedDate ) ; int dayInYear = elapsedDate - DateUtil . getDayFromYear ( year ) ; int month = DateUtil . getMonthOfYear ( dayInYear , DateUtil . isLeap ( year ) ) ; int day = DateUtil . getDayOfMonth ( dayInYear , DateUtil . isLeap ( year ) ) ; putStringValue ( buffer , year , POS_YEAR , <NUM_LIT:4> ) ; putStringValue ( buffer , month , POS_MONTH , <NUM_LIT:2> ) ; putStringValue ( buffer , day , POS_DAY , <NUM_LIT:2> ) ; return buffer ; } @ Override int parse ( CharSequence sequence ) { if ( sequence .'}]",".length()!= LENGTH) { return -1; } int year = parseIntValue(sequence, POS_YEAR, <NUM_LIT:4>); if (year == -1) { return -1; } int month = parseIntValue(sequence, POS_MONTH, <NUM_LIT:2>); if (month == -1) { return -1; } int day = parseIntValue(sequence, POS_DAY, <NUM_LIT:2>); if (day == -1) { return -1; } return DateUtil.getDayFromYearMonthDay(year, month, day); } private static void putStringValue(CharBuffer buffer, int value, int offset, int len) { buffer.put((char) (value / 10000 + '0')); buffer.put((char) ((value / 1000) % 10 + '0')); buffer.put((char) ((value / 100) % 10 + '0')); buffer.put((char) ((value / 10) % 10 + '0')); buffer.put((char) (value % 10 + '0')); buffer.position(offset); buffer.limit(offset + len); } private static int parseIntValue(CharSequence sequence, int offset, int len) { int result =",0.000376103667568964
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . hierarchy ; import junit . framework . TestCase ; import net .'}]",".sf.sveditor.core.hierarchy.SVHierarchy; public class SVHierarchyTest extends TestCase { public SVHierarchyTest ( String testName ) { super ( testName ) ; } public void testNewHierarchy ( ) throws Exception { SVHierarchy hierarchy = new SVHierarchy ( ) ; } public void testSaveAndLoadHierarchy ( ) throws Exception { SVHierarchy hierarchy = new SVHierarchy ( ) ; hierarchy. save ( ""hierarchy.sv"" ) ; SVHierarchy loadedHierarchy = new SVHierarchy ( ""hierarchy.sv"" ) ; } public void testSaveAndLoadHierarchyWithParents ( ) throws Exception { SVHierarchy hierarchy = new SVHierarchy ( ) ; hierarchy. save ( ""hierarchy.sv"" ) ; SVHierarchy loadedHierarchy = new SVHierarchy ( ""hierarchy.sv"" ) ; loadedHierarchy. setParent ( ""parent"" ) ; } public void testGetNode ( ) { SVHierarchy hierarchy = new SVHierarchy ( ) ; hierarchy. addNode ( ""node"" ) ; } }",0.0002659480668703784
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules . schedules ; import java . text . ParseException ; import junit . framework . TestCase ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . standard . StandardFragmentParser ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . schedules . Interval ; import org . oddjob . schedules . IntervalTo ; import org . oddjob . schedules . Schedule ; import org . oddjob . schedules . ScheduleContext ; import org . oddjob . schedules . ScheduleResult ; import org . oddjob . schedules . SimpleScheduleResult ; public class TimeScheduleExamplesTest extends TestCase { public void testSimpleExample ( ) throws ArooaParseException , ParseException { OddjobDescriptorFactory df = new OddjobDescriptorFactory ( ) ; ArooaDescriptor descriptor = df . createDescriptor ( getClass ( ) . getClassLoader ( ) ) ; StandardFragmentParser parser = new StandardFragmentParser ( descriptor ) ; parser . parse ( new XMLConfiguration ( ""<STR_LIT>"" , getClass ( ) . getClassLoader ( ) ) ) ; TimeSchedule schedule = ( TimeSchedule ) parser . getRoot ( ) ; assertEquals ( ""<STR_LIT>"" , schedule . getFrom ( ) ) ; assertEquals ( ""<STR_LIT>"" , schedule . getTo ( ) ) ; ScheduleResult expected , result ; result = schedule . nextDue ( new ScheduleContext ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ) ; expected = new SimpleScheduleResult ( new IntervalTo ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) , null ) ; assertEquals ( expected ,'}]",result ); } },2.727243795374177e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . directio ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . junit . Test ; public class DirectDataSourceRepositoryTest { @ Test public void simple ( ) throws Exception { DirectDataSourceRepository repo = repo ( ""<STR_LIT>"" ) ; assertThat ( repo . getRelatedId ( ""<STR_LIT>"" ) , is ( ""<STR_LIT:id>"" ) ) ; assertThat ( repo . getRelatedId ( ""<STR_LIT>"" ) , is ( ""<STR_LIT:id>"" ) ) ; assertThat ( repo . getRelatedId ( ""<STR_LIT>"" ) , is ( ""<STR_LIT:id>"" ) ) ; assertThat ( repo . getContainerPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( repo . getContainerPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( repo . getContainerPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( repo . getComponentPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( repo . getComponentPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT:foo>"" ) ) ; assertThat ( repo . getComponentPath ( ""<STR_LIT>"" ) , is ( ""<STR_LIT>"" ) ) ; } @ Test public void root ( ) throws Exception { DirectDataSourceRepository repo = repo ( ""<STR_LIT>"" ) ; assertThat'}]","(repo.getRelatedId(""<STR_LIT>""), is(""<STR_LIT:id>""));",4.247782787221796e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . workingsets ; import org . eclipse . osgi . util . NLS ; public class WorkingSetMessages extends NLS { private static final String BUNDLE_NAME = WorkingSetMessages . class . getName ( ) ; public static String WorkingSetModel_others_name ; public static String ClearWorkingSetAction_text ; public static String ClearWorkingSetAction_toolTip ; public static String SelectWorkingSetAction_text ; public static String SelectWorkingSetAction_toolTip ; public static String EditWorkingSetAction_text ; public static String EditWorkingSetAction_toolTip ; public static String EditWorkingSetAction_error_nowizard_title ; public static String EditWorkingSetAction_error_nowizard_message ; public static String WorkingSetConfigurationDialog_title ; public static String WorkingSetConfigurationDialog_message ; public static String WorkingSetConfigurationDialog_new_label ; public static String WorkingSetConfigurationDialog_edit_label ; public static String WorkingSetConfigurationDialog_remove_label ; public static String WorkingSetConfigurationDialog_up_label ; public static String WorkingSetConfigurationDialog_down_label ; public static String WorkingSetConfigurationDialog_selectAll_label ; public static String WorkingSetConfigurationDialog_deselectAll_label ;'}]",public static String WorkingSetConfigurationDialog_add_label;,3.1580478947667014e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package br . com . caelum . vraptor . dash . interceptor ; import javax . servlet . http . HttpServletResponse ; import br . com . caelum . vraptor . InterceptionException ; import br . com . caelum . vraptor . Intercepts ; import br . com . caelum . vraptor . Lazy ; import br . com . caelum . vraptor . core . InterceptorStack ; import br . com . caelum . vraptor . interceptor . Interceptor ; import br . com . caelum . vraptor . ioc . RequestScoped ; import br . com . caelum . vraptor . resource . ResourceMethod ; @ Intercepts @ RequestScoped @ Lazy public class ContentTypeInterceptor implements Interceptor { private final HttpServletResponse response ; public ContentTypeInterceptor ( HttpServletResponse response ) { this . response = response ; } @ Override public boolean accepts ( ResourceMethod method ) { return method . getResource ( ) .'}]",getContentType ( )!= null ; } @ Override public void around ( ResourceMethod method ) throws InterceptionException { String contentType = method. getResource ( ). getContentType ( ) ; if ( contentType!= null ) { response. setContentType ( contentType ) ; } } @ Override public void handleException ( Exception ex ) { // do nothing } },0.00010616219776588366
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . actions ; import net . ggtools . grand . ui . graph . GraphControlerProvider ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . swt . SWT ; public class ZoomResetAction extends GraphControlerAction { private static final String DEFAULT_ACTION_NAME = ""<STR_LIT>"" ; private static final Log log = LogFactory . getLog ( ZoomResetAction . class ) ; public ZoomResetAction'}]","(String actionName) { super(actionName!= null? actionName : DEFAULT_ACTION_NAME); } @Override public void run() { GraphControlerProvider.getGraphControler().zoomReset(); log.info(""Zoom reset action performed""); } }",7.791098906647349e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . testing . flow ; import com . asakusafw . compiler . flow . testing . external . Ex1MockImporterDescription ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory . Update ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow'}]",". InPort ; import com. asakusafw. vocabulary. flow. Out ; import com. asakusafw. vocabulary. flow. OutPort ; import com. asakusafw. vocabulary. flow. Source ; import com. asakusafw. vocabulary. flow. Target ; import org. hamcrest. Matcher ; public class Ex1CompilerTest extends CompilerTest { @ Override protected FlowDescription createFlowDescription ( ) { return new Ex1MockImporterDescription ( ). setIn ( new In ( ""in"" ). setPort ( new InPort ( ""in"" ). setSource ( new Source ( ""ex1"" ). setOperator ( ExOperatorFactory. update ( new Ex1 ( ) ). setExport ( new Export ( ""out"" ). setPort ( new OutPort ( ""out"" ). setTarget ( new Target ( ""ex1"" ). setUpdate ( Update. of ( new Matcher < Ex1 > ( ) ) ) ) ) ) ) ) ) ; } }",0.0002960519622125732
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package jtwitter ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLEncoder ; import java . text . ParseException ; import javax . xml . parsers . ParserConfigurationException ; import oauth . signpost . exception . OAuthCommunicationException ; import oauth . signpost . exception . OAuthExpectationFailedException ; import oauth . signpost . exception . OAuthMessageSignerException ; import org . xml . sax . SAXException ; import com . fredbrunel . android . twitter . AuthConstants ; public class TwitterConnection implements AuthConstants { public static final String PUBLIC_TIMELINE_URL = ""<STR_LIT>"" ; public static final String FRIENDS_TIMELINE_URL = ""<STR_LIT>"" ; public static final String UPDATE_URL = ""<STR_LIT>"" ; private String accessKey = ""<STR_LIT>"" ; private String accessSecret = ""<STR_LIT>"" ; public TwitterConnection ( String accessKey , String accessSecret ) { this . accessKey = accessKey ; this . accessSecret = accessSecret ; } public TwitterResponse getPublicTimeline ( ) throws Exception { return new TwitterResponse ( ) . parse ( getResponseBody ( makeConnection ( PUBLIC_TIMELINE_URL ) ) ) ; } public TwitterResponse getFriendsTimeline ( ) throws ParseException , SAXException , ParserConfigurationException , IOException , TwitterConnectionException { return new TwitterResponse ( ) . parse ( getResponseBody ( makeAuthConnection ( FRIENDS_TIMELINE_URL ) ) ) ; } public InputStream getFriendsTimelineStream ( ) throws IOException { return makeAuthConnection ( FRIENDS_TIMELINE_URL ) . getInputStream ( ) ; } public TwitterResponse updateStatus ( String text ) throws ParseException , SAXException , ParserConfigurationException , IOException , TwitterConnectionException { if ( text . length ( ) > <NUM_LIT> ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } String status = ""<STR_LIT>"" + URLEncoder . encode ( text , ""<STR_LIT:UTF-8>"" ) ; HttpURLConnection conn = makeAuthConnection ( UPDATE_URL ) ; sendPostRequest ( conn , status ) ; return new TwitterResponse ( ) . parse ( getResponseBody ( conn ) ) ; } private HttpURLConnection makeConnection ( String resource ) throws IOException { HttpURLConnection conn = ( HttpURLConnection ) ( new URL ( resource ) . openConnection ( ) ) ; conn . setDoOutput ( true ) ; return conn ; } private HttpURLConnection makeAuthConnection ( String resource ) throws IOException { HttpURLConnection conn = makeConnection ( resource ) ; conn . setUseCaches ( false ) ; try { consumer . sign ( conn ) ; } catch ( OAuthMessageSignerException e ) { e . printStackTrace ( ) ; } catch ( OAuthExpectationFailedException e ) { e . printStackTrace ( ) ; } catch ( OAuthCommunicationException e ) { e . printStackTrace ( ) ; } return conn ; } private String getResponseBody ( HttpURLConnection conn ) throws TwitterConnectionException { try { BufferedReader rd = new'}]","BufferedReader ( new InputStreamReader ( conn. getInputStream ( ) ) ) ; String body = rd. lines ( ). collect ( StringBuilder :: new, StringBuilder :: append, StringBuilder :: append ) ; rd. close ( ) ; return body ; } catch ( IOException e ) { throw new TwitterConnectionException ( e ) ; } } private void sendPostRequest ( HttpURLConnection conn, String data ) throws IOException { OutputStreamWriter writer = new OutputStreamWriter ( conn. getOutputStream ( ) ) ; writer. write ( data ) ; writer. flush ( ) ; writer. close ( ) ; } }",0.00018224696359523705
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . bulkloader ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import com . asakusafw . vocabulary . model . TableModel ; @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) final class AttributeHelper { static String getTableName ( Class < ? > modelType ) { OriginalName original = modelType . getAnnotation ( OriginalName . class ) ; if ( original != null ) { return original . value ( ) ; } TableModel meta = modelType . getAnnotation ( TableModel . class ) ; if ( meta != null ) { return meta . name ( ) ; } StackTraceElement caller = getCaller ( ) ; throw new UnsupportedOperationException ( MessageFormat . format ( ""<STR_LIT>"" , caller . getClassName ( ) , OriginalName . class . getSimpleName ( ) , caller . getMethodName ( ) ) ) ; } static List <'}]","String > getAttributeNames(Class<?> modelType) { TableModel meta = modelType.getAnnotation(TableModel.class); if (meta!= null) { return meta.columns(); } StackTraceElement caller = getCaller(); throw new UnsupportedOperationException(MessageFormat.format(""<STR_LIT>"", caller.getClassName(), TableModel.class.getSimpleName(), caller.getMethodName())); } private static StackTraceElement getCaller() { return new Exception().getStackTrace()[2]; }",0.0001257483266003119
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . external ; import java . util . Collections ; import java . util . Set ; import com . asakusafw . compiler . flow . testing . model . ExJoined ; import com . asakusafw . compiler . testing . TemporaryInputDescription ; public class ExJoinedMockImporterDescription extends TemporaryInputDescription { @ Override public Class < ?'}]","> getTargetClass() { return ExJoined.class; } @Override public Set<ExJoined> getTargets() { Set<ExJoined> targets = super.getTargets(); if (targets == null) { targets = Collections.emptySet(); } return targets; } @Override public String getDescription() { return ""Mock importer description""; } }",9.926642921650584e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . view ; import java . awt . Component ; import javax . swing . ImageIcon ; import javax . swing . JTree ; import javax . swing . tree . DefaultTreeCellRenderer ; import org . oddjob . monitor . model . JobTreeNode ; public class JobTreeCellRenderer extends DefaultTreeCellRenderer { private static final long serialVersionUID = <NUM_LIT> ; public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , hasFocus ) ; JobTreeNode node = ( JobTreeNode ) value ;'}]",if ( node!= null ) { if ( node.isError() ) { setForeground(java.awt.Color.RED); } else if ( node.isRunning() ) { setForeground(java.awt.Color.GREEN); } else { setForeground(java.awt.Color.BLACK); } } return this; },8.760798743061861e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . phobos . script . util ; import javax . script . * ; import java . lang . reflect . * ; public class InterfaceImplementor { private Invocable engine ; public InterfaceImplementor ( Invocable engine ) { this . engine = engine ; } public class InterfaceImplementorInvocationHandler implements InvocationHandler { private Invocable engine ; private Object thiz ; public InterfaceImplementorInvocationHandler ( Invocable engine , Object thiz ) { this . engine = engine ; this . thiz = thiz ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws java . lang . Throwable { args = convertArguments ( method , args ) ; Object result = engine . invokeMethod ( thiz , method . getName ( ) , args ) ; return convertResult ( method , result ) ; } } public < T > T getInterface ( Object thiz , Class'}]","<T> T getInterface(Object thiz, Class<T> clazz) { return (T) java.lang.reflect.Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{clazz}, new InterfaceImplementor.InvocationHandler(engine, thiz)); }",7.668062704667879e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . graph ; import java . util . List ; import net . ggtools . grand . exceptions . GrandException ; import net . ggtools . grand . filters . FilterChain ; import net . ggtools . grand . filters . GraphFilter ; import net . ggtools . grand . graph . Graph ; import net . ggtools . grand . graph . GraphProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FilterChainModel implements GraphProducer { private static final Log log = LogFactory . getLog ( FilterChainModel . class ) ; private final FilterChain filterChain ; private Graph graph = null ; private GraphModel graphModel ; public FilterChainModel ( final GraphModel graphModel ) { filterChain = new FilterChain ( ) ; this . graphModel = graphModel ; filterChain . setProducer ( graphModel ) ; } public void addFilterFirst ( final GraphFilter newFilter ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ""<STR_LIT>"" + newFilter ) ; } filterChain . addFilterFirst ( newFilter ) ;'}]","} public void addFilterLast(final GraphFilter newFilter) { if (log.isDebugEnabled()) { log.debug(""<STR_LIT>"" + newFilter); } filterChain.addFilterLast(newFilter); } public void setGraph(Graph graph) { this.graph = graph; } public Graph getGraph() { return graph; } public void setGraphProducer(GraphProducer producer) { filterChain.setProducer(producer); } public GraphProducer getGraphProducer() { return filterChain.getProducer(); } public void setFilterChain(FilterChain filterChain) { this.filterChain = filterChain; } public FilterChain getFilterChain() { return filterChain; } }",0.00018281331148375373
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . tools . doclet . utils ; import junit . framework . TestCase ; import org . mockito . Mockito ; import org . oddjob . Helper ; import com . sun . javadoc . ClassDoc ; import com . sun . javadoc . PackageDoc ; import com . sun . javadoc . Tag ; public class XMLResourceTagProcessorTest extends TestCase { public void testProcessTag ( ) { PackageDoc packageDoc = Mockito . mock ( PackageDoc . class ) ; Mockito . when ( packageDoc . name ( ) ) . thenReturn ( ""<STR_LIT>"" ) ; ClassDoc classDoc = Mockito . mock ( ClassDoc . class ) ; Mockito . when ( classDoc . containingPackage'}]","( ) ). thenReturn ( packageDoc ) ; Tag tag = Mockito. mock ( Tag. class ) ; Mockito. when ( tag. kind ( ) ). thenReturn ( Helper. XML_RESOURCE ) ; XMLResourceTagProcessor processor = new XMLResourceTagProcessor ( ) ; processor. processTag ( tag, classDoc ) ; } }",0.0001044386757751132
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . util . Assert ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . ide . IDE ; import org . eclipse . ui . model . IWorkbenchAdapter ; import org . rubypeople . rdt . core . Flags ; import org . rubypeople . rdt . core . IMember ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . ERBScript ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . RubyUIMessages ; import org . rubypeople . rdt . ui . RubyElementImageDescriptor ; import org . rubypeople . rdt . ui . viewsupport . ImageDescriptorRegistry ; public class RubyElementImageProvider { public final static int OVERLAY_ICONS = <NUM_LIT> ; public final static int SMALL_ICONS = <NUM_LIT> ; public final static int LIGHT_TYPE_ICONS = <NUM_LIT> ; public static final Point SMALL_SIZE = new Point ( <NUM_LIT:16> , <NUM_LIT:16> ) ; public static final Point BIG_SIZE = new Point ( <NUM_LIT> , <NUM_LIT:16> ) ; private static ImageDescriptor DESC_OBJ_PROJECT_CLOSED ; private static ImageDescriptor DESC_OBJ_PROJECT ; { ISharedImages images = RubyPlugin . getDefault ( ) . getWorkbench ( ) . getSharedImages ( ) ; DESC_OBJ_PROJECT_CLOSED = images . getImageDescriptor ( IDE . SharedImages . IMG_OBJ_PROJECT_CLOSED ) ; DESC_OBJ_PROJECT = images . getImageDescriptor ( IDE . SharedImages . IMG_OBJ_PROJECT ) ; } private ImageDescriptorRegistry fRegistry ; public RubyElementImageProvider ( ) { fRegistry = null ; } public Image getImageLabel ( Object element , int flags ) { return getImageLabel ( computeDescriptor ( element , flags ) ) ; } private Image getImageLabel ( ImageDescriptor descriptor ) { if ( descriptor == null ) return null ; return getRegistry ( ) . get ( descriptor ) ; } private ImageDescriptorRegistry getRegistry ( ) { if ( fRegistry == null ) { fRegistry = RubyPlugin . getImageDescriptorRegistry ( ) ; } return fRegistry ; } private ImageDescriptor computeDescriptor ( Object element , int flags ) { if ( element instanceof IRubyElement ) { return getRubyImageDescriptor ( ( IRubyElement ) element , flags ) ; } else if ( element instanceof IAdaptable ) { return getWorkbenchImageDescriptor ( ( IAdaptable ) element , flags ) ; } else if ( element instanceof IFile ) { IFile file = ( IFile ) element ; if ( RubyCore . isRubyLikeFileName ( file . getName ( ) ) ) { return getCUResourceImageDescriptor ( file , flags ) ; } return getWorkbenchImageDescriptor ( file , flags ) ; } return null ; } private static boolean showOverlayIcons ( int flags ) { return ( flags & OVERLAY_ICONS ) != <NUM_LIT:0> ; } private static boolean useSmallSize ('}]","int flags) { return (flags & SMALL_ICONS)!= <NUM_LIT:0>; } private ImageDescriptor getRubyImageDescriptor(IRubyElement element, int flags) { if (element instanceof IMember) { IMember member = (IMember) element; if (showOverlayIcons(flags)) { return RubyElementImageDescriptor.IMG_RUBY_METHOD_OVERLAY; } else { return RubyElementImageDescriptor.IMG_RUBY_METHOD; } } else if (element instanceof IMethod) { IMethod method = (IMethod) element; if (showOverlayIcons(flags)) { return RubyElementImageDescriptor.IMG_RUBY_METHOD_OVERLAY; } else { return RubyElementImageDescriptor.IMG_RUBY_METHOD; } } else if (element instanceof IType) { IType type = (IType) element; if (showOverlayIcons(flags)) { return RubyElementImageDescriptor.IMG_RUBY_TYPE_OVERLAY; } else { return RubyElementImageDescriptor.IMG_RUBY_TYPE; } } else if (element instanceof IRubyProject) { IRubyProject project = (IRubyProject) element; if (showOverlayIcons(flags)) { return RubyElementImageDescriptor.IMG_RUBY_PROJECT_OVERLAY; } else { return RubyElementImageDescriptor.",1.4121392572872223e-06
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . pmd ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class Tokens { private List tokens = new ArrayList ( ) ; public void add ( TokenEntry tokenEntry ) { this . tokens . add ( tokenEntry ) ; } public Iterator iterator ( ) { return tokens . iterator ( ) ; }'}]",public TokenEntry nextToken ( ) { return ( TokenEntry ) tokens. iterator ( ). next ( ) ; },4.560090501338816e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . explorer ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . index . ISVDBIndexChangeListener ; import net . sf . sveditor . core . db . project . ISVDBProjectSettingsListener ; import net . sf . sveditor . core . db . project . SVDBProjectData ; import net . sf . sveditor . core . dirtree . SVDBDirTreeNode ; import net . sf . sveditor . core . job_mgr . IJob ; import net . sf . sveditor . core . job_mgr . IJobMgr ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . jobs . ILock ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . viewers . IElementComparer ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . widgets . Display ; public class ProjectPathsContentProvider implements ITreeContentProvider , ISVDBProjectSettingsListener , ISVDBIndexChangeListener { private List < ProjectPathsData > fProjectDataMap ; private static Object NO_ELEMENTS [ ] = new Object [ <NUM_LIT:0> ] ; private Viewer fViewer ; private boolean fRefreshQueued ; private IElementComparer fDefaultComparer ; public ProjectPathsContentProvider ( ) { fProjectDataMap = new ArrayList < ProjectPathsData > ( ) ; } public Object [ ] getChildren ( Object parentElement ) { if ( parentElement instanceof IProject && ( ( IProject ) parentElement ) . getFile ( ""<STR_LIT>"" ) . exists ( ) ) { SVDBProjectData pd = SVCorePlugin . getDefault ( ) . getProjMgr ( ) . getProjectData ( ( IProject ) parentElement ) ; ProjectPathsData paths_d = getProjectPathsData ( pd ) ; if ( paths_d == null ) { return new Object [ <NUM_LIT:0> ] ; } else { return new Object [ ] { paths_d } ; } } else if ( parentElement instanceof IProjectPathsData ) { return ( ( IProjectPathsData ) parentElement ) . getChildren ( parentElement ) ; } else if ( parentElement instanceof SVDBDirTreeNode ) { return ( ( SVDBDirTreeNode ) parentElement ) . getChildren ( ) . toArray ( ) ; } return NO_ELEMENTS ; } private ProjectPathsData getProjectPathsData ( final SVDBProjectData pd ) { int idx ; synchronized ( fProjectDataMap ) { ProjectPathsData tmp = new ProjectPathsData ( pd , false ) ; idx = fProjectDataMap . indexOf ( tmp ) ; } if ( idx == <NUM_LIT:0> ) { return fProjectDataMap . get ( idx ) ; } else if ( idx == - <NUM_LIT:1> ) { synchronized ( fProjectDataMap ) { while ( fProjectDataMap . size ( ) >= <NUM_LIT:15> ) { ProjectPathsData paths_d = fProjectDataMap . remove ( <NUM_LIT:0> ) ; removeListeners ( paths_d . getProjectData ( ) ) ; } } IJobMgr job_mgr = SVCorePlugin . getJobMgr ( ) ; IJob job = job_mgr . createJob ( ) ; job . init ( ""<STR_LIT>"" , new Runnable ( ) { public void run ( ) { ProjectPathsData paths_d = new ProjectPathsData ( pd ) ; addListeners ( pd ) ; synchronized ( fProjectDataMap ) { fProjectDataMap . add ( paths_d ) ; } Display d = fViewer . getControl ( ) . getDisplay ( ) ; if ( d != null && ! d . isDisposed ( ) && !'}]","fViewer.getControl().isDisposed()) { fViewer.getControl().getDisplay().asyncExec(new Runnable() { public void run() { fViewer.refresh(); } }); } } }, true, null ); job_mgr.schedule(job); return null; } else { return fProjectDataMap.get(idx); } } private void addListeners(SVDBProjectData pd) { pd.addProjectSettingsListener(this); pd.addIndexChangeListener(this); } private void removeListeners(SVDBProjectData pd) { pd.removeProjectSettingsListener(this); pd.removeIndexChangeListener(this); } public void inputChanged(Viewer v, Object oldInput, Object newInput) { } public void dispose() { } public void refresh() { } public void refresh(Object parentElement) { } public void refresh(Object[] children) { } public void refresh(Object[] children, Object parentElement) { } public void refreshChildren(Object parentElement) { } public void refreshChildren(Object parentElement, Object[] children) { } public void refreshChildren(Object parentElement, Object[] children, boolean forceRefresh) { } public void refreshChildren(Object parentElement, Object[] children, boolean forceRefresh, boolean queueRefresh) { } public void refreshChildren(Object parentElement, Object[] children, boolean forceRefresh, boolean queue",0.0003770921143798788
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . debug . core . tests ; import junit . framework . TestSuite ; public class FTC_Single extends TestSuite { public static junit . framework . TestSuite suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( new FTC_RubyDebugCommunicationTest ( ""<STR_LIT>"" ) ) ; return suite ; } public static TestSuite classicSuite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_ClassicDebuggerCommunicationTest ( ""<STR_LIT>"" ) ) ; return suite ; } public static TestSuite rdebugSuite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( new FTC_RubyDebugCommunicationTest ( ""<STR_LIT>"" ) ) ; suite . addTest ( new FTC_RubyDebugCommunicationTest ( ""<STR_LIT>"" ) ) ;'}]","suite.addTest(new FTC_RubyDebugCommunicationTest(""<STR_LIT>""));",4.093688986705559e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBChildItem ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBStmt extends SVDBChildItem { protected SVDBStmt ( SVDBItemType type ) { super ( type ) ; } @ Override public void init ( ISVDBItemBase other ) { super . init ( other ) ; } @ Override public boolean equals ( Object obj ) { return super . equals ( obj ) ; } @ Override public SVDBStmt duplicate ( ) { return ( SVDBStmt ) super . duplicate ( ) ; } @ Override public boolean equals ( ISVDBItemBase obj , boolean full ) { return super . equals ( obj , full ) ; } public static'}]","SVDBStmt create(SVDBItemType type, ISVDBItemBase other);",3.825448476621257e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob ; import org . oddjob . structural . StructuralListener ; public class MockStructural implements Structural { public void addStructuralListener ( StructuralListener listener ) { throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } public void removeStructuralListener ( StructuralListener listener ) {'}]","throw new RuntimeException ( ""<STR_LIT>"" + getClass ( ) ) ; } }",3.635235847161777e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . typehierarchy ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . util . Assert ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; public class ToggleViewAction extends Action { private TypeHierarchyViewPart fViewPart ; private int fViewerIndex ; public ToggleViewAction ( TypeHierarchyViewPart v , int viewerIndex ) { super ( ""<STR_LIT>"" , AS_RADIO_BUTTON ) ; String contextHelpId = null ; if ( viewerIndex == TypeHierarchyViewPart . VIEW_ID_SUPER ) { setText ( TypeHierarchyMessages . ToggleViewAction_supertypes_label ) ; contextHelpId = IRubyHelpContextIds . SHOW_SUPERTYPES ; setDescription ( TypeHierarchyMessages . ToggleViewAction_supertypes_description ) ; setToolTipText ( TypeHierarchyMessages . ToggleViewAction_supertypes_tooltip ) ; RubyPluginImages . setLocalImageDescriptors ( this , ""<STR_LIT>"" ) ; } else if ( viewerIndex == TypeHierarchyViewPart . VIEW_ID_SUB ) { setText ( TypeHierarchyMessages . ToggleViewAction_subtypes_label ) ; contextHelpId = IRubyHelpContextIds . SHOW_SUBTYPES ; setDescription ( TypeHierarchyMessages'}]",".ToggleViewAction_subtypes_description); setToolTipText(TypeHierarchyMessages.ToggleViewAction_subtypes_tooltip); RubyPluginImages.setLocalImageDescriptors(this, ""<STR_LIT>""); } fViewPart = v; fViewerIndex = viewerIndex; } @Override public void run() { if (fViewPart!= null) { fViewPart.toggleViewer(fViewerIndex); } } }",4.413156744872415e-07
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import java . util . List ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . dialogs . PopupDialog ; import org . eclipse . jface . text . IInformationControl ; import org . eclipse . jface . text . IInformationControlExtension ; import org . eclipse . jface . text . IInformationControlExtension2 ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . FocusListener ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . KeyListener ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseMoveListener ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . FontMetrics ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . ui . IKeyBindingService ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . commands . ActionHandler ; import org . eclipse . ui . commands . HandlerSubmission ; import org . eclipse . ui . commands . ICommand ; import org . eclipse . ui . commands . ICommandManager ; import org . eclipse . ui . commands . IKeySequenceBinding ; import org . eclipse . ui . commands . Priority ; import org . eclipse . ui . contexts . IWorkbenchContextSupport ; import org . eclipse . ui . keys . KeySequence ; import org . rubypeople . rdt . core . IParent ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . actions . OpenActionUtil ; import org . rubypeople . rdt . internal . ui . util . StringMatcher ; import org . rubypeople . rdt . ui . actions . CustomFiltersActionGroup ; public abstract class AbstractInformationControl extends PopupDialog implements IInformationControl , IInformationControlExtension , IInformationControlExtension2 , DisposeListener { protected class NamePatternFilter extends ViewerFilter { public NamePatternFilter ( ) { } public boolean select ( Viewer viewer , Object parentElement , Object element ) { StringMatcher matcher = getMatcher ( ) ; if ( matcher == null || ! ( viewer instanceof TreeViewer ) ) return true ; TreeViewer treeViewer = ( TreeViewer ) viewer ; String matchName = ( ( ILabelProvider ) treeViewer . getLabelProvider ( ) ) . getText ( element ) ; if ( matchName != null && matcher . match ( matchName ) ) return true ; return hasUnfilteredChild ( treeViewer , element ) ; } private boolean hasUnfilteredChild ( TreeViewer viewer , Object element ) { if ( element instanceof IParent ) { Object [ ] children = ( ( ITreeContentProvider ) viewer . getContentProvider ( ) ) . getChildren ( element ) ; for ( int i = <NUM_LIT:0> ; i < children . length ; i ++ ) if ( select ( viewer , element , children [ i ] ) ) return true ; } return false ; } } private Text fFilterText ; private TreeViewer fTreeViewer ; protected StringMatcher fStringMatcher ; private ICommand fInvokingCommand ; private KeySequence [ ] fInvokingCommandKeySequences ; private Composite fViewMenuButtonComposite ; private CustomFiltersActionGroup fCustomFiltersActionGroup ; private IKeyBindingService fKeyBindingService ; private String [ ] fKeyBindingScopes ; private IAction fShowViewMenuAction ; private HandlerSubmission fShowViewMenuHandlerSubmission ; private int fTreeStyle ; public AbstractInformationControl ( Shell parent , int shellStyle , int treeStyle , String invokingCommandId , boolean showStatusField ) { super ( parent , shellStyle , true , true , true , true , null , null ) ; if ( invokingCommandId != null ) { ICommandManager commandManager = PlatformUI . getWorkbench ( ) . getCommandSupport ( ) . getCommandManager ( ) ; fInvokingCommand = commandManager . getCommand ( invokingCommandId ) ; if ( fInvokingCommand != null && ! fInvokingCommand . isDefined ( ) ) fInvokingCommand = null ; else getInvokingCommandKeySequences ( ) ; } fTreeStyle = treeStyle ; if ( hasHeader ( ) ) setTitleText ( ""<STR_LIT>"" ) ; setInfoText ( ""<STR_LIT>"" ) ; create ( ) ; setInfoText ( getStatusFieldText ( ) ) ; } protected Control createDialogArea ( Composite parent ) { fTreeViewer = createTreeViewer ( parent , fTreeStyle ) ; fCustomFiltersActionGroup = new CustomFiltersActionGroup ( getId ( ) , fTreeViewer ) ; final Tree tree = fTreeViewer . getTree ( ) ; tree . addKeyListener ( new KeyListener ( ) { public void keyPressed ( KeyEvent e ) { if ( e . character == <NUM_LIT> ) dispose ( ) ; } public void keyReleased ( KeyEvent e ) { } } ) ; tree . addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ('}]","SelectionEvent e) { IStructuredSelection selection = ( IStructuredSelection ) e. getData ( ) ; if ( selection == null || selection. size ( ) == 0 ) return ; ITreeContentProvider contentProvider = ( ITreeContentProvider ) fTreeViewer. getContentProvider ( ) ; Object parent = selection. getFirstElement ( ) ; Object [ ] children = contentProvider. getChildren ( parent ) ; fTreeViewer. setSelection ( selection ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { } } ) ; return new Composite ( parent, SWT. NONE ) ; }",0.00022345654723413016
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; public class SVDBTypeInfoFwdDecl extends SVDBTypeInfo { public String fTypeClass ; public SVDBTypeInfoFwdDecl ( ) { this ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } public SVDBTypeInfoFwdDecl ('}]","String fTypeClass, String fTableName) { super(); this.fTypeClass = fTypeClass; this.fTableName = fTableName; } }",5.8866664995491536e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . ui . actions ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PlatformUI ; import com . aptana . rdt . AptanaRDTPlugin ; public class CleanupGemsActionDelegate implements IObjectActionDelegate , IViewActionDelegate { private IWorkbenchPart targetPart ; public void setActivePart ('}]","IAction action, IWorkbenchPart targetPart ) { this. targetPart = targetPart ; } public void run ( IAction action ) { if ( targetPart!= null ) { cleanupGems ( ) ; } } public void selectionChanged ( IAction action, ISelection selection ) { } public void runAs ( IAction action ) { } public void run ( IAction action, IEditorPart editor ) { } public void run ( IAction action, IObject target ) { } public void run ( IAction action, IViewPart view ) { } public void run ( IAction action, IWorkbenchPart target ) { } private void cleanupGems ( ) { // cleanup gems code here } }",0.00020325623999012133
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import junit . framework . TestCase ; import org . eclipse . jface . text . DefaultLineTracker ; import org . eclipse . jface . text . Document ; import org . eclipse . jface . text . DocumentCommand ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor . TabConverter ; public class TC_TabConverter extends TestCase { private static final String TEST_TEXT = ""<STR_LIT>"" ; private static class TestDocumentCommand extends DocumentCommand { public TestDocumentCommand ( int offset ) { this . offset = offset ; } } public void testSpacesForTab ( ) { verifyTabExpansion ( <NUM_LIT:4> , <NUM_LIT:0> , <NUM_LIT:4> ) ; verifyTabExpansion ( <NUM_LIT:4> , <NUM_LIT:1> , <NUM_LIT:3> ) ; verifyTabExpansion ( <NUM_LIT:4> , <NUM_LIT:2> , <NUM_LIT:2> ) ; verifyTabExpansion ( <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:1> ) ; verifyTabExpansion ( <NUM_LIT:4> , <NUM_LIT:4>'}]",", <NUM_LIT:0> ) ; } private void verifyTabExpansion ( int offset, int tabSize, int expected ) { Document document = new Document ( TEST_TEXT ) ; DocumentCommand command = new TestDocumentCommand ( offset ) ; int result = TabConverter. convert ( document, command, tabSize ) ; assertEquals ( expected, result ) ; } }",0.00011439160770886002
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx . general ; import java . lang . management . ManagementFactory ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import junit . framework . TestCase ; import org . oddjob . arooa . beanutils . BeanUtilsPropertyAccessor ; import org . oddjob . arooa . convert . DefaultConverter ; import org . oddjob . arooa . life . ClassLoaderClassResolver ; import org . oddjob . arooa . reflect . PropertyAccessor ; import org . oddjob . arooa . utils . DateHelper ; import org . oddjob . logging . LogEvent ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . logging . log4j . Log4jArchiver ; import org . oddjob . script . ConvertableArguments ; import org . oddjob . script . InvokerArguments ; public class SimpleMBeanNodeTest extends TestCase { ObjectName objectName ; MBeanServer mBeanServer ; Vendor simple = new Vendor ( ""<STR_LIT>"" ) ; protected void setUp ( ) throws Exception { objectName = new ObjectName ( ""<STR_LIT>"" ) ; mBeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; mBeanServer . registerMBean ( simple , objectName ) ; } @ Override protected void tearDown ( ) throws Exception { mBeanServer . unregisterMBean ( objectName ) ; } public void testInvoking ( ) throws Exception { SimpleMBeanNode test = new SimpleMBeanNode ( objectName , mBeanServer , new ClassLoaderClassResolver ( getClass ( ) . getClassLoader ( ) ) ) ; InvokerArguments arguments = new ConvertableArguments ( new DefaultConverter ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , <NUM_LIT> ) ; double result = ( Double ) test . invoke ( ""<STR_LIT>"" , arguments ) ; assertEquals ( <NUM_LIT> , result , <NUM_LIT> ) ; assertEquals ( ""<STR_LIT>"" , simple . fruit ) ; assertEquals ( DateHelper . parseDate ( ""<STR_LIT>"" ) , simple . delivery ) ; assertEquals ( <NUM_LIT> , simple . quantity ) ; } public void testGetProperty ( ) throws Exception { SimpleMBeanNode test = new SimpleMBeanNode ( objectName , mBeanServer , new ClassLoaderClassResolver ( getClass ( ) . getClassLoader ( ) ) ) ; PropertyAccessor accessor = new BeanUtilsPropertyAccessor ( ) ; String result = accessor . getProperty ( test , ""<STR_LIT>"" , String . class ) ; assertEquals ( ""<STR_LIT>"" , result ) ; accessor . setProperty ( test , ""<STR_LIT>"" , <NUM_LIT> ) ; assertEquals ( <NUM_LIT> , simple . rating , <NUM_LIT> ) ; } public void testLogEnabled ( ) throws Exception { final StringBuilder builder = new StringBuilder ( ) ; class TestListener implements LogListener { public void logEvent ( LogEvent logEvent ) { builder . append ( logEvent . getMessage ( ) + ""<STR_LIT:n>"" ) ; } } SimpleMBeanNode test'}]","= new SimpleMBeanNode(objectName, mBeanServer, new ClassLoaderClassResolver(getClass().getClassLoader())); Log4jArchiver archiver = new Log4jArchiver(); archiver.setMBeanServer(mBeanServer); archiver.setLogLevel(LogLevel.ALL); archiver.addLogListener(new TestListener()); archiver.setEnabled(true); test.logEnabled(archiver); assertEquals(""<STR_LIT>n"", builder.toString()); } public void testPropertyAccessors ( ) throws Exception { SimpleMBeanNode test = new SimpleMBeanNode(objectName, mBeanServer, new ClassLoaderClassResolver(getClass().getClassLoader())); PropertyAccessor accessor = new BeanUtilsPropertyAccessor(); String result = accessor.getProperty(test, ""<STR_LIT>"", String.class); assertEquals(""<STR_LIT>"", result); accessor.setProperty(test, ""<STR_LIT>"", <NUM_LIT>); assertEquals(<NUM_LIT>, simple.rating, <NUM_LIT>); } }",0.0002856501314477353
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . typehierarchy ; import org . eclipse . jface . action . Action ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; public class SortByDefiningTypeAction extends Action { private MethodsViewer fMethodsViewer ; public SortByDefiningTypeAction ( MethodsViewer viewer , boolean initValue ) { super ( TypeHierarchyMessages . SortByDefiningTypeAction_label ) ;'}]",fMethodsViewer = viewer; setChecked(initValue); } @Override public void run() { if (isChecked()) { fMethodsViewer.sortByDefiningType(); } else { fMethodsViewer.sortByMethod(); } } },7.943082746700415e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . expr ; import de . fuberlin . wiwiss . d2rq . algebra . ColumnRenamer ;'}]",import de.fuberlin.wiwiss.d2rq.algebra.Expression;,3.385491063972746e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . formatter ; import java . util . Map ; public class NoFormattingMarker extends AbstractBlockMarker { public NoFormattingMarker ( String aKeyword , int aPos ) { super ( aKeyword , aPos ) ; } public boolean isFormatting ( ) { return false ; } protected void'}]","format(Map<String, String> attributes, StringBuilder buffer);",3.0019105012739463e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . rubypeople . rdt . internal . ui . search ; import org . rubypeople . rdt . core . IField ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . ui . RubyElementLabels ; public class PatternStrings { public static String getSignature ( IRubyElement element ) { if ( element == null ) return null ; else switch ( element . getElementType ( ) ) { case IRubyElement . METHOD : return getMethodSignature ( ( IMethod ) element ) ; case IRubyElement . TYPE : return getTypeSignature ( ( IType ) element ) ; case IRubyElement . FIELD : return getFieldSignature ( ( IField ) element ) ; default : return element . getElementName ( ) ; } } public static String getMethodSignature ( IMethod method ) { StringBuffer buffer = new StringBuffer ( ) ; if ( method . isSingleton ( ) || method . isConstructor ( ) ) { buffer . append ( RubyElementLabels . getElementLabel ( method . getDeclaringType ( ) , RubyElementLabels . USE_RESOLVED ) ) ; buffer . append ( '<CHAR_LIT:.>' ) ; } boolean isConstructor = method . isConstructor ( ) ; if ( ! isConstructor ) { buffer . append ( getUnqualifiedMethodSignature ( method , ! isConstructor ) ) ; } else { buffer . append (""}]","getUnqualifiedMethodSignature(method, true)); if (method.isSingleton()) { buffer.append(""<CHAR_LIT:>'<CHAR_LIT:static>'<CHAR_LIT:>'""); } else { buffer.append(""<CHAR_LIT:>'<CHAR_LIT:static>'""); } return buffer.toString(); } public static String getTypeSignature(IMethod method) { return getUnqualifiedMethodSignature(method, false); } public static String getFieldSignature(IField field) { StringBuffer buffer = new StringBuffer(); buffer.append(RubyElementLabels.getElementLabel(field.getDeclaringType(), RubyElementLabels.USE_RESOLVED)); buffer.append(""<CHAR_LIT:.>'<CHAR_LIT:>'""); buffer.append(getUnqualifiedFieldSignature(field)); return buffer.toString(); }",0.00021865130835284076
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . hierarchy ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . rubypeople . rdt . core . IOpenable ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . codeassist . RubyElementRequestor ; import org . rubypeople . rdt . internal . core . LogicalType ; public class HierarchyResolver { private static final int RECURSE_DEPTH_BAILOUT = <NUM_LIT> ; private boolean superTypesOnly ; private HierarchyBuilder builder ; private HashSet < String > visitedTypes ; public HierarchyResolver ( Map options , HierarchyBuilder builder ) { this . builder = builder ; } public void resolve ( IOpenable [ ] openables , HashSet < String > localTypes , IProgressMonitor monitor ) { try { int openablesLength = openables . length ; IType focus = this . builder . getType ( ) ; for ( int i = <NUM_LIT:0> ; i < openablesLength ; i ++ ) { IOpenable openable = openables [ i ] ; if ( openable instanceof org . rubypeople . rdt . core . IRubyScript ) { org . rubypeople . rdt . core . IRubyScript cu = ( org . rubypeople . rdt . core . IRubyScript ) openable ; IType [ ] types = cu . getAllTypes ( ) ; for ( int j = <NUM_LIT:0> ; j < types . length ; j ++ ) { IType type = types [ j ] ; if ( focusIsInHierarchy ( focus , type , <NUM_LIT:0> ) ) { try { this . visitedTypes = new HashSet < String > ( ) ; reportHierarchy ( type ) ; visitedTypes . clear ( ) ; } catch ( RubyModelException e ) { } } } } } } catch ( ClassCastException e ) { } catch ( RubyModelException e ) { } finally { reset ( ) ; } } private boolean focusIsInHierarchy ( IType focus , IType type , int currentDepth ) throws RubyModelException { if ( currentDepth > RECURSE_DEPTH_BAILOUT ) { RubyCore . log ( IStatus . ERROR , ""<STR_LIT>"" + currentDepth + ""<STR_LIT>"" + type . getFullyQualifiedName ( ) , new IllegalStateException ( ) . fillInStackTrace ( ) ) ; return false ; } if ( focus == null || type == null ) return false ; if ( type . getFullyQualifiedName ( ) . equals ( focus . getFullyQualifiedName ( ) ) ) return true ; return focusIsInHierarchy ( focus , findSuperClass ( type ) , ++ currentDepth ) ; } private void reportHierarchy ( IType type ) throws RubyModelException { visitedTypes . add ( type . getFullyQualifiedName ( ) ) ; IType superclass ; if ( type . isModule ( ) ) { superclass = null ; } else { superclass = findSuperClass ( type ) ; } IType [ ] superinterfaces = findSuperInterfaces ( type ) ; this . builder . connect ( type , superclass'}]",", superinterfaces, visitedTypes); } private IType findSuperClass ( IType type ) throws RubyModelException { if ( type. isClass ( ) ) { return type. getSuperClass ( ) ; } else if ( type. isModule ( ) ) { return null ; } else { return type. getSuperClass ( ) ; } } private IType [ ] findSuperInterfaces ( IType type ) throws RubyModelException { if ( type. isClass ( ) ) { return type. getSuperInterfaces ( ) ; } else { return new IType [ ] { } ; } } private void reset ( ) { this. superTypesOnly = false ; this. visitedTypes = null ; } }",0.0002270057340661906
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBMinTypMaxExpr extends SVDBExpr { public SVDBExpr fMin ; public SVDBExpr fTyp ; public SVDBExpr fMax ; public SVDBMinTypMaxExpr ( ) { super ( SVDBItemType . MinTypMaxExpr ) ; } public'}]","SVDBMinTypMaxExpr ( SVDBExpr min, SVDBExpr typ, SVDBExpr max ) { super ( SVDBItemType. MinTypMaxExpr ) ; this. fMin = min ; this. fTyp = typ ; this. fMax = max ; } }",8.664321296219321e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core ; import java . util . Collection ; import org . jruby . ast . ArgsNode ; import org . jruby . ast . ArgumentNode ; import org . jruby . ast . BlockNode ; import org . jruby . ast . ClassNode ; import org . jruby . ast . Colon2Node ; import org . jruby . ast . CommentNode ; import org . jruby . ast . ConstNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . LocalAsgnNode ; import org . jruby . ast . LocalVarNode ; import org . jruby . ast . NewlineNode ; import org . jruby . ast . Node ; import org . jruby . ast . RootNode ; import org . jruby . ast . SymbolNode ; import org . jruby . lexer . yacc . IDESourcePosition ; import org . jruby . parser . LocalStaticScope ; import org . rubypeople . rdt . core . util . Util ; import org . rubypeople . rdt . internal . core . parser . ClosestNodeLocator ; import org . rubypeople . rdt . refactoring . core . NodeProvider ; import org . rubypeople . rdt . refactoring . core . SelectionNodeProvider ; import org . rubypeople . rdt . refactoring . tests . FileTestCase ; import org . rubypeople . rdt . refactoring . util . NodeUtil ; public class TC_NodeProvider extends FileTestCase { public TC_NodeProvider ( ) { super ( ""<STR_LIT>"" ) ; } public void testGetAllNodes ( ) { Node rootNode = getRootNode ( ""<STR_LIT>"" ) ; Node [ ] allNodes = NodeProvider . getAllNodes ( rootNode ) . toArray ( new Node [ ] { } ) ; assertEquals ( <NUM_LIT> , allNodes . length ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( allNodes [ <NUM_LIT:1> ] , BlockNode . class ) ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( allNodes [ <NUM_LIT:2> ] , NewlineNode . class ) ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( allNodes [ <NUM_LIT:3> ] , ClassNode . class ) ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( allNodes [ <NUM_LIT:4> ] , Colon2Node . class ) ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( allNodes [ <NUM_LIT:20> ] , ConstNode . class ) ) ; } public void testGetSelectedNodeOfType ( ) { Node rootNode = getRootNode ( ""<STR_LIT>"" ) ; Node defnNode = SelectionNodeProvider . getSelectedNodeOfType ( rootNode , <NUM_LIT:2> , DefnNode . class ) ; assertEquals ( DefnNode . class , defnNode . getClass ( ) ) ; Node argumentNode = SelectionNodeProvider . getSelectedNodeOfType ( rootNode , <NUM_LIT> , ArgumentNode . class ) ; assertEquals ( ArgumentNode . class , argumentNode . getClass ( ) ) ; Node nullNode = SelectionNodeProvider . getSelectedNodeOfType ( rootNode , <NUM_LIT:0> , ArgumentNode . class ) ; assertNull ( nullNode ) ; Node localAsgnNode = SelectionNodeProvider . getSelectedNodeOfType ( rootNode , <NUM_LIT> , LocalAsgnNode . class ) ; assertEquals ( LocalAsgnNode . class , localAsgnNode . getClass ( ) ) ; } public void testNodeAssignableFrom ( ) { ArgsNode args = new ArgsNode ( null , null , null , null , null , null ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( new DefnNode ( null , null , args , new LocalStaticScope ( null ) , null ) , DefnNode . class ) ) ; assertTrue ( NodeUtil . nodeAssignableFrom ( new LocalVarNode ( null , <NUM_LIT:0> , ""<STR_LIT>"" ) , LocalVarNode . class ) ) ; }'}]","public void testGetAllNodes ( ) { Node rootNode = getRootNode ( ""<STR_LIT>"" ) ; Node [ ] allNodes = NodeProvider. getAllNodes ( rootNode ). toArray ( new Node [ ] { } ) ; assertEquals ( 21, allNodes.length); assertTrue ( NodeUtil. nodeAssignableFrom ( allNodes [ 1 ], BlockNode. class ) ) ; assertTrue ( NodeUtil. nodeAssignableFrom ( allNodes [ 2 ], NewlineNode. class ) ) ; assertTrue ( NodeUtil. nodeAssignableFrom ( allNodes [ 3 ], ClassNode. class ) ) ; assertTrue ( NodeUtil. nodeAssignableFrom ( allNodes [ 4 ], Colon2Node. class ) ) ; assertTrue ( NodeUtil. nodeAssignableFrom ( allNodes [ 20 ], ConstNode. class ) ) ; }",0.0002598398606547967
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . testing . io ; import java . io . IOException ; import com . asakusafw . compiler . flow . testing . model . ExJoined2 ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class ExJoined2Input implements ModelInput < ExJoined2 > { private final RecordParser parser ; public ExJoined2Input ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . parser = parser ; }'}]",@Override public ExJoined2 read() throws IOException { return parser.read(ExJoined2.class); },4.2355802724876475e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import java . io . Serializable ; import org . oddjob . Oddjob ; import org . oddjob . arooa . design . DesignComponentBase ; import org . oddjob . arooa . design . DesignFactory ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignProperty ; import org . oddjob . arooa . design . SimpleDesignProperty ; import org . oddjob . arooa . design . screem . BorderedGroup ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design . screem . StandardForm ; import org . oddjob . arooa . life . SimpleArooaClass ; import org . oddjob . arooa . parsing'}]",".xml; public class OddjobForm extends StandardForm { public static class Factory implements DesignFactory<OddjobForm> { @Override public Class<? super OddjobForm> designClass() { return OddjobForm.class; } @Override public OddjobForm create(DesignInstance designInstance) { return new OddjobForm(designInstance); } } public OddjobForm(DesignInstance designInstance) { super(designInstance); } @Override public void configure(DesignComponentBase designComponent) { designComponent.setClass(SimpleArooaClass.create(Oddjob.class)); } @Override public SimpleDesignProperty<? super Oddjob> designProperty() { return new SimpleDesignProperty<>(""oddjob"", Oddjob.class); } }",0.0002065682733840975
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . connect ; import java . util . Map ; import org . springframework . http . HttpEntity ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . MediaType ; import org . springframework . http . ResponseEntity ; import org . springframework .'}]","social::connect::GoogleConnection;public class GoogleConnectTemplate { private final GoogleConnection connection;public GoogleConnectTemplate(GoogleConnection connection) { this.connection = connection; } public ResponseEntity<String> connect(String redirectUri, String scope, String state) throws Exception { String authorizationUrl = connection.getAuthorizationUrl(redirectUri, scope, state); HttpEntity<String> entity = new HttpEntity<>(null, connection.getHttpHeaders()); HttpEntity<String> response = connection.getRestTemplate().exchange(authorizationUrl, HttpMethod.GET, entity, String.class); return new ResponseEntity<>(response.getBody(), connection.getHttpHeaders(), response.getStatusCode()); } }",0.00017606347619692096
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . editprovider ; import org . eclipse . text . edits . TextEdit ; import org . jruby . ast . NewlineNode ; import org . jruby . ast . Node ; import org . jruby . lexer . yacc . ISourcePosition ; import org . rubypeople . rdt . core . formatter . EditableFormatHelper ; import org . rubypeople . rdt . core . formatter . FormatHelper ; import org . rubypeople . rdt . core . formatter . ReWriteVisitor ; import org . rubypeople . rdt . refactoring . core . NodeFactory ; import org . rubypeople . rdt . refactoring . util . FileHelper ; import org . rubypeople . rdt . refactoring . util . HsrFormatter ; public abstract class EditProvider implements IEditProvider { protected boolean lastEditInGroup ; protected boolean firstEditInGroup ; private boolean doFormat ; private boolean doTrim ; public abstract TextEdit getEdit ( String document ) ; protected abstract int getOffset ( String document ) ; protected abstract Node getEditNode ( int offset , String document ) ; public EditProvider ( boolean doFormat , boolean doTrim ) { this . doFormat = doFormat ; this . doTrim = doTrim ; } protected FormatHelper getFormatHelper ( ) { return new EditableFormatHelper ( ) ; } protected String getFormatedNode ( String document ) { int offset = getOffset ( document ) ; Node insertNode = getEditNode ( offset , document ) ; String text = ReWriteVisitor . createCodeFromNode ( insertNode , document , getFormatHelper ( ) ) ; if ( doFormat ) { text = HsrFormatter . format ( document , text , offset ) ; } if ( doTrim ) { text = text . trim ( ) ; } return text . replaceAll ( ""<STR_LIT:n>"" , FileHelper'}]",".getNewline(document, offset)); } }",3.523381623451535e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . gems ; import java . util . Set ; import com . aptana . rdt . core . gems . Gem ; public class GemParserTest extends AbstractGemParserTestCase { public void testParsingLocalGems ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT> , gems . size ( ) ) ; } public void testEndsWithTwoLineDescription ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT> , gems . size ( ) ) ; } public void testMattsBrokenList ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT> , gems . size ( ) ) ; } public void testJavaHomeErrorFromJRuby ( ) throws GemParseException { String contents = ""<STR_LIT>"" ; Set < Gem > gems = getParser ( ) . parse ( contents ) ; assertEquals ( <NUM_LIT:0> , gems . size ( ) ) ; }'}]","public void testParsingLocalGemsWithDependencies ( ) throws GemParseException { String contents = getContents ( ""<STR_LIT>"" ) ; Set < Gem > gems = getParser ( ). parse ( contents ) ; assertEquals ( <NUM_LIT>, gems. size ( ) ) ; }",9.822962447115756e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . testunit ; public interface ITestRunListener { public static final int STATUS_OK = <NUM_LIT:0> ; public static final int STATUS_ERROR = <NUM_LIT:1> ; public static final int STATUS_FAILURE = <NUM_LIT:2> ; public void testRunStarted ( int testCount ) ; public void'}]","testRunFinished ( int testCount, int successCount, int failureCount, int errorCount ) ; }",5.2255994080086436e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui ; import junit . framework . TestCase ; import org . rubypeople . eclipse . shams . resources . ShamFile ; public class TC_RubyFileMatcher extends TestCase { private RubyFileMatcher matcher ; protected void setUp ( ) throws Exception { super . setUp ( ) ; matcher = new RubyFileMatcher ( ) ; } public void testHasRubyEditorAssociationIfContainsRubyShebang ( ) { ShamFile file = new ShamFile ( ""<STR_LIT>"" , false ) ; file . setContents ( ""<STR_LIT>"" ) ; assertTrue ( matcher . hasRubyEditorAssociation ( file ) ) ; } public void testRakefileHasRubyEditorAssociation ( ) { ShamFile file = new ShamFile ( ""<STR_LIT>"" , false ) ; assertTrue ( matcher . hasRubyEditorAssociation ( file ) ) ; } public void testGemHasRubyEditorAssociation ( ) { ShamFile file = new ShamFile ( ""<STR_LIT>"" , false ) ; assertTrue ( matcher . hasRubyEditorAssociation ('}]","file ) ; } public void testPlainTextFileDoesNotHaveRubyEditorAssociation ( ) { ShamFile file = new ShamFile ( ""<STR_LIT>"", false ) ; assertFalse ( matcher. hasRubyEditorAssociation ( file ) ) ; } public void testRubyFileWithoutShebangDoesNotHaveRubyEditorAssociation ( ) { ShamFile file = new ShamFile ( ""<STR_LIT>"", false ) ; assertFalse ( matcher. hasRubyEditorAssociation ( file ) ) ; } }",0.00015277244028728406
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api . plus . person ; public class ProfileURL { private String value ; private String type ; @ Override public String toString ( ) { if ( type == null ) {'}]","return value; } else { return type + ""://"" + value; } } }",3.849224686696906e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import org . eclipse . core . resources . IContainer ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . dialogs . ElementTreeSelectionDialog ; import org . eclipse . ui . dialogs . NewFolderDialog ; import org . eclipse . ui . views . navigator . ResourceSorter ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; public class FolderSelectionDialog extends ElementTreeSelectionDialog implements ISelectionChangedListener { private Button fNewFolderButton ; private IContainer fSelectedContainer ; public FolderSelectionDialog ( Shell parent , ILabelProvider labelProvider , ITreeContentProvider contentProvider ) { super ( parent , labelProvider , contentProvider ) ; setSorter ( new ResourceSorter ( ResourceSorter . NAME ) ) ; } protected Control createDialogArea ( Composite parent ) { Composite result = ( Composite ) super . createDialogArea ( parent ) ; getTreeViewer ( ) . addSelectionChangedListener ( this ) ; Button button'}]","= new Button(result, SWT.PUSH); button.setText(NewWizardMessages.FolderSelectionDialog_newFolder); button.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { NewFolderDialog dialog = new NewFolderDialog(getShell()); dialog.open(); } }); result.layout(); return result; } @Override public void selectionChanged(SelectionChangedEvent event) { IStructuredSelection selection = getStructuredSelection(); if (selection!= null &&!selection.isEmpty()) { ITreeContentProvider provider = getTreeViewer().getContentProvider(); fSelectedContainer = (IContainer) provider.getParent(selection.getFirstElement()); } } }",0.0001947107605143072
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . thundergate . model ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . List ; import com . asakusafw . utils . collections . Lists ; public class JoinedModelDescription extends ModelDescription { private List < Source > leftCondition ; private List < Source > rightCondition ; public JoinedModelDescription ( ModelReference reference , List < ModelProperty > properties , List < Source > leftCondition , List < Source > rightCondition ) { super ( reference , properties ) ; if ( leftCondition . isEmpty ( ) ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , reference ) ) ; } if ( leftCondition . size ( ) != rightCondition . size ( ) ) { throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , reference ) ) ; } this . leftCondition = Lists . freeze ( leftCondition ) ; this . rightCondition = Lists . freeze ( rightCondition ) ; } @ Override protected Source convertPropertyToSource ( ModelProperty property ) { return new Source ( Aggregator . IDENT , getReference ( ) , property . getName ( ) , property . getType ( ) , Collections . < Attribute > emptySet ( ) ) ; } public ModelReference getFromModel ( ) { return leftCondition . get ( <NUM_LIT:0> ) . getDeclaring ( ) ; } public ModelReference getJoinModel ( ) { return rightCondition . get ( <NUM_LIT:0> ) . getDeclaring ( ) ; } public List < Source > getFromCondition ( ) { return leftCondition ; } public List < Source > getJoinCondition ( ) { return rightCondition ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT:31> ; int result = <NUM_LIT:1> ; result += result * prime + getReference ( ) . hashCode ( ) ; result += result * prime + getProperties ( ) . hashCode ( ) ; result += result * prime + leftCondition . hashCode ( ) ; result += result * prime + rightCondition . hashCode ( ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return'}]","false; if ( getClass ( )!= obj. getClass ( ) ) { return false ; } JoinedModelDescription other = ( JoinedModelDescription ) obj; if (! getReference ( ). equals ( other. getReference ( ) ) ) { return false ; } if (! getProperties ( ). equals ( other. getProperties ( ) ) ) { return false ; } if (! leftCondition. equals ( other. leftCondition ) ) { return false ; } if (! rightCondition. equals ( other. rightCondition ) ) { return false ; } return true; } @Override public String toString ( ) { return MessageFormat. format ( ""<STR_LIT>"", getReference ( ), getProperties ( ), leftCondition, rightCondition ) ; } }",0.0002287857645691214
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . rule ; import java . math . BigDecimal ; import java . util . Calendar ; public final class Predicates { public static ValuePredicate < Object > equalTo ( Object value ) { return new ExpectConstant < Object > ( value , new Equals ( ) ) ; } public static < T > ValuePredicate < T > not ( ValuePredicate < T > predicate ) { if ( predicate == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return new Not < T > ( predicate ) ; } public static ValuePredicate < Object > equals ( ) { return new Equals ( ) ; } public static ValuePredicate < Object > isNull ( ) { return new IsNull ( ) ; } public static ValuePredicate < Number > floatRange ( double lower , double upper ) { return new FloatRange ( lower , upper ) ; } public static ValuePredicate < Number > integerRange ( long lower'}]",", long upper ) { return new IntegerRange ( lower, upper ) ; } public static ValuePredicate < Number > doubleRange ( double lower, double upper ) { return new DoubleRange ( lower, upper ) ; } }",7.275634996273425e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . algebra ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import de . fuberlin . wiwiss . d2rq . expr . Expression ; import de . fuberlin . wiwiss . d2rq . sql . ConnectedDB ; public abstract class Relation implements RelationalOperators { public final static int NO_LIMIT = - <NUM_LIT:1> ; public static Relation createSimpleRelation ( ConnectedDB database , Attribute [ ] attributes ) { return new RelationImpl ( database , AliasMap . NO_ALIASES , Expression . TRUE , Expression . TRUE , Collections . < Join > emptySet ( ) , new HashSet < ProjectionSpec > ( Arrays . asList ( attributes ) ) , false , Collections . < OrderSpec > emptyList ( ) , - <NUM_LIT:1> , - <NUM_LIT:1> ) ; } public static Relation EMPTY = new Relation ( ) { public ConnectedDB database ( ) { return null ; } public AliasMap aliases ( ) { return AliasMap . NO_ALIASES ; } public Set < Join'}]",> emptySet ( ) ; public Set < OrderSpec > orders ( ) { return Collections. < OrderSpec > emptyList ( ) ; } public int limitRows ( ) { return NO_LIMIT; } public int limitColumns ( ) { return NO_LIMIT; } public void setLimitRows ( int limitRows ) { this.limitRows = limitRows; } public void setLimitColumns ( int limitColumns ) { this.limitColumns = limitColumns; } };,0.0001390984674377178
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . docs . html ; import java . io . File ; import net . sf . sveditor . core . docs . DocGenConfig ; import net . sf . sveditor . core . docs . model . DocFile ; import net . sf . sveditor . core . docs . model . DocModel ; import net . sf . sveditor . core . docs . model . DocTopic ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; public class HTMLFileFactory { private DocGenConfig cfg ; private DocModel model ; @ SuppressWarnings ( ""<STR_LIT:unused>"" ) private LogHandle fLog ; private HTMLFromNDMarkup fMarkupToHTML ; public HTMLFileFactory ( DocGenConfig cfg , DocModel model ) { this . cfg = cfg ; this . model = model ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; fMarkupToHTML = new HTMLFromNDMarkup ( this . model ) ; } public static String getRelPathToHTML ( String path ) { String res = ""<STR_LIT>"" ; File filePath = new File ( path ) ; int numParents = <NUM_LIT:0> ; while ( filePath . getParentFile ( ) != null ) { numParents ++ ; filePath = filePath . getParentFile ( ) ; } for ( int i = <NUM_LIT:0> ; i < numParents ; i ++ ) { res += ""<STR_LIT>"" ; } return res ; } public String build ( DocFile docFile ) { String res = HTMLUtils . STR_DOCTYPE ; res += HTMLUtils . genHTMLHeadStart ( getRelPathToHTML ( docFile . getTitle ( ) ) , docFile . getPageTitle ( ) ) ; res += HTMLUtils . genBodyBegin ( ""<STR_LIT>"" ) ; res += HTMLUtils . genContentBegin ( ) ; res += genContent ( docFile ) ; res += HTMLUtils . genContentEnd ( ) ; res += HTMLUtils . genFooter ( ) ; res += HTMLUtils . genMenu ( cfg , getRelPathToHTML ( docFile . getTitle ( ) ) , docFile . getPageTitle ( ) , model . getDocTopics ( ) . getAllTopicTypes ( ) ) ; res += HTMLUtils . genBodyHTMLEnd ( ) ; return res ; } private String genSummaryStart ( DocFile docFile , DocTopic docItem ) { String result = ""<STR_LIT>"" ; result += fMarkupToHTML . convertNDMarkupToHTML ( docFile , docItem , docItem . getBody ( ) , HTMLFromNDMarkup . NDMarkupToHTMLStyle . General ) ; return result ; } private String genMemberDetail ( DocFile docFile , DocTopic docTopic ) { String res = ""<STR_LIT>"" ; for ( DocTopic child : docTopic . getChildren ( ) ) { res += genDetails ( docFile , docTopic , child ) ; } return res ; } private String genSTRMain ( DocFile docFile , DocTopic topic ) { String res = ""<STR_LIT>"" ; if ( topic . getTopic ( ) . equals ( ""<STR_LIT>"" ) ) { res += ""<STR_LIT>"" + ""<STR_LIT>"" + topic . getQualifiedName ( ) + ""<STR_LIT>"" + topic . getTitle ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; } else { res += ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + getRelPathToHTML ( topic . getDocFile ( ) . getTitle ( ) ) + HTMLIconUtils . getImagePath ( topic ) + ""<STR_LIT:>>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + topic . getTitle ( ) + ""<STR_LIT>"" + topic . getTitle ( ) + ""<STR_LIT>"" + ""<STR_LIT>"" ; res += topic . getSummary ( ) ; res += ""<STR_LIT>"" ; } return res ; } private String genTopicStart ( DocTopic contentItem ) { String res = ""<STR_LIT>"" + HTMLUtils . genCSSClassForTopic ( contentItem . getTopic ( ) ) + ""<STR_LIT>"" ; return res ; } private String genClassEnd ( ) { String res = ""<STR_LIT>"" ; return res ; } private String genContent ( DocFile docFile ) { String res = ""<STR_LIT>"" ; if ( docFile . getChildren ( ) . size ( ) > <NUM_LIT:1> ) { res += genFileSummary ( docFile ) ; } for ( DocTopic contentItem : docFile . getChildren ( ) ) { if ( ! contentItem . getTopic ( ) . equals ( ""<STR_LIT>"" ) ) { res += genContent ( docFile , contentItem ) ; } } return res ; } private String genContent ( DocFile docFile , DocTopic contentItem ) { String res = ""<STR_LIT>"" ; res += genTopicStart ( contentItem ) ; res += HTMLUtils . genCTopicBegin ( ""<STR_LIT>"" ) ; res += HTMLUtils . genCTitle ( contentItem . getTitle ( ) ) ; res += HTMLUtils . genCBodyBegin ( ) ; res += genSummaryStart ( docFile , contentItem ) ; res += HTMLUtils . genSummaryBegin ( ) ; res += HTMLUtils . genSTitle ( ) ; res += HTMLUtils . genSBorderBegin ( ) ; res += HTMLUtils . genSTableBegin ( ) ; res += genSTRMain ( docFile , contentItem ) ; res += genSummaryMembers ( docFile , contentItem ) ; res += HTMLUtils . genSTableEnd ( ) ; res += HTMLUtils . genSBorderEnd ( ) ; res += HTMLUtils . genSummaryEnd ( ) ; res += HTMLUtils . genCBodyEnd ( ) ; res += HTMLUtils . genCTopicEnd ( ) ; res += genClassEnd ( ) ; res'}]","} private String genFileSummary ( DocFile docFile ) { String res = ""<STR_LIT>"" ; res += HTMLUtils. genCSSClassForTopic ( docFile. getTopic ( ) ) + ""<STR_LIT>"" ; res += genSummaryStart ( docFile, docFile ) ; return res ; } private String genSummaryMembers ( DocFile docFile, DocTopic contentItem ) { String res = ""<STR_LIT>"" ; res += HTMLUtils. genSummaryMembersBegin ( ) ; for ( DocTopic child : contentItem. getChildren ( ) ) { res += genMemberDetail ( docFile, child ) ; } res += HTMLUtils. genSummaryMembersEnd ( ) ; return res ; } private String genDetails ( DocFile docFile, DocTopic topic, DocTopic child ) { String res = ""<STR_LIT>"" ; res += genMemberDetail ( docFile, child ) ; return res ; } }",0.0003137176476130348
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . StringTokenizer ; import java . util . WeakHashMap ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . XMLTransformUtils ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . log . ILogHandle ; import net . sf . sveditor . core . log . ILogLevel ; import net . sf . sveditor . core . log . ILogListener ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . templates . IExternalTemplatePathProvider ; import net . sf . sveditor . core . templates . ITemplateParameterProvider ; import net . sf . sveditor . core . templates . TemplateParameterProvider ; import net . sf . sveditor . core . templates . TemplateRegistry ; import net . sf . sveditor . ui . pref . SVEditorPrefsConstants ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . text . templates . ContextTypeRegistry ; import org . eclipse . jface . text . templates . persistence . TemplateStore ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . console . ConsolePlugin ; import org . eclipse . ui . console . IConsole ; import org . eclipse . ui . console . MessageConsole ; import org . eclipse . ui . console . MessageConsoleStream ; import org . eclipse . ui . editors . text . EditorsUI ; import org . eclipse . ui . editors . text . templates . ContributionContextTypeRegistry ; import org . eclipse . ui . editors . text . templates . ContributionTemplateStore ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . eclipse . ui . texteditor . AbstractDecoratedTextEditorPreferenceConstants ; import org . eclipse . ui . texteditor . ChainedPreferenceStore ; import org . osgi . framework . BundleContext ; public class SVUiPlugin extends AbstractUIPlugin implements IPropertyChangeListener , ILogListener , IExternalTemplatePathProvider { private class LogMessage { ILogHandle handle ; int type ; int level ; String message ; } public static final String PLUGIN_ID = ""<STR_LIT>"" ; private static SVUiPlugin fPlugin ; private ResourceBundle fResources ; private WeakHashMap < String , Image > fImageMap ; private MessageConsole fConsole ; private MessageConsoleStream fStdoutStream ; private MessageConsoleStream fStderrStream ; private ContributionContextTypeRegistry fContextRegistry ; private TemplateStore fTemplateStore ; private boolean fDebugConsole ; public static final String CUSTOM_TEMPLATES_KEY = ""<STR_LIT>"" ; public static final String SV_TEMPLATE_CONTEXT = ""<STR_LIT>"" ; private String fInsertSpaceTestOverride ; private boolean fStartRefreshJob = false ; private RefreshIndexJob fRefreshIndexJob ; private List < String > fTemplatePaths ; private TemplateParameterProvider fGlobalPrefsProvider ; private List < LogMessage > fLogMessageQueue ; private boolean fLogMessageScheduled ; public SVUiPlugin ( ) { fImageMap = new WeakHashMap < String , Image > ( ) ; fGlobalPrefsProvider = new TemplateParameterProvider ( ) ; fLogMessageQueue = new ArrayList < SVUiPlugin . LogMessage > ( ) ; } public void start ( BundleContext context ) throws Exception { super . start ( context ) ; fPlugin = this ; LogFactory . getDefault ( ) . addLogListener ( this ) ; getPreferenceStore ( ) . addPropertyChangeListener ( this ) ; SVCorePlugin . getDefault ( ) . setDebugLevel ( getDebugLevel ( getPreferenceStore ( ) . getString ( SVEditorPrefsConstants . P_DEBUG_LEVEL_S ) ) ) ; SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) . setEnableAutoRebuild ( getPreferenceStore ( ) . getBoolean ( SVEditorPrefsConstants . P_AUTO_REBUILD_INDEX ) ) ; TemplateRegistry rgy = SVCorePlugin . getDefault ( ) . getTemplateRgy ( ) ; rgy . addPathProvider ( this ) ; update_template_paths ( ) ; update_global_parameters ( ) ; } public static IWorkbenchPage getActivePage ( ) { return getDefault ( ) . getActivePage ( ) ; } private void update_template_paths ( ) { fTemplatePaths = parse_paths ( getPreferenceStore ( ) . getString ( SVEditorPrefsConstants . P_SV_TEMPLATE_PATHS ) ) ; } private void update_global_parameters ( ) { Map < String , String > params = null ; try { params = XMLTransformUtils . xml2Map ( getPreferenceStore ( ) . getString ( SVEditorPrefsConstants . P_SV_TEMPLATE_PROPERTIES ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } catch ( Exception e ) { } if ( params != null ) { fGlobalPrefsProvider = new TemplateParameterProvider ( params ) ; } } public List < String > getExternalTemplatePath ( ) { return fTemplatePaths ; } public ITemplateParameterProvider getGlobalTemplateParameters ( ) { return fGlobalPrefsProvider ; } private static List < String > parse_paths ( String stringList ) { StringTokenizer st = new StringTokenizer ( stringList , File . pathSeparator + ""<STR_LIT>"" ) ; ArrayList < String > v = new ArrayList < String > ( ) ; while ( st . hasMoreElements ( ) ) { v . add ( ( String ) st . nextElement ( ) ) ; } return v ; } private int getDebugLevel ( String level_s ) { if ( level_s . equals ( ""<STR_LIT>"" ) ) { return ILogLevel . LEVEL_MIN ; } else if ( level_s . equals ( ""<STR_LIT>"" ) ) { return ILogLevel . LEVEL_MID ; } else if ( level_s . equals ( ""<STR_LIT>"" ) ) { return ILogLevel . LEVEL_MAX ; } else { return ILogLevel . LEVEL_OFF ; } } public synchronized void startRefreshJob ( ) { if ( ! fStartRefreshJob ) { RefreshProjectIndexesJob rj = new RefreshProjectIndexesJob ( ) ; rj . setPriority ( Job . LONG ) ; rj . schedule ( <NUM_LIT> ) ; fStartRefreshJob = true ; } } public synchronized void refreshIndex ( ISVDBIndex index ) { if ( fRefreshIndexJob == null ) { fRefreshIndexJob = new RefreshIndexJob ( this ) ; fRefreshIndexJob . setPriority ( Job . LONG ) ; fRefreshIndexJob . schedule ( <NUM_LIT:1000> ) ; } fRefreshIndexJob . addIndex ( index ) ; } public synchronized void refreshIndexList ( List < ISVDBIndex > list ) { if ( fRefreshIndexJob == null ) { fRefreshIndexJob = new RefreshIndexJob ( this ) ; fRefreshIndexJob . setPriority ( Job . LONG ) ; fRefreshIndexJob . schedule ( <NUM_LIT:1000> ) ; } fRefreshIndexJob . addIndexList ( list ) ; } public synchronized void refreshJobComplete ( ) { fRefreshIndexJob = null ; } public void stop ( BundleContext context ) throws Exception { fPlugin = null ; getPreferenceStore ( ) . removePropertyChangeListener ( this ) ; LogFactory . getDefault ( ) . removeLogListener ( this ) ; super . stop ( context ) ; } public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( SVEditorPrefsConstants . P_DEBUG_LEVEL_S ) ) { SVCorePlugin . getDefault ( ) . setDebugLevel ( getDebugLevel ( ( String ) event . getNewValue ( ) ) ) ; } else if ( event . getProperty ( ) . equals ( SVEditorPrefsConstants . P_DEBUG_CONSOLE_S ) ) { synchronized ( fLogMessageQueue ) { fDebugConsole = ( Boolean ) event . getNewValue ( ) ; } } else if ( event . getProperty ( ) . equals ( SVEditorPrefsConstants . P_SV_TEMPLATE_PATHS ) ) { update_template_paths ( ) ; } else if ( event . getProperty ( ) . equals ( SVEditorPrefsConstants . P_AUTO_REBUILD_INDEX ) ) { SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) . setEnableAutoRebuild ( ( Boolean ) event . getNewValue ( ) ) ; } else if ( event . getProperty ( ) . equals ( SVEditorPrefsConstants . P_SV_TEMPLATE_PROPERTIES ) ) { update_global_parameters ( ) ; } } private Runnable logMessageRunnable = new Runnable ( ) { public void run ( ) { synchronized ( fLogMessageQueue ) { for ( LogMessage msg : fLogMessageQueue ) { ILogHandle handle = msg . handle ; int type = msg . type ; int level = msg . level ; String message = msg . message ; MessageConsoleStream out = null ; if ( type == ILogListener . Type_Error ) { out = getStderrStream ( ) ; } else if ( type == ILogListener . Type_Info ) { out = getStdoutStream ( ) ; } else if ( SVCorePlugin . getDefault ( ) . getDebugLevel ( ) >= level ) { if ( ( type & ILogListener . Type_Error ) != <NUM_LIT:0> ) { out = getStderrStream ( ) ; } else { out = getStdoutStream ( ) ; } } if ( out != null ) { out . println ( ""<STR_LIT:[>"" + handle . getName ( ) + ""<STR_LIT>"" + message ) ; } } fLogMessageQueue . clear ( ) ; fLogMessageScheduled = false ; } } } ; public void message ( ILogHandle handle , int type , int level , String message ) { synchronized ( fLogMessageQueue ) { if ( ! fDebugConsole && type != ILogListener . Type_Error ) { return ; } LogMessage msg = new LogMessage ( ) ; msg . handle = handle ; msg . type = type ; msg . level = level ; msg . message = message ; fLogMessageQueue . add ( msg ) ; if ( ! fLogMessageScheduled ) { Display . getDefault ( ) . asyncExec ( logMessageRunnable ) ; fLogMessageScheduled = true ; } } } public ResourceBundle getResources ( ) { if ( fResources == null ) { try { fResources = ResourceBundle . getBundle ( PLUGIN_ID + ""<STR_LIT>"" ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } return fResources ; } public static Image getImage ( String resource ) { SVUiPlugin p = getDefault ( ) ;'}]","Image image = p.fImageMap.get(resource); if (image == null) { image = p.loadImage(resource); p.fImageMap.put(resource, image); } return image; } private Image loadImage(String resource) { return imageDescriptorFromPlugin(PLUGIN_ID, resource).createImage(); } private ImageDescriptor imageDescriptorFromPlugin(String plugin, String resource) { return PlatformUI.getWorkbench().getEditorRegistry().getImageDescriptor(resource, plugin); }",0.0001998260587188856
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ti ; import org . jruby . ast . CallNode ; import org . jruby . ast . ClassNode ; import org . jruby . ast . ConstNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . DefsNode ; import org . jruby . ast . IterNode ; import org . jruby . ast . LocalAsgnNode ; import org . jruby . ast . LocalVarNode ; import org . jruby . ast . ModuleNode ; import org . jruby . ast . Node ; import org . rubypeople . rdt . internal . core . parser . InOrderVisitor ; import org . rubypeople . rdt . internal . ti . data . LiteralNodeTypeNames ; import org . rubypeople . rdt . internal . ti . data . TypicalMethodReturnNames ; public class TypeInferenceVisitor extends InOrderVisitor { private Scope globalScope ; private Scope currentScope ; public TypeInferenceVisitor ( Node rootNode ) { globalScope = new Scope ( rootNode , null ) ; currentScope = globalScope ; } public Object visitModuleNode ( ModuleNode iVisited ) { Scope newScope = pushScope ( iVisited ) ; Variable . insertLocalsFromScopeNode ( iVisited . getScope ( ) , newScope ) ; return super . visitModuleNode ( iVisited ) ; } public Object visitClassNode ( ClassNode iVisited ) { Scope newScope = pushScope ( iVisited ) ; Variable . insertLocalsFromScopeNode ( iVisited . getScope ( ) , newScope ) ; return super . visitClassNode ( iVisited ) ; } public Object visitDefnNode ( DefnNode iVisited ) { Scope newScope = pushScope ( iVisited ) ; Variable . insertLocalsFromScopeNode ( iVisited . getScope ( ) , newScope ) ; return super'}]",".visitDefnNode(iVisited); } public Object visitLocalAsgnNode(LocalAsgnNode iVisited) { Variable var = Variable.find(iVisited.getVar(), currentScope); if (var == null) { var = Variable.create(iVisited.getVar(), currentScope); } var.setAssigned(true); return super.visitLocalAsgnNode(iVisited); } }",0.00011857405357317822
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . stage ; import java . io . IOException ; import java . text . MessageFormat ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . compiler . common . Precondition ; import com . asakusafw . compiler . flow . FlowCompilingEnvironment ; import com . asakusafw . compiler . flow . plan . FlowBlock ; import com . asakusafw . compiler . flow . plan . StageBlock ; import com . asakusafw . compiler . flow . plan . StageGraph ; import com . asakusafw . compiler . flow . stage . StageModel . Fragment ; import com . asakusafw . compiler . flow . stage . StageModel . ResourceFragment ; import com . asakusafw . compiler . flow . stage . StageModel . Unit ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . vocabulary . flow . graph . FlowElement ; import com . asakusafw . vocabulary . flow . graph . FlowResourceDescription ; public class StageCompiler { static final Logger LOG = LoggerFactory . getLogger ( StageCompiler . class ) ; private final FlowCompilingEnvironment environment ; private final ShuffleAnalyzer shuffleAnalyzer ; private final StageAnalyzer mapredAnalyzer ; private final ShuffleKeyEmitter shuffleKeyEmitter ; private final ShuffleValueEmitter shuffleValueEmitter ; private final ShuffleGroupingComparatorEmitter shuffleGroupingEmitter ; private final ShuffleSortComparatorEmitter shuffleSortingEmitter ; private final ShufflePartitionerEmitter shuffleParitioningEmitter ; private final FlowResourceEmitter flowResourceEmitter ; private final MapFragmentEmitter mapFragmentEmitter ; private final ShuffleFragmentEmitter shuffleFragmentEmitter ; private final ReduceFragmentEmitter reduceFragmentEmitter ; private final MapperEmitter mapperEmitter ; private final ReducerEmitter reducerEmitter ; private final CombinerEmitter combinerEmitter ; public StageCompiler ( FlowCompilingEnvironment environment ) { Precondition . checkMustNotBeNull ( environment , ""<STR_LIT>"" ) ; this . environment = environment ; this . shuffleAnalyzer = new ShuffleAnalyzer ( environment ) ; this . mapredAnalyzer = new StageAnalyzer ( environment ) ; this . shuffleKeyEmitter = new ShuffleKeyEmitter ( environment ) ; this . shuffleValueEmitter = new ShuffleValueEmitter ( environment ) ; this . shuffleGroupingEmitter = new ShuffleGroupingComparatorEmitter ( environment ) ; this . shuffleSortingEmitter = new ShuffleSortComparatorEmitter ( environment ) ; this . shuffleParitioningEmitter = new ShufflePartitionerEmitter ( environment ) ; this . flowResourceEmitter = new FlowResourceEmitter ( environment ) ; this . mapFragmentEmitter = new MapFragmentEmitter ( environment ) ; this . shuffleFragmentEmitter = new ShuffleFragmentEmitter ( environment ) ; this . reduceFragmentEmitter = new ReduceFragmentEmitter ( environment ) ; this . mapperEmitter = new MapperEmitter ( environment ) ; this . reducerEmitter = new ReducerEmitter ( environment ) ; this . combinerEmitter = new CombinerEmitter ( environment ) ; } public List < StageModel > compile ( StageGraph graph ) throws IOException { Precondition . checkMustNotBeNull ( graph , ""<STR_LIT>"" ) ; LOG . info ( ""<STR_LIT>"" , graph . getInput ( ) . getSource ( ) . getDescription ( ) . getName ( ) ) ; Map < FlowResourceDescription , CompiledType > resourceMap = compileResources ( graph ) ; List < StageModel > results = Lists . create ( ) ; for ( StageBlock block : graph . getStages ( ) ) { StageModel model = compileStage ( block , resourceMap ) ; results . add ( model ) ; } if ( environment . hasError ( ) ) { throw new IOException ( MessageFormat . format ( ""<STR_LIT>"" , environment . getErrorMessage ( ) ) ) ; } return results ; } private StageModel compileStage ( StageBlock block , Map < FlowResourceDescription , CompiledType > resourceMap ) throws IOException { assert block != null ; assert resourceMap != null ; LOG . info ( ""<STR_LIT>"" , block ) ; StageModel model = analyze ( block ) ; blessResources ( model , resourceMap ) ; compileShuffle ( model ) ; compileFragments ( model ) ; compileUnits ( model ) ; return model ; } private void compileUnits ( StageModel model ) throws IOException { assert model != null ; for ( StageModel . MapUnit unit : model . getMapUnits ( ) ) { CompiledType compiled = mapperEmitter . emit ( model , unit ) ; unit . setCompiled ( compiled ) ; } if ( model . getReduceUnits ( ) . isEmpty ( ) == false ) { CompiledType compiledReducer = reducerEmitter . emit ( model ) ; CompiledType compiledCombiner = combinerEmitter . emit ( model ) ; CompiledReduce compiled = new CompiledReduce ( compiledReducer , compiledCombiner ) ; for ( StageModel . ReduceUnit unit : model . getReduceUnits ( ) ) { unit . setCompiled ( compiled ) ; } } } private void compileFragments ( StageModel model ) throws IOException { assert model != null ; StageBlock block = model . getStageBlock ( ) ; for ( StageModel . MapUnit unit : model . getMapUnits ( ) ) { for ( StageModel . Fragment fragment : unit . getFragments ( ) ) { if ( fragment . isCompiled ( ) ) { continue ; } CompiledType compiled = mapFragmentEmitter . emit ( fragment , block ) ; fragment . setCompiled ( compiled ) ; } } ShuffleModel shuffle = model . getShuffleModel ( ) ; if ( shuffle == null ) { return ; } Name keyTypeName = shuffle . getCompiled ( ) . getKeyTypeName ( ) ; Name valueTypeName = shuffle . getCompiled ( ) . getValueTypeName ( ) ; for ( ShuffleModel . Segment segment : shuffle . getSegments ( ) ) { CompiledShuffleFragment fragment = shuffleFragmentEmitter . emit ( segment , keyTypeName , valueTypeName , block ) ; segment . setCompiled ( fragment ) ; } for ( StageModel . ReduceUnit unit : model . getReduceUnits ( ) ) { for ( StageModel . Fragment fragment : unit . getFragments ( ) ) { if ( fragment . isCompiled ( ) ) { continue ; } CompiledType compiled ; if ( fragment . isRendezvous ( ) ) { compiled = reduceFragmentEmitter . emit ( fragment , shuffle , block ) ; } else {'}]","compiled = reduceFragmentEmitter.emit(fragment, block);fragment.setCompiled(compiled); } } }",6.801141565796723e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . java . emitter ; import java . io . IOException ; import java . io . PrintWriter ; import java . math . BigDecimal ; import java . text . MessageFormat ; import java . util . Collections ; import java . util . Set ; import org . apache . hadoop . io . Text ; import com . asakusafw . dmdl . java . Configuration ; import com . asakusafw . dmdl . java . util . JavaName ; import com . asakusafw . dmdl . java . util . NameUtil ; import com . asakusafw . dmdl . model . AstDescription ; import com . asakusafw . dmdl . model . AstName ; import com . asakusafw . dmdl . model . AstSimpleName ; import com . asakusafw . dmdl . model . BasicTypeKind ; import com . asakusafw . dmdl . semantics . Declaration ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; import com . asakusafw . dmdl . semantics . ModelSymbol ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . dmdl . semantics . trait . NamespaceTrait ; import com . asakusafw . dmdl . semantics . type . BasicType ; import com . asakusafw . runtime . value . BooleanOption ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . DoubleOption ; import com . asakusafw . runtime . value . FloatOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . ShortOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . utils . collections . Sets ; import com . asakusafw . utils . java . model . syntax . Comment ; import com . asakusafw . utils . java . model . syntax . CompilationUnit ; import com . asakusafw . utils . java . model . syntax . Expression ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . Name ; import com . asakusafw . utils . java . model . syntax . QualifiedName ; import com . asakusafw . utils . java . model . syntax . SimpleName ; import com . asakusafw . utils . java . model . syntax . Type ; import com . asakusafw . utils . java . model . syntax . TypeDeclaration ; import com . asakusafw . utils . java . model . util . ImportBuilder ; import com . asakusafw . utils . java . model . util . Models ; public final class EmitContext { private final DmdlSemantics semantics ; private final Configuration config ; private final ModelFactory factory ; private final SimpleName typeName ; private final ImportBuilder imports ; private final Set < String > fieldNames ; public EmitContext ( DmdlSemantics semantics , Configuration config , ModelDeclaration model , String categoryName , String typeNamePattern ) { if ( semantics == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( config == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( model == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( categoryName == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . semantics = semantics ; this . config = config ; this . factory = config . getFactory ( ) ; this . typeName = getTypeName ( model , typeNamePattern ) ; Name namespace = getNamespace ( model ) ; this . imports = new ImportBuilder ( factory , factory . newPackageDeclaration ( Models . append ( factory , config . getBasePackage ( ) , namespace , factory . newSimpleName ( categoryName ) ) ) , ImportBuilder . Strategy . TOP_LEVEL ) ; this . imports . resolvePackageMember ( this . typeName ) ; this . fieldNames = collectFieldNames ( model ) ; } private Set < String > collectFieldNames ( ModelDeclaration model ) { assert model != null ; Set < String > results = Sets . create ( ) ; for ( PropertyDeclaration property : model . getDeclaredProperties ( ) ) { results . add ( getFieldName ( property ) . getToken ( ) ) ; } return results ; } public ModelFactory getModelFactory ( ) { return factory ; } public DmdlSemantics getSemantics ( ) { return semantics ; } public Configuration getConfiguration ( ) { return config ; } private SimpleName getTypeName ( ModelDeclaration model , String namePattern ) { assert model != null ; assert namePattern != null ; return factory . newSimpleName ( MessageFormat . format ( namePattern , JavaName . of ( model . getName ( ) ) . toTypeName ( ) ) ) ; } private Name getNamespace ( ModelDeclaration model ) { assert model != null ; NamespaceTrait trait = model . getTrait ( NamespaceTrait . class ) ; AstName name ; if ( trait == null ) { name = new AstSimpleName ( null , NameConstants . DEFAULT_NAMESPACE ) ; } else { name = trait . getNamespace ( ) ; } return Models . toName ( factory , NameUtil . toPackageName ( name ) ) ; } public SimpleName getTypeName ( ) { return typeName ; } public QualifiedName getQualifiedTypeName ( ) { return factory . newQualifiedName ( imports . getPackageDeclaration ( ) . getName ( ) , typeName ) ; } public void emit ( TypeDeclaration type ) throws IOException { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } CompilationUnit compilationUnit = factory . newCompilationUnit ( imports . getPackageDeclaration ( ) , imports . toImportDeclarations ( ) , Collections . singletonList ( type ) , Collections . < Comment > emptyList ( ) ) ; PrintWriter writer = config . getOutput ( ) . openFor ( compilationUnit ) ; try { Models . emit ( compilationUnit , writer ) ; } finally { writer . close ( ) ; } } public Type resolve ( ModelSymbol model ) { if ( model == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ModelDeclaration decl = model . findDeclaration ( ) ; if ( decl == null ) { throw new IllegalArgumentException ( ) ; } Name qualifiedName = Models . append ( factory , config . getBasePackage ( ) , getNamespace ( decl ) , factory . newSimpleName ( NameConstants . CATEGORY_DATA_MODEL ) , getTypeName ( decl , NameConstants . PATTERN_DATA_MODEL ) ) ; return imports . toType ( qualifiedName ) ; } public Type resolve ( java . lang . reflect . Type type ) { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return imports . toType ( type ) ; } public Type resolve ( Name name ) { if ( name == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return imports . toType ( name ) ; } public Type resolve ( Type type ) { if ( type == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return imports . resolve ( type ) ; } public SimpleName getFieldName ( PropertyDeclaration property ) { if ( property == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } String name = JavaName . of ( property . getName ( ) ) . toMemberName ( ) ; return factory . newSimpleName ( name ) ; } public Type getValueType ( PropertyDeclaration property ) { if ( property == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( property . getType ( ) instanceof BasicType ) { BasicType bt = ( BasicType ) property . getType ( ) ; switch ( bt . getKind ( ) ) { case BOOLEAN : return resolve ( boolean . class ) ; case DATE : return resolve ( Date . class ) ; case DATETIME : return resolve ( DateTime . class ) ; case DECIMAL : return resolve ( BigDecimal . class ) ; case DOUBLE : return resolve ( double . class ) ; case FLOAT : return resolve ( float . class ) ; case BYTE : return resolve ( byte . class ) ; case SHORT : return resolve ( short . class ) ; case INT : return resolve ( int . class ) ; case LONG : return resolve ( long . class ) ; case TEXT : return resolve ( Text . class ) ; default : throw new IllegalArgumentException ( MessageFormat . format ( ""<STR_LIT>"" , bt . getKind ( ) ) ) ; } } throw new IllegalArgumentException ( ) ; } public Type getFieldType ( PropertyDeclaration property ) { if ( property == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( property . getType ( ) instanceof BasicType ) { BasicType bt = ( BasicType ) property . getType ( ) ; switch ( bt . getKind ( ) ) { case BOOLEAN : return resolve ( BooleanOption . class ) ; case DATE : return resolve ( DateOption . class ) ; case DATETIME : return resolve ( DateTimeOption . class ) ; case DECIMAL : return resolve ( DecimalOption . class ) ; case BYTE : return resolve ('}]","ByteOption.class);case SHORT:return resolve(FloatOption.class);case INT:return resolve(IntOption.class);case LONG:return resolve(LongOption.class);case TEXT:return resolve(StringOption.class);default:throw newIllegalArgumentException(MessageFormat.format(""<STR_LIT>"", bt.getKind()));}throw newIllegalArgumentException();}publicTypegetArrayType(PropertyDeclarationproperty){if(property==null){thrownewIllegalArgumentException(""<STR_LIT>"");}if(property.getType()instanceofBasicType){BasicTypelt=(BasicType)property.getType();switch(bt.getKind()){caseBOOLEAN:returnresolve(Boolean[].class);caseDATE:returnresolve(Date[].class);caseDATETIME:returnresolve(DateTime[].class);caseDECIMAL:returnresolve(BigDecimal[].class);caseDOUBLE:returnresolve(double[].class);caseFLOAT:returnresolve(float[].class);caseBYTE:returnresolve(byte[].class);caseSHORT:returnresolve(short[].class);caseINT:returnresolve(int[].class);caseLONG:returnresolve(long[].class);caseTEXT:returnresolve(Text[].class);default:thrownewIllegalArgumentException(MessageFormat.format(""<STR_LIT>"",bt.getKind()));}thrownewIllegalArgumentException();}publicTypegetMapType(PropertyDeclarationproperty){if(property==null){thrownewIllegalArgumentException(""<STR_LIT>"");}if(property.getType()instanceofBasicType){BasicTypelt=(",0.0004527720880945822
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . jface . resource . ColorRegistry ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . rubypeople . rdt . internal . ui . preferences . AppearancePreferencePage ; import org . rubypeople . rdt . ui . PreferenceConstants ; public class ColoredViewersManager implements IPropertyChangeListener { public static final String QUALIFIER_COLOR_NAME = ""<STR_LIT>"" ; public static final String DECORATIONS_COLOR_NAME = ""<STR_LIT>"" ; public static final String COUNTER_COLOR_NAME = ""<STR_LIT>"" ;'}]","private static final String[] COLOR_NAMES = { QUALIFIER_COLOR_NAME, DECORATIONS_COLOR_NAME, COUNTER_COLOR_NAME };private Map<String, Color> colorMap = new HashMap<>();private IBaseLabelProvider labelProvider;private StructuredViewer viewer;private Display display;private Control control;private ColorRegistry registry;public ColoredViewersManager(StructuredViewer viewer, Display display, Control control, ColorRegistry registry) {this.viewer = viewer;this.display = display;this.control = control;this.registry = registry;addDisposeListener(new DisposeListener() { @Override public void dispose(DisposeEvent e) { dispose(); } });viewer.addSelectionChangedListener(new org.eclipse.jface.viewers.SelectionChangedListener() { @Override public void selectionChanged(SelectionChangedEvent event) { refreshColors(); } });refreshColors();}public void dispose() {if (viewer!= null) {viewer.removeSelectionChangedListener(this);viewer = null;}if (display!= null) {display.dispose();display = null;}if (control!= null) {control.dispose();control = null;}if (registry!= null) {registry.dispose();registry = null;}colorMap.clear();}private void refreshColors() {if (viewer!= null && display!= null && control!=",0.00034040667455007847
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package $ { package } . jobflow ; import $ { package } . modelgen . table . model . SalesDetail ; import com . asakusafw . vocabulary . bulkloader . DbImporterDescription ; public class SalesDetailFromJdbc extends DbImporterDescription { @ Override public String getTargetName ( ) { return ""<STR_LIT>"" ; } @ Override public Class <'}]",> getTargetClass() { return SalesDetail.class; } },3.169956110012307e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . util ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public abstract class ResourceSelector { protected final static String EMPTY_STRING = ""<STR_LIT>"" ; protected Composite composite ; protected Button browseButton ; protected Text textField ; protected String browseDialogMessage = EMPTY_STRING ; protected String browseDialogTitle = EMPTY_STRING ; protected String validatedSelectionText = EMPTY_STRING ; public ResourceSelector ( Composite parent ) { composite = new Composite ( parent , SWT . NONE ) ; GridLayout'}]","layout = new GridLayout ( 2, true ) ; composite.setLayout ( layout ) ; } public void setBrowseDialogMessage ( String message ) { this. browseDialogMessage = message ; } public void setBrowseDialogTitle ( String title ) { this. browseDialogTitle = title ; } public void setBrowseButton ( Button button ) { this. browseButton = button ; } public void setTextField ( Text textField ) { this. textField = textField ; } public void setValidatedSelectionText ( String text ) { this. validatedSelectionText = text ; } public Button getBrowseButton ( ) { return browseButton ; } public Text getTextField ( ) { return textField ; } public void setBrowseButtonEnabled ( boolean enabled ) { if ( browseButton!= null ) { browseButton. setEnabled ( enabled ) ; } } public void setTextFieldEnabled ( boolean enabled ) { if ( textField!= null ) { textField. setEnabled ( enabled ) ; } } public void setTextFieldEditable ( boolean editable ) { if ( textField!= null ) { textField. setEditable ( editable ) ; } } public void createControls ( ) { browseButton = new Button ( composite, SWT. PUSH ) ; browseButton. addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected",0.00034680905200951004
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . parser ; import net . sf . sveditor . core . db . ISVDBAddChildItem ; import net . sf . sveditor . core . db . SVDBLocation ; import net . sf . sveditor . core . db . SVDBTypeInfo ; import net . sf . sveditor . core . db . SVDBTypeInfoBuiltin ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclItem ; import net . sf . sveditor . core . db . stmt . SVDBVarDeclStmt ; import net . sf . sveditor . core . scanner . SVKeywords ; public class SVBlockItemDeclParser extends SVParserBase { public SVBlockItemDeclParser ( ISVParser parser ) { super ( parser ) ; } public void parse ( ISVDBAddChildItem parent , SVDBTypeInfo type , SVDBLocation start ) throws SVParseException { parse ( parent , type , start , true ) ; } public void parse ( ISVDBAddChildItem parent , SVDBTypeInfo type , SVDBLocation start , boolean consume_terminator ) throws SVParseException { if ( fLexer . peekKeyword ( ""<STR_LIT>"" ) ) { parsers ( ) . dataTypeParser ( ) . typedef ( parent ) ; } else { String dir = null ; if ( start == null ) { start = fLexer . getStartLocation ( ) ; } if ( fLexer'}]",".peekKeyword(SVKeywords.DIRECTIVE) || fLexer.peekKeyword(SVKeywords.FUNCTION)) { dir = SVKeywords.DIRECTIVE; } else if (fLexer.peekKeyword(SVKeywords.VARIABLE)) { dir = SVKeywords.VARIABLE; } else { throw new SVParseException(fLexer.getErrorMessage(""<STR_LIT>"")); } if (dir == null) { throw new SVParseException(fLexer.getErrorMessage(""<STR_LIT>"")); } SVDBVarDeclStmt stmt = parsers().dataTypeParser().varDecl(parent, type, dir, start, consume_terminator); parent.addChild(stmt); } }",0.00018188875684952273
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . evaluation ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . Set ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . eclipse . jface . text . Assert ; import org . rubypeople . rdt . internal . debug . ui . RdtDebugUiMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class EvaluationExpressionReaderWriter { private static final String TEMPLATE_ROOT = ""<STR_LIT>"" ; private static final String TEMPLATE_ELEMENT = ""<STR_LIT>"" ; private static final String NAME_ATTRIBUTE = ""<STR_LIT:name>"" ; private static final String DESCRIPTION_ATTRIBUTE = ""<STR_LIT:description>"" ; private static final String ENABLED_ATTRIBUTE = ""<STR_LIT>"" ; public EvaluationExpressionReaderWriter ( ) { } public EvaluationExpression [ ] read ( Reader reader ) throws IOException { return read ( reader , null ) ; } public EvaluationExpression [ ] read ( Reader reader , ResourceBundle bundle ) throws IOException { return read ( new InputSource ( reader ) , bundle ) ; } public EvaluationExpression [ ] read ( InputStream stream , ResourceBundle bundle ) throws IOException { return read ( new InputSource ( stream ) , bundle ) ; } private EvaluationExpression [ ] read ( InputSource source , ResourceBundle bundle ) throws IOException { try { Collection expressions = new ArrayList ( ) ; Set ids = new HashSet ( ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder parser = factory . newDocumentBuilder ( ) ; Document document = parser . parse ( source ) ; NodeList elements = document . getElementsByTagName ( TEMPLATE_ELEMENT ) ; int count = elements . getLength ( ) ; for ( int i = <NUM_LIT:0> ; i != count ; i ++ ) { Node node = elements . item ( i ) ; NamedNodeMap attributes = node . getAttributes ( ) ; if ( attributes == null ) continue ; String name = getStringValue ( attributes , NAME_ATTRIBUTE ) ; name = translateString ( name'}]",", bundle ) ; String description = getStringValue ( attributes, DESCRIPTION_ATTRIBUTE ) ; description = translateString ( description, bundle ) ; boolean enabled = getBooleanValue ( attributes, ENABLED_ATTRIBUTE ) ; if ( name!= null &&!ids. contains ( name ) ) { EvaluationExpression expression = new EvaluationExpression ( name, description, enabled ) ; expressions. add ( expression ) ; ids. add ( name ) ; } } return expressions. toArray ( new EvaluationExpression [ expressions. size ( ) ] ) ; } private static String getStringValue ( NamedNodeMap attributes, String attributeName ) { Attr attr = ( Attr ) attributes. getNamedItem ( attributeName ) ; return attr!= null? attr. getValue ( ) : null ; } private static boolean getBooleanValue ( NamedNodeMap attributes, String attributeName ) { Attr attr = ( Attr ) attributes. getNamedItem ( attributeName ) ; return attr!= null? attr. getValue ( ). equals ( ""true"" ) : false ; } private static String translateString ( String value, ResourceBundle bundle ) { if ( value == null ) return null ; if ( bundle == null ) return value ; try { return bundle. getString ( value ) ; } catch ( MissingResourceException e ) { return value ; } } }",0.00036665720016598003
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt ; import junit . framework . Test ; import junit . framework . TestSuite ; import com . aptana . rdt . core . rspec . RSpecStructureCreatorTest ; import com . aptana . rdt . internal . core . gems . AllTests ; import com . aptana . rdt . internal . core'}]",". projects. ProjectSystemTest;public class RDTTestSuite extends TestSuite { public RDTTestSuite ( ) { addTest ( new RSpecStructureCreatorTest ( ) ) ; addTest ( new AllTests ( ) ) ; addTest ( new ProjectSystemTest ( ) ) ; } public static void main ( String [ ] args ) { TestRunner. run ( new RDTTestSuite ( ), args ) ; } }",0.0001247341963002804
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . vaadin . teemu . clara . inflater ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . logging . Logger ; import org . vaadin . teemu . clara . AttributeContext ; import org . vaadin . teemu . clara . AttributeInterceptor ; import org . vaadin . teemu . clara . util . ReflectionUtils ; import com . vaadin . ui . Component ; import com . vaadin . ui . ComponentContainer ; public class DefaultComponentManager implements ComponentManager { private List < AttributeParser > attributeParsers = new ArrayList < AttributeParser > ( ) ; private List < AttributeInterceptor > interceptors = new ArrayList < AttributeInterceptor > ( ) ; private Logger getLogger ( ) { return Logger . getLogger ( DefaultComponentManager . class . getName ( ) ) ; } public DefaultComponentManager ( ) { addAttributeParser ( new PrimitiveAttributeParser ( ) ) ; addAttributeParser ( new VaadinAttributeParser ( ) ) ; } public void addAttributeParser ( AttributeParser handler ) { attributeParsers . add ( handler ) ; } public void removeAttributeParser ( AttributeParser handler ) { attributeParsers . remove ( handler ) ; } public Component createComponent ( String namespace , String name , Map < String , String > attributes ) throws ComponentInstantiationException { try { Class < ? extends Component > componentClass = resolveComponentClass ( namespace , name ) ; Component newComponent = componentClass . newInstance ( ) ; handleAttributes ( newComponent , attributes ) ; return newComponent ; } catch ( Exception e ) { throw createException ( e , namespace , name ) ; } } protected ComponentInstantiationException createException ( Exception e , String namespace , String name ) { String message = String . format ( ""<STR_LIT>"" , namespace , name ) ; if ( e != null ) { return new ComponentInstantiationException ( message , e ) ; } else { return new ComponentInstantiationException ( message ) ; } } @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) protected Class < ? extends Component > resolveComponentClass ( String namespace , String name ) throws ClassNotFoundException { String qualifiedClassName = namespace + ""<STR_LIT:.>"" + name ; Class < ? > componentClass = null ; componentClass = Class . forName ( qualifiedClassName ) ; if ( ReflectionUtils . isComponent ( componentClass ) ) { return ( Class < ? extends Component > ) componentClass ; } else { throw new IllegalArgumentException ( String . format ( ""<STR_LIT>"" , componentClass . getName ( ) , Component . class . getName ( ) ) ) ; } } protected void handleAttributes ( Component component , Map < String , String > attributes ) { getLogger ( ) . fine ( attributes . toString ( ) ) ; try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method setter = getSetter ( attribute . getKey ( ) , component . getClass ( ) ) ; if ( setter != null ) { AttributeParser handler = getHandlerFor ( setter . getParameterTypes ( ) [ <NUM_LIT:0> ] ) ; if ( handler != null ) { String attributeValue = attribute . getValue ( ) ; if ( attributeValue == null || attributeValue . length ( ) == <NUM_LIT:0> ) { invokeWithInterceptors ( setter , component , attributeValue ) ; } else { invokeWithInterceptors ( setter , component , handler . getValueAs ( attributeValue , setter . getParameterTypes ( ) [ <NUM_LIT:0> ] ) ) ; } } } } } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } protected void invokeWithInterceptors ( final Method methodToInvoke , final Object obj , final Object ... args ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( interceptors . isEmpty ( ) ) { methodToInvoke . invoke ( obj , args ) ; } else { final LinkedList < AttributeInterceptor > interceptorsCopy = new LinkedList < AttributeInterceptor > ( interceptors ) ; AttributeInterceptor interceptor = interceptorsCopy . pop ( ) ; interceptor . intercept ( new AttributeContext ( methodToInvoke , args . length > <NUM_LIT:1> ? args [ <NUM_LIT:1> ] : args [ <NUM_LIT:0> ] ) { @ Override public void proceed ( ) throws Exception { if ( interceptorsCopy . size ( ) > <NUM_LIT:0> ) { interceptorsCopy . pop ( ) . intercept ( this ) ; } else { if ( args . length > <NUM_LIT:1> ) { methodToInvoke . invoke ( obj , args [ <NUM_LIT:0> ] , this . getValue ( ) ) ; } else { methodToInvoke . invoke ( obj , this . getValue ( ) ) ; } } } } ) ; } } protected AttributeParser getHandlerFor ( Class < ? > type ) { for ( AttributeParser handler : attributeParsers ) { if ( handler . isSupported ( type ) ) { return handler ; } } return null ; } public void applyLayoutAttributes ( ComponentContainer container , Component component , Map < String , String > attributes ) { if ( ! component . getParent ( ) . equals ( container ) ) { throw new IllegalStateException ( ""<STR_LIT>"" ) ; } try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method layoutMethod = getLayoutMethod ( container . getClass ( ) , attribute . getKey ( ) ) ; if ( layoutMethod != null ) { AttributeParser handler = getHandlerFor ( layoutMethod . getParameterTypes ( ) [ <NUM_LIT:1> ] ) ; if ( handler != null ) { invokeWithInterceptors ('}]","layoutMethod, container, handler.getValueAs(attribute.getValue(), layoutMethod.getParameterTypes()[<NUM_LIT:1>]));} catch (SecurityException e) {e.printStackTrace();} catch (IllegalArgumentException e) {e.printStackTrace();} catch (IllegalAccessException e) {e.printStackTrace();} catch (InvocationTargetException e) {e.printStackTrace();}} finally {if (attributes!= null) {attributes.clear();}}} protected Method getLayoutMethod(Class<?> clazz, String attributeName) {try {return clazz.getMethod(""set"" + attributeName, new Class[] { Class.forName(attributeName) });} catch (NoSuchMethodException e) {return null;} catch (ClassNotFoundException e) {return null;}} protected Method getSetter(String attributeName, Class<?> clazz) {try {return clazz.getMethod(""set"" + attributeName, new Class[] { Class.forName(attributeName) });} catch (NoSuchMethodException e) {return null;} catch (ClassNotFoundException e) {return null;}} public void addInterceptor(AttributeInterceptor interceptor) {interceptors.add(interceptor);} public void removeInterceptor(AttributeInterceptor interceptor) {interceptors.remove(interceptor);} }",0.00035481991295490767
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt ; import java . util . List ; import com . pogofish . jadt . errors . UserError ; import com . pogofish . jadt . printer . UserErrorPrinter ; public class JADTUserErrorsException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private final List < UserError > errors ; public JADTUserErrorsException ( List < UserError > errors ) { super ( makeString ( errors ) ) ; this .'}]",errors = errors; } private static String makeString ( List < UserError > errors ) { UserErrorPrinter printer = new UserErrorPrinter (); return printer. print ( errors ) ; } },6.422327987399576e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . widgets ; import net . ggtools . grand . ui . log . LogEventBufferImpl ; import net . ggtools . grand . ui . log . LogViewer ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse .'}]","swt. custom. CTabFolder; import org.eclipse.swt.custom.CTabItem; import org.eclipse.swt.layout.FormLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; public class LogViewerWidget { public LogViewerWidget ( Shell shell ) { Display display = new Display ( ) ; Window window = new Window ( display, SWT. DELEGATE ) ; LogViewer logViewer = new LogViewer ( ) ; LogEventBufferImpl buffer = new LogEventBufferImpl ( ) ; logViewer. setLogBuffer ( buffer ) ; CTabFolder tabFolder = new CTabFolder ( window, SWT. FLAT ) ; CTabItem tabItem = new CTabItem ( tabFolder, SWT. NONE ) ; tabItem. setText ( ""Log Viewer"" ) ; tabFolder. setTopControl ( tabItem ) ; tabItem. setControl ( logViewer ) ; window. open ( ) ; while (! window. isDisposed ( ) ) { if (! display. readAndDispatch ( ) ) { display. sleep ( ) ; } } display. dispose ( ) ; } }",0.000296250849551307
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . windgate . common . driver ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . List ; import com . asakusafw . utils . collections . Lists ; import com . asakusafw . utils . java . jsr199 . testing . VolatileJavaFile ; import com . asakusafw . utils . java . model . syntax . PackageDeclaration ; import com . asakusafw . utils . java . model . util . Emitter ; public class VolatileEmitter extends Emitter { private final List < VolatileJavaFile > emitted = Lists . create ( ) ; @ Override public PrintWriter openFor ( PackageDeclaration packageDeclOrNull , String subPath ) throws IOException { StringBuilder buf = new StringBuilder ( ) ; if ( packageDeclOrNull != null ) { buf . append ( packageDeclOrNull . getName ( )'}]",) ; } return new PrintWriter ( new VolatileJavaFile ( buf. toString ( ) + subPath ). getOutputStream ( ) ) ; },5.5883431068885773e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . expr_utils ; import net . sf . sveditor . core . log . ILogHandle ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . parser . ISVParser ; import net . sf . sveditor . core . parser . SVLexer ; import net . sf . sveditor . core . parser . SVParseException ; import net . sf . sveditor . core . parser . SVParsers ; import net . sf . sveditor . core . scanutils . StringTextScanner ; public class SVExprUtilsParser implements ISVParser { private SVLexer fLexer ; private SVParsers fParsers ; private LogHandle fLog ; public SVExprUtilsParser ( SVExprContext context ) { this ( context , false ) ; } public SVExprUtilsParser ( SVExprContext context , boolean parse_full ) { StringBuilder content = new StringBuilder ( ) ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" , ILogHandle . LOG_CAT_PARSER ) ; if ( context . fTrigger == null ) { content . append ( context . fLeaf ) ; } else { content . append ( context . fRoot ) ; if ( parse_full ) { content . append ( context . fTrigger ) ; content . append ( context . fLeaf ) ; } } fLexer = new SVLexer ( ) ; fLexer . init ( this , new StringTextScanner ( content ) ) ; fParsers = new SVParsers ( this ) ; fParsers . init ( this ) ; }'}]",@Override public void init(ISVParser parser) throws SVParseException { // initialization code here },4.555005707432731e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver ; import java . text . MessageFormat ; import com . asakusafw . testdriver . core . ModelVerifier ; public class IdentityVerifier implements ModelVerifier < Object > { @ Override public Object getKey ( Object target ) { return target ; } @ Override public Object verify ( Object expected , Object actual ) { if ( expected == null ) { return MessageFormat . format ( ""<STR_LIT>"" , actual ) ; } else if'}]","actual == null ) { return MessageFormat. format ( ""<STR_LIT>"", expected ) ; } else if (! expected. equals ( actual ) ) { return MessageFormat. format ( ""<STR_LIT>"", expected, actual ) ; } else { return expected ; } } }",8.871597985279164e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory ; import com . asakusafw . compiler . flow . testing . operator . ExOperatorFactory . Error ; import com .'}]",asakusafw.compiler.flow.testing.model.Ex1; import com.asakusafw.compiler.flow.testing.operator.ExOperatorFactory; import com.asakusafw.compiler.flow.testing.operator.ExOperatorFactory.Error; import org.junit.Test; public class ExOperatorFactoryTest { @Test public void test() throws Error { Ex1 ex1 = new Ex1(); ExOperatorFactory operatorFactory = new ExOperatorFactory(); ExOperator operator = operatorFactory.create(ex1); } },0.00013655952344085502
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . graph . draw2d ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import net . ggtools . grand . ui . Application ; import net . ggtools . grand . ui . graph . GraphControler ; import net . ggtools . grand . ui . graph . GraphListener ; import net . ggtools . grand . ui . graph . SelectionManager ; import net . ggtools . grand . ui . widgets . CanvasScroller ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . draw2d . Cursors ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . InputEvent ; import org . eclipse . draw2d . MouseEvent ; import org . eclipse . draw2d . MouseListener ; import org . eclipse . draw2d . Panel ; import org . eclipse . draw2d . ScaledGraphics ; import org . eclipse . draw2d . XYLayout ; import org . eclipse . draw2d . geometry . Dimension ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . draw2d . geometry . Translatable ; import sf . jzgraph . IVertex ; public class Draw2dGraph extends Panel implements SelectionManager { private final class GraphMouseListener extends MouseListener . Stub { @ Override public void mousePressed ( final MouseEvent me ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" + me . button ) ; } switch ( me . button ) { case ( <NUM_LIT:1> ) : deselectAllNodes ( ) ; me . consume ( ) ; case ( <NUM_LIT:2> ) : if ( scroller != null ) { scroller . enterDragMode ( ) ; } break ; case ( <NUM_LIT:3> ) : if ( graphControler != null ) { graphControler . getDisplayer ( ) . getContextMenu ( ) . setVisible ( true ) ; } break ; } } @ Override public void mouseReleased ( final MouseEvent me ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" + me . button ) ; } switch ( me . button ) { case ( <NUM_LIT:1> ) : case ( <NUM_LIT:2> ) : if ( scroller != null ) { scroller . leaveDragMode ( ) ; } break ; } } } private final class NodeMouseListener extends MouseListener . Stub { private final Log log = LogFactory . getLog ( NodeMouseListener . class ) ; private final Draw2dNode node ; private NodeMouseListener ( final Draw2dNode node ) { super ( ) ; this . node = node ; } @ Override public void mouseDoubleClicked ( final MouseEvent me ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" + me . button ) ; } switch ( me . button ) { case ( <NUM_LIT:1> ) : { final boolean addToSelection ; if ( ( me . getState ( ) & InputEvent . CONTROL ) == <NUM_LIT:0> ) { addToSelection = false ; } else { addToSelection = true ; } selectNode ( node , addToSelection ) ; graphControler . openNodeFile ( node ) ; } } me . consume ( ) ; } @ Override public void mousePressed ( final MouseEvent me ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" + me . button ) ; } switch ( me . button ) { case ( <NUM_LIT:1> ) : { final boolean addToSelection ; if ( ( me . getState ( ) & InputEvent . CONTROL ) == <NUM_LIT:0> ) { addToSelection = false ; } else { addToSelection = true ; } toggleSelection ( node , addToSelection ) ; me . consume ( ) ; break ; } case ( <NUM_LIT:3> ) : { if ( ! node . isSelected ( ) ) { selectNode ( node , false ) ; } if ( graphControler != null ) { ( graphControler ) . getDisplayer ( ) . getContextMenu ( ) . setVisible ( true ) ; } break ; } } } @ Override public void mouseReleased ( final MouseEvent me ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" + me . button ) ; } switch ( me . button ) { case ( <NUM_LIT:1> ) : case ( <NUM_LIT:2> ) : if ( scroller != null ) { scroller . leaveDragMode ( ) ; } break ; } } } private static final Log log = LogFactory . getLog ( Draw2dGraph . class ) ; private GraphControler graphControler ; private GraphMouseListener graphMouseListener ; private final Map < String , Draw2dNode > nodeIndex = new HashMap < String , Draw2dNode > ( ) ; private CanvasScroller scroller ; private float zoom ; public Draw2dGraph ( ) { super ( ) ; scroller = null ; setLayoutManager ( new XYLayout ( ) ) ; setZoom ( <NUM_LIT:1.0f> ) ; } public void addListener ( final GraphListener listener ) { if ( graphControler != null ) { graphControler . addListener ( listener ) ; } } @ Override public void addNotify ( ) { if ( log . isTraceEnabled ( ) ) { log . trace ( ""<STR_LIT>"" ) ; } super . addNotify ( ) ; graphMouseListener = new GraphMouseListener ( ) ; addMouseListener ( graphMouseListener ) ; setFocusTraversable ( true ) ; } public Draw2dNode createNode ( final IVertex vertex ) { final Draw2dNode node = new Draw2dNode ( this , vertex ) ; add ( node , node . getBounds ( ) ) ; node . setFont ( Application . getInstance ( ) . getFont ( Application . NODE_FONT ) ) ; node . addMouseListener ( new NodeMouseListener ( node ) ) ; node . setCursor ( Cursors . HAND ) ; nodeIndex'}]",".put(node.getVertex().getId(), node); return node; } public void deselectAllNodes() { for (final Draw2dNode node : nodeIndex.values()) { node.deselect(); } } public void setGraphControler(GraphControler graphControler) { this.graphControler = graphControler; } public GraphControler getGraphControler() { return graphControler; } public void setScroller(CanvasScroller scroller) { this.scroller = scroller; } public CanvasScroller getScroller() { return scroller; } public void setZoom(float zoom) { this.zoom = zoom; } public float getZoom() { return zoom; } }",0.00023591998693426932
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . corext . template . ruby ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . TextUtilities ; import org . eclipse . jface . text . templates . Template ; import org . eclipse . jface . text . templates . TemplateBuffer ; import org . eclipse . jface . text . templates . TemplateContextType ; import org . eclipse . jface . text . templates . TemplateException ; import org . eclipse . jface . text . templates . TemplateTranslator ; import org . eclipse . jface . text . templates . TemplateVariable ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . internal . corext . util . Strings ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . template . contentassist . MultiVariable ; import org . rubypeople . rdt . ui . PreferenceConstants ; public class RubyContext extends RubyScriptContext { public RubyContext ( TemplateContextType type , IDocument document , int completionOffset , int completionLength , IRubyScript compilationUnit ) { super ( type , document , completionOffset , completionLength , compilationUnit ) ; } public TemplateBuffer evaluate ( Template template ) throws BadLocationException , TemplateException { if ( ! canEvaluate ( template ) ) throw new TemplateException ( RubyTemplateMessages . Context_error_cannot_evaluate ) ; TemplateTranslator translator = new TemplateTranslator ( ) { protected TemplateVariable createVariable ( String type , String name , int [ ] offsets ) { return new MultiVariable ( type , name , offsets ) ; } } ; TemplateBuffer buffer = translator . translate ( template ) ; getContextType ( ) . resolve ( buffer , this ) ; IPreferenceStore prefs = RubyPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean useCodeFormatter = prefs . getBoolean ( PreferenceConstants . TEMPLATES_USE_CODEFORMATTER ) ; IRubyProject project = getRubyScript ( ) != null ? getRubyScript ( ) . getRubyProject ( ) : null ; RubyFormatter formatter = new RubyFormatter ( TextUtilities . getDefaultLineDelimiter ( getDocument ( ) ) , getIndentation ( ) , useCodeFormatter , project ) ; formatter . format ( buffer , this ) ; return buffer ; } private int getIndentation ( ) { int start = getStart ( ) ; IDocument document = getDocument ( ) ; try { IRegion region = document . getLineInformationOfOffset ( start ) ; String lineContent = document . get ( region . getOffset ( ) , region . getLength ( ) ) ; IRubyScript compilationUnit = getRubyScript ( ) ; IRubyProject project = compilationUnit == null ? null : compilationUnit . getRubyProject ( ) ; return Strings . computeIndentUnits ( lineContent , project ) ; } catch ( BadLocationException e ) { return <NUM_LIT:0> ; } } public boolean canEvaluate ( Template template ) { if ( fForceEvaluation ) return true ; String key = getKey ( ) ; return template . matches ( key , getContextType ( ) . getId ( ) ) && key . length ( ) != <NUM_LIT:0> && template . getName ( ) . toLowerCase ( ) . startsWith ( key . toLowerCase ( ) ) ; } public String getKey ( ) { if ( getCompletionLength ( ) == <NUM_LIT:0> ) return super . getKey ( ) ; try { IDocument document = getDocument ( ) ; int start = getStart ( ) ; int end = getCompletionOffset ( ) ; return start <= end ? document . get ( start , end - start ) : ""<STR_LIT>"" ; }'}]","catch (BadLocationException e) { return """"; }",4.213801779703924e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . parser . javadoc . ir ; public class IrDocArrayType extends AbstractIrDocElement implements IrDocType { private static final long serialVersionUID = <NUM_LIT:1L> ; private IrDocType componentType ; public IrDocArrayType ( IrDocType componentType ) { super ( ) ; if ( componentType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . componentType = componentType ; } @ Override public IrDocElementKind getKind ( ) { return IrDocElementKind . ARRAY_TYPE ; } public IrDocType getComponentType ( ) { return this . componentType ; } public void setComponentType ( IrDocType componentType ) { if ( componentType == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } checkCyclic ( componentType ) ; this . componentType = componentType ; } private void checkCyclic ( IrDocType t ) { IrDocType current = t ; while'}]","( current!= null ) { if ( current == this ) { throw new IllegalStateException ( ""<STR_LIT>"" ) ; } current = current. getComponentType ( ) ; } } }",6.475540967196923e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . matching ; import org . rubypeople . rdt . core . search . SearchPattern ; import org . rubypeople . rdt . internal . core . search . indexing . IIndexConstants ; import org . rubypeople . rdt . internal . core . util . CharOperation ; public class TypeReferencePattern extends AndPattern implements IIndexConstants { protected char [ ] qualification ; protected char [ ] simpleName ; protected char [ ] currentCategory ; public int segmentsSize ; protected char [ ] [ ] segments ; protected int currentSegment ; protected static char [ ] [ ] CATEGORIES = { REF } ; public TypeReferencePattern ( char [ ] qualification , char [ ] simpleName , int matchRule ) { this ( matchRule ) ; if ( qualification != null && qualification . length == <NUM_LIT:0> ) { this . qualification = null ; } else { this . qualification = isCaseSensitive ( ) ? qualification : CharOperation . toLowerCase ( qualification ) ; } this . simpleName = ( isCaseSensitive ( ) || isCamelCase ( ) ) ? simpleName : CharOperation . toLowerCase ( simpleName ) ; if ( simpleName == null ) this . segments = this . qualification == null ? ONE_STAR_CHAR : CharOperation . splitOn ( ""<STR_LIT>"" , this . qualification ) ; else this . segments = null ; if ( this . segments == null ) if ( this . qualification == null ) this . segmentsSize'}]",= 0; else this.segmentsSize = this.qualification.length; } public TypeReferencePattern(int matchRule) { super(matchRule); } },5.6997289466970836e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . hadoop . fs . Path ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; public class FileListTest { @ Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; @ Test public void simple ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT>"" ) ; FileOutputStream output = new FileOutputStream ( file ) ; try { FileList . Writer writer = FileList . createWriter ( output ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; writer . close ( ) ; } finally { output . close ( ) ; } FileInputStream input = new FileInputStream ( file ) ; try { FileList . Reader reader = FileList . createReader ( input ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertThat ( reader . next ( ) , is ( false ) ) ; reader . close ( ) ; } finally { input . close ( ) ; } } @ Test public void empty ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT>"" ) ; FileOutputStream output = new FileOutputStream ( file ) ; try { FileList . Writer writer = FileList . createWriter ( output ) ; writer . close ( ) ; } finally { output . close ( ) ; } FileInputStream input = new FileInputStream ( file ) ; try { FileList . Reader reader = FileList . createReader ( input ) ; assertThat ( reader . next ( ) , is ( false ) ) ; reader . close ( ) ; } finally { input . close ( ) ; } } @ Test public void multiple ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT>"" ) ; FileOutputStream output = new FileOutputStream ( file ) ; try { FileList . Writer writer = FileList . createWriter ( output ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; writer . close ( ) ; } finally { output . close ( ) ; } FileInputStream input = new FileInputStream ( file ) ; try { FileList . Reader reader = FileList . createReader ( input ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; assertThat ( reader . next ( ) , is ( false ) ) ; reader . close ( ) ; } finally { input . close ( ) ; } } @ Test public void unexpected_eof ( ) throws Exception { File file = folder . newFile ( ""<STR_LIT>"" ) ; FileOutputStream output = new FileOutputStream ( file ) ; try { FileList . Writer writer = FileList . createWriter ( output ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; write ( writer , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } finally { output . close ( ) ; } FileInputStream input = new FileInputStream ( file ) ; try { FileList . Reader reader = FileList . createReader ( input ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; read ( reader , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; reader . next ( ) ; fail ( ) ; } catch ( IOException e ) { } finally { input .'}]",.close();,3.150842532473699e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . example ; import com . asakusafw . compiler . operator . model . MockHoge ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow'}]",. Out;public class Example extends FlowDescription { @Import public MockHoge hoge = new MockHoge(); @In public String input = new String(); @Out public String output = new String(); },7.634618811639628e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . renamemethod ; import java . util . ArrayList ; import java . util . Collection ; import org . jruby . ast . CallNode ; import org . jruby . ast . ClassNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . jruby . ast . SClassNode ; import org . jruby . ast . SymbolNode ; import org . jruby . ast . VCallNode ; import org . rubypeople . rdt . refactoring . classnodeprovider . ClassNodeProvider ; import org . rubypeople . rdt . refactoring . core . NodeProvider ; import org . rubypeople . rdt . refactoring . core . SelectionNodeProvider ; import org . rubypeople . rdt . refactoring . core . renamefield . FieldRenameEditProvider ; import org . rubypeople . rdt . refactoring . core . renamefield . fielditems . FieldItem ; import org . rubypeople . rdt . refactoring . core . renamemethod . methoditems . CallCandidateItem ; import org . rubypeople . rdt . refactoring . core . renamemethod . methoditems . MethodNameArgumentItem ; import org . rubypeople . rdt . refactoring . core . renamemethod . methoditems . SymbolItem ; import org . rubypeople . rdt . refactoring . editprovider . FileEditProvider ; import org . rubypeople . rdt . refactoring . editprovider . FileMultiEditProvider ; import org . rubypeople . rdt . refactoring . editprovider . IMultiFileEditProvider ; import org . rubypeople . rdt . refactoring . editprovider . MultiFileEditProvider ; import org . rubypeople . rdt . refactoring . exception . NoClassNodeException ; import org . rubypeople . rdt . refactoring . nodewrapper . ClassNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . INodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodCallNodeWrapper ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodNodeWrapper ; public class MethodRenamer implements IMultiFileEditProvider { private RenameMethodConfig config ; public Collection < String > getAllMethodsFromClass ( ) { Collection < String > names = new ArrayList < String > ( ) ; if ( config . getSelectedClass ( ) != null ) { for ( MethodNodeWrapper method : config . getSelectedClass ( ) . getMethods ( ) ) { names . add ( method . getName ( ) ) ; } } return names ; } public MethodRenamer ( RenameMethodConfig config ) { this . config = config ; Collection < INodeWrapper > probableClass = getCallCandidatesInClass ( ) ; probableClass . addAll ( getSubsequentCalls ( ) ) ; probableClass . addAll ( config . getSelectedCalls ( ) ) ; config . setSelectedCalls ( probableClass ) ; } public Collection < FileMultiEditProvider > getFileEditProviders ( ) { MultiFileEditProvider fileEdits = new MultiFileEditProvider ( ) ; addDefinitionRenamer ( fileEdits ) ; addCallRenamers ( fileEdits ) ; if ( ! config . getTargetMethod ( ) . isClassMethod ( ) ) { addSymbolRenamers ( fileEdits ) ; } return fileEdits . getFileEditProviders ( ) ; } private void addSymbolRenamers ( MultiFileEditProvider fileEdits ) { if ( config . getTargetMethod ( ) . isClassMethod ( ) ) { return ; } String file = config . getDocumentProvider ( ) . getActiveFileName ( ) ; for ( SymbolNode currentNode : getSymbolCandidatesInClass ( ) ) { addSymbolRenamer ( fileEdits , file , currentNode , config . getNewName ( ) ) ; } } private void addSymbolRenamer ( MultiFileEditProvider fileEdits , String file , SymbolNode currentNode , String name ) { SymbolItem currentItem = new SymbolItem ( currentNode ) ; fileEdits . addEditProvider ( new FileEditProvider ( file , new MethodRenameEditProvider ( currentItem , name ) ) ) ; } private void addCallRenamers ( MultiFileEditProvider fileEdits ) { for ( INodeWrapper currentCandidate : config . getSelectedCalls ( ) ) { String file = currentCandidate . getWrappedNode ( ) . getPosition ( ) . getFile ( ) ; String newName = config . getNewName ( ) ; if ( currentCandidate instanceof MethodCallNodeWrapper ) { CallCandidateItem candidateItem = new CallCandidateItem ( ( MethodCallNodeWrapper ) currentCandidate ) ; fileEdits . addEditProvider ( new FileEditProvider ( file , new MethodRenameEditProvider ( candidateItem , newName ) ) ) ; } else if ( config . renameFields ( ) ) {'}]","FieldRenameEditProvider editProvider = new FieldRenameEditProvider(new FieldItem(currentCandidate), newName); fileEdits.addEditProvider(new FileEditProvider(file, editProvider)); } } private void addDefinitionRenamer ( MultiFileEditProvider fileEdits ) { String file = config. getDocumentProvider ( ). getActiveFileName ( ) ; String newName = config. getNewName ( ) ; fileEdits. addEditProvider ( new FileEditProvider ( file, new MethodRenameEditProvider ( config. getTargetMethod ( ), newName ) ) ) ; } private Collection < INodeWrapper > getCallCandidatesInClass ( ) { Collection < INodeWrapper > probableClass = new ArrayList < INodeWrapper > ( ) ; probableClass. add ( new ClassNodeWrapper ( config. getSelectedClass ( ) ) ) ; probableClass. add ( new MethodCallNodeWrapper ( config. getTargetMethod ( ) ) ) ; return probableClass ; } private Collection < INodeWrapper > getSubsequentCalls ( ) { Collection < INodeWrapper > subsequentCalls = new ArrayList < INodeWrapper > ( ) ; for ( VCallNode call : config. getSelectedClass ( ). getMethods ( ) ) { if ( call. getMethod",0.0003972823941422432
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . server ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Vector ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletRequestWrapper ; public class RequestParamHandler { private static final String ATTRIBUTE_NAME_IS_HANDLED = ""<STR_LIT>"" ; private final static HashMap < String , String > mimeTypes = new HashMap < String , String > ( ) ; static { mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mimeTypes . put ( ""<STR_LIT>"" , ""<STR_LIT:text/plain>"" ) ; mimeTypes . put ( ""<STR_LIT:text>"" , ""<STR_LIT:text/plain>"" ) ; } public static String removeOutputRequestParam ( String uri ) { return uri . replaceFirst ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; }'}]","public static HttpServletRequest removeOutputRequestParam(HttpServletRequest request, String uri)",3.3584775982440694e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; public class CPVariableElementLabelProvider extends LabelProvider implements IColorProvider { private Image fJARImage ; private Image fFolderImage ; private boolean fShowResolvedVariables ; private Color fResolvedBackground ; public CPVariableElementLabelProvider ( boolean showResolvedVariables ) { ImageRegistry reg = RubyPlugin . getDefault ( ) . getImageRegistry ( ) ; fJARImage = reg . get ( RubyPluginImages . IMG_OBJS_EXTJAR ) ; fFolderImage = PlatformUI . getWorkbench ( ) . getSharedImages ( ) . getImage ( ISharedImages . IMG_OBJ_FOLDER ) ; fShowResolvedVariables = showResolvedVariables ; fResolvedBackground = null ; } public Image getImage ( Object element ) { if ( element instanceof CPVariableElement ) { CPVariableElement curr = ( CPVariableElement ) element ; IPath path = curr . getPath ( ) [ <NUM_LIT:0> ] ; if ( path . toFile ( ) . isFile ( ) ) { return fJARImage ; } return fFolderImage ; } return super . getImage ( element ) ; } public String getText ( Object element ) { if ( element instanceof CPVariableElement ) { CPVariableElement curr = ( CPVariableElement ) element ; String name = curr . getName ( ) ; IPath path = curr . getPath ( ) [ <NUM_LIT:0> ] ; StringBuffer buf = new StringBuffer ( name ) ; if ( curr . isReserved ( ) ) { buf . append ( \'<CHAR_LIT:U+0020>\' ) ; buf . append ( NewWizardMessages . CPVariableElementLabelProvider_reserved ) ; } if ( path != null ) { buf . append ( ""<STR_LIT:U+0020-U+0020>"" ) ; if ( ! path . isEmpty ( ) ) { buf . append ( path . toOSString ( ) ) ; } else { buf . append ('}]","""<STR_LIT:U+0020-U+0020>"" ) ; } } return buf. toString ( ) ; } public Color getForeground ( Object element ) { if ( element instanceof CPVariableElement ) { CPVariableElement curr = ( CPVariableElement ) element ; if ( curr. isResolved ( ) ) { return fResolvedBackground == null? null : fResolvedBackground ; } } return super. getForeground ( element ) ; } public Color getBackground ( Object element ) { if ( element instanceof CPVariableElement ) { CPVariableElement curr = ( CPVariableElement ) element ; if ( curr. isResolved ( ) ) { return fResolvedBackground ; } } return super. getBackground ( element ) ; } }",0.00021657897857575253
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . mcbans . firestar . mcbans . callBacks ; import java . util . HashMap ; import org . bukkit . ChatColor ; import com . mcbans . firestar . mcbans . BukkitInterface ; import com . mcbans . firestar . mcbans . request . JsonHandler ; public class Ping implements Runnable { private final BukkitInterface MCBans ; private String commandSend = ""<STR_LIT>"" ; public Ping ( BukkitInterface p , String player ) { MCBans = p ; commandSend = player ; } @ Override public void run ( ) { while ( MCBans . notSelectedServer ) { try { Thread .'}]",".sleep(1000); // wait 1 second} catch (InterruptedException e) {e.printStackTrace();}if (!MCBans.notSelectedServer) {JsonHandler handler = new JsonHandler(MCBans.getJson());String response = handler.handle(commandSend);if (!response.equalsIgnoreCase(""You are not connected to a server."")) {MCBans.sendMessage(ChatColor.RED + ""Player is online: "" + ChatColor.GOLD + player + ChatColor.RED + "" ("" + ChatColor.GOLD + response + ChatColor.RED + "")"");}}}}",0.00015083674247652216
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import net . sf . sveditor . core . db . SVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBTypeInfo ; public class SVDBParamPortDecl extends SVDBVarDeclStmt { public static final int Direction_Ref = ( <NUM_LIT:1> << <NUM_LIT> ) ; public static final int Direction_Const = ( <NUM_LIT:1> << <NUM_LIT:20> ) ; public static final int Direction_Var = ( <NUM_LIT:1> << <NUM_LIT> ) ; public static final int Direction_Input = ( <NUM_LIT:1> << <NUM_LIT:16> ) ; public static final int Direction_Output = ( <NUM_LIT:1> << <NUM_LIT> ) ; public static final int Direction_Inout = ( <NUM_LIT:1> << <NUM_LIT> ) ; public static final int WireType_Shift = <NUM_LIT:20> ; public static final int WireType_none = ( <NUM_LIT:0> << WireType_Shift ) ; public static final int WireType_supply0 = ( <NUM_LIT:1> << WireType_Shift ) ; public static final int Direction_supply1 = ( <NUM_LIT:2> << WireType_Shift ) ; public static final int Direction_tri = ( <NUM_LIT:3> << WireType_Shift ) ; public static final int Direction_triand = ( <NUM_LIT:4> <<'}]","WireType_Shift) ; public static final int Direction_triord = ( <NUM_LIT:5> << WireType_Shift) ; public static final int Direction_clock = ( <NUM_LIT:6> << WireType_Shift) ; public static final int Direction_tristate = ( <NUM_LIT:7> << WireType_Shift) ; public SVDBParamPortDecl ( SVDBItemBase item, SVDBTypeInfo info ) { super ( item, info ) ; } }",0.00015267020009620617
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq ; import junit . framework . Test ; import junit . framework . TestSuite ; public class AllTests {'}]","public static void main(String[] args) { TestSuite suite = new TestSuite(); suite.addTest(new Test(""Test1"")); suite.addTest(new Test(""Test2"")); TestRunner.run(suite); }",6.703505301242196e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . server ; import java . io . IOException ; import java . util . Map ; import java . util . TreeMap ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . velocity . context . Context ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ResIterator ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . rdf . model . Statement ; import de . fuberlin . wiwiss . d2rq . ClassMapLister ; public class DirectoryServlet extends HttpServlet { protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { D2RServer server = D2RServer . fromServletContext ( getServletContext ( ) ) ; server . checkMappingFileChanged ( ) ; if ( request . getPathInfo ( ) == null ) { response . sendError ( <NUM_LIT> ) ; return ; } String classMapName = request . getPathInfo ( ) . substring ( <NUM_LIT:1> ) ; Model resourceList = getClassMapLister ( ) . classMapInventory ( classMapName , server . getConfig ( ) . getLimitPerClassMap ( ) ) ; if ( resourceList == null ) { response . sendError ( <NUM_LIT> , ""<STR_LIT>"" + classMapName + ""<STR_LIT>"" ) ; return ; } Map < String , String > resources = new TreeMap < String , String > ( ) ; ResIterator subjects = resourceList . listSubjects ( ) ;'}]","while ( subjects. hasNext ( ) ) { Resource subject = subjects. nextResource ( ) ; Statement statement = resourceList. getStatement ( subject, RDFS.label, null ) ; resources. put ( subject. getLocalName ( ), statement. getLiteral ( ). stringValue ( ) ) ; } response. setContentType ( ""text/html"" ) ; Context context = VelocityEngine. getVelocityEngine ( ). createContext ( ) ; context. put ( ""resources"", resources ) ; context. put ( ""classMapName"", classMapName ) ; context. put ( ""server"", server ) ; context. put ( ""config"", server. getConfig ( ) ) ; context. put ( ""limit"", server. getConfig ( ). getLimitPerClassMap ( ) ) ; context. put ( ""resourceList"", resourceList ) ; context. put ( ""request"", request ) ; context. put ( ""response"", response ) ; getServletContext ( ). getAttribute ( ""templateEngine"" ). mergeTemplate ( ""directory"", response. getOutputStream ( ) ) ; } } private ClassMapLister getClassMapLister ( ) { // implementation }",0.0003461207486422901
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . internal . parser . javadoc . ir ; public enum JavadocTokenKind { WHITE_SPACES , LINE_BREAK , ASTERISK'}]",", SLASH, AT, LETTER, DIGIT, SYMBOL, ELLIPSIS, LBRACE, RBRACE, LPAREN, RPAREN, COLON, COMMA, SEMICOLON, QUESTION, HASH, DOLLAR, CARET, UNDERSCORE, TILDE, BACKSLASH, QUOTE, SINGLE_QUOTE, BANG, EXCLAMATION, DOT, EQUALS, GTEQ, LTEQ, NOTEQUAL, PLUS, MINUS, LSHIFT, RSASHIFT, URSHIFT, OR, XOR, AND, NOT, INSTANCEOF, INSTANCEOF_TYPE, INSTANCEOF_VALUE, INSTANCEOF_TARGET, INSTANCEOF_TARGET_TYPE, INSTANCEOF_TARGET_VALUE, INSTANCEOF_TARGET_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE_TYPE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE, INSTANCEOF_TARGET_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE_VALUE_TYPE,",0.00033815514314552297
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . utility . authorizationinfo . sample ; import java . util . List ; import java . util . logging . Logger ; import fi . koku . services . utility . authorizationinfo . v1 . Constants ; import fi . koku . services . utility . authorizationinfo . v1 . AuthorizationInfoService ; import fi . koku . services . utility . authorizationinfo . v1 . impl . AuthorizationInfoServiceDummyImpl ; import fi . koku . services . utility . authorizationinfo . v1 . model . Group ; import fi . koku . services . utility . authorizationinfo . v1 . model . OrgUnit ; import fi . koku . services . utility . authorizationinfo . v1 . model . Registry ; import fi . koku . services . utility . authorizationinfo . v1 . model . Role ; public class SampleClientUsage {'}]","public static void main(String[] args) { Logger logger = Logger.getLogger(SampleClientUsage.class.getName()); AuthorizationInfoService service = new AuthorizationInfoServiceDummyImpl(); List<Group> groups = service.getGroupsForUser(""username"", ""domain""); List<OrgUnit> orgUnits = service.getOrgUnitsForUser(""username"", ""domain""); List<Registry> registries = service.getRegistriesForUser(""username"", ""domain""); List<Role> roles = service.getRolesForUser(""username"", ""domain""); }",0.00014862292084754313
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . parser . warnings ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; public class EmptyStatementVisitorTest extends AbstractRubyLintVisitorTestCase { @ Override protected RubyLintVisitor createVisitor ( String src ) { return new EmptyStatementVisitor ( src ) { @ Override protected String getSeverity ( ) { return RubyCore . WARNING ; } } ; } public void testComplainsAboutEmptyMethod ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src ) . size ( ) ) ; } public void testDoesntComplainAboutMethodWithBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:0> , getProblems ( src ) . size ( ) ) ; } public void testComplainsAboutEmptySingletonMethod ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src ) . size ( ) ) ; } public void testDoesntComplainAboutSingletonMethodWithBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:0> , getProblems ( src ) . size ( ) ) ; } public void testComplainsAboutEmptyIfBody ( ) throws Exception { String src = ""<STR_LIT>"" + ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src ) . size ( ) ) ; } public void testDoesntComplainAboutIfWithBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:0> , getProblems ( src ) . size ( ) ) ; } public void testComplainsAboutEmptyUnlessBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src ) . size ( ) ) ; } public void testDoesntComplainAboutUnlessWithBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:0> , getProblems ( src ) . size ( ) ) ; } public void testComplainsAboutEmptyBlock ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src ) . size ( ) ) ; } public void testDoesntComplainAboutBlockWithBody ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:0> , getProblems ( src ) . size ( ) ) ; } public void testComplainsAboutEmptyWhen ( ) throws Exception { String src = ""<STR_LIT>"" ; assertEquals ( <NUM_LIT:1> , getProblems ( src )'}]",.size()); },2.947621551029245e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . prefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . Map ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . preference . PreferenceStore ; import org . eclipse . jface . resource . ColorRegistry ; import org . eclipse . jface . resource . FontRegistry ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class ComplexPreferenceStore extends PreferenceStore { private interface PropertyLoader { void addEntry ( final String key , final String value ) ; void addProperties ( final String key , final Element propertiesElement ) ; } private interface PropertySaver { String get ( final String key ) ; Collection < ? > getKeys ( ) ; boolean needSaving ( final String key ) ; } private static final int COLLECTION_NO_LIMIT = - <NUM_LIT:1> ; private static final String DATE_ATTRIBUTE = ""<STR_LIT:date>"" ; private static final String ENTRY_ELEMENT = ""<STR_LIT>"" ; private static final String KEY_ATTRIBUTE = ""<STR_LIT:key>"" ; private static final Log log = LogFactory . getLog ( ComplexPreferenceStore . class ) ; private static final int PREF_FILE_VERSION_MAJOR = <NUM_LIT:1> ; private static final int PREF_FILE_VERSION_MINOR = <NUM_LIT:0> ; private static final String PROPERTIES_ELEMENT = ""<STR_LIT>"" ; private static final String ROOT_ELEMENT = ""<STR_LIT>"" ; private static final String VERSION_ATTRIBUTE = ""<STR_LIT:version>"" ; private static String escapeString ( final String item ) { return item . replaceAll ( ""<STR_LIT:%>"" , ""<STR_LIT>"" ) . replaceAll ( ""<STR_LIT:U+002C>"" , ""<STR_LIT>"" ) ; } private static String unEscapeString ( final String item ) { return item . replaceAll ( ""<STR_LIT>"" , ""<STR_LIT:U+002C>"" ) . replaceAll ( ""<STR_LIT>"" , ""<STR_LIT:%>"" ) ; } private final ColorRegistry colorRegistry = new ColorRegistry ( ) ; private final FontRegistry fontRegistry = new FontRegistry ( ) ; private File prefFile ; private final Map < String , Properties > propertiesTable = new HashMap < String , Properties > ( ) ; public Collection < String > getCollection ( final String key ) { return getCollection ( key , COLLECTION_NO_LIMIT ) ; } public Collection < String > getCollection ( final String key , int limit ) { final LinkedList < String > list = new LinkedList < String > ( ) ; final StringTokenizer tokenizer = new StringTokenizer ( getString ( key ) , ""<STR_LIT:U+002C>"" ) ; if ( limit == COLLECTION_NO_LIMIT ) { limit = tokenizer . countTokens ( ) ; } for ( int i = <NUM_LIT:0> ; ( i < limit ) && tokenizer . hasMoreTokens ( ) ; i ++ ) { list . addLast ( unEscapeString ( tokenizer . nextToken ( ) ) ) ; } return list ; } public Color getColor ( final String key ) { final RGB newRGBColor = PreferenceConverter . getColor ( this , key ) ; final RGB currentRGBColor = colorRegistry . getRGB ( key ) ; if ( ! newRGBColor . equals ( currentRGBColor ) ) { colorRegistry . put ( key , newRGBColor ) ; } return colorRegistry . get ( key ) ; } public Font'}]","getFont(String key) { final FontData newFontData = PreferenceConverter.getFont(this, key); final FontData currentFontData = fontRegistry.getFont(key); if (!newFontData.equals(currentFontData)) { fontRegistry.put(key, newFontData); } return fontRegistry.get(key); } public void initialize() throws IOException, SAXException, ParserConfigurationException { final File prefFile = getFile(); if (prefFile.exists()) { load(prefFile); } else { save(prefFile); } } public void load(File prefFile) throws IOException, SAXException, ParserConfigurationException { final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); final DocumentBuilder builder = factory.newDocumentBuilder(); final InputSource inputSource = new InputSource(new FileInputStream(prefFile)); final Document document = builder.parse(inputSource); final Element root = document.getDocumentElement(); if (root == null) { log. warn ( ""No root element found in preferences file"" ) ; return ; } final NodeList nodeList = root. getChildNodes ( ) ; final PropertyLoader loader = new PropertyLoader ( ) { @ Override public void addEntry ( final String key, final String value ) { final Properties properties = propertiesTable. get ( key ) ; if ( properties == null ) { properties = new Properties ( ) ; properties",0.00039598982563704253
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . ColorDialog ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . jface . resource . JFaceResources ; class ColorEditor { private Point fExtent ; private Image fImage ; private RGB fColorValue ; private Color fColor ; private Button fButton ; public ColorEditor ( Composite parent ) { fButton = new Button ( parent , SWT . PUSH ) ; fExtent = computeImageSize ( parent ) ; fImage = new Image ( parent . getDisplay ( ) , fExtent . x , fExtent . y ) ; GC gc = new GC ( fImage ) ; gc . setBackground ( fButton . getBackground ( ) ) ; gc . fillRectangle ( <NUM_LIT:0> , <NUM_LIT:0> , fExtent . x , fExtent . y ) ; gc . dispose ( ) ; fButton . setImage ( fImage ) ; fButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent event ) { ColorDialog colorDialog = new ColorDialog ( fButton . getShell ( ) ) ; colorDialog . setRGB ( fColorValue ) ; RGB newColor = colorDialog . open ( ) ; if ( newColor != null ) { fColorValue = newColor ; updateColorImage ( ) ; } } } ) ; fButton . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { if ( fImage != null ) { fImage . dispose ( ) ; fImage = null ; } if ( fColor != null ) { fColor . dispose ( ) ; fColor = null ; } } } ) ; } public RGB getColorValue ( ) { return fColorValue ; } public void setColorValue ( RGB rgb ) { fColorValue = rgb ; updateColorImage ( ) ; } public Button getButton ( ) { return fButton ; } protected void updateColorImage'}]","( ) { if ( fImage!= null && fButton!= null ) { fImage. dispose ( ) ; fImage = new Image ( fButton. getShell ( ). getDisplay ( ), fExtent. x, fExtent. y ) ; GC gc = new GC ( fImage ) ; gc. setBackground ( fButton. getBackground ( ) ) ; gc. fillRectangle ( 0, 0, fExtent. x, fExtent. y ) ; gc. setColor ( fColorValue ) ; gc. drawRectangle ( 0, 0, fExtent. x, fExtent. y ) ; gc. dispose ( ) ; fButton. setImage ( fImage ) ; } } protected Point computeImageSize ( Composite parent ) { Point parentSize = parent. getSize ( ) ; int size = Math. min ( parentSize. x, parentSize. y ) ; return new Point ( size, size ) ; } }",0.00029528603330633357
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . actions ; import org . eclipse . core . resources . IResource ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . IWorkbenchWindowActionDelegate ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rdocexport . RDocUtility ; public class GenerateRdocAction implements IWorkbenchWindowActionDelegate { private ISelection fSelection ; private Shell fCurrentShell ; public void dispose ( ) { } public void init ( IWorkbenchWindow window ) { fCurrentShell = window . getShell ( ) ; } private void showNoSelectionMessage ( ) { MessageDialog . openInformation ( fCurrentShell . getShell ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; return ; } private IResource findSelectedResource ( ) { if ( fSelection instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) fSelection ; Object first = selection . getFirstElement ( ) ; if ( first instanceof IResource ) { return ( ( IResource ) first ) ; } } IWorkbenchPage page = RubyPlugin . getActivePage ( ) ; if ( page == null ) { return null ; } IEditorPart editor = page . getActiveEditor'}]",(); if ( editor!= null && editor. getEditorInput () instanceof IFileEditorInput ) { IFileEditorInput fileEditorInput = ( IFileEditorInput ) editor. getEditorInput (); return fileEditorInput. getFile (); } return null; } public void run ( IAction action ) { if ( fSelection == null || fSelection. getLength () == 0 ) { showNoSelectionMessage ( ) ; return ; } IResource selectedResource = findSelectedResource ( ) ; if ( selectedResource == null ) { showNoSelectionMessage ( ) ; return ; } if ( selectedResource. getType ( ) == IResource. FILE ) { RDocUtility. generateRdoc ( selectedResource ) ; } } },0.00021689112208328793
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . model ; public @ interface Property { String name ( ) default ""<STR_LIT>"" ; Source from ( ) default @ Source ( declaring = void . class , name = ""<STR_LIT>"" ) ; Source join ( ) default @ Source ( declaring = void . class , name = ""<STR_LIT>"" ) ; Aggregator aggregator ( ) default Aggregator . IDENT ; public @ interface Source { Class < ? > declaring ( ) ;'}]","String name ( ) default ""<STR_LIT>"" ; }",3.16547816007686e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text . ruby ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . text . Assert ; import org . rubypeople . rdt . core . CompletionProposal ; import org . rubypeople . rdt . core . Flags ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . viewsupport . RubyElementImageProvider ; import org . rubypeople . rdt . ui . RubyElementImageDescriptor ; import org . rubypeople . rdt . ui . RubyElementLabels ; public class CompletionProposalLabelProvider { public ImageDescriptor createImageDescriptor ( CompletionProposal proposal ) { final int flags = proposal . getFlags ( ) ; ImageDescriptor descriptor ; switch ( proposal . getKind ( ) ) { case CompletionProposal . METHOD_DECLARATION : case CompletionProposal . METHOD_NAME_REFERENCE : case CompletionProposal . METHOD_REF : case CompletionProposal . POTENTIAL_METHOD_DECLARATION : descriptor = RubyElementImageProvider . getMethodImageDescriptor ( flags ) ; break ; case CompletionProposal . TYPE_REF : descriptor = RubyElementImageProvider . getTypeImageDescriptor ( false , false , false ) ; break ; case CompletionProposal . CONSTANT_REF : descriptor = RubyElementImageProvider . getConstantImageDescriptor ( ) ; break ; case CompletionProposal . GLOBAL_REF : descriptor = RubyElementImageProvider . getGlobalVariableImageDescriptor ( ) ; break ; case CompletionProposal . INSTANCE_VARIABLE_REF : descriptor = RubyElementImageProvider . getInstanceVariableImageDescriptor ( ) ; break ; case CompletionProposal . CLASS_VARIABLE_REF : descriptor = RubyElementImageProvider . getClassVariableImageDescriptor ( ) ; break ; case CompletionProposal . LOCAL_VARIABLE_REF : case CompletionProposal . VARIABLE_DECLARATION : descriptor = RubyPluginImages . DESC_OBJS_LOCAL_VAR ; break ; case CompletionProposal . KEYWORD : descriptor = null ; break ; default : descriptor = null ; Assert . isTrue ( false ) ; } if ( descriptor == null ) return null ; return decorateImageDescriptor ( descriptor , proposal ) ; } private ImageDescriptor decorateImageDescriptor ( ImageDescriptor descriptor , CompletionProposal proposal ) { int adornments = <NUM_LIT:0> ; int flags = proposal . getFlags ( ) ; int kind = proposal . getKind ( ) ; if ( kind == CompletionProposal . CONSTANT_REF || kind == CompletionProposal . METHOD_DECLARATION || kind == CompletionProposal . METHOD_DECLARATION || kind == CompletionProposal . METHOD_NAME_REFERENCE || kind == CompletionProposal . METHOD_REF ) if ( Flags . isStatic ('}]","flags)) { adornments |= RubyElementLabels.ADORNMENT_STATIC; } if (Flags.isFinal(flags)) { adornments |= RubyElementLabels.ADORNMENT_FINAL; } if (Flags.isVolatile(flags)) { adornments |= RubyElementLabels.ADORNMENT_VOLATILE; } if (Flags.isSynchronized(flags)) { adornments |= RubyElementLabels.ADORNMENT_SYNCHRONIZED; } return RubyPluginImages.decorateImageDescriptor(descriptor, adornments); } }",0.000150449099728812
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITextViewer ; import org . eclipse . jface . text . Region ; import org . eclipse . jface . text . information . IInformationProvider ; import org . eclipse . jface . text . information . IInformationProviderExtension ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . IEditorPart ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . actions . SelectionConverter ; import org . rubypeople . rdt . internal . ui . rubyeditor . EditorUtility ; import org . rubypeople . rdt . internal . ui . rubyeditor . RubyEditor ; public class RubyElementProvider implements IInformationProvider , IInformationProviderExtension { private RubyEditor fEditor ; private boolean fUseCodeResolve ; public RubyElementProvider ( IEditorPart editor ) { fUseCodeResolve = false ; if ('}]","editor instanceof RubyEditor) { fEditor = (RubyEditor) editor; } else { fEditor = null; } } @Override public void dispose ( ) { fEditor = null; } @Override public IRegion getInformation ( ITextViewer textViewer, IStructuredSelection selection ) throws RubyModelException { if (fEditor == null) { return null; } if (selection.isEmpty()) { return null; } IRubyElement rubyElement = SelectionConverter.toRubyElement(selection); if (rubyElement == null) { return null; } IRegion region = EditorUtility.getInformationRegion(fEditor, rubyElement); if (region == null) { return null; } return region; } @Override public IRegion getInformation ( ITextViewer textViewer, int offset ) throws RubyModelException { if (fEditor == null) { return null; } IRegion region = fEditor.getDocument().getRegion(offset); if (region == null) { return null; } if (region.getLength() == 0) { return null; } IRubyElement rubyElement = fEditor.getRubyModel().getRubyElement(region.getOffset(), region.getLength()); if (rubyElement == null) { return null; } return region; } @Override public void setUseCode",0.0003541187556367499
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow . graph ; import java . text . MessageFormat ; import com . asakusafw . vocabulary . flow . In ; public final class FlowIn < T > implements In < T > { private InputDescription description ; private FlowElementResolver resolver ; public FlowIn ( InputDescription description ) { if ( description == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . description = description ; this . resolver = new FlowElementResolver ( description ) ; } public static < T > FlowIn < T > newInstance ( InputDescription description ) { return new FlowIn < T > ( description ) ; } public InputDescription getDescription ( ) { return description ; } public FlowElement getFlowElement ( ) { return resolver . getElement ( ) ; }'}]",public FlowElementResolver getResolver() { return resolver; },3.214557769307496e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . frontend ; import com . team1160 . scouting . frontend . panels . CommentPanel ; import com . team1160 . scouting . frontend . panels . GraphPanel ; import java . awt . HeadlessException ; import javax . swing . JFrame ; import javax . swing . JPanel ; import com . team1160 . scouting . frontend . panels . InitialPanel ; import com . team1160 . scouting . frontend . panels . MatchScoutingPanel ; import com . team1160 . scouting . frontend . resourcePackets . CardLayoutPacket ; import com . team1160 . scouting . h2 . CommentTable ; import com . team1160 . scouting . h2 . DictTable ; import com . team1160 . scouting . h2 . MatchScoutingTable ; import com . team1160 . scouting . h2 . WeightingTable ; import java . io . File ; public class ScoutingAppWindow extends JFrame { private static final long serialVersionUID = <NUM_LIT> ; private InitialPanel splash ; private MatchScoutingPanel match ; private CardLayoutPacket layout ; private JPanel cards ; private GraphPanel graph ; private CommentPanel comment ; private MatchScoutingTable scoutingTable ; private WeightingTable weightingTable ; private DictTable dictTable ; private CommentTable commentTable ; public ScoutingAppWindow ( String title ) throws Exception { super ( title ) ; this . scoutingTable = new MatchScoutingTable ( ""<STR_LIT:.>"" + File . separator + ""<STR_LIT:data>"" + File . separator + ""<STR_LIT>"" ) ; this . weightingTable = new WeightingTable ( ""<STR_LIT:.>"" + File . separator + ""<STR_LIT:data>"" + File . separator + ""<STR_LIT>"" ) ; this . dictTable = new DictTable ( ""<STR_LIT:.>"" + File . separator + ""<STR_LIT:data>"" + File . separator + ""<STR_LIT>"" ) ; this . commentTable = new CommentTable ( ""<STR_LIT:.>"" + File . separator + ""<STR_LIT:data>"" + File . separator + ""<STR_LIT>"" ) ; this . cards = new JPanel ( ) ; layout = new CardLayoutPacket ( cards ) ; cards . setLayout ( this . layout . getLayout ( ) ) ; splash = new InitialPanel ( layout ) ; splash . setOpaque ( true ) ; match = new MatchScoutingPanel ( layout , this . scoutingTable , this . weightingTable , this . dictTable , this . commentTable'}]",") ; graph = new GraphPanel ( ) ; comment = new CommentPanel ( ) ; this. add ( splash ) ; this. setSize ( 800, 600 ) ; this. setDefaultCloseOperation ( JFrame. EXIT_ON_CLOSE ) ; this. setVisible ( true ) ; } }",9.479358913205087e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . wizards . templates ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ;'}]",import org.eclipse.swt.widgets.Shell;,2.775118414971973e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . social . google . api'}]",import com.google.api.services.googleplus.model.Person;,2.8719415579742017e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . modelgen . model ; import java . text . MessageFormat ; public class DecimalType implements PropertyType { private int precision ; private int scale ; public DecimalType ( int precision , int scale ) { this . precision = precision ; this . scale = scale ; } public int getPrecision ( ) { return precision ; } public int getScale ( ) { return scale ; } @ Override public PropertyTypeKind getKind ( ) { return PropertyTypeKind . BIG_DECIMAL ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT:31> ; int result = <NUM_LIT:1> ; result = prime * result + precision ; result = prime * result + scale ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ('}]","obj == null || getClass ()!= obj.getClass ()) { return false ; } DecimalType other = ( DecimalType ) obj ; return precision == other.precision && scale == other.scale ; } public String toString ( ) { return MessageFormat. format ( ""{0}({1},{2})"", getClass (). getName (), precision, scale ); } }",0.00010307952559696945
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . ui . handlers ; import net . bioclipse . opentox . ui . wizards . CreateDatasetWizard ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . IHandler ; import org . eclipse . core . commands . IHandlerListener ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . WizardDialog ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . handlers . HandlerUtil ; public class CreateDatasetHandler extends AbstractHandler { @'}]","Override
public Object execute(ExecutionEvent event) throws ExecutionException {
	IStructuredSelection selection = HandlerUtil
			.getActiveFinalSelection(event);
	if (selection!= null && selection.size() == 1) {
		IFile file = (IFile) selection.getFirstElement();
		if (file!= null) {
			CreateDatasetWizard wizard = new CreateDatasetWizard(file);
			WizardDialog dialog = PlatformUI
					.createDialogShell(file.getShell());
			dialog.setBlockOnOpen(true);
			dialog.open();
		}
	}
	return null;
}
}",0.00017495670420294076
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import org . eclipse . osgi . util . NLS ; public class RubyEditorMessages extends NLS { private static final String BUNDLE_NAME = RubyEditorMessages . class . getName ( ) ; public'}]",static ResourceBundle ResourceBundle. getBundle ( BUNDLE_NAME ) ; },3.213809766016162e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import org . junit . Rule ; import org . junit . Test ; import com . asakusafw . runtime . configuration . FrameworkDeployer ; import com . asakusafw . testdriver . testing . jobflow . SimpleJobflow ; import com . asakusafw . testdriver . testing . model . Simple ; public class JobFlowTesterTest { @ Rule public FrameworkDeployer framework = new FrameworkDeployer ( ) ; @ Test public void simple ( ) { JobFlowTester tester = new JobFlowTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; tester . input ( ""<STR_LIT>"" , Simple . class ) . prepare ( ""<STR_LIT>"" ) ; tester . output ( ""<STR_LIT>"" , Simple . class ) . verify ( ""<STR_LIT>"" , new IdentityVerifier ( ) ) ; tester . runTest ( SimpleJobflow . class ) ; } @ Test public void dumpActual_path ( ) { File target = new File ( ""<STR_LIT>"" ) ; target . delete ( ) ; JobFlowTester tester = new JobFlowTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; tester . input ( ""<STR_LIT>"" , Simple . class ) . prepare ( ""<STR_LIT>"" ) ; tester . output ( ""<STR_LIT>"" , Simple . class ) . verify ( ""<STR_LIT>"" , new IdentityVerifier ( ) ) . dumpActual ( target . getPath ( ) ) ; tester . runTest ( SimpleJobflow . class ) ; assertThat ( target . exists ( ) , is ( true ) ) ; } @ Test public void dumpActual_uri ( ) { File target = new File ( ""<STR_LIT>"" ) ; target . delete ( ) ; JobFlowTester tester = new JobFlowTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; tester . input ( ""<STR_LIT>""'}]",", Simple.class).prepare(""<STR_LIT>"").output(""<STR_LIT>"", Simple.class).verify(""<STR_LIT>"", new IdentityVerifier()).dumpActual(""file://"" + target.getAbsolutePath());tester.runTest(SimpleJobflow.class);assertThat(target.exists(), is(true));}",9.360621288662712e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; public class SVDBGenerateBlock extends SVDBScopeItem {'}]",private SVDBGenerateBlock() {},2.5181814293556613e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . util ; import java . io . IOException ; import java . io . Reader ; import java . net . URI ; import java . text . MessageFormat ; import java . util . ServiceLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . dmdl . Diagnostic ; import com . asakusafw . dmdl . analyzer . DmdlAnalyzer ; import com . asakusafw . dmdl . analyzer . DmdlSemanticException ; import com . asakusafw . dmdl . model . AstModelDefinition ; import com . asakusafw . dmdl . model . AstScript ; import com . asakusafw . dmdl . parser . DmdlParser ; import com . asakusafw . dmdl . parser . DmdlSyntaxException ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . source . DmdlSourceRepository ; import com . asakusafw . dmdl . source . DmdlSourceRepository . Cursor ; import com . asakusafw . dmdl . spi . AttributeDriver ; import com . asakusafw . dmdl . spi . TypeDriver ; public class AnalyzeTask { static final Logger LOG = LoggerFactory . getLogger ( AnalyzeTask . class ) ; private final String processName ; private final ClassLoader serviceClassLoader ; public AnalyzeTask ( String processName'}]",", ClassLoader serviceClassLoader) { this.processName = processName; this.serviceClassLoader = serviceClassLoader; } public void execute(AstScript script) throws DmdlSyntaxException, DmdlSemanticException { Diagnostic diagnostic = new Diagnostic(processName, script); DmdlAnalyzer analyzer = new DmdlAnalyzer(serviceClassLoader, diagnostic); AstModelDefinition model = analyzer.parse(script); DmdlSemantics semantics = new DmdlSemantics(model); diagnostic.setSemantic(semantics); if (LOG.isDebugEnabled()) { LOG.debug(MessageFormat.format(""AnalyzeTask: Processed {0}"", script)); } } }",0.00017316283138066996
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ti ; import java . util . Collections ; import java . util . LinkedList ; import java . util . List ; import org . jruby . ast . Node ; public class Scope extends LinkedList < Scope > { private static final long serialVersionUID = - <NUM_LIT> ; private List < Variable > variables ; private List < Scope > childScopes ; private Scope parentScope ; private Node node ; public Scope ( Node node , Scope parentScope ) { super ( ) ; this . node = node ; this . parentScope = parentScope ; this . childScopes = new LinkedList < Scope > ( ) ; this . variables = new LinkedList < Variable > ( ) ; } public List < Variable > getVariables ( ) { return variables ; } public void setVariables ( List < Variable > variables ) { this . variables = variables ; }'}]",public List<Scope> getChildScopes() { return childScopes; },3.922402450648082e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . preferences ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . texteditor . spelling . IPreferenceStatusMonitor ; import org . eclipse . ui . texteditor . spelling . ISpellingPreferenceBlock ; import org . rubypeople . rdt . internal . ui . wizards . IStatusChangeListener ; public class SpellingPreferenceBlock implements ISpellingPreferenceBlock { private class NullStatusChangeListener implements IStatusChangeListener { public void statusChanged ( IStatus status ) { } } private class StatusChangeListenerAdapter implements IStatusChangeListener { private IPreferenceStatusMonitor fMonitor ; private IStatus fStatus ; public StatusChangeListenerAdapter ( IPreferenceStatusMonitor monitor ) { super ( ) ; fMonitor = monitor ; } public void statusChanged ( IStatus status ) { fStatus = status ; fMonitor . statusChanged ( status ) ; } public IStatus getStatus ( ) { return fStatus ; } } private SpellingConfigurationBlock fBlock = new SpellingConfigurationBlock ( new NullStatusChangeListener ( ) , null , null ) ; private SpellingPreferenceBlock . StatusChangeListenerAdapter fStatusMonitor ; public Control createControl ( Composite parent ) { return fBlock . createContents ( parent ) ; } public void initialize ( IPreferenceStatusMonitor statusMonitor ) { fStatusMonitor = new StatusChangeListenerAdapter ( statusMonitor ) ; fBlock . fContext = fStatusMonitor ; } public boolean canPerformOk ( ) { return fStatusMonitor == null || fStatusMonitor . getStatus ( ) == null || ! fStatusMonitor . getStatus ( ) . matches ( IStatus . ERROR ) ; } public'}]",IStatus getStatus() { return fStatusMonitor == null? null : fStatusMonitor.getStatus(); },5.153138544223252e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . view ; import java . awt . event . KeyEvent ; import javax . swing . ActionMap ; import javax . swing . InputMap ; import javax . swing . JComponent ; import javax . swing . KeyStroke ; import org . oddjob . arooa . design . actions . ActionContributor ; import org . oddjob . arooa . design . actions . ActionMenu ; import org . oddjob . arooa . design . actions . ActionRegistry ; import org . oddjob . monitor . actions . ExplorerAction ; import org . oddjob . monitor . context . ExplorerContext ; import org . oddjob . monitor . model . SelectedContextAware ; public class ExplorerJobActions implements ActionContributor , SelectedContextAware { private final JobSwingAction [ ] swingActions ; private final ExplorerAction [ ] actions ; public ExplorerJobActions ( ExplorerAction [ ] actions ) {'}]","this.actions = actions; this.swingActions = new JobSwingAction[actions.length]; for (int i = 0; i < actions.length; i++) { this.swingActions[i] = new JobSwingAction(actions[i]); } } @Override public void selectedContextChanged(ExplorerContext context) { } @Override public void addActions(JComponent component, ActionRegistry registry) { ActionMap actionMap = component.getActionMap(); InputMap inputMap = component.getInputMap(); for (int i = 0; i < swingActions.length; i++) { KeyStroke key = swingActions[i].getKey(); if (key!= null) { inputMap.put(key, swingActions[i].getActionKey()); actionMap.put(swingActions[i].getActionKey(), swingActions[i]); } else { inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), swingActions[i].getActionKey()); actionMap.put(swingActions[i].getActionKey(), swingActions[i]); } } } }",0.000285441934524418
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jmx ; import java . util . HashMap ; import java . util . Map ; import javax . management . MBeanServerConnection ; import javax . management . remote . JMXConnector ; import javax . management . remote . JMXConnectorFactory ; import javax . management . remote . JMXServiceURL ; import junit . framework . TestCase ; import org . apache . commons . beanutils . DynaBean ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . Structural ; import org . oddjob . arooa . ArooaSession ; import org . oddjob . arooa . registry . BeanRegistry ; import org . oddjob . arooa . registry . MockBeanRegistry ; import org . oddjob . arooa . registry . SimpleBeanRegistry ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . jobs . WaitJob ; import org . oddjob . state . IsNotExecuting ; import org . oddjob . state . ParentState ; import org . oddjob . state . State ; import org . oddjob . structural . ChildHelper ; import org . oddjob . structural . StructuralListener ; public class JMXServerJobTest extends TestCase { private static final Logger logger = Logger . getLogger ( JMXServerJobTest . class ) ; protected void setUp ( ) { logger . debug ( ""<STR_LIT>"" + getName ( ) + ""<STR_LIT>"" ) ; } int unique ; Map < Object , String > ids = new HashMap < Object , String > ( ) ; private class OurEmptyRegistrySession extends StandardArooaSession { @ Override public BeanRegistry getBeanRegistry ( ) { return new MockBeanRegistry ( ) { @ Override public String getIdFor ( Object component ) { assertNotNull ( component ) ; String id = ids . get ( component ) ; if ( id == null ) { id = ""<STR_LIT:x>"" + unique ++ ; ids . put ( component , id ) ; } return id ; } } ; } } public void testServerMBeans ( ) throws Exception { Object root = new Object ( ) { public String toString ( ) { return ""<STR_LIT:test>"" ; } } ; JMXServerJob server = new JMXServerJob ( ) ; server . setRoot ( root ) ; server . setArooaSession ( new StandardArooaSession ( ) ) ; server . setUrl ( ""<STR_LIT>"" ) ; server . start ( ) ; JMXServiceURL address = new JMXServiceURL ( server . getAddress ( ) ) ; JMXConnector cntor = JMXConnectorFactory . connect ( address ) ; MBeanServerConnection mBeanServer = cntor . getMBeanServerConnection ( ) ; assertEquals ( new Integer ( <NUM_LIT:3> ) , mBeanServer . getMBeanCount ( ) ) ; cntor . close ( ) ; server . stop ( ) ; } public void testRun ( ) throws Exception { Object root = new Object ( ) { public String toString ( ) { return ""<STR_LIT:test>"" ; } } ; JMXServerJob server = new JMXServerJob ( ) ; server . setRoot ( root ) ; server . setArooaSession ( new StandardArooaSession ( ) ) ; server . setUrl ( ""<STR_LIT>"" ) ; server . start ( ) ; JMXClientJob client = new JMXClientJob ( ) ; client . setConnection ( server . getAddress ( ) ) ; client . setArooaSession ( new StandardArooaSession ( ) ) ; client . run ( ) ; Object [ ] children = Helper . getChildren ( client ) ; assertEquals ( <NUM_LIT:1> , children . length ) ; assertEquals ( ""<STR_LIT:test>"" , children [ <NUM_LIT:0> ] . toString ( ) ) ; client . stop ( ) ; server . stop ( ) ; } public static class Component { public String getFruit ( ) { return ""<STR_LIT>"" ; } } private class OurSession extends StandardArooaSession { SimpleBeanRegistry registry = new SimpleBeanRegistry ( ) ; @ Override public BeanRegistry getBeanRegistry ( ) { return registry ; } } public void testLinkedServers ( ) throws Exception { ArooaSession server2Session = new OurSession ( ) ; Component comp1 = new Component ( ) ; server2Session . getBeanRegistry ( ) . register ( ""<STR_LIT>"" , comp1 ) ; JMXServerJob server2 = new JMXServerJob ( ) ; server2 . setRoot ( comp1 ) ; server2 . setArooaSession ( server2Session ) ; server2 . setUrl ( ""<STR_LIT>"" ) ; server2 . start ( ) ; OurSession server1Session = new OurSession ( ) ; JMXClientJob client = new JMXClientJob ( ) ; server1Session . registry . register ( ""<STR_LIT>"" , client ) ; client . setArooaSession ( server1Session ) ; client . setConnection ( server2 . getAddress ( ) ) ; client . run ( ) ; JMXServerJob server1 = new JMXServerJob ( ) ; server1 . setRoot ( client ) ; server1 . setUrl ( ""<STR_LIT>"" ) ; server1 . setArooaSession ( new OurEmptyRegistrySession ( ) ) ; server1 . start ( ) ; Object o = server1Session . registry . lookup ( ""<STR_LIT>"" ) ; assertNotNull ( o ) ; DynaBean db = ( DynaBean ) o ; assertEquals ( ""<STR_LIT>"" , db . get ( ""<STR_LIT>"" ) ) ; client . stop ( ) ; server1 . stop ( ) ; server2 . stop ( ) ; } public void testNestedOddjob ( ) throws Exception { String EOL = System . getProperty ( ""<STR_LIT>"" ) ; final String xml = ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL + ""<STR_LIT>"" + EOL ; final Oddjob oj = new Oddjob ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oj . run ( ) ; assertNotNull ( new OddjobLookup ( oj ) . lookup ( ""<STR_LIT>"" ) ) ; JMXClientJob client = new JMXClientJob ( ) ; client . setArooaSession ( new StandardArooaSession ( ) ) ; client . setConnection ( ( String ) new OddjobLookup ( oj ) . lookup ( ""<STR_LIT>"" ) ) ; client . run ( ) ; oj . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oj . run ( ) ; Object o = new OddjobLookup ( client ) . lookup ( ""<STR_LIT>"" ) ; assertNotNull ( o ) ; while ( new OddjobLookup ('}]","(client).lookup(""<STR_LIT>"").getState() instanceof IsNotExecuting) { client.run(); } client.stop(); oj.stop(); } }",8.382661796785973e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . samples . ast . data ; import java . util . List ; public final class Arg { public static final Arg _Arg ( Type type , String name ) { return new Arg ( type , name ) ; } public final Type type ; public final String name ; public Arg'}]","( Type type, String name ) { this. type = type ; this. name = name ; } @Override public String toString ( ) { return ""Arg [type="" + type + "", name="" + name + ""]"" ; } }",7.411255988875214e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . viewsupport ; import java . util . ArrayList ; import org . eclipse . core . resources . IResource ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . Widget ; import org . rubypeople . rdt . ui . IWorkingCopyProvider ; import org . rubypeople . rdt . ui . ProblemsLabelDecorator . ProblemsLabelChangedEvent ; public class ProblemTableViewer extends TableViewer implements ResourceToItemsMapper . IContentViewerAccessor { protected ResourceToItemsMapper fResourceToItemsMapper ; public ProblemTableViewer ( Composite parent ) { super ( parent ) ; initMapper ( ) ; } public ProblemTableViewer ( Composite parent , int style ) { super ( parent , style ) ; initMapper ( ) ; } public ProblemTableViewer ( Table table ) { super ( table ) ; initMapper ( ) ; } private void initMapper ( ) { fResourceToItemsMapper = new ResourceToItemsMapper ( this ) ; } public void'}]",setWorkingCopyProvider(IWorkingCopyProvider provider) { fResourceToItemsMapper.setWorkingCopyProvider(provider); super.refresh(); },5.231757970724392e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . util ; import junit . framework . TestCase ; import org . rubypeople . rdt . internal . ui . util . StringMatcher . Position ; public class StringMatcherTest extends TestCase { public void testStartAfterEnd ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , true , false ) ; assertNull ( matcher . find ( ""<STR_LIT>"" , <NUM_LIT:3> , <NUM_LIT:1> ) ) ; assertFalse ( matcher . match ( ""<STR_LIT>"" , <NUM_LIT:3> , <NUM_LIT:1> ) ) ; } public void testNullPattern ( ) { try { new StringMatcher ( null , true , false ) ; fail ( ""<STR_LIT>"" ) ; } catch ( IllegalArgumentException e ) { assertTrue ( true ) ; } } public void testFindWithNullText ( ) { StringMatcher matcher = new StringMatcher ( ""<STR_LIT:*>"" , true , false ) ; try { matcher . find ( null , <NUM_LIT:0> , <NUM_LIT:0> ) ; fail ( ""<STR_LIT>"" ) ; } catch ( IllegalArgumentException e ) { assertTrue ( true ) ; } } public void testMatchWithNullText ( ) { StringMatcher matcher = new StringMatcher ( ""<STR_LIT:*>"" , true , false ) ; try { matcher . match ( null ) ; fail ( ""<STR_LIT>"" ) ; } catch ( IllegalArgumentException e ) { assertTrue ( true ) ; } } public void testMatchWithStartAndEndWithNullText ( ) { StringMatcher matcher = new StringMatcher ( ""<STR_LIT:*>"" , true , false ) ; try { matcher . match ( null , <NUM_LIT:0> , <NUM_LIT:0> ) ; fail ( ""<STR_LIT>"" ) ; } catch ( IllegalArgumentException e ) { assertTrue ( true ) ; } } public void testFindWithEmptyTextString ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , true , false ) ; assertNull ( matcher . find ( ""<STR_LIT>"" , <NUM_LIT:0> , ""<STR_LIT>"" . length ( ) ) ) ; pattern = ""<STR_LIT:*>"" ; matcher = new StringMatcher ( pattern , true , false ) ; assertNull ( matcher . find ( ""<STR_LIT>"" , <NUM_LIT:0> , ""<STR_LIT>"" . length ( ) ) ) ; pattern = ""<STR_LIT:?>"" ; matcher = new StringMatcher ( pattern , true , false ) ; assertNull ( matcher . find ( ""<STR_LIT>"" , <NUM_LIT:0> , ""<STR_LIT>"" . length ( ) ) ) ; } public void testFindWithEmptyPattern ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , false , false ) ; String text = ""<STR_LIT>"" ; Position pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNotNull ( pos ) ; assertEquals ( <NUM_LIT:0> , pos . getStart ( ) ) ; assertEquals ( <NUM_LIT:0> , pos . getEnd ( ) ) ; } public void testFindIgnoringCase ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , true , false ) ; String text = ""<STR_LIT>"" ; Position pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNotNull ( pos ) ; assertEquals ( <NUM_LIT:0> , pos . getStart ( ) ) ; assertEquals ( <NUM_LIT:5> , pos . getEnd ( ) ) ; } public void testMatchIgnoringCase ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , true , false ) ; assertTrue ( matcher . match ( ""<STR_LIT>"" ) ) ; assertTrue ( matcher . match ( ""<STR_LIT>"" ) ) ; assertFalse ( matcher . match ( ""<STR_LIT>"" ) ) ; } public void testMatchNotIgnoringCase ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , false , false ) ; assertFalse ( matcher . match ( ""<STR_LIT>"" ) ) ; assertTrue ( matcher . match ( ""<STR_LIT>"" ) ) ; assertFalse ( matcher . match ( ""<STR_LIT>"" ) ) ; } public void testFindNotIgnoringCase ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , false , false ) ; String text = ""<STR_LIT>"" ; Position pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNotNull ( pos ) ; assertEquals ( <NUM_LIT:0> , pos . getStart ( ) ) ; assertEquals ( <NUM_LIT:5> , pos . getEnd ( ) ) ; text = ""<STR_LIT>"" ; pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNull ( pos ) ; } public void testFindStarInPatternIgnoringWildcards ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , false , true ) ; String text = ""<STR_LIT>"" ; Position pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNull ( pos ) ; text = ""<STR_LIT>"" ; pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertEquals ( <NUM_LIT:0> , pos . getStart ( ) ) ; assertEquals ( <NUM_LIT:4> , pos . getEnd ( ) ) ; } public void testFindQuestionMarkInPatternIgnoringWildcards ( ) { String pattern = ""<STR_LIT>"" ; StringMatcher matcher = new StringMatcher ( pattern , false , true ) ; String text = ""<STR_LIT>"" ; Position pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertNull ( pos ) ; text = ""<STR_LIT>"" ; pos = matcher . find ( text , <NUM_LIT:0> , text . length ( ) ) ; assertEquals ( <NUM_LIT:0> , pos . getStart ( ) ) ; assertEquals ( <NUM_LIT:4> , pos . getEnd ( ) ) ; } public void'}]","testFindStarInPatternNotIgnoringWildcards() { String pattern = ""<STR_LIT:*>""; StringMatcher matcher = new StringMatcher(pattern, false, false); String text = ""<STR_LIT>""; Position pos = matcher.find(text, <NUM_LIT:0>, text.length()); assertNotNull(pos); assertEquals(<NUM_LIT:0>, pos.getStart()); assertEquals(<NUM_LIT:5>, pos.getEnd()); }",0.00016323803348683514
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . action ; import java . awt . Component ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import java . util . SortedSet ; import java . util . TreeSet ; import javax . swing . JPanel ; import javax . swing . KeyStroke ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design . screem . FormItem ; import org . oddjob . arooa . design . screem . LabelledComboBox ; import org . oddjob . arooa . design . view . Looks ; import org . oddjob . arooa . design . view . SwingFormFactory ; import org . oddjob . arooa . design . view . SwingFormView ; import org . oddjob . arooa . design . view . SwingItemFactory ; import org . oddjob . arooa . design . view . SwingItemView ; import org . oddjob . arooa . design . view . ViewHelper ; import org . oddjob . arooa . life . InstantiationContext ; import org . oddjob . arooa . life . SimpleArooaClass ; import org . oddjob . arooa . parsing . ArooaElement ; import org . oddjob . arooa . parsing . ConfigurationSession ; import org . oddjob . arooa . parsing . DragPoint ; import org . oddjob . arooa . parsing . DragTransaction ; import org . oddjob . arooa . parsing . QTag ; import org . oddjob . arooa . parsing . QTagConfiguration ; import org . oddjob . arooa . registry . ChangeHow ; import org . oddjob . arooa . xml . XMLArooaParser ; import org . oddjob . monitor . Standards ; import org . oddjob . monitor . actions . FormAction ; import org . oddjob . monitor . context . ExplorerContext ; import org . oddjob . monitor . model . ConfigContextSearch ; import org . oddjob . monitor . model . JobFormAction ; public class AddJobAction extends JobFormAction implements FormAction { static { SwingFormFactory . register ( AddJobForm . class , new SwingFormFactory < AddJobForm > ( ) { public SwingFormView onCreate ( AddJobForm form ) { return new AddJobFormView ( form ) ; } } ) ; } private LabelledComboBox < QTag > comboBox ; private Form form ; private ConfigurationSession configurationSession ; private DragPoint dragPoint ; private Object component ; public String getName ( ) { return ""<STR_LIT>"" ; } public String getGroup ( ) { return DESIGN_GROUP ; } public'}]","void execute(ExplorerContext explorerContext, JobFormAction.Action action) throws Exception {",4.923059095600261e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . expr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . SVDBItemType ; public class SVDBPropertyCaseStmt extends SVDBExpr { public SVDBExpr fExpr ; public List < SVDBPropertyCaseItem > fItemList ; public SVDBPropertyCaseStmt ( ) { super ( SVDBItemType . PropertyCaseStmt ) ; fItemList = new ArrayList < SVDBPropertyCaseItem > ( ) ; } public void setExpr ( SVDBExpr expr ) { fExpr = expr ; } public SVDBExpr'}]",getExpr ( ) { return fExpr ; } public void addItem ( SVDBPropertyCaseItem item ) { fItemList. add ( item ) ; } public List < SVDBPropertyCaseItem > getItemList ( ) { return fItemList ; } },8.033843870566697e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . excel . legacy ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . EnumSet ; import java . util . Set ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; import com . asakusafw . testdriver . excel . ExcelRuleExtractor ; import com . asakusafw . testdriver . excel . NullityConditionKind ; import com . asakusafw . testdriver . excel . ValueConditionKind ; import com . asakusafw . testdriver . rule . DataModelCondition ; public class LegacyExcelRuleExtractor implements ExcelRuleExtractor { @ Override public boolean supports ( Sheet sheet ) { if ( sheet == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( getStringCell ( sheet , <NUM_LIT:0> , <NUM_LIT:0> ) != null ) { return false ; } ConditionSheetItem item = ConditionSheetItem . TABLE_NAME ; String cell = getStringCell ( sheet , item . getRow ( ) , item . getCol ( ) ) ; return cell != null && cell . equals ( item . getName ( ) ) ; } @ Override public Set < DataModelCondition > extractDataModelCondition ( Sheet sheet ) throws FormatException { if ( sheet == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } ConditionSheetItem item = ConditionSheetItem . ROW_MATCHING_CONDITION ; String cell = getStringCell ( sheet , item . getRow ( ) , item . getCol ( ) + <NUM_LIT:1> ) ; if ( cell == null ) { cell = ""<STR_LIT>"" ; } RowMatchingCondition condition = RowMatchingCondition . getConditonByJapanseName ( cell ) ; if ( condition == null ) { throw new FormatException ( MessageFormat . format ( ""<STR_LIT>"" , ConditionSheetItem . ROW_MATCHING_CONDITION . getName ( ) , cell , Arrays . asList ( RowMatchingCondition . getJapaneseNames ( ) ) ) ) ; } switch ( condition ) { case NONE : return EnumSet . allOf ( DataModelCondition . class ) ; case EXACT : return EnumSet . noneOf ( DataModelCondition . class ) ; case PARTIAL : return EnumSet . of ( DataModelCondition . IGNORE_UNEXPECTED ) ; default : throw new AssertionError ( condition ) ; } } @ Override public int extractPropertyRowStartIndex ( Sheet sheet ) throws FormatException { if ( sheet == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } return ConditionSheetItem . COLUMN_NAME . getRow ( ) + <NUM_LIT:1> ; } private String getStringCell ( Sheet sheet , int rowIndex , int colIndex ) { assert sheet != null ; Row row = sheet . getRow ( rowIndex ) ; if ( row == null ) { return null ; } Cell cell = row . getCell ( colIndex ) ; if ( cell == null || cell . getCellType ( ) != Cell . CELL_TYPE_STRING ) { return null ; } return cell . getStringCellValue ( ) ; }'}]","private String getStringCell ( Sheet sheet, int rowIndex, int colIndex ) { assert sheet!= null ; Row row = sheet. getRow ( rowIndex ) ; if ( row == null ) { return null ; } Cell cell = row. getCell ( colIndex ) ; if ( cell == null || cell. getCellType ( )!= Cell. CELL_TYPE_STRING ) { return null ; } return cell. getStringCellValue ( ) ; }",0.00014455804574112647
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . logging . polling ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . oddjob . jmx . client . MockLogPollable ; import org . oddjob . logging . ArchiveNameResolver ; import org . oddjob . logging . LogEvent ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . logging . cache . LogEventSource ; import org . oddjob . logging . cache . PollingLogArchiver ; public class PollingLogArchiver2Test extends TestCase { Object expected ; class OurEventSource implements LogEventSource { LogEvent [ ] logEvents = { new LogEvent ( ""<STR_LIT>"" , <NUM_LIT> , LogLevel . DEBUG , ""<STR_LIT:1>"" ) , new LogEvent ( ""<STR_LIT>"" , <NUM_LIT> , LogLevel . DEBUG , ""<STR_LIT:2>"" ) , new LogEvent ( ""<STR_LIT>"" , <NUM_LIT> , LogLevel . DEBUG , ""<STR_LIT:3>"" ) , new LogEvent ( ""<STR_LIT>"" , <NUM_LIT> , LogLevel . DEBUG , ""<STR_LIT:4>"" ) , new LogEvent ( ""<STR_LIT>"" , <NUM_LIT> , LogLevel . DEBUG , ""<STR_LIT:5>"" ) } ; public LogEvent [ ] retrieveEvents ( Object component , long from , int max ) { assertEquals ( expected , component ) ; if ( from < <NUM_LIT:0> ) { from = <NUM_LIT> ; } long num = Math . min ( max , <NUM_LIT> - from ) ; LogEvent [ ] out = new LogEvent [ ( int ) num ] ; System . arraycopy ( logEvents , ( int ) from - <NUM_LIT> , out , <NUM_LIT:0> , ( int ) num ) ; return out ; } } class LL implements LogListener { List < LogEvent > results = new ArrayList < LogEvent > ( ) ; public void logEvent ( LogEvent logEvent ) { results . add ( logEvent ) ; } } class OurResolver implements ArchiveNameResolver { public String resolveName ( Object component ) { assertEquals ( expected , component ) ; return ""<STR_LIT>"" ; } } public void testSimpleLogEvents ( ) { MockLogPollable root = new MockLogPollable ( ) ; this . expected = root ; PollingLogArchiver test = new PollingLogArchiver ( <NUM_LIT:3> , new OurResolver ( ) , new OurEventSource ( ) ) ; LL results = new LL ( ) ; test . addLogListener ( results , root , LogLevel . DEBUG , - <NUM_LIT:1> , <NUM_LIT:10> ) ; assertEquals ( <NUM_LIT:3> , results . results . size ( ) ) ; assertEquals ( ""<STR_LIT:3>"" , results . results . get ( <NUM_LIT:2> ) . getMessage ( ) ) ; test . poll ( ) ; assertEquals ( <NUM_LIT:5> , results . results . size ( ) ) ; assertEquals ( ""<STR_LIT:5>"" , results'}]",.results.get(<NUM_LIT:4>).getMessage()); },4.2929748619088346e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package $ { package } . operator ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . ArrayList ; import java . util . List ; import org . junit . Test ; import $ { package } . modelgen . dmdl . model . ItemInfo ; import $ { package } . modelgen . dmdl . model . SalesDetail ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateTime ; public class CategorySummaryOperatorTest { @ Test public void selectAvailableItem ( ) { List < ItemInfo > candidates = new ArrayList < ItemInfo > ( ) ; candidates . add ( item ( ""<STR_LIT:A>"" , <NUM_LIT:1> , <NUM_LIT:10> ) ) ; candidates . add ( item ( ""<STR_LIT:B>""'}]",", <NUM_LIT:2>, <NUM_LIT:20> ) ) ; List < ItemInfo > expected = new ArrayList < ItemInfo > ( ) ; expected.add(item(""<STR_LIT:A>"", <NUM_LIT:1>, <NUM_LIT:10> )); List < ItemInfo > actual = new CategorySummaryOperator().selectAvailableItem(candidates); assertSame(expected, actual); }",0.0001287350973968577
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . stage ; import java . text . MessageFormat ; import com . asakusafw . runtime . util . VariableTable ; public final class StageConstants { public static final String PROP_USER = ""<STR_LIT>"" ; public static final String PROP_EXECUTION_ID = ""<STR_LIT>"" ; public static final String PROP_BATCH_ID = ""<STR_LIT>"" ; public static final String PROP_FLOW_ID = ""<STR_LIT>"" ; public static final String PROP_ASAKUSA_BATCH_ARGS ='}]","""<STR_LIT>""",2.7336165582241454e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . launching ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . core . Launch ; import org . eclipse . debug . core . model . IProcess ; import org . rubypeople . rdt . core . util . Util ; import org . rubypeople . rdt . launching . AbstractVMInstall ; import org . rubypeople . rdt . launching . IVMInstallType ; import org . rubypeople . rdt . launching . IVMRunner ; public class StandardVM extends AbstractVMInstall { private static final String FINISHED_MARKER = ""<STR_LIT>"" ; private static final int FIVE_MINUTES = <NUM_LIT:5> * <NUM_LIT> * <NUM_LIT:1000> ; private static final String VERSION_TXT = ""<STR_LIT>"" ; private static final int CORE_STUBS_VERSION = <NUM_LIT:3> ; private Job coreStubJob ; public StandardVM ( IVMInstallType type , String id ) { super ( type , id ) ; } @ Override public IVMRunner getVMRunner ( String mode ) { if ( ILaunchManager . RUN_MODE . equals ( mode ) ) { IVMRunner runner = new StandardVMRunner ( ) ; runner . setVMInstall ( this ) ; return runner ; } else if ( ILaunchManager . DEBUG_MODE . equals ( mode ) ) { IVMRunner runner = null ; if ( useRDebug ( ) ) { runner = new RDebugVMDebugger ( ) ; } else { runner = new StandardVMDebugger ( ) ; } runner . setVMInstall ( this ) ; return runner ; } else if ( ILaunchManager . PROFILE_MODE . equals ( mode ) ) { return getVMRunner ( this , mode ) ; } return null ; } protected boolean useRDebug ( ) { return LaunchingPlugin . getDefault ( ) . getPluginPreferences ( ) . getBoolean ( PreferenceConstants . USE_RUBY_DEBUG ) ; } public String getRubyVersion ( ) { IVMInstallType installType = getVMInstallType ( ) ; File installLocation = getInstallLocation ( ) ; if ( installLocation != null ) { File executable = installType . findExecutable ( installLocation ) ; if ( executable != null ) { String vmVersion = installType . getVMVersion ( installLocation , executable ) ; StringBuffer version = new StringBuffer ( ) ; for ( int i = <NUM_LIT:0> ; i < vmVersion . length ( ) ; i ++ ) { char ch = vmVersion . charAt ( i ) ; if ( Character . isDigit ( ch ) || ch == \'<CHAR_LIT:.>\' ) { version . append ( ch ) ; } else { break ; } } if ( version . length ( ) > <NUM_LIT:0> ) { return version . toString ( ) ; } } } return null ; } public String getPlatform ( ) { IVMInstallType installType = getVMInstallType ( ) ; File installLocation = getInstallLocation ( ) ; if ( installLocation != null ) { File executable = installType . findExecutable ( installLocation ) ; if ( executable != null ) { String platform = installType . getVMPlatform ( installLocation , executable ) ; if ( platform != null ) return platform ; } } return ""<STR_LIT>"" ; } @ Override public IPath [ ] getLibraryLocations ( ) { IPath [ ] paths = super . getLibraryLocations ( ) ; if ( paths != null ) { generateCoreStubs ( getVMInstallType ( ) . findExecutable ( getInstallLocation ( ) ) ) ; return paths ; } return getDefaultLibraryLocations ( ) ; } private IPath [ ] getDefaultLibraryLocations ( ) { IPath [ ] dflts = getVMInstallType ( ) . getDefaultLibraryLocations ( getInstallLocation ( ) ) ; IPath coreStubsPath = generateCoreStubs ( getVMInstallType ( ) . findExecutable ( getInstallLocation ( ) ) ) ; if ( coreStubsPath == null ) { return dflts ; } IPath [ ] paths = new IPath [ dflts . length + <NUM_LIT:1> ] ; for ( int i = <NUM_LIT:0> ; i < dflts . length ; i ++ ) { paths [ i ] = dflts [ i ] ; } paths [ dflts . length ] = coreStubsPath ; return paths ; } private IPath generateCoreStubs'}]","(File executable) { if ( executable!= null && executable. exists ( ) ) { IPath coreStubsPath = new Path ( executable. getAbsolutePath ( ) + ""<STR_LIT>"" + File. separator + ""core_stubs"" ) ; if ( coreStubsPath. toFile ( ). exists ( ) ) { return coreStubsPath ; } } return null ; } @Override public void create ( IProgressMonitor monitor ) throws CoreException { super. create ( monitor ) ; if (! monitor. isCanceled ( ) ) { coreStubJob = Util. createJob ( getVMInstallType ( ). getVMInstallName ( ) + ""<STR_LIT>"" + getVMInstallName ( ) + ""<STR_LIT>"" + "" core stubs"", FIVE_MINUTES ) ; coreStubJob. setRule ( getVMInstallType ( ). getVMInstallName ( ) + ""<STR_LIT>"" + getVMInstallName ( ) + ""<STR_LIT>"" + "" core stubs"" ) ; coreStubJob. setPriority ( Job. HIGH ) ; coreStubJob. setRule ( getVMInstallType ( ). getVMInstallName ( ) + ""<STR_LIT>"" + getVMInstall",0.000398581237501694
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . operator ; import java . lang . annotation . Documented ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . asakusafw . vocabulary . flow . Source ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; @'}]","Target ( value = { ElementType. TYPE, ElementType. METHOD, ElementType. FIELD, ElementType. CONSTRUCTOR, ElementType. PARAMETER } ) @Retention ( RetentionPolicy. CLASS ) @Documented public @interface Operator { }",7.184044148891985e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . cache ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . TimeUnit ; import com . asakusafw . bulkloader . bean . ImportBean ; import com . asakusafw . bulkloader . bean . ImportTargetTableBean ; import com . asakusafw . bulkloader . common . BulkLoaderInitializer ; import com . asakusafw . bulkloader . common . ConfigurationLoader ; import com . asakusafw . bulkloader . common . Constants ; import com . asakusafw . bulkloader . common . JobFlowParamLoader ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . importer . Importer ; import com . asakusafw . bulkloader . log . Log ; import com . asakusafw . runtime . core . context . RuntimeContext ; public final class BuildCache { static final Log LOG = new Log ( BuildCache . class ) ; private static final List < String > PROPERTIES = Constants . PROPERTIES_DB ; private BuildCache ( ) { return ; } public static void main ( String [ ] args ) { RuntimeContext . set ( RuntimeContext . DEFAULT . apply ( System . getenv ( ) ) ) ; RuntimeContext . get ( ) . verifyApplication ( BuildCache . class . getClassLoader ( ) ) ; if ( args . length != <NUM_LIT:4> && args . length != <NUM_LIT:5> ) { LOG . error ( ""<STR_LIT>"" , Arrays . toString ( args ) ) ; System . exit ( Constants . EXIT_CODE_ERROR ) ; return ; } String targetName = args [ <NUM_LIT:0> ] ; String batchId = args [ <NUM_LIT:1> ] ; String flowId = args [ <NUM_LIT:2> ] ; String tableName = args [ <NUM_LIT:3> ] ; String executionId = args . length == <NUM_LIT:5> ? args [ <NUM_LIT:4> ] : UUID . randomUUID ( ) . toString ( ) ; int initExit = initialize ( targetName , flowId , executionId ) ; if ( initExit != Constants . EXIT_CODE_SUCCESS ) { System . exit ( initExit ) ; } LOG . info ( ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName ) ; int exitCode = new BuildCache ( ) . execute ( targetName , batchId , flowId , tableName , executionId ) ; LOG . info ( ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName , exitCode ) ; System . exit ( exitCode ) ; } private static int initialize ( String targetName , String flowId , String executionId ) { if ( ! BulkLoaderInitializer . initDBServer ( flowId , executionId , PROPERTIES , targetName ) ) { LOG . error ( ""<STR_LIT>"" , targetName , flowId , executionId ) ; return Constants . EXIT_CODE_ERROR ; } return Constants . EXIT_CODE_SUCCESS ; } private int execute ( String targetName , String batchId , String flowId , String tableName , String executionId ) { assert targetName != null ; assert batchId != null ; assert flowId != null ; assert tableName != null ; assert executionId != null ; try { ImportBean bean = createBean ( targetName , batchId , flowId , executionId , tableName ) ; if ( bean == null ) { return Constants . EXIT_CODE_ERROR ; } if ( RuntimeContext . get ( ) . isSimulation ( ) ) { return Constants . EXIT_CODE_SUCCESS ; } Importer importer = new Importer ( ) ; int exitCode = importer . importTables ( bean ) ; if ( exitCode == Constants . EXIT_CODE_SUCCESS ) { LOG . info ( ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName ) ; int releaseExit = new ReleaseCacheLock ( ) . execute ( targetName , executionId ) ; if ( releaseExit != Constants . EXIT_CODE_SUCCESS ) { LOG . error ( ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName ) ; exitCode = Constants . EXIT_CODE_WARNING ; } } else { LOG . info ( ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName ) ; } return exitCode ; } catch ( BulkLoaderSystemException e ) { LOG . log ( e ) ; return Constants . EXIT_CODE_ERROR ; } catch ( Exception e ) { try { LOG . error ( e , ""<STR_LIT>"" , targetName , batchId , flowId , executionId , tableName ) ; return Constants . EXIT_CODE_ERROR ; } catch ( Exception e1 ) { System . err . print ( ""<STR_LIT>"" ) ; e1 . printStackTrace ( ) ; return Constants . EXIT_CODE_ERROR ; } } } private ImportBean createBean ( String targetName , String batchId , String jobflowId , String executionId , String tableName ) { assert targetName != null ; assert batchId != null ; assert jobflowId != null ; assert executionId != null ; assert tableName != null ;'}]","ImportTargetTableBean targetTable = new ImportTargetTableBean(targetName, tableName); ImportBean bean = new ImportBean(batchId, jobflowId, executionId, targetTable); return bean;",9.489388613075178e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . rubyeditor ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . jface . text . Assert ; import org . eclipse . jface . text . ISynchronizable ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . source . Annotation ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . jface . text . source . IAnnotationModelExtension ; import org . eclipse . ui . PartInitException ; import org . jruby . ast . Node ; import org . jruby . ast . RootNode ; import org . rubypeople . rdt . core . IMethod ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . ITypeHierarchy ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . util . Messages ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . actions . OpenActionUtil ; import org . rubypeople . rdt . internal . ui . text . ruby . IRubyReconcilingListener ; class OverrideIndicatorManager implements IRubyReconcilingListener { class OverrideIndicator extends Annotation { private boolean fIsOverwriteIndicator ; private String fHandleIdentifier ; OverrideIndicator ( boolean isOverwriteIndicator , String text , String handleIdentifier ) { super ( ANNOTATION_TYPE , false , text ) ; fIsOverwriteIndicator = isOverwriteIndicator ; fHandleIdentifier = handleIdentifier ; } public boolean isOverwriteIndicator ( ) { return fIsOverwriteIndicator ; } public void open ( ) { try { OpenActionUtil . open ( RubyCore . create ( fHandleIdentifier ) , true ) ; } catch ( PartInitException e ) { RubyPlugin . log ( e ) ; } catch ( RubyModelException e ) { RubyPlugin . log ( e ) ; } } } static final String ANNOTATION_TYPE = ""<STR_LIT>"" ; private IAnnotationModel fAnnotationModel ; private Object fAnnotationModelLockObject ; private Annotation [ ] fOverrideAnnotations ; public OverrideIndicatorManager ( IAnnotationModel annotationModel , IRubyElement rubyElement , Node ast ) { Assert . isNotNull ( annotationModel ) ; Assert . isNotNull ( rubyElement ) ; fAnnotationModel = annotationModel ; fAnnotationModelLockObject = getLockObject ( fAnnotationModel ) ; if ( ast != null ) updateAnnotations ( ( IRubyScript ) rubyElement , new NullProgressMonitor ( ) ) ; } private Object getLockObject ( IAnnotationModel annotationModel ) { if ( annotationModel instanceof ISynchronizable ) { Object lock = ( ( ISynchronizable ) annotationModel ) . getLockObject ( ) ; if ( lock != null'}]",") { return lock; } } return annotationModel; } private void updateAnnotations ( IRubyScript rubyScript, IProgressMonitor progressMonitor ) { List<OverrideIndicator> indicators = new ArrayList<>(); Map<String, IMethod> methods = rubyScript.getMethodMap(); for (Map.Entry<String, IMethod> entry : methods.entrySet()) { String methodHandle = entry.getKey(); IMethod method = entry.getValue(); if (method.isOverwrite()) { indicators.add(new OverrideIndicator(true, Messages.OVERWRITE_INDICATOR, methodHandle)); } else { indicators.add(new OverrideIndicator(false, Messages.NO_OVERWRITE_INDICATOR, methodHandle)); } } fOverrideAnnotations = indicators.toArray(new OverrideIndicator[indicators.size()]); } @Override public void reconciled ( IRubyReconcilingEvent event ) { if (! event. isTextChange ( ) ) { return ; } synchronized ( fAnnotationModelLockObject ) { updateAnnotations ( event. getRubyElement ( ), event. getProgressMonitor ( ) ) ; } } }",0.0003180471145807993
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package bonsai . app . alarm ; import java . util . Date ; import bonsai . app . AndroidProjectActivity ; import bonsai . app . BonsaiDbUtil ; import bonsai . app . FamilyDbUtil ; import bonsai . app . R ; import android . app . IntentService ; import android . app . Notification ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . content . Intent ; import android . database . Cursor ; public class NotificationService extends IntentService { public static boolean notificado ; public static boolean enabled ; private BonsaiDbUtil bonsaidb ; private FamilyDbUtil familydb ; public NotificationService ( ) { super ( ""<STR_LIT>"" ) ; } @ Override protected void onHandleIntent ( Intent intent ) { while ( true ) { try { enabled = true ; Thread . sleep ( <NUM_LIT> ) ; if ( ! enabled ) break ; boolean tarea = checkForTasks ( ) ; if ( notificado ) { if ( tarea ) { } else { notificado = false ; } } else { if ( tarea ) { notifica ( ) ; notificado = true ; } else { } } } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } } } private boolean checkForTasks ( ) { Cursor bonsaisCursor = null ; try { bonsaidb = new BonsaiDbUtil ( this ) ; bonsaidb . open ( ) ; familydb = new FamilyDbUtil ( this ) ; familydb . open ( ) ; bonsaisCursor = bonsaidb . fetchAllBonsais ( ) ; bonsaisCursor . moveToFirst ( ) ; for ( int i = <NUM_LIT:0> ; i < bonsaisCursor . getCount ( ) ; i ++ ) { long id = bonsaisCursor . getLong ( bonsaisCursor . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_ROWID ) ) ; String possibletask = checkWater ( id ) ; if ( possibletask != null ) { return true ; } possibletask = checkPode ( id ) ; if ( possibletask != null ) { return true ; } possibletask = checkTransplant ( id ) ; if ( possibletask != null ) { return true ; } if ( i < bonsaisCursor . getCount ( ) - <NUM_LIT:1> ) bonsaisCursor . moveToNext ( ) ; } bonsaisCursor . close ( ) ; bonsaidb . close ( ) ; familydb . close ( ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; bonsaisCursor . close ( ) ; bonsaidb . close ( ) ; familydb . close ( ) ; } return false ; } private void notifica ( ) { try { int icon = R . drawable . bonsai ; CharSequence tickerText = ""<STR_LIT>"" ; long when = System . currentTimeMillis ( ) ; Notification notification = new Notification ( icon , tickerText , when ) ; NotificationManager notificationManager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; Intent notificationIntent = new Intent ( this , AndroidProjectActivity . class ) ; PendingIntent contentIntent = PendingIntent . getActivity ( this , <NUM_LIT:0> , notificationIntent , <NUM_LIT:0> ) ; notification . setLatestEventInfo ( this , ""<STR_LIT>"" , ""<STR_LIT>"" , contentIntent ) ; notification . defaults |= Notification . DEFAULT_SOUND ; notification . defaults |= Notification . DEFAULT_VIBRATE ; notification . defaults |= Notification . DEFAULT_LIGHTS ; notification . flags = Notification . FLAG_AUTO_CANCEL ; notification . ledARGB = <NUM_LIT> ; notification . ledOnMS = <NUM_LIT> ; notification . ledOffMS = <NUM_LIT:1000> ; notification . flags |= Notification . FLAG_SHOW_LIGHTS ; notificationManager . notify ( <NUM_LIT:1> , notification ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } } private String checkWater ( long id ) { String name ; String family ; long lastwatered ; long waterfrec ; int height = <NUM_LIT:30> ; long hoursTime = ( new Date ( ) . getTime ( ) ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; Cursor bonsai = null ; Cursor cfamily = null ; try { bonsai = bonsaidb . fetchBonsai ( id ) ; name = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_NAME ) ) ; family = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_FAMILY ) ) ; lastwatered = bonsai . getInt ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_LAST_WATER ) ) ; height = bonsai . getInt ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_HEIGHT ) ) ; cfamily = familydb . fetchFamilybyName ( family ) ; waterfrec = cfamily . getInt ( cfamily . getColumnIndexOrThrow ( FamilyDbUtil . KEY_WATER_FRECUENCY ) ) ; if ( lastwatered == <NUM_LIT:0> ) return ( ""<STR_LIT>"" + name ) ; else if ( ( hoursTime - lastwatered ) > waterfrec ) return ( ""<STR_LIT>"" + name + ""<STR_LIT>"" + height / <NUM_LIT:2> + ""<STR_LIT>"" ) ; else return null ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; return null ; } finally { bonsai . close ( ) ; cfamily . close ( ) ; } } private String checkTransplant ( long id ) { String name ; String family ; long lasttransplant ; long transplantfrec ; long age = <NUM_LIT:1> ; long hoursTime = ( new Date ( ) . getTime ( ) ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; Cursor bonsai = null ; Cursor cfamily = null ; try { bonsai = bonsaidb . fetchBonsai ( id ) ; name = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_NAME ) ) ; family = bonsai . getString ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_FAMILY ) ) ; lasttransplant = bonsai . getInt ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_LAST_TRASPLANT ) ) ; long date = new Date ( ) . getTime ( ) / ( <NUM_LIT:1000> * <NUM_LIT> * <NUM_LIT> ) ; age = ( ( date - bonsai . getLong ( bonsai . getColumnIndexOrThrow ( BonsaiDbUtil . KEY_AGE ) ) ) / ( <NUM_LIT> * <NUM_LIT:24> ) ) ; cfamily = familydb .'}]","fetchFamilybyName(family); transplantfrec = cfamily.getInt(cfamily.getColumnIndexOrThrow(FamilyDbUtil.KEY_TRANSPLANT_FRECUENCY)); if (lasttransplant == 0) return (""<STR_LIT>"" + name); else if ((hoursTime - lasttransplant) > transplantfrec) return (""<STR_LIT>"" + name + ""<STR_LIT>"" + age + ""<STR_LIT>"")); else return null; } catch (Exception e) { System.out.println(e.toString()); return null; } finally { bonsai.close(); cfamily.close(); } }",0.00021606845231678736
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . epic . regexp ; import org . eclipse . ui . plugin . * ; import org . eclipse . core . runtime . * ; import org . eclipse . core . resources . * ; import java . io . IOException ; import java . net . URL ; import java . util . * ; public class RegExpPlugin extends AbstractUIPlugin { private static RegExpPlugin plugin ; private ResourceBundle resourceBundle ; public RegExpPlugin ( ) { super ( ) ; plugin = this ; try { resourceBundle = ResourceBundle . getBundle ( ""<STR_LIT>"" ) ; } catch ( MissingResourceException x ) { resourceBundle = null ; } } public static RegExpPlugin getDefault ( ) { return plugin ; } public static IWorkspace getWorkspace ( ) { return ResourcesPlugin . getWorkspace ( ) ; } public static String getResourceString ( String key ) { ResourceBundle bundle = RegExpPlugin . getDefault ( ) . getResourceBundle ( ) ; try { return bundle . getString ( key ) ; } catch ( MissingResourceException e ) { return key ; } } public ResourceBundle getResourceBundle ( ) {'}]",return resourceBundle;,2.333675077473452e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package hudson . jbpm ; import hudson . model . Hudson ; import java . io . IOException ; import java . io . Serializable ; import java . security . Principal ; import javax . servlet . Filter ; import javax . servlet . FilterChain ; import javax . servlet . FilterConfig ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import org . acegisecurity . Authentication ; import org . jbpm . JbpmConfiguration ; import org . jbpm . JbpmContext ; public class JbpmContextFilter implements Filter , Serializable { private static final long serialVersionUID = <NUM_LIT:1L> ; String jbpmConfigurationResource = null ; String jbpmContextName = null ; boolean isAuthenticationEnabled = true ; public void init ( FilterConfig filterConfig ) throws ServletException { this . jbpmConfigurationResource = filterConfig . getInitParameter ( ""<STR_LIT>"" ) ; this . jbpmContextName = filterConfig . getInitParameter ( ""<STR_LIT>"" ) ; if ( jbpmContextName == null ) { jbpmContextName = JbpmContext . DEFAULT_JBPM_CONTEXT_NAME ; } String isAuthenticationEnabledText = filterConfig . getInitParameter ( ""<STR_LIT>"" ) ; if ( ( isAuthenticationEnabledText != null ) && ( ""<STR_LIT>"" . equalsIgnoreCase ( isAuthenticationEnabledText ) ) ) { isAuthenticationEnabled = false ; } } public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { String actorId = null ; if ( servletRequest instanceof HttpServletRequest ) { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; Principal userPrincipal = httpServletRequest . getUserPrincipal ( ) ; if ( userPrincipal != null ) { actorId = userPrincipal . getName ( ) ; } } if ( actorId == null ) { Authentication auth = Hudson . getAuthentication ( ) ; if ( auth'}]","!= null) { actorId = auth.getName(); } } JbpmContext jbpmContext = JbpmContextFactory.getDefaultJbpmContext(); if (jbpmContext!= null) { jbpmContext.setActorId(actorId); } filterChain.doFilter(servletRequest, servletResponse); } public void destroy ( ) { } }",0.00011659422158662839
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . log ; import java . io . Serializable ; import java . util . List ; public interface LogEventBuffer extends Serializable { void addListener'}]",(LogEventBuffer.Listener listener); },2.4164164316441e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBParamValueAssignList ; import net'}]",.sf.sveditor.core.db.SVDBParamValueAssignList createParamValueAssignList();,4.010791006670414e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package edsdk ; import com . sun . jna . NativeLong ; import com . sun . jna . Structure ; public class EdsVolumeInfo extends Structure { public NativeLong storageType ; public int access ; public long maxCapacity ; public long freeSpaceInBytes ; public byte [ ] szVolumeLabel = new byte [ ( <NUM_LIT> ) ] ; public EdsVolumeInfo ( ) { super ( ) ; initFieldOrder ( ) ; } protected void initFieldOrder ( ) { setFieldOrder ( new java . lang . String [ ] { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } ) ; } public'}]",static class ByReference extends Structure { },2.774992164943178e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . callhierarchy ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . PlatformUI ; import org . rubypeople . rdt . core . search . IRubySearchScope ; import org . rubypeople . rdt . internal . ui . IRubyHelpContextIds ; import org . rubypeople . rdt . internal . ui . search . RubySearchScopeFactory ; class SearchScopeWorkingSetAction extends SearchScopeAction { private IWorkingSet [ ] fWorkingSets ; public SearchScopeWorkingSetAction ( SearchScopeActionGroup group , IWorkingSet [ ] workingSets , String name ) { super ( group , name ) ; setToolTipText ( CallHierarchyMessages . SearchScopeActionGroup_workingset_tooltip ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) .'}]",".setContext(IWorkingSet.class, IRubyHelpContextIds.SEARCH_SCOPE_WORKING_SET, this); } public void run ( ) { if ( fWorkingSets!= null ) { IRubySearchScope scope = RubySearchScopeFactory. createScope ( fWorkingSets ) ; getActionGroup ( ). setAction ( new SearchScopeAction ( scope ) ) ; } else { getActionGroup ( ). setAction ( new SearchScopeAction ( IRubySearchScope. ALL_WORKING_SETS ) ) ; } super. run ( ) ; } }",0.0001668757051023915
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core . resource ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class MockDrainDriver <'}]",> extends Thread { private final List<InputStream> streams = new ArrayList<>(); public void addStream(InputStream stream) { streams.add(stream); } @Override public void run() { for (InputStream stream : streams) { try { stream.close(); } catch (IOException e) { // ignore } } } },9.659335403489819e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . directio ; public final class DirectDataSourceConstants { public static final'}]",int BUFFER_SIZE = 4096;,2.6710784723974244e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . templates ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Set ; public class DynamicTemplateParameterProvider implements ITemplateParameterProvider { public boolean providesParameter ( String id ) {'}]","return id.equals(""date""); // or any other logic to check if the provider provides the parameter",3.8622924496046954e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import java . util . ArrayList ; import java . util . Collections ; import java . util . EnumSet ; import java . util . List ; import java . util . Set ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocBasicType ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocBlock ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocField ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocFragment ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocMethod ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocName ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocNamedType ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocSimpleName ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocText ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrDocType ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . JavadocTokenKind ; public abstract class JavadocBlockParser extends JavadocBaseParser { private static final Set < JavadocTokenKind > S_FOLLOW ; static { Set < JavadocTokenKind > set = EnumSet . noneOf ( JavadocTokenKind . class ) ; set . add ( JavadocTokenKind . WHITE_SPACES ) ; set . add ( JavadocTokenKind . LINE_BREAK ) ; set . add ( JavadocTokenKind . EOF ) ; S_FOLLOW = Collections . unmodifiableSet ( set ) ; } protected JavadocBlockParser ( ) { this ( Collections . < JavadocBlockParser > emptyList ( ) ) ; } protected JavadocBlockParser ( List < ? extends JavadocBlockParser > blockParsers ) { super ( blockParsers ) ; } public abstract boolean canAccept ( String tag ) ; public abstract IrDocBlock parse ( String tag , JavadocScanner scanner ) throws JavadocParseException ; public IrDocBlock newBlock ( String tag , List < ? extends IrDocFragment > fragments ) { if ( fragments == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } IrDocBlock block = new IrDocBlock ( ) ; block . setTag ( tag ) ; block . setFragments ( fragments ) ; return block ; } public List < IrDocFragment > fetchRestFragments ( JavadocScanner scanner ) throws JavadocParseException { int index = scanner . getIndex ( ) ; try { ArrayList < IrDocFragment > fragments = new ArrayList < IrDocFragment > ( ) ; while ( true ) { JavadocTokenKind la = scanner . lookahead ( <NUM_LIT:0> ) . getKind ( ) ; if ( la == JavadocTokenKind . LINE_BREAK ) { int count = JavadocScannerUtil . countUntilNextPrintable ( scanner , <NUM_LIT:0> ) ; scanner . consume ( count ) ; } else if ( la == JavadocTokenKind . LEFT_BRACE ) { JavadocBlockInfo info = JavadocBlockParserUtil . fetchBlockInfo ( scanner ) ; IrDocBlock inline = parseBlock ( info ) ; fragments . add ('}]",inline);scanner.consume(info.getConsumed());} else { break;}return fragments;} catch (JavadocParseException e) { scanner.setIndex(index);throw e;} finally { scanner.setIndex(index);} return Collections.emptyList();},8.838575096810709e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db .'}]","import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; public class SveditorCoreDB { public static void main ( String [ ] args ) { try { Class. forName ( ""org.h2.Driver"" ) ; Connection conn = DriverManager. getConnection ( ""jdbc:h2:~/sveditor"", ""sa"", """" ) ; Statement stmt = conn. createStatement ( ) ; } catch ( SQLException | ClassNotFoundException e ) { // handle exception } } }",0.00016894636168411382
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . text ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . reconciler . DirtyRegion ; import org . eclipse . jface . text . reconciler . IReconcilingStrategy ; import org . eclipse . jface . text . source . IAnnotationModel ; import org . eclipse . ui . texteditor . IDocumentProvider ; import org . eclipse . ui . texteditor . ITextEditor ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . text . ruby . IProblemRequestorExtension ; import org . rubypeople . rdt . internal . ui . text . ruby . RubyReconcilingStrategy ; import org . rubypeople . rdt . internal . ui . text . spelling . RubySpellingReconcileStrategy ; public class RubyCompositeReconcilingStrategy extends CompositeReconcilingStrategy { private ITextEditor fEditor ; private RubyReconcilingStrategy fRubyStrategy ; public RubyCompositeReconcilingStrategy ( ITextEditor editor , String documentPartitioning ) { fEditor = editor ; fRubyStrategy = new RubyReconcilingStrategy ( editor ) ; setReconcilingStrategies ( new IReconcilingStrategy [ ] { fRubyStrategy , new RubySpellingReconcileStrategy ( editor ) }'}]",", documentPartitioning ) ; } @Override public void setDocumentProvider ( IDocumentProvider provider ) { fRubyStrategy. setDocumentProvider ( provider ) ; super. setDocumentProvider ( provider ) ; } @Override public void setDocument ( String document ) { fRubyStrategy. setDocument ( document ) ; super. setDocument ( document ) ; } @Override public void setDocument ( IStructuredDocument document ) { fRubyStrategy. setDocument ( document ) ; super. setDocument ( document ) ; } @Override public void setDocumentPartitioning ( String partitioning ) { fRubyStrategy. setDocumentPartitioning ( partitioning ) ; super. setDocumentPartitioning ( partitioning ) ; } @Override public void setAnnotationModel ( IAnnotationModel model ) { fRubyStrategy. setAnnotationModel ( model ) ; super. setAnnotationModel ( model ) ; } @Override public void setProblemRequestorExtension ( IProblemRequestorExtension extension ) { fRubyStrategy. setProblemRequestorExtension ( extension ) ; super. setProblemRequestorExtension ( extension ) ; } }",0.00030106093021121114
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . search ; import java . util . ArrayList ; import java . util . List ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . db . index . SVDBIndexListIterator ; import net . sf . sveditor . core . db . project . SVDBProjectData ; import net . sf . sveditor . core . db . project . SVDBProjectManager ; import net . sf . sveditor . core . db . search . SVDBSearchSpecification ; import net . sf . sveditor . core . db . search . SVDBSearchType ; import net . sf . sveditor . core . db . search . SVDBSearchUsage ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . ui . SVUiPlugin ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . DialogPage ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . search . ui . ISearchPage ; import org . eclipse . search . ui . ISearchPageContainer ; import org . eclipse . search . ui . ISearchQuery ; import org . eclipse . search . ui . NewSearchUI ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Group ; import org . eclipse . ui . IWorkingSet ; public class SVSearchPage extends DialogPage implements ISearchPage { private Combo fSearchExprCombo ; private Button fCaseSensitiveButton ; private Button fSearchForTypeButton ; private Button fSearchForMethodButton ; private Button fSearchForPackageButton ; private Button fSearchForFieldButton ; private ISearchPageContainer fContainer ; private Button fLimitToDeclarationsButton ; private Button fLimitToReferencesButton ; private Button fLimitToAllButton ; private LogHandle fLog ; private List < SearchSettings > fSearchHistory ; private SearchSettings fCurrentSearch ; private static final String PAGE_NAME = ""<STR_LIT>"" ; private class SearchSettings { public String fSearchExpr ; public SVDBSearchType fSearchFor ; public SVDBSearchUsage fLimitTo ; public boolean fCaseSensitive ; public SearchSettings ( ) { fSearchExpr = ""<STR_LIT>"" ; fSearchFor = SVDBSearchType . Type ; fLimitTo = SVDBSearchUsage . Declaration ; fCaseSensitive = false ; } public void store ( IDialogSettings s ) { s . put ( PREF_CASE_SENSITIVE , fCaseSensitive ) ; s . put ( PREF_SEARCH_FOR , fSearchFor . name ( ) ) ; s . put ( PREF_LIMIT_TO , fLimitTo . name ( ) ) ; s . put ( PREF_PATTERN , fSearchExpr ) ; } public void load ( IDialogSettings s ) { fCaseSensitive = s . getBoolean ( PREF_CASE_SENSITIVE ) ; String search_for = s . get ( PREF_SEARCH_FOR ) ; if ( search_for == null ) { search_for = ""<STR_LIT>"" ; } if ( search_for . equals ( SVDBSearchType . Type . name ( ) ) ) { fSearchFor = SVDBSearchType . Type ; } else if ( search_for . equals ( SVDBSearchType . Method . name ( ) ) ) { fSearchFor = SVDBSearchType . Method ; } else if ( search_for . equals ( SVDBSearchType . Package . name ( ) ) ) { fSearchFor = SVDBSearchType . Package ; } else if ( search_for . equals ( SVDBSearchType . Field . name ( ) ) ) { fSearchFor = SVDBSearchType . Field ; } else { fSearchFor = SVDBSearchType . Type ; } String limit_to = s . get ( PREF_LIMIT_TO ) ; if ( limit_to == null ) { limit_to = ""<STR_LIT>"" ; } if ( limit_to . equals ( SVDBSearchUsage . Declaration . name ( ) ) ) { fLimitTo = SVDBSearchUsage . Declaration ; } else if ( limit_to . equals ( SVDBSearchUsage . Reference . name ( ) ) ) { fLimitTo = SVDBSearchUsage . Reference ; } else if ( limit_to . equals ( SVDBSearchUsage . All . name ( ) ) ) { fLimitTo = SVDBSearchUsage . All ; } else { fLimitTo = SVDBSearchUsage . Declaration ; } fSearchExpr = s . get ( PREF_PATTERN ) ; } public void apply ( ) { fCaseSensitiveButton . setSelection ( fCaseSensitive ) ; fSearchExprCombo . setText ( fSearchExpr ) ; fSearchForTypeButton . setSelection ( false ) ; fSearchForMethodButton . setSelection ( false ) ; fSearchForPackageButton . setSelection ( false ) ; fSearchForFieldButton . setSelection ( false ) ; switch ( fSearchFor ) { case Type : fSearchForTypeButton . setSelection ( true ) ; break ; case Field : fSearchForFieldButton . setSelection ( true ) ; break ; case Method : fSearchForMethodButton . setSelection ( true ) ; break ; case Package : fSearchForPackageButton . setSelection ( true ) ; break ; } fLimitToDeclarationsButton . setSelection ( false ) ; fLimitToReferencesButton . setSelection ( false ) ; fLimitToAllButton . setSelection ( false ) ; switch ( fLimitTo ) { case Declaration : fLimitToDeclarationsButton . setSelection ( true ) ; break ; case Reference : fLimitToReferencesButton . setSelection ( true ) ; break ; case All : fLimitToAllButton . setSelection ( true ) ; break ; } } public SearchSettings duplicate ( ) { SearchSettings ret = new SearchSettings ( ) ; ret . fCaseSensitive = fCaseSensitive ; ret . fLimitTo = fLimitTo ; ret . fSearchExpr = fSearchExpr ; ret . fSearchFor = fSearchFor ; return ret ; } public boolean equals ( Object other ) { if ( other instanceof SearchSettings ) { SearchSettings s = ( SearchSettings ) other ; return ( s . fCaseSensitive == fCaseSensitive ) && ( s . fLimitTo == fLimitTo ) && ( s . fSearchExpr . equals ( fSearchExpr ) ) && ( s . fSearchFor == fSearchFor ) ; } else { return false ; } } } public SVSearchPage ( ) { super ( ) ; fSearchHistory = new ArrayList < SVSearchPage . SearchSettings > ( ) ; fCurrentSearch = new SearchSettings ( ) ; fLog = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; } public SVSearchPage ( String title ) { super ( title ) ; } public SVSearchPage ( String title , ImageDescriptor image ) { super ( title , image ) ; } private ISearchQuery createQuery ( ) { SVDBSearchSpecification spec = new SVDBSearchSpecification ( fCurrentSearch . fSearchExpr . trim ( ) , fCurrentSearch . fCaseSensitive , false ) ; spec . setSearchType ( fCurrentSearch . fSearchFor ) ; spec . setSearchUsage ( fCurrentSearch . fLimitTo ) ; SVDBIndexListIterator search_ctxt = new SVDBIndexListIterator ( ) ; switch ( fContainer . getSelectedScope ( ) ) { case ISearchPageContainer . SELECTED_PROJECTS_SCOPE : { IWorkspace ws = ResourcesPlugin . getWorkspace ( ) ; SVDBProjectManager mgr = SVCorePlugin . getDefault ( ) . getProjMgr ( ) ; for ( String pn : fContainer . getSelectedProjectNames ( ) ) { IProject p = ws . getRoot ( ) . getProject ( pn ) ; SVDBProjectData p_data = mgr . getProjectData ( p ) ; if ( p_data != null ) { ISVDBIndexIterator it = p_data . getProjectIndexMgr ( ) ; search_ctxt . addIndexIterator ( it ) ; } } } break ; case ISearchPageContainer . WORKSPACE_SCOPE : { IWorkspace ws = ResourcesPlugin . getWorkspace ( ) ; SVDBProjectManager mgr = SVCorePlugin . getDefault ( ) . getProjMgr ( ) ; for ( IProject p : ws . getRoot ( ) . getProjects ( ) ) { SVDBProjectData p_data = mgr . getProjectData ( p ) ; if ( p_data != null ) { ISVDBIndexIterator it = p_data . getProjectIndexMgr ( ) ; search_ctxt . addIndexIterator ( it ) ; } } } break ; case ISearchPageContainer . WORKING_SET_SCOPE : { for ( IWorkingSet set : fContainer . getSelectedWorkingSets ( ) ) { SVDBProjectManager mgr = SVCorePlugin . getDefault ( ) . getProjMgr ( ) ; for ( IAdaptable adapter : set . getElements ( ) ) { Object project_o = adapter . getAdapter ( IProject . class ) ; if ( project_o != null ) { IProject project = ( IProject ) project_o ; SVDBProjectData p_data = mgr . getProjectData ( project ) ; if ( p_data != null ) { ISVDBIndexIterator it = p_data . getProjectIndexMgr ( ) ; search_ctxt . addIndexIterator ( it ) ; } } } } } break ; case ISearchPageContainer . SELECTION_SCOPE : { fLog . error ( ""<STR_LIT>"" ) ; ISelection sel = fContainer . getSelection ( ) ; if ( sel instanceof IStructuredSelection ) { IStructuredSelection ss = ( IStructuredSelection ) sel ; for ( Object sel_o : ss . toList ( ) ) { if ( sel_o instanceof IProject ) { } else if ( sel_o instanceof IFile ) { } } } } break ; } return new SVSearchQuery ( search_ctxt , spec ) ; } public boolean performAction ( ) { saveSettings ( true ) ; try { NewSearchUI . runQueryInBackground ( createQuery ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; ErrorDialog . openError ( getShell ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , Status . CANCEL_STATUS ) ; return false ; } return true ; } @ Override public void dispose ( ) { super . dispose ( ) ; } public void setContainer ( ISearchPageContainer container ) { fContainer = container ; fContainer . setPerformActionEnabled ( true ) ; } public void createControl ( Composite parent ) { Composite c = new Composite ( parent , SWT . NONE ) ; setControl ( c ) ; c . setLayout ( new GridLayout ( <NUM_LIT:1> , false ) ) ; Composite composite = new Composite ( c , SWT . NONE ) ; composite . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; composite . setLayout ( new GridLayout ( <NUM_LIT:2> , false ) ) ; fSearchExprCombo = new Combo ( composite , SWT . NONE ) ; fSearchExprCombo . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false , <NUM_LIT:1> , <NUM_LIT:1> ) ) ; fSearchExprCombo . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { fCurrentSearch . fSearchExpr = fSearchExprCombo . getText ( ) ; } } ) ; fSearchExprCombo . addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ( SelectionEvent e ) { fCurrentSearch = fSearchHistory . get ( fSearchExprCombo . getSelectionIndex ( ) ) . duplicate ( ) ; fCurrentSearch . apply ( ) ; } public void widgetDefaultSelected'}]","( SelectionEvent e ) { } } ) ; fCaseSensitiveButton = new Button ( composite, SWT. CHECKED ) ; fCaseSensitiveButton. addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ( SelectionEvent e ) { fCurrentSearch. fCaseSensitive = fCaseSensitiveButton. getSelection ( ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { } } ) ; fSearchForTypeButton = new Button ( composite, SWT. CHECKED ) ; fSearchForTypeButton. addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ( SelectionEvent e ) { fCurrentSearch. fSearchFor = SVDBSearchType. Type ; fCurrentSearch. apply ( ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { } } ) ; fSearchForMethodButton = new Button ( composite, SWT. CHECKED ) ; fSearchForMethodButton. addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ( SelectionEvent e ) { fCurrentSearch. fSearchFor = SVDBSearchType. Method ; fCurrentSearch. apply ( ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { } } ) ; fSearchForPackageButton = new",0.0004839352193382755
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . persistence ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBLocation ; import net . sf . sveditor . core . db . attr . SVDBDoNotSaveAttr ; import net . sf . sveditor . core . db . attr . SVDBParentAttr ; import net . sf . sveditor . core . db . index . SVDBArgFileIndexCacheData ; import net . sf . sveditor . core . db . index . SVDBBaseIndexCacheData ; import net . sf . sveditor . core . db . index . SVDBDeclCacheItem ; import net . sf . sveditor . core . db . index . SVDBFileTree ; import net . sf . sveditor . core . db . refs . SVDBRefCacheEntry ; import org . objectweb . asm . ClassWriter ; import org . objectweb . asm . Label ; import org . objectweb . asm . MethodVisitor ; import org . objectweb . asm . Opcodes ; @ SuppressWarnings ( { ""<STR_LIT:rawtypes>"" , ""<STR_LIT:unchecked>"" } ) public class JITPersistenceDelegateFactory implements Opcodes { private static JITPersistenceDelegateFactory fInstance ; private Class < JITPersistenceDelegateBase > fDelegateCls ; private String fTargetPkg ; private List < String > fTargetPkgList ; private Map < SVDBItemType , Class > fTypeClassMap ; private List < Class > fClassList ; private Set < Class > fClassSet ; private static final String fBaseClass = getClassName ( JITPersistenceDelegateBase . class ) ; private static final String fPersistenceDelegateParentClass = getClassName ( ISVDBPersistenceRWDelegateParent . class ) ; private static final String fChildItem = ""<STR_LIT>"" ; private static final String fDBFormatException = ""<STR_LIT>"" ; private static final String fDBWriteException = ""<STR_LIT>"" ; private static final String WRITE_ENUM_TYPE_SIG = ""<STR_LIT>"" ; private static final String READ_ENUM_TYPE_SIG = ""<STR_LIT>"" ; private static final String WRITE_STRING_SIG = ""<STR_LIT>"" ; private static final String READ_STRING_SIG = ""<STR_LIT>"" ; private static final String WRITE_LOCATION_SIG = ""<STR_LIT>"" ; private static final String READ_LOCATION_SIG = ""<STR_LIT>"" ; private static final String READ_LIST_SIG = ""<STR_LIT>"" ; private static final String WRITE_LIST_SIG = ""<STR_LIT>"" ; private static final String READ_SET_SIG = ""<STR_LIT>"" ; private static final String WRITE_SET_SIG = ""<STR_LIT>"" ; private static final String READ_ITEM_LIST_SIG = ""<STR_LIT>"" + fChildItem + ""<STR_LIT>"" ; private static final String WRITE_INT_SIG = ""<STR_LIT>"" ; private static final String READ_INT_SIG = ""<STR_LIT>"" ; private static final String WRITE_LONG_SIG = ""<STR_LIT>"" ; private static final String READ_LONG_SIG = ""<STR_LIT>"" ; private static final String WRITE_BOOL_SIG = ""<STR_LIT>"" ; private static final String READ_BOOL_SIG = ""<STR_LIT>"" ; private static final String WRITE_ITEM_SIG = ""<STR_LIT>"" ; private static final String READ_ITEM_SIG = ""<STR_LIT>"" + getClassName ( ISVDBChildItem . class ) + ""<STR_LIT>"" ; private static final String WRITE_MAP_SIG = ""<STR_LIT>"" ; private static final String READ_MAP_SIG = ""<STR_LIT>"" ; private boolean fDebugEn = false ; private int fLevel ; private static final int THIS_VAR = <NUM_LIT:0> ; private static final int READ_PARENT_VAR = <NUM_LIT:1> ; private static final int READ_OBJ_VAR = <NUM_LIT:2> ; private static final int WRITE_OBJ_VAR = <NUM_LIT:1> ; private class JITClassLoader extends ClassLoader { private byte fClassBytes [ ] ; private Class < JITPersistenceDelegateBase > fCls ; JITClassLoader ( ClassLoader parent , byte class_bytes [ ] ) { super ( parent ) ; fClassBytes = class_bytes ; } @ Override protected Class < ? > findClass ( String name ) throws ClassNotFoundException { if ( name . equals ( fTargetPkg + ""<STR_LIT>"" ) ) { if ( fCls == null ) { fCls = ( Class < JITPersistenceDelegateBase > ) defineClass ( name , fClassBytes , <NUM_LIT:0> , fClassBytes . length ) ; } return fCls ; } return super . findClass ( name ) ; } } private JITPersistenceDelegateFactory ( ) { fTypeClassMap = new HashMap < SVDBItemType , Class > ( ) ; fClassList = new ArrayList < Class > ( ) ; fClassSet = new HashSet < Class > ( ) ; fTargetPkg = ""<STR_LIT>"" ; fTargetPkgList = new ArrayList < String > ( ) ; fTargetPkgList . add ( ""<STR_LIT>"" ) ; fTargetPkgList . add ( ""<STR_LIT>"" ) ; fTargetPkgList . add ( ""<STR_LIT>"" ) ; fClassList . add ( SVDBFile . class ) ; fClassList . add ( SVDBFileTree . class ) ; fClassList . add ( SVDBBaseIndexCacheData . class ) ; fClassList . add ( SVDBArgFileIndexCacheData . class ) ; fClassList . add ( SVDBDeclCacheItem . class ) ; fClassList . add ( SVDBRefCacheEntry . class ) ; fClassSet . addAll ( fClassList ) ; } private void build ( ) { ClassWriter cw = new ClassWriter ( <NUM_LIT:0> ) ; final ClassLoader cl = getClass ( ) . getClassLoader ( ) ; for ( SVDBItemType t : SVDBItemType . values ( ) ) { Class cls = null ; for ( String pkg : fTargetPkgList ) { try { cls = cl . loadClass ( pkg + ""<STR_LIT>"" + t . name ( ) ) ; } catch ( Exception e ) { } if ( cls != null ) { break ; } } if ( cls != null ) { fTypeClassMap . put ( t , cls ) ; } else { System . out . println ( ""<STR_LIT>"" + t . name ( ) ) ; } } long start = System . currentTimeMillis ( ) ; build_boilerplate ( cw ) ; for ( SVDBItemType t : fTypeClassMap . keySet ( ) ) { Class cls = fTypeClassMap . get ( t ) ; buildItemAccessor ( cw , t , cls ) ; } for ( Class c : fClassList ) { buildObjectAccessor ( cw , c ) ; } cw . visitEnd ( ) ; JITClassLoader jit_cl = new JITClassLoader ( cl , cw . toByteArray ( ) ) ; try { fDelegateCls = ( Class < JITPersistenceDelegateBase > ) jit_cl . loadClass ( fTargetPkg + ""<STR_LIT>"" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( ""<STR_LIT>"" + ( end - start ) ) ; System . out . println ( ""<STR_LIT>"" + cw . toByteArray ( ) . length ) ; } private void build_boilerplate ( ClassWriter cw ) { String classname = ""<STR_LIT>"" ; String full_classname = transform_cls ( fTargetPkg ) + ""<STR_LIT:/>"" + classname ; cw . visit ( Opcodes . V1_5 , ACC_PROTECTED + ACC_PUBLIC + ACC_SUPER , full_classname , null , fBaseClass , null ) ; cw . visitSource ( classname + ""<STR_LIT>"" , null ) ; MethodVisitor mv ; mv = cw . visitMethod ( ACC_PUBLIC , ""<STR_LIT>"" , ""<STR_LIT>"" , null , null ) ; mv . visitCode ( ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:0> ) ; mv . visitMethodInsn ( INVOKESPECIAL , fBaseClass , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:1> , <NUM_LIT:1> ) ; mv . visitEnd ( ) ; buildItemDispatchMethods ( cw ) ; buildObjectDispatchMethods ( cw ) ; } private void buildItemDispatchMethods ( ClassWriter cw ) { String classname = ""<STR_LIT>"" ; String full_classname = transform_cls ( fTargetPkg ) + ""<STR_LIT:/>"" + classname ; Label labels [ ] = new Label [ SVDBItemType . values ( ) . length ] ; int indexes [ ] = new int [ SVDBItemType . values ( ) . length ] ; Label dflt , endcase ; for ( int i = <NUM_LIT:0> ; i < SVDBItemType . values ( ) . length ; i ++ ) { indexes [ i ] = i ; } MethodVisitor mv = cw . visitMethod ( ACC_PUBLIC , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( ISVDBItemBase . class ) + ""<STR_LIT>"" , null , new String [ ] { fDBWriteException } ) ; for ( int i = <NUM_LIT:0> ; i < SVDBItemType . values ( ) . length ; i ++ ) { labels [ i ] = new Label ( ) ; } dflt = new Label ( ) ; endcase = new Label ( ) ; mv . visitVarInsn ( ALOAD , WRITE_OBJ_VAR ) ; mv . visitMethodInsn ( INVOKEINTERFACE , getClassName ( ISVDBItemBase . class ) , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( SVDBItemType . class ) + ""<STR_LIT:;>"" ) ; mv . visitMethodInsn ( INVOKEVIRTUAL , getClassName ( SVDBItemType . class ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mv . visitLookupSwitchInsn ( dflt , indexes , labels ) ; for ( SVDBItemType t : SVDBItemType . values ( ) ) { Class c = fTypeClassMap . get ( t ) ; mv . visitLabel ( labels [ t . ordinal ( ) ] ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , WRITE_OBJ_VAR ) ; mv . visitTypeInsn ( CHECKCAST , getClassName ( c ) ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" + t . name ( ) , ""<STR_LIT>"" + getClassName ( c ) + ""<STR_LIT>"" ) ; mv . visitJumpInsn ( GOTO , endcase ) ; } mv . visitLabel ( dflt ) ; mv . visitLabel ( endcase ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:16> , <NUM_LIT:16> ) ; mv . visitEnd ( ) ; mv = cw . visitMethod ( ACC_PUBLIC , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( SVDBItemType . class ) + ""<STR_LIT>"" + getClassName ( ISVDBChildItem . class ) + ""<STR_LIT>"" + getClassName ( ISVDBItemBase . class ) + ""<STR_LIT:;>"" , null , new String [ ] { fDBWriteException } ) ; for ( int i = <NUM_LIT:0> ; i < SVDBItemType . values ( ) . length ; i ++ ) { labels [ i ] = new Label ( ) ; } dflt = new Label ( ) ; endcase = new Label ( ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:1> ) ; mv . visitMethodInsn ( INVOKEVIRTUAL , getClassName ( SVDBItemType . class ) , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mv . visitLookupSwitchInsn ( dflt , indexes , labels ) ; for ( SVDBItemType t : SVDBItemType . values ( ) ) { Class c = fTypeClassMap . get ( t ) ; mv . visitLabel ( labels [ t . ordinal ( ) ] ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:2> ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" + t . name ( ) , ""<STR_LIT>"" + getClassName ( ISVDBChildItem . class ) + ""<STR_LIT>"" + ""<STR_LIT>"" + getClassName ( c ) + ""<STR_LIT:;>"" ) ; mv . visitJumpInsn ( GOTO , endcase ) ; } mv . visitLabel ( dflt ) ; mv . visitInsn ( ACONST_NULL ) ; mv . visitLabel ( endcase ) ; mv . visitInsn ( ARETURN ) ; mv . visitMaxs ( <NUM_LIT:16> , <NUM_LIT:16> ) ; mv . visitEnd ( ) ; } private void buildObjectDispatchMethods ( ClassWriter cw ) { String classname = ""<STR_LIT>"" ; String full_classname = transform_cls ( fTargetPkg ) + ""<STR_LIT:/>"" + classname ; int idx ; Label labels [ ] = new Label [ fClassList . size ( ) ] ; int indexes [ ] = new int [ fClassList . size ( ) ] ; Label dflt , endcase ; for ( int i = <NUM_LIT:0> ; i < fClassList . size ( ) ; i ++ ) { indexes [ i ] = i ; } MethodVisitor mv = cw . visitMethod ( ACC_PUBLIC , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( Class . class ) + ""<STR_LIT:;>"" + ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" , null , new String [ ] { fDBWriteException } ) ; for ( int i = <NUM_LIT:0> ; i < fClassList . size ( ) ; i ++ ) { labels [ i ] = new Label ( ) ; } dflt = new Label ( ) ; endcase = new Label ( ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitFieldInsn ( GETFIELD , fBaseClass , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( List . class ) + ""<STR_LIT:;>"" ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:1> ) ; mv . visitMethodInsn ( INVOKEINTERFACE , getClassName ( List . class ) , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" ) ; mv . visitLookupSwitchInsn ( dflt , indexes , labels ) ; idx = <NUM_LIT:0> ; for ( Class c : fClassList ) { mv . visitLabel ( labels [ idx ] ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:2> ) ; mv . visitTypeInsn ( CHECKCAST , getClassName ( c ) ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" + getClassLeafName ( c ) , ""<STR_LIT>"" + getClassName ( c ) + ""<STR_LIT>"" ) ; mv . visitJumpInsn ( GOTO , endcase ) ; idx ++ ; } mv . visitLabel ( dflt ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:2> ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" ) ; mv . visitLabel ( endcase ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:16> , <NUM_LIT:16> ) ; mv . visitEnd ( ) ; mv = cw . visitMethod ( ACC_PUBLIC , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( ISVDBChildItem . class ) + ""<STR_LIT:;>"" + ""<STR_LIT>"" + getClassName ( Class . class ) + ""<STR_LIT:;>"" + ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" , null , new String [ ] { fDBWriteException } ) ; for ( int i = <NUM_LIT:0> ; i < fClassList . size ( ) ; i ++ ) { labels [ i ] = new Label ( ) ; } dflt = new Label ( ) ; endcase = new Label ( ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitFieldInsn ( GETFIELD , fBaseClass , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( List . class ) + ""<STR_LIT:;>"" ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:2> ) ; mv . visitMethodInsn ( INVOKEINTERFACE , getClassName ( List . class ) , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" ) ; mv . visitLookupSwitchInsn ( dflt , indexes , labels ) ; idx = <NUM_LIT:0> ; for ( Class c : fClassList ) { mv . visitLabel ( labels [ idx ] ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:1> ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:3> ) ; mv . visitTypeInsn ( CHECKCAST , getClassName ( c ) ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" + getClassLeafName ( c ) , ""<STR_LIT>"" + getClassName ( ISVDBChildItem . class ) + ""<STR_LIT:;>"" + ""<STR_LIT>"" + getClassName ( c ) + ""<STR_LIT>"" ) ; mv . visitJumpInsn ( GOTO , endcase ) ; idx ++ ; } mv . visitLabel ( dflt ) ; mv . visitVarInsn ( ALOAD , THIS_VAR ) ; mv . visitVarInsn ( ALOAD , <NUM_LIT:3> ) ; mv . visitMethodInsn ( INVOKESPECIAL , full_classname , ""<STR_LIT>"" , ""<STR_LIT>"" + getClassName ( Object . class ) + ""<STR_LIT>"" ) ; mv . visitLabel ( endcase ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:4> , <NUM_LIT:4> ) ; mv . visitEnd ( ) ; } private void buildObjectAccessor ( ClassWriter cw , Class cls ) { MethodVisitor mv ; if ( fDebugEn ) { debug ( ""<STR_LIT>"" + cls . getName ( ) ) ; } String tgt_clsname = getClassName ( cls ) ; String cls_name = getClassLeafName ( cls ) ; mv = cw . visitMethod ( ACC_PRIVATE , ""<STR_LIT>"" + cls_name , ""<STR_LIT>"" + fChildItem + ""<STR_LIT:;>"" + ""<STR_LIT>"" + tgt_clsname + ""<STR_LIT>"" , null , new String [ ] { fDBFormatException } ) ; mv . visitCode ( ) ; visit ( false , tgt_clsname , mv , cls ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:3> , <NUM_LIT:3> ) ; mv . visitEnd ( ) ; mv = cw . visitMethod ( ACC_PRIVATE , ""<STR_LIT>"" + cls_name , ""<STR_LIT>"" + tgt_clsname + ""<STR_LIT>"" , null , new String [ ] { fDBWriteException } ) ; mv . visitCode ( ) ; visit ( true , tgt_clsname , mv , cls ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:3> , <NUM_LIT:3> ) ; mv . visitEnd ( ) ; if ( fDebugEn ) { debug ( ""<STR_LIT>"" + cls . getName ( ) ) ; } } private void buildItemAccessor ( ClassWriter cw , SVDBItemType t , Class cls ) { MethodVisitor mv ; if ( fDebugEn ) { debug ( ""<STR_LIT>"" + t . name ( ) + ""<STR_LIT>"" + cls . getName ( ) ) ; } String item_name = t . name ( ) ; String tgt_clsname = getClassName ( cls ) ; mv = cw . visitMethod ( ACC_PRIVATE , ""<STR_LIT>"" + item_name , ""<STR_LIT>"" + fChildItem + ""<STR_LIT>"" + tgt_clsname + ""<STR_LIT:;>"" , null , new String [ ] { fDBFormatException } ) ; mv . visitCode ( ) ; mv . visitTypeInsn ( NEW , tgt_clsname ) ; mv . visitInsn ( DUP ) ; mv . visitMethodInsn ( INVOKESPECIAL , tgt_clsname , ""<STR_LIT>"" , ""<STR_LIT>"" ) ; mv . visitVarInsn ( ASTORE , READ_OBJ_VAR ) ; visit ( false , tgt_clsname , mv , cls ) ; mv . visitVarInsn ( ALOAD , READ_OBJ_VAR ) ; mv . visitInsn ( ARETURN ) ; mv . visitMaxs ( <NUM_LIT:3> , <NUM_LIT:3> ) ; mv . visitEnd ( ) ; mv = cw . visitMethod ( ACC_PRIVATE , ""<STR_LIT>"" + item_name , ""<STR_LIT>"" + tgt_clsname + ""<STR_LIT>"" , null , new String [ ] { fDBWriteException } ) ; mv . visitCode ( ) ; visit ( true , tgt_clsname , mv , cls ) ; mv . visitInsn ( RETURN ) ; mv . visitMaxs ( <NUM_LIT:3> , <NUM_LIT:3> ) ; mv . visitEnd ( ) ; if ( fDebugEn ) { debug ( ""<STR_LIT>"" + t + ""<STR_LIT>"" + cls . getName ( ) ) ; } } protected void visit ( boolean write , String tgt_classname , MethodVisitor mv , Class cls ) { if ( fDebugEn ) { debug ( ""<STR_LIT>"" + ( ++ fLevel ) + ""<STR_LIT>"" + cls . getName ( ) ) ; } if ( cls . getSuperclass ( ) != null && cls . getSuperclass ( ) != Object . class ) { String tgt_super_classname = getClassName ( cls . getSuperclass ( ) ) ; visit ( write , tgt_super_classname , mv , cls . getSuperclass ( ) ) ; } Field fields [ ] = cls . getDeclaredFields ( ) ; for ( Field f : fields ) { Class field_class = f . getType ( ) ; String field_classname = getClassName ( field_class ) ; if ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) { if ( f . getAnnotation ( SVDBParentAttr . class ) != null ) { if ( ! write ) { mv . visitVarInsn ( ALOAD , READ_OBJ_VAR ) ; mv . visitVarInsn ( ALOAD , READ_PARENT_VAR ) ; mv . visitFieldInsn ( PUTFIELD , tgt_classname , f . getName ( ) , ""<STR_LIT>"" + field_classname + ""<STR_LIT:;>"" ) ; } continue ; } if ( f . getAnnotation ( SVDBDoNotSaveAttr . class ) != null ) { continue ; } if ( ( f . getModifiers ( ) & Modifier . PUBLIC ) == <NUM_LIT:0> ) { throw new RuntimeException ( ""<STR_LIT>"" + tgt_classname +'}]","""<STR_LIT>"" + f. getName ( ) + ""<STR_LIT>"" + field_classname + ""<STR_LIT>"" ) ; } String field_name = f. getName ( ) ; if (! write ) { mv. visitVarInsn ( ALOAD, READ_OBJ_VAR ) ; mv. visitVarInsn ( ALOAD, READ_PARENT_VAR ) ; mv. visitFieldInsn ( GETFIELD, tgt_classname, field_name, ""<STR_LIT>"" + field_classname + ""<STR_LIT:;>"" ) ; } else { mv. visitVarInsn ( ALOAD, WRITE_OBJ_VAR ) ; mv. visitVarInsn ( ALOAD, WRITE_PARENT_VAR ) ; mv. visitFieldInsn ( PUTFIELD, tgt_classname, field_name, ""<STR_LIT>"" + field_classname + ""<STR_LIT:;>"" ) ; } visit ( write, field_classname, mv, field_class ) ; } if ( fDebugEn ) { debug ( ""<STR_LIT>"" + ( -- fLevel ) + ""<STR_LIT>"" + cls. getName ( ) ) ; } } private void debug ( String message ) { if ( fDebugEn ) { System. out. println ( ""<STR_LIT>"" + message ) ; } }",0.000635327699049439
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . entity . person . v1 . impl ; import java . util . ArrayList ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import fi . arcusys . tampere . hrsoa . entity . User ; import fi . arcusys . tampere . hrsoa . ws . ldap . LdapService ; import fi . koku . services . common . kahva . LdapServiceFactory ; import fi . koku . services . entity . customer . v1 . AuditInfoType ; import fi . koku . services . entity . customer . v1 . CustomerQueryCriteriaType ; import fi . koku . services . entity . customer . v1 . CustomerServiceFactory ; import fi . koku . services . entity . customer . v1 . CustomerServicePortType ; import fi . koku . services . entity . customer . v1 . CustomerType ; import fi . koku . services . entity . customer . v1 . CustomersType ; import fi . koku . services . entity . customer . v1 . PicsType ; import fi . koku . services . entity . customer . v1 . ServiceFault ; import fi . koku . services . entity . person . v1 . Person ; import fi . koku . services . entity . person . v1 . PersonConstants ; import fi . koku . services . entity . person . v1 . PersonInfoProvider ; import fi . koku . services . entity . person . v1 . PersonService ; import fi . koku . services . entity . userinformation . UserInformationConstants ; import fi . koku . services . entity . userinformation . v1 . UserInformationServiceFactory ; import fi . tampere . contract . municipalityportal . uis . UserInformationFault ; import fi . tampere . contract . municipalityportal . uis . UserInformationServicePortType ; import fi . tampere . schema . municipalityportal . uis . UserInformationType ; public class TampereImpl implements PersonInfoProvider { private static final Logger LOG = LoggerFactory . getLogger ( PersonService . class ) ; private static String endpoint ; private CustomerServicePortType customerService ; private LdapService ldapService ; private UserInformationServicePortType userInformationService ; public TampereImpl ( ) { CustomerServiceFactory customerServiceFactory ='}]",new CustomerServiceFactory(); endpoint = customerServiceFactory.getEndpoint(); customerService = customerServiceFactory.createCustomerService(); ldapService = LdapServiceFactory.getInstance().createLdapService(); userInformationService = UserInformationServiceFactory.getInstance().createUserInformationService(); } @Override public Person createPerson ( Person person ) { //... } @Override public List < Person > findPersonByQueryCriteria ( CustomerQueryCriteriaType queryCriteria ) { //... } @Override public Person getPerson ( String personId ) { //... } @Override public void updatePerson ( Person person ) { //... } @Override public void deletePerson ( String personId ) { //... } },0.00019977390237491469
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . input . requests ; import org . oddjob . input . InputMedium ; public class InputText extends BaseInputRequest { private String prompt ; private String defaultValue ; @ Override public void render ( InputMedium medium ) {'}]","medium.print(prompt); medium.print("" ["" + defaultValue + ""] ""); medium.newLine(); } }",3.9748362191829574e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . generateaccessors ; public class AccessorSelection { private String className ; private String attributeName ; private boolean readerSelected ; private boolean writerSelected ; public AccessorSelection ( String'}]","className, String attributeName, boolean readerSelected, boolean writerSelected ) { this. className = className ; this. attributeName = attributeName ; this. readerSelected = readerSelected ; this. writerSelected = writerSelected ; } public String getClassName ( ) { return className ; } public String getAttributeName ( ) { return attributeName ; } public boolean isReaderSelected ( ) { return readerSelected ; } public boolean isWriterSelected ( ) { return writerSelected ; } }",0.0001287491657852926
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . java . parser . javadoc ; import com . asakusafw . utils . java . internal . parser . javadoc . ir . IrLocation ; public class IllegalDocCommentFormatException extends JavadocParseException { private static final long serialVersionUID = <NUM_LIT:1L> ; private boolean'}]",hasLocation = false;,2.3572292663387496e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . windgate . jdbc . driver ; import java . util . Map ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstAttributeElement ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . PropertyDeclaration ; import com . asakusafw . dmdl .'}]","semantics.TableDeclaration; public class DmdlDriver implements java. sql. Driver { private static final DmdlSemantics SEMANTICS = new DmdlSemantics ( ) ; @ Override public java. sql. Connection connect ( java. util. Properties info ) throws java. sql. SQLException { //... } @ Override public boolean acceptsURL ( java. lang. String url ) throws java. sql. SQLException { //... } @ Override public int getMajorVersion ( ) { return 1 ; } @ Override public int getMinorVersion ( ) { return 0 ; } @ Override public boolean isWrapperFor ( java. lang. Class <?> arg0 ) throws java. sql. SQLException { return false ; } @ Override public java. lang. Class <?> getType ( java. lang. String arg0 ) throws java. sql. SQLException { return null ; } @ Override public java. sql. ParameterMetaData getMetaData ( java. sql. PreparedStatement statement ) throws java. sql. SQLException { //... } @ Override public java. sql. DatabaseMetaData getMetaData ( ) throws java. sql. SQLException { return new DmdlDatabaseMetaData ( ) ; } @ Override public java. lang. String getName ( ) { return ""DmdlDriver"" ; }",0.00034059494208533433
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . io ; import java . io . IOException ; import test . modelgen . model . Bar ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . runtime . io . RecordEmitter ; public final class BarModelOutput implements ModelOutput < Bar > { private final RecordEmitter emitter ; public BarModelOutput ( RecordEmitter emitter ) { if ( emitter == null ) { throw new IllegalArgumentException ( ) ; } this . emitter = emitter ; } @ Override public void write ( Bar model ) throws IOException { emitter . emit ( model . getPkOption ( ) ) ; emitter . emit ( model . getDetailGroupIdOption ( ) ) ; emitter . emit ( model . getDetailTypeOption ( ) ) ; emitter . emit ( model . getDetailSenderIdOption ( ) ) ; emitter . emit ( model . getDetailReceiverIdOption ( ) ) ; emitter . emit ( model . getDetailTestTypeOption ( ) ) ; emitter . emit ( model . getDetailStatusOption ( ) ) ; emitter . emit ( model . getDetailLineNoOption ( ) ) ; emitter . emit ( model . getDeleteFlgOption ( ) ) ; emitter . emit ( model . getInsertDatetimeOption ( ) ) ; emitter . emit ( model . getUpdateDatetimeOption ( ) ) ; emitter . emit ( model . getPurchaseNoOption ( ) ) ; emitter . emit ( model . getPurchaseTypeOption ( ) ) ; emitter . emit ( model . getTradeTypeOption ( ) ) ; emitter . emit ( model . getTradeNoOption ( ) ) ; emitter . emit ( model . getLineNoOption ( ) ) ; emitter . emit ( model . getDeliveryDateOption ( ) ) ; emitter . emit ( model . getStoreCodeOption ( ) ) ; emitter . emit ( model . getBuyerCodeOption ( ) ) ; emitter . emit ( model . getSalesTypeCodeOption ( ) ) ; emitter . emit ( model . getSellerCodeOption ( ) ) ; emitter . emit ( model . getTenantCodeOption ( ) ) ; emitter . emit ( model . getNetPriceTotalOption ( ) ) ; emitter . emit ( model . getSellingPriceTotalOption ( ) ) ;'}]",emitter. emit ( model. getSalesmanCodeOption ( ) ) ; } @ Override public void close ( ) throws IOException { emitter. close ( ) ; } },6.701610119777932e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . eclipse . shams . runtime ; import java . io . File ; import org . eclipse . core . runtime . IPath ; public class ShamIPath implements IPath { protected String path ; public ShamIPath ( String thePath ) { path = thePath ; } public IPath addFileExtension ( String extension ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IPath addTrailingSeparator ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IPath append ( String path ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IPath append ( IPath path ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public Object clone ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public String getDevice ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public String getFileExtension ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean hasTrailingSeparator ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isAbsolute ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isEmpty ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isPrefixOf ( IPath anotherPath ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isRoot ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isUNC ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isValidPath ( String path ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public boolean isValidSegment ( String segment ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public String lastSegment ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } public IPath makeAbsolute ( ) { throw'}]",new ShamIPath(new File(this.path).getAbsolutePath());,3.7230915260115996e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . team1160 . scouting . h2 ; import java . sql . * ; import java . util . LinkedHashMap ; import java . util . Map ; public class DictTable extends H2Table { public DictTable ( String database ) throws SQLException , ClassNotFoundException { super ( database ) ; statement . executeUpdate ( ""<STR_LIT>"" ) ; } public void insert ( int ID , String value ) throws SQLException { PreparedStatement prep = connection . prepareStatement ( ""<STR_LIT>"" ) ; prep . setInt ( <NUM_LIT:1> , ID ) ; prep . setString ( <NUM_LIT:2> , value ) ; prep . addBatch ( ) ; connection . setAutoCommit ( false ) ; prep . executeBatch ( ) ; connection . setAutoCommit ( true ) ; } public String getString ( int ID ) throws SQLException { ResultSet rs = statement . executeQuery ( ""<STR_LIT>"" + Integer . toString ( ID ) ) ; return rs . getString ( ""<STR_LIT:value>"" ) ; } public String getID ( String value ) throws SQLException { ResultSet rs'}]","= statement. executeQuery ( ""<STR_LIT>"" + value ) ; int ID = rs. getInt ( ""<STR_LIT>ID>"" ) ; return Integer. toString ( ID ) ; } }",6.650252210152595e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . buffer . LRUCache ; import org . rubypeople . rdt . internal . core . buffer . OverflowingLRUCache ; public class ElementCache extends OverflowingLRUCache { IRubyElement spaceLimitParent = null ; public ElementCache ( int size ) { super ( size ) ; } public ElementCache ( int size , int overflow ) { super ( size , overflow ) ; } protected void ensureSpaceLimit ( int childrenSize , IRubyElement parent ) { int spaceNeeded = <NUM_LIT:1> + ( int ) ( ( <NUM_LIT:1> + fLoadFactor ) * ( childrenSize + fOverflow ) ) ; if ( fSpaceLimit < spaceNeeded ) { shrink ( ) ; setSpaceLimit ( spaceNeeded ) ; this . spaceLimitParent = parent ; } } protected void resetSpaceLimit ( int defaultLimit , IRubyElement parent ) { if ( parent . equals ( this . spaceLimitParent ) ) { setSpaceLimit ( defaultLimit ) ; this . spaceLimitParent = null ; } } protected boolean close ( LRUCacheEntry entry ) {'}]",if ( entry == null ) return false; if ( entry. element. equals ( this. spaceLimitParent ) ) { this. spaceLimitParent = null ; } return super. close ( entry ) ; },7.378576251566844e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . flow ; import java . lang . annotation . Documented ; import java . lang .'}]",.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.lang.reflect.Method; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; import java.util.stream.Stream; import com.asakusafw.utils.collection.MapBuilder; import com.asakusafw.windgate.api.annotation.Fluent; @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Fluent public @interface Vocabulary { },0.00015373323965013275
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . utils . collections ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; public final class Maps { public static < K , V > Map < K , V > create ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > Map < K , V > from ( Map < ? extends K , ? extends V > map ) { return new HashMap < K , V > ( map ) ; } public static < K , V > Map < K , V > freeze ( Map < ? extends K , ? extends V > map ) { return Collections . unmodifiableMap ( from ( map ) ) ; } public static < K , V > Map < V , List < K > > transpose ( Map < ? extends K , ? extends V > map ) { if ( map == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Map < V , List < K > > results = create ( ) ; for ( Map . Entry < ? extends K , ? extends V > entry : map . entrySet ( ) ) { addToList ( results , entry . getValue ( ) , entry . getKey ( ) ) ; } return results ; } public static < T > Map < T , T > pairs ( T ... pairs ) { if ( pairs == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( pairs . length % <NUM_LIT:2> != <NUM_LIT:0> ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } Map < T , T > result = new HashMap < T ,'}]","T > ( pairs. length / 2 ) ; for ( int i = 0 ; i < pairs. length ; i += 2 ) { result. put ( pairs [ i ], pairs [ i + 1 ] ) ; } return result ; } private static < T > void addToList ( Map < T, List < T > > map, T key, T value ) { List < T > list = map. get ( key ) ; if ( list == null ) { list = new ArrayList < T > ( ) ; map. put ( key, list ) ; } list. add ( value ) ; } }",0.00019508964100927709
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui ; import org . eclipse . core . resources . IResource ; import org . rubypeople . rdt . core . RubyModelException ; public interface IResourceLocator { IResource getUnderlyingResource ( Object element ) throws RubyModelException ; IResource getCorrespondingResource ( Object element'}]",) throws RubyModelException; },2.5490369583467124e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . windgate ; import java . text . MessageFormat ; import java . util . List ; import com . asakusafw . windgate . core . vocabulary . DataModelJdbcSupport ; final class JdbcDescriptionUtil { static void checkCommonConfig ( String descriptionClass , Class < ? > modelType , Class < ? extends DataModelJdbcSupport < ? > > supportClass , String table , List < String > columns ) { if ( isEmpty ( table ) ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , descriptionClass , ""<STR_LIT>"" ) ) ; } if ( columns == null ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , descriptionClass , ""<STR_LIT>"" ) ) ; } if ( columns . isEmpty ( ) ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , descriptionClass , ""<STR_LIT>"" ) ) ; } for ( String column : columns ) { if ( isEmpty ('}]","column ) ) { throw new IllegalStateException ( MessageFormat. format ( ""<STR_LIT>"", descriptionClass, ""<STR_LIT>"" ) ) ; } } } }",5.9544664466620226e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . framework ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . log4j . Logger ; import org . oddjob . FailedToStopException ; import org . oddjob . Resetable ; import org . oddjob . Stateful ; import org . oddjob . Stoppable ; import org . oddjob . arooa . life . ComponentPersistException ; import org . oddjob . images . IconHelper ; import org . oddjob . logging . LogEnabled ; import org . oddjob . persist . Persistable ; import org . oddjob . state . IsAnyState ; import org . oddjob . state . IsExecutable ; import org . oddjob . state . IsHardResetable ; import org . oddjob . state . IsSoftResetable ; import org . oddjob . state . IsStoppable ; import org . oddjob . state . ServiceState ; import org . oddjob . state . ServiceStateChanger ; import org . oddjob . state . ServiceStateHandler ; abstract public class SimpleService extends BaseComponent implements Runnable , Stateful , Resetable , Stoppable , LogEnabled { private static final AtomicInteger instanceCount = new AtomicInteger ( ) ; private final Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) + ""<STR_LIT:.>"" + instanceCount . incrementAndGet ( ) ) ; protected final ServiceStateHandler stateHandler ; private final ServiceStateChanger stateChanger ; private String name ; public SimpleService ( ) { stateHandler = new ServiceStateHandler ( this ) ; stateChanger = new ServiceStateChanger ( stateHandler , iconHelper , new Persistable ( ) { @ Override public void persist ( ) throws ComponentPersistException { save ( ) ; } } ) ; } @ Override protected Logger logger ( ) { return logger ; } @ Override public String loggerName ( ) { return logger . getName ( ) ; } @ Override protected ServiceStateHandler stateHandler ( ) { return stateHandler ; } protected ServiceStateChanger getStateChanger ( ) { return stateChanger ; } public void run ( ) { ComponentBoundry . push ( logger ( ) . getName ( ) , this ) ; try { if ( ! stateHandler . waitToWhen ( new IsExecutable ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( ServiceState . STARTING ) ; } } ) ) { return ; } logger ( ) . info ( ""<STR_LIT>"" ) ; try { configure ( SimpleService . this ) ; onStart ( ) ; stateHandler . waitToWhen ( new IsAnyState ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setState ( ServiceState . STARTED ) ; } } ) ; } catch ( final Throwable e ) { logger ( ) . warn ( ""<STR_LIT>"" , e ) ; stateHandler . waitToWhen ( new IsAnyState ( ) , new Runnable ( ) { public void run ( ) { getStateChanger ( ) . setStateException ( e ) ; } } ) ; } } finally { ComponentBoundry . pop ( ) ; } } abstract protected void onStart ( ) throws Throwable ; @ Override public void stop ( ) throws FailedToStopException { ComponentBoundry . push ( logger ( ) . getName ( ) , this ) ; try { logger ( ) . debug ( ""<STR_LIT>"" ) ; if ( ! stateHandler . waitToWhen ( new IsStoppable ( ) , new Runnable ( ) { public void run ( ) { iconHelper . changeIcon ( IconHelper . STOPPING ) ; } } ) ) { logger ( ) . debug ( ""<STR_LIT>"" ) ; return ; } logger ( ) . info'}]","(""<STR_LIT>"") ; stateHandler. waitToWhen ( new IsAnyState ( ), new Runnable ( ) { public void run ( ) { getStateChanger ( ). setState ( ServiceState. STOPPING ) ; } } ) ; } finally { ComponentBoundry. pop ( ) ; } } @ Override public void reset ( ) { ComponentBoundry. push ( logger ( ). getName ( ), this ) ; try { logger ( ). debug ( ""<STR_LIT>"" ) ; if (! stateHandler. waitToWhen ( new IsHardResetable ( ), new Runnable ( ) { public void run ( ) { iconHelper. changeIcon ( IconHelper. HARD_RESETTING ) ; } } ) ) { logger ( ). debug ( ""<STR_LIT>"" ) ; return ; } logger ( ). info ( ""<STR_LIT>"" ) ; stateHandler. waitToWhen ( new IsAnyState ( ), new Runnable ( ) { public void run ( ) { getStateChanger ( ). setState ( ServiceState. HARD_RESETTING ) ; } } ) ; } finally { ComponentBoundry. pop ( ) ; } } @ Override public void setName ( String name ) { this. name = name ; } public",0.0003705548093851545
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspace ; import org'}]",.eclipse.core.resources.IFile;,2.3846949700532427e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . svcp ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBChildParent ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItemType ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; public class SVTreeContentProvider implements ITreeContentProvider { private static final Set < SVDBItemType > fDoNotRecurseScopes ; private static final Set < SVDBItemType > fExpandInLineItems ; private static final Set < SVDBItemType > fIgnoreItems ; static { fDoNotRecurseScopes = new HashSet < SVDBItemType > ( ) ; fDoNotRecurseScopes . add ( SVDBItemType . Function ) ; fDoNotRecurseScopes . add ( SVDBItemType . Task ) ; fDoNotRecurseScopes . add ( SVDBItemType . Coverpoint ) ; fDoNotRecurseScopes . add ( SVDBItemType . CoverpointCross ) ; fDoNotRecurseScopes . add ( SVDBItemType . ConfigDecl ) ; fExpandInLineItems = new HashSet < SVDBItemType > ( ) ; fExpandInLineItems . add ( SVDBItemType . VarDeclStmt ) ; fExpandInLineItems . add ( SVDBItemType . ParamPortDecl ) ; fExpandInLineItems . add ( SVDBItemType . ModIfcInst ) ; fExpandInLineItems . add ( SVDBItemType . ImportStmt ) ; fExpandInLineItems . add ( SVDBItemType . ExportStmt ) ; fIgnoreItems = new HashSet < SVDBItemType > ( ) ; fIgnoreItems . add ( SVDBItemType . NullStmt ) ; } public'}]",List<?> getElements(Object inputElement) { return new ArrayList<>(); },4.133342035844563e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . util ; import org . oddjob . OddjobException ; import org . oddjob . arooa . parsing . Location ; public class OddjobConfigException extends OddjobException { private static final long serialVersionUID = <NUM_LIT> ; public OddjobConfigException ( String msg ) { super ( msg ) ; } public'}]","OddjobConfigException(String msg, Location location) { super(msg, location); }",3.73385012026151e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . parser ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBFile ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . SVDBMarker ; import net . sf . sveditor . core . tests . SVDBTestUtils ; public class TestParseProgramBlocks extends TestCase { public void testNamedProgramBlock ( ) { String doc = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT:n>"" + ""<STR_LIT>"" ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; SVDBFile file = SVDBTestUtils . parse ( doc , ""<STR_LIT>"" ) ; for ( ISVDBItemBase it : file . getItems ( ) ) { if ( it . getType ( ) == SVDBItemType . Marker ) { System . out . println ( ""<STR_LIT>"" + ( ( SVDBMarker ) it ) . getMessage ( ) ) ; } } SVDBTestUtils . assertFileHasElements ( file , ""<STR_LIT>"" ) ; } public void testAnonProgramBlock ( ) { String doc ='}]","""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT",0.00035468794840616845
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . springframework . samples . petclinic . web ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . samples . petclinic . Clinic ; import org . springframework . samples . petclinic . Owner ; import org . springframework . samples . petclinic . validation . OwnerValidator ; import org . springframework . stereotype . Controller ; import org . springframework . ui . Model ; import org . springframework . validation . BindingResult ; import org . springframework . web . bind . WebDataBinder ; import org . springframework . web . bind . annotation . InitBinder ; import org . springframework . web . bind . annotation . ModelAttribute ; import org .'}]",".springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.RestControllerAdvice; @Controller public class ClinicController { @Autowired private Clinic clinic; @Autowired private OwnerValidator ownerValidator; @InitBinder public void initBinder(WebDataBinder binder) { binder.setValidator(ownerValidator); } @RequestMapping(value = ""/owners"", method = RequestMethod.GET) public String listOwners(@ModelAttribute Owner owner, BindingResult result) { return ""owners""; } @RequestMapping(value = ""/owners"", method = RequestMethod.POST) public @ResponseBody Owner addOwner(@ModelAttribute Owner owner, BindingResult result) { // add owner logic here return owner; } }",0.00020023707352982738
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . tests . core . splitlocal . conditionchecks ; import java . io . FileNotFoundException ; import java . io . IOException ; import org . rubypeople . rdt . refactoring . core . splitlocal . SplitLocalConditionChecker ; import org . rubypeople . rdt . refactoring . core . splitlocal . SplitLocalConfig ; import org . rubypeople . rdt . refactoring . core . splitlocal . SplitTempEditProvider ; import org . rubypeople . rdt . refactoring . tests . FilePropertyData ; import org . rubypeople . rdt . refactoring . tests . FileTestData ; import org . rubypeople . rdt . refactoring . tests . RefactoringConditionTestCase ; public class SplitLocalConditionTester extends RefactoringConditionTestCase { private FilePropertyData testData ; private SplitLocalConfig config ; public SplitLocalConditionTester ( String fileName ) { super ( fileName'}]","); testData = new FilePropertyData(fileName); config = new SplitLocalConfig(testData); } @Override protected SplitLocalConditionChecker createConditionChecker() { return new SplitLocalConditionChecker(config); } @Override protected SplitTempEditProvider createTempEditProvider() { return new SplitTempEditProvider(config); } @Override protected FileTestData createTestData() throws IOException, FileNotFoundException { return testData; } }",0.0001159325469929474
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . processor ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . util . List ; import org . junit . Test ; import com . asakusafw . compiler . flow . JobflowCompilerTestRoot ; import com . asakusafw . compiler . flow . plan . StageGraph ; import com . asakusafw . compiler . flow . processor . flow . ProjectFlowInvalid ; import com . asakusafw . compiler . flow . processor . flow . ProjectFlowSame ; import com . asakusafw . compiler . flow . processor . flow . ProjectFlowSimple ; import com . asakusafw . compiler . flow . stage . StageCompiler ; import com . asakusafw . compiler . flow . stage . StageModel ; import com . asakusafw . compiler . flow . stage . StageModel . Fragment ; import com . asakusafw . compiler . flow . testing . model . Ex1 ; import com . asakusafw . compiler . flow . testing . model . Ex2 ; import com . asakusafw . compiler . flow . testing . model . Part1 ; import com . asakusafw . runtime . core . Result ; import com . asakusafw . runtime . testing . MockResult ; import com . asakusafw . utils . java . model . syntax . Name ; public class ProjectFlowProcessorTest extends JobflowCompilerTestRoot { @ Test public void Ex1_Part ( ) { List < StageModel > stages = compile ( ProjectFlowSimple . class ) ; Fragment fragment = stages . get ( <NUM_LIT:0> ) . getMapUnits ( ) . get ( <NUM_LIT:0> ) . getFragments ( ) . get ( <NUM_LIT:0> ) ; Name name = fragment . getCompiled ( ) . getQualifiedName ( ) ; ClassLoader loader = start ( ) ; PortMapper mapper = new PortMapper ( fragment ) ; MockResult < Part1 > result = mapper . create ( ""<STR_LIT>"" ) ; @ SuppressWarnings ( ""<STR_LIT:unchecked>"" ) Result < Ex1 > f = ( Result < Ex1 > ) create ( loader , name , mapper . toArguments ( ) ) ; Ex1 in = new Ex1 ( ) ; in . setSid ( <NUM_LIT> ) ; in . setValue ( <NUM_LIT:100> ) ; in . setStringAsString ( ""<STR_LIT>"" ) ; f . add ( in ) ; assertThat ( result . getResults ( ) . size ( ) ,'}]",is ( <NUM_LIT:1> ) ); },4.0855034593792465e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . monitor . model ; import java . util . Observable ; import java . util . Observer ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . MockStateful ; import org . oddjob . Oddjob ; import org . oddjob . logging . ConsoleArchiver ; import org . oddjob . logging . LogArchiver ; import org . oddjob . logging . LogHelper ; import org . oddjob . logging . LogLevel ; import org . oddjob . logging . LogListener ; import org . oddjob . logging . cache . LocalConsoleArchiver ; import org . oddjob . state . StateListener ; public class DetailModelTest extends TestCase { private static final Logger logger = Logger . getLogger ( DetailModelTest . class ) ; class OurExplorerContext extends MockExplorerContext { ConsoleArchiver consoleArchiver ; LogArchiver logArchiver ; Object component ; @ Override public Object getThisComponent ( ) { return component ; } @ Override public Object getValue ( String key ) { if ( LogContextInialiser . LOG_ARCHIVER . equals ( key ) ) { return logArchiver ; } if ( LogContextInialiser . CONSOLE_ARCHIVER . equals ( key ) ) { return consoleArchiver ; } throw new RuntimeException ( key ) ; } } class MyLA implements LogArchiver { boolean removed ; public void addLogListener ( LogListener l , Object component , LogLevel level , long last , int max ) { logger . debug ( ""<STR_LIT>"" + LogHelper . getLogger ( component ) ) ; assertEquals ( LogLevel . DEBUG , level ) ; assertEquals ( - <NUM_LIT:1> , last ) ; assertEquals ( <NUM_LIT:1000> , max ) ; } public void removeLogListener ( LogListener l , Object component ) { removed = true ; logger . debug ( ""<STR_LIT>"" ) ; } public void onDestroy ( ) { throw new RuntimeException ( ""<STR_LIT>"" ) ; } } class MyJob extends MockStateful { public String getLogger ( ) { return ""<STR_LIT:foo>"" ; } boolean added ; boolean removed ; public void addStateListener ( StateListener listener ) { logger . debug ( ""<STR_LIT>"" ) ; added = true ; } public void removeStateListener ( StateListener listener ) { logger . debug ( ""<STR_LIT>"" ) ; removed = true ; } } Observable observable ; Object ar ; class MyO implements Observer { public void update ( Observable o , Object arg ) { observable = o ; ar = arg ; } } public void testSelect ( ) { MyLA la = new MyLA ( ) ; MyJob myJob ='}]","new MyJob ( ) ; OurExplorerContext explorerContext = new OurExplorerContext ( ) ; explorerContext. component = myJob ; explorerContext. consoleArchiver = new LocalConsoleArchiver ( ) ; explorerContext. logArchiver = la ; Oddjob oddjob = new Oddjob ( ) ; oddjob. setExplorerContext ( explorerContext ) ; MyO observer = new MyO ( ) ; observable = oddjob ; oddjob. addObserver ( observer ) ; oddjob. start ( ) ; oddjob. stop ( ) ; assertEquals ( la, oddjob. getLogArchiver ( ) ) ; assertEquals ( true, la. removed ) ; assertEquals ( true, myJob. removed ) ; assertEquals ( true, myJob. added ) ; assertEquals ( explorerContext. logArchiver, oddjob. getLogArchiver ( ) ) ; assertEquals ( explorerContext. consoleArchiver, oddjob. getConsoleArchiver ( ) ) ; } }",0.0002881491102766821
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . flow ; import java . io . IOException ; import org . apache . hadoop .'}]","fs. FileSystem ; import org. apache. hadoop. fs. Path ; import com. asakusafw.runtime.flow.util. FlowConstants ; import com. asakusafw.runtime.flow.util. FlowUtils ; public class FileInputOperator extends AbstractOperator { private final Path filePath ; private final long offset ; private final long length ; private final FileSystem fileSystem ; public FileInputOperator ( Path filePath, long offset, long length ) { this ( FlowUtils. getFileSystem ( ), filePath, offset, length ) ; } public FileInputOperator ( FileSystem fileSystem, Path filePath, long offset, long length ) { this. fileSystem = fileSystem ; this. filePath = filePath ; this. offset = offset ; this. length = length ; } @ Override public void prepare ( OperatorContext context ) throws IOException { super. prepare ( context ) ; } @ Override public void run ( OperatorContext context ) throws IOException { try ( FSDataInputStream in = fileSystem. open ( filePath ) ) { in. seek ( offset ) ; in. skipBytes ( ( int ) offset ) ; final long lengthToRead = Math. min ( length, in. available ( ) ) ; final byte [ ] buffer = new byte [ ( int ) lengthTo",0.0003268817740171063
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . sun . tools . hat . internal . model ; import static com . sun . tools . hat . internal . model . ArrayTypeCodes . * ; import com . sun . tools . hat . internal . parser . ReadBuffer ; import java . io . IOException ; public class JavaValueArray extends JavaLazyReadObject { private static String arrayTypeName ( byte sig ) { switch ( sig ) { case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT:Z>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; case \'<CHAR_LIT>\' : return ""<STR_LIT>"" ; default : throw new IllegalArgumentException ( ""<STR_LIT>"" + sig ) ; } } private static int elementSize ( byte type ) { switch ( type ) { case T_BYTE : case T_BOOLEAN : return <NUM_LIT:1> ; case T_CHAR : case T_SHORT : return <NUM_LIT:2> ; case T_INT : case T_FLOAT : return <NUM_LIT:4> ; case T_LONG : case T_DOUBLE : return <NUM_LIT:8> ; default : throw new IllegalArgumentException ( ""<STR_LIT>"" + type ) ; } } protected final int readValueLength ( ) throws IOException { JavaClass cl = getClazz ( ) ; ReadBuffer buf = cl . getReadBuffer ( ) ; int idSize = cl . getIdentifierSize ( ) ; long offset = getOffset ( ) + idSize + <NUM_LIT:4> ; int len = buf . getInt ( offset ) ; byte type = buf . getByte ( offset + <NUM_LIT:4> ) ; return len * elementSize ( type ) ; } protected final byte [ ] readValue ( ) throws IOException { JavaClass cl = getClazz ( ) ; ReadBuffer buf = cl . getReadBuffer ( ) ; int idSize = cl . getIdentifierSize ( ) ; long offset = getOffset ( ) + idSize + <NUM_LIT:4> ; int length = buf . getInt ( offset ) ; byte type = buf . getByte ( offset + <NUM_LIT:4> ) ; if ( length == <NUM_LIT:0> ) { return Snapshot . EMPTY_BYTE_ARRAY ; } else { length *= elementSize ( type ) ; byte [ ] res = new byte [ length ] ; buf . get ( offset + <NUM_LIT:5> , res ) ; return res ; } } private JavaClass clazz ; private int data ; private static final int SIGNATURE_MASK = <NUM_LIT> ; private static final int LENGTH_DIVIDER_MASK = <NUM_LIT> ; private static final int LENGTH_DIVIDER_SHIFT = <NUM_LIT:8> ; public JavaValueArray ( byte elementSignature , long offset ) { super ( offset ) ; this . data = ( elementSignature & SIGNATURE_MASK ) ; } public JavaClass getClazz ( ) { return clazz ; } public void visitReferencedObjects ('}]",JavaValueArrayVisitor visitor) throws IOException { visitor.visit(this); } },4.5362846432316703e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package fi . koku . services . utility . authorizationinfo . v1 . model ; public class Role { private String id ; private String name ; public Role ( String id ) { this . id = id ; } public Role ( String id , String name ) { this . id = id ; this . name = name ; } public String getId ( ) { return id ; } public void setId ( String id ) { this . id = id ; } public String getName ( ) { return name ; }'}]",public void setName(String name) { this.name = name; },3.226871347176098e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package de . fuberlin . wiwiss . d2rq . server ; import javax . servlet . ServletContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . joseki . RDFServer ; import org . joseki . Registry ; import org . joseki . Service ; import org . joseki . ServiceRegistry ; import org . joseki . processors . SPARQL ; import com . hp . hpl . jena . graph . BulkUpdateHandler ; import com . hp . hpl . jena . query . ARQ ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . shared . PrefixMapping ; import com . hp . hpl . jena . sparql . core . describe . DescribeHandler ; import com . hp . hpl . jena . sparql . core . describe . DescribeHandlerFactory ; import com . hp . hpl . jena . sparql . core . describe . DescribeHandlerRegistry ; import com . hp . hpl . jena . sparql . util . Context ; import de . fuberlin . wiwiss . d2rq . ResourceDescriber ; import de . fuberlin . wiwiss . d2rq . SystemLoader ; import de . fuberlin . wiwiss . d2rq . algebra . Relation ; import de . fuberlin . wiwiss . d2rq . map . Mapping ; public class D2RServer { private final static String SPARQL_SERVICE_NAME = ""<STR_LIT>"" ; private final static String RESOURCE_SERVICE_NAME = ""<STR_LIT>"" ; private final static String DATASET_SERVICE_NAME = ""<STR_LIT>"" ; private final static String DATA_SERVICE_NAME = ""<STR_LIT:data>"" ; private final static String PAGE_SERVICE_NAME = ""<STR_LIT>"" ; private final static String VOCABULARY_STEM = ""<STR_LIT>"" ; private final static String DEFAULT_SERVER_NAME = ""<STR_LIT>"" ; private final static String SYSTEM_LOADER = ""<STR_LIT>"" ; private static final Log log = LogFactory . getLog ( D2RServer . class ) ;'}]",private final Registry registry;,2.9966761128327706e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . launcher ; import org . eclipse . osgi . util . NLS ; public class LauncherMessages extends NLS { private static final String BUNDLE_NAME = ""<STR_LIT>"" ;'}]",public static String Launch ; public static String LaunchError ; public static String Launching ; public static String LaunchingError ; public static String NoLaunchers ; public static String NoLaunchersError ; public static String NoLaunchersMessage ; public static String NoLaunchersTitle ; public static String Run ; public static String RunError ; public static String Running ; public static String RunningError ; },0.00011084333486727545
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . bootstrap ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URI ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import org . junit . Assume ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; public class CommandLineUtilTest { @ Rule public TemporaryFolder folder = new TemporaryFolder ( ) ; @ Test public void loadProperties_local ( ) throws Exception { Properties p = new Properties ( ) ; p . setProperty ( ""<STR_LIT:hello>"" , ""<STR_LIT>"" ) ; File file = store ( p ) ; Properties loaded = CommandLineUtil . loadProperties ( new URI ( file . toURI ( ) . getPath ( ) ) , null ) ; assertThat ( loaded , is ( p ) ) ; } @ Test public void loadProperties_uri ( ) throws Exception { Properties p = new Properties ( ) ; p . setProperty ( ""<STR_LIT:hello>"" , ""<STR_LIT>"" ) ; File file = store ( p ) ; Properties loaded = CommandLineUtil . loadProperties ( file . toURI ( ) , null ) ; assertThat ( loaded , is ( p ) ) ; } @ Test public void loadProperties_classpath ( ) throws Exception { String className = getClass ( ) . getName ( ) ; String packageName = className . substring ( <NUM_LIT:0> , className . lastIndexOf ( \'<CHAR_LIT:.>\' ) ) ; URI uri = new URI ( ""<STR_LIT>"" + packageName . replace ( \'<CHAR_LIT:.>\' , \'<CHAR_LIT:/>\' ) + ""<STR_LIT>"" ) ; Properties loaded = CommandLineUtil . loadProperties ( uri , getClass ( ) . getClassLoader ( ) ) ; Properties p = new Properties ( ) ; p . setProperty ( ""<STR_LIT:hello>"" , ""<STR_LIT>"" ) ; assertThat ( loaded , is ( p ) ) ; } @ Test ( expected = IOException . class ) public void loadProperties_classpath_missing ( ) throws Exception { URI uri = new URI ( ""<STR_LIT>"" ) ; CommandLineUtil . loadProperties ( uri , null ) ; } @ Test public void parseFileList ( ) throws Exception {'}]","List<URI> uris = Arrays.asList(new URI(""<STR_LIT>file1.properties</STR_LIT>""), new URI(""<STR_LIT>file2.properties</STR_LIT>"")); List<URI> expected = Arrays.asList(new URI(""<STR_LIT>file1.properties</STR_LIT>""), new URI(""<STR_LIT>file2.properties</STR_LIT>"")); List<URI> actual = CommandLineUtil.parseFileList(uris, null); assertThat(actual, is(expected)); } private File store(Properties p) throws IOException { File file = folder.newFile(); try (FileOutputStream fos = new FileOutputStream(file)) { p.store(fos, null); } return file; } }",0.00021393012468579707
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . search ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . index . ISVDBIndex ; public interface ISVDBItemVisitor { int CONTINUE ='}]","1; int BREAK = 2; int SKIP = 3; void visit ( SVDBItem item, ISVDBIndex index ); }",5.2999106274644425e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . search ; import org . eclipse . core . resources . IFile ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . search . ui . NewSearchUI ; import org . eclipse . search . ui . text . Match ; import org . eclipse . ui . IEditorDescriptor ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . IEditorRegistry ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IPartService ; import org . eclipse . ui . IReusableEditor ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . ide . IDE ; import org . eclipse . ui . part . FileEditorInput ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . rubyeditor . EditorUtility ; public class RubySearchEditorOpener { private static class ReusedEditorWatcher implements IPartListener { private IEditorPart fReusedEditor ; private IPartService fPartService ; public ReusedEditorWatcher ( ) { fReusedEditor = null ; fPartService = null ; } public IEditorPart getReusedEditor ( ) { return fReusedEditor ; } public void initialize ( IEditorPart editor ) { if ( fReusedEditor != null ) { fPartService . removePartListener ( this ) ; } fReusedEditor = editor ; if ( editor != null ) { fPartService = editor . getSite ( ) . getWorkbenchWindow ( ) . getPartService ( ) ; fPartService'}]",.addPartListener(this); } public void partActivated(IWorkbenchPart part) { // do nothing } public void partBroughtToTop(IWorkbenchPart part) { // do nothing } public void partClosed(IWorkbenchPart part) { if (fReusedEditor!= null && fReusedEditor.equals(part)) { fReusedEditor = null; fPartService = null; } } public void partDeactivated(IWorkbenchPart part) { // do nothing } public void partOpened(IWorkbenchPart part) { if (fReusedEditor!= null && fReusedEditor.equals(part)) { fPartService.removePartListener(this); } } },0.00019602494980006885
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . io ; import java . io . File ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import org . oddjob . arooa . ArooaValue ; import org . oddjob . arooa . convert . Convertlet ; import org . oddjob . arooa . convert . ConvertletException ; import org . oddjob . arooa . convert . ConversionProvider ; import org . oddjob . arooa . convert . ConversionRegistry ; public class FilesType implements ArooaValue , Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static class Conversions implements ConversionProvider { public void registerWith ( ConversionRegistry registry ) { registry . register ( FilesType . class , File [ ] . class , new Convertlet < FilesType , File [ ] > ( ) { public File [ ] convert ( FilesType from ) throws ConvertletException { return from . toFiles ( ) ; } } ) ; } } private String files ; private final List < File [ ] > list = new ArrayList < File [ ] > ( ) ; public void setFiles ( String files ) { this . files = files ; } public String getFiles ( ) { return files ; } public void setList ( int index , File [ ] files ) { if ( files == null ) { list . remove ( index ) ; } else { list . add ( index , files ) ; } } public File [ ] toFiles ( ) { List < File > all = new ArrayList < File > ( ) ; if ( files != null ) { addFileArray ( all , Files . expand ( new File [ ] { new File ( files ) } ) ) ; } for ( File [ ] files :'}]","list) { addFileArray(all, files); } return all.toArray(new File[all.size()]); } private static void addFileArray(List<File> list, File[] files) { for (File file : files) { if (file!= null && file.exists()) { list.add(file); } else { if (file!= null) { System.err.println(""Ignoring file "" + file.getAbsolutePath() + "" as it does not exist""); } } } } }",0.00014136731659181813
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . log ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class LogFactory implements ILogListener { private static LogFactory fDefault ; private Map < String , LogHandle > fLogHandleMap ; private int fLogLevel = <NUM_LIT:0> ; private Map < String , LogCategory > fLogHandleCategoryMap ; private List < WeakReference < ILogListener > > fLogListeners ; public LogFactory ( ) { fLogHandleMap = new HashMap < String , LogHandle > ( ) ; fLogHandleCategoryMap = new HashMap < String , LogCategory > ( ) ; fLogListeners = new ArrayList < WeakReference < ILogListener > > ( ) ; } public synchronized static LogFactory getDefault ( ) { if ( fDefault == null ) { fDefault = new LogFactory ( ) ; } return fDefault ; } public static synchronized LogHandle getLogHandle ( String name ) { return getLogHandle ( name , ILogHandle . LOG_CAT_DEFAULT ) ; } public void setLogLevel ( String category , int level ) { if ( category == null ) { fLogLevel = level ; for ( Entry < String , LogCategory > e : fLogHandleCategoryMap . entrySet ( ) ) { e .'}]","getValue().setLevel(level); } else { LogCategory category = fLogHandleCategoryMap.get(category); if (category!= null) { category.setLevel(level); } } } public synchronized LogHandle getLogHandle(String name, String category) { if (name == null || name.isEmpty()) { return null; } LogHandle logHandle = fLogHandleMap.get(name); if (logHandle == null) { logHandle = new LogHandle(name, category); fLogHandleMap.put(name, logHandle); } return logHandle; } public synchronized void addListener(ILogListener listener) { fLogListeners.add(new WeakReference<ILogListener>(listener)); } public synchronized void removeListener(ILogListener listener) { if (listener!= null) { List<WeakReference<ILogListener>> list = fLogListeners; for (WeakReference<ILogListener> ref : list) { if (ref.get() == listener) { list.remove(ref); break; } } } } public synchronized void log(String category, String message, int level) { if (level <= fLogLevel) { for (ILogListener listener : fLogListeners) { if (listener!= null) { listener.log(category, message, level); } } } }",0.0003451689119924143
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . sql ; import java . io . ByteArrayInputStream ; import java . sql . Connection ; import java . sql . SQLException ; import junit . framework . TestCase ; import org . oddjob . Oddjob ; import org . oddjob . OddjobLookup ; import org . oddjob . arooa . convert . ArooaConversionException ; import org . oddjob . arooa . reflect . ArooaPropertyException ; import org . oddjob . arooa . standard . StandardArooaSession ; import org . oddjob . arooa . types . ArooaObject ; import org . oddjob . arooa . xml . XMLConfiguration ; import org . oddjob . state . ParentState ; public class SQLParametersTest extends TestCase { public void testSomeInserts ( ) throws SQLException , ArooaPropertyException , ArooaConversionException { ConnectionType connection = new ConnectionType ( ) ; connection . setDriver ( ""<STR_LIT>"" ) ; connection . setUrl ( ""<STR_LIT>"" ) ; connection . setUsername ( ""<STR_LIT>"" ) ; Connection keepAlive = connection . toValue ( ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . setExport ( ""<STR_LIT:c>"" , connection ) ; oddjob . setExport ( ""<STR_LIT>"" , new ArooaObject ( ""<STR_LIT>"" ) ) ; oddjob . run ( ) ; assertEquals ( ParentState . COMPLETE , oddjob . lastStateEvent ( ) . getState ( ) ) ; int count = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" , Integer . class ) ; assertEquals ( <NUM_LIT:2> , count ) ; keepAlive . close ( ) ; oddjob . destroy ( ) ; } public void testInsertsMultipleStatements ( ) throws SQLException , ArooaPropertyException , ArooaConversionException { ConnectionType connection = new ConnectionType ( ) ; connection . setDriver ( ""<STR_LIT>"" ) ; connection . setUrl ( ""<STR_LIT>"" ) ; connection . setUsername ( ""<STR_LIT>"" ) ; String xml = ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" + ""<STR_LIT>"" ; Oddjob oddjob = new Oddjob ( ) ; oddjob . setConfiguration ( new XMLConfiguration ( ""<STR_LIT>"" , xml ) ) ; oddjob . setExport ( ""<STR_LIT:c>"" , connection ) ; oddjob . run ( ) ; assertEquals ( ParentState . COMPLETE , oddjob . lastStateEvent ( ) . getState ( ) ) ; int count = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" , Integer . class ) ; assertEquals ( <NUM_LIT:3> , count ) ; int sum = new OddjobLookup ( oddjob ) . lookup ( ""<STR_LIT>"" , Integer . class ) ; assertEquals ('}]","<NUM_LIT:6>, sum ); } }",4.9841691288724675e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . ui . pages . inlinemethod ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . PlatformUI ; import org . jruby . ast . types . INameNode ; import org . rubypeople . rdt . core . IType ; import org . rubypeople . rdt . core . search . IRubySearchConstants ; import org . rubypeople . rdt . core . search . SearchEngine ; import org . rubypeople . rdt . internal . ui . dialogs . TypeSelectionDialog2 ; import org . rubypeople . rdt . refactoring . core . inlinemethod . ITargetClassFinder ; import org . rubypeople . rdt . refactoring . core . inlinemethod . TargetClassFinder ; import org . rubypeople . rdt . refactoring . documentprovider . IDocumentProvider ; import org . rubypeople . rdt . refactoring . nodewrapper . MethodCallNodeWrapper ; public class TargetClassFinderUI implements ITargetClassFinder { private TargetClassFinder targetClassFinder ; public TargetClassFinderUI ( ) { targetClassFinder = new TargetClassFinder ( ) ; } public String findTargetClass ( MethodCallNodeWrapper call , IDocumentProvider doc ) { String result = targetClassFinder . findTargetClass ( call , doc ) ; if ( ""<STR_LIT>"" . equals ( result ) && call . getReceiverNode ( ) == null ) { return ""<STR_LIT>"" ; } if ( result == null || ""<STR_LIT>"" . equals ( result ) ) { final String title = Messages . TargetClassFinderUI_ChooseType + ( ( INameNode ) call . getReceiverNode ( ) ) . getName ( ) + \'<CHAR_LIT::>\' ; TypeSelectionDialog2 dialog ='}]","new TypeSelectionDialog2 ( PlatformUI. getWorkbench ( ). getActiveWorkbenchWindow ( ). getShell ( ), title, SearchEngine. getInstance ( ). getSearchResult ( call. getReceiverNode ( ), IRubySearchConstants. TYPES ) ) ; String type = dialog. open ( ) ; if ( type!= null ) { return type ; } } return result ; } public void setDocumentProvider ( IDocumentProvider docProvider ) { targetClassFinder. setDocumentProvider ( docProvider ) ; } }",0.00015976313815612605
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . runtime . io ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . IOException ; import java . io . StringReader ; import java . io . StringWriter ; import java . math . BigDecimal ; import org . junit . Before ; import org . junit . Test ; import com . asakusafw . runtime . value . BooleanOption ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DateUtil ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . DoubleOption ; import com . asakusafw . runtime . value . FloatOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . ShortOption ; import com . asakusafw . runtime . value . StringOption ; @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class TsvEmitterTest { private static final String LONG_STRING = ""<STR_LIT>"" ; private final StringWriter buffer = new StringWriter ( ) ; private TsvEmitter emitter ; @ Before public void setUp ( ) throws Exception { emitter = new TsvEmitter ( buffer ) ; } private RecordParser parser ( ) throws IOException { emitter . close ( ) ; return new TsvParser ( new StringReader ( buffer . toString ( ) ) ) ; } @ Test public void emitBoolean ( ) throws Exception { BooleanOption value = new BooleanOption ( ) ; value . modify ( true ) ; emitter . emit ( value ) ; value . modify ( false ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; value . modify ( false ) ; emitter . emit ( value ) ; value . modify ( true ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; value . setNull ( ) ; emitter . emit ( value ) ; value . modify ( true ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; emitter . close ( ) ; RecordParser parser = parser ( ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( false ) ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( false ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( true ) ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . isNull ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . isNull ( ) , is ( false ) ) ; } @ Test public void emitByte ( ) throws Exception { ByteOption value = new ByteOption ( ) ; value . modify ( ( byte ) <NUM_LIT:0> ) ; emitter . emit ( value ) ; value . modify ( ( byte ) <NUM_LIT:10> ) ; emitter . emit ( value ) ; value . modify ( ( byte ) - <NUM_LIT:10> ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; value . setNull ( ) ; emitter . emit ( value ) ; value . modify ( Byte . MAX_VALUE ) ; emitter . emit ( value ) ; value . modify ( Byte . MIN_VALUE ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; emitter . close ( ) ; RecordParser parser = parser ( ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( byte ) <NUM_LIT:0> ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( byte ) <NUM_LIT:10> ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( byte ) - <NUM_LIT:10> ) ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . isNull ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( Byte . MAX_VALUE ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( Byte . MIN_VALUE ) ) ; assertThat ( parser . next ( ) , is ( false ) ) ; } @ Test public void emitShort ( ) throws Exception { ShortOption value = new ShortOption ( ) ; value . modify ( ( short ) <NUM_LIT:0> ) ; emitter . emit ( value ) ; value . modify ( ( short ) <NUM_LIT:10> ) ; emitter . emit ( value ) ; value . modify ( ( short ) - <NUM_LIT:10> ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; value . setNull ( ) ; emitter . emit ( value ) ; value . modify ( Short . MAX_VALUE ) ; emitter . emit ( value ) ; value . modify ( Short . MIN_VALUE ) ; emitter . emit ( value ) ; emitter . endRecord ( ) ; emitter . close ( ) ; RecordParser parser = parser ( ) ; assertThat ( parser . next ( ) , is ( true ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( short ) <NUM_LIT:0> ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( short ) <NUM_LIT:10> ) ) ; parser . fill ( value ) ; assertThat ( value . get ( ) , is ( ( short ) - <NUM_LIT:10> ) ) ; assertThat'}]","(parser. next ( ), is ( true ) ) ; parser. fill ( value ) ; assertThat ( value. isNull ( ), is ( true ) ) ; parser. fill ( value ) ; assertThat ( value. get ( ), is ( Short. MAX_VALUE ) ) ; parser. fill ( value ) ; assertThat ( value. get ( ), is ( Short. MIN_VALUE ) ) ; } @Test public void emitInt ( ) throws Exception { IntOption value = new IntOption ( ) ; value. modify ( 0 ) ; emitter. emit ( value ) ; value. modify ( 10 ) ; emitter. emit ( value ) ; value. modify ( - 10 ) ; emitter. emit ( value ) ; emitter. endRecord ( ) ; value. setNull ( ) ; emitter. emit ( value ) ; value. modify ( Integer. MAX_VALUE ) ; emitter. emit ( value ) ; value. modify ( Integer. MIN_VALUE ) ; emitter. emit ( value ) ; emitter. endRecord ( ) ; emitter. close ( ) ; RecordParser parser = parser ( ) ; assertThat ( parser. next ( ), is ( true ) ) ; parser. fill ( value ) ; assertThat ( value. get ( ), is",0.00041298861775111647
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . debug . ui . rubyvms ; import java . text . MessageFormat ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . rubypeople . rdt . debug . ui . RdtDebugUiConstants ; import org . rubypeople . rdt . internal . debug . ui . RdtDebugUiPlugin ; public final class LibraryStandin { private IPath fSystemLibrary ; public LibraryStandin ( IPath path ) { fSystemLibrary = path ; } public IPath getSystemLibraryPath ( ) { return fSystemLibrary ; } public boolean equals ( Object obj ) { if ( obj instanceof LibraryStandin ) { LibraryStandin lib = ( LibraryStandin ) obj ; return getSystemLibraryPath ( ) . equals'}]","( lib. getSystemLibraryPath ( ) ) ; } public int hashCode ( ) { return getSystemLibraryPath ( ). hashCode ( ) ; } public String toString ( ) { return MessageFormat. format ( RdtDebugUiConstants. LibraryStandin_FORMAT, getSystemLibraryPath ( ) ) ; } }",9.618261733906386e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . parser . warnings ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . jruby . ast . CallNode ; import org . jruby . ast . ClassNode ; import org . jruby . ast . DefnNode ; import org . jruby . ast . FCallNode ; import org . jruby . ast . Node ; import org . jruby . ast . SelfNode ; import org . jruby . ast . SymbolNode ; import org . jruby . ast . VCallNode ; import org . jruby . runtime . Visibility ; import org . rubypeople . rdt . core . compiler . IProblem ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import org . rubypeople . rdt . internal . core . util . ASTUtil ; import com . aptana . rdt . AptanaRDTPlugin ; public class UnusedPrivateMethodVisitor extends RubyLintVisitor { private Map < String , Node > privateMethods = new HashMap < String , Node > ( ) ; private Set < String > usedMethods = new HashSet < String > ( ) ; private Visibility visibility ; public UnusedPrivateMethodVisitor ( String contents ) { super ( AptanaRDTPlugin . getDefault ( ) . getOptions ( ) , contents ) ; visibility = Visibility . PUBLIC ; } public Object visitFCallNode ( FCallNode iVisited ) { usedMethods . add ( iVisited . getName ( )'}]",". toString ( ) ) ; return super. visitFCallNode ( iVisited ) ; } public Object visitVCallNode ( VCallNode iVisited ) { usedMethods. add ( iVisited. getName ( ). toString ( ) ) ; return super. visitVCallNode ( iVisited ) ; } public Object visitDefnNode ( DefnNode iVisited ) { if ( iVisited. getVisibility ( ) == visibility ) { String methodName = ASTUtil. getMethodName ( iVisited ) ; privateMethods. put ( methodName, iVisited ) ; } return super. visitDefnNode ( iVisited ) ; } public Object visitCallNode ( CallNode iVisited ) { usedMethods. add ( iVisited. getName ( ). toString ( ) ) ; return super. visitCallNode ( iVisited ) ; } public Object visitClassNode ( ClassNode iVisited ) { visibility = iVisited. getVisibility ( ) ; return super. visitClassNode ( iVisited ) ; } public Object visitSelfNode ( SelfNode iVisited ) { usedMethods. add ( ""self"" ) ; return super. visitSelfNode ( iVisited ) ; } public Object visitSymbolNode ( SymbolNode iVisited ) { usedMethods. add ( iVisited",0.0003416377500036509
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . core . parser ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . jruby . ast . BlockNode ; import org . jruby . ast . CaseNode ; import org . jruby . ast . IfNode ; import org . jruby . ast . ListNode ; import org . jruby . ast . NewlineNode ; import org . jruby . ast . Node ; import org . jruby . ast . OpAsgnAndNode ; import org . jruby . ast . OpAsgnNode ; import org . jruby . ast . OpAsgnOrNode ; import org . jruby . ast . OpElementAsgnNode ; import org . jruby . ast . ReturnNode ; import org . jruby . ast . RootNode ; import org . jruby . ast . WhenNode ; import org . rubypeople . rdt . internal . core . parser . InOrderVisitor ; public class ReturnVisitor extends InOrderVisitor { private boolean implicit = false ; private Set < ReturnVisitor > branches = new HashSet < ReturnVisitor > ( ) ; private List < Node > values = new ArrayList < Node > ( ) ; private Node lastNode ; @ Override protected Object visitNode ( Node iVisited ) { if ( iVisited != null && ! structuralNode ( iVisited ) && ! branchingNode ( iVisited ) && ! ( iVisited instanceof ReturnNode ) ) { implicit = true ; lastNode = iVisited ; } return super . visitNode ( iVisited ) ; } @ Override public Object visitOpAsgnAndNode ( OpAsgnAndNode iVisited ) { handleNode ( iVisited ) ; acceptNode ( iVisited . getFirstNode ( ) ) ; return null ; } @ Override public Object visitOpAsgnNode ( OpAsgnNode iVisited ) { handleNode ( iVisited ) ; acceptNode ( iVisited . getReceiverNode ( ) ) ; return null ; } @ Override public Object visitOpAsgnOrNode ( OpAsgnOrNode iVisited ) { handleNode ( iVisited ) ; acceptNode ( iVisited . getFirstNode ( ) ) ; return null ; } private boolean structuralNode ( Node visited ) { return ( visited instanceof RootNode ) || ( visited instanceof NewlineNode ) ; } private boolean branchingNode ( Node visited ) { return ( visited instanceof IfNode ) || ( visited instanceof CaseNode ) ; } @ Override public Object visitReturnNode ( ReturnNode iVisited ) { implicit = false ; lastNode = null ; values . add ( iVisited ) ; return null ; } @ Override public Object visitCaseNode ( CaseNode iVisited ) { ListNode node = iVisited . getCases ( ) ; List < Node > caseChildren = node . childNodes ( ) ; WhenNode whenNode = ( WhenNode ) caseChildren . get ( <NUM_LIT:0> ) ; while ( whenNode != null ) { ReturnVisitor visitor = new ReturnVisitor ( ) ; whenNode . getBodyNode ( ) . accept ( visitor ) ; branches . add ( visitor ) ; Node nextCase = whenNode . getNextCase ( ) ; if ( nextCase instanceof BlockNode ) { ReturnVisitor visitor2 = new ReturnVisitor ( ) ; nextCase . accept ( visitor2 ) ; branches . add ( visitor ) ; whenNode = null ; break ; } if ( nextCase instanceof NewlineNode ) { NewlineNode newline = ( NewlineNode ) nextCase ; nextCase = newline . getNextNode ( ) ; }'}]",whenNode = ( WhenNode ) nextCase ; } return null; } @Override public Object visitBlockNode(BlockNode iVisited) { return null; } private void handleNode(OpAsgnAndNode iVisited) { if (iVisited.getConditionNode() instanceof ReturnNode) { ReturnVisitor visitor = new ReturnVisitor(); iVisited.getConditionNode().accept(visitor); branches.add(visitor); } } private void handleNode(OpAsgnOrNode iVisited) { if (iVisited.getConditionNode() instanceof ReturnNode) { ReturnVisitor visitor = new ReturnVisitor(); iVisited.getConditionNode().accept(visitor); branches.add(visitor); } } private void acceptNode(Node node) { if (node instanceof ReturnNode) { ReturnVisitor visitor = new ReturnVisitor(); node.accept(visitor); branches.add(visitor); } } },0.000255395350142951
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator . io ; import java . io . IOException ; import com . asakusafw . compiler . operator . model . MockKeyValue1 ; import com . asakusafw . runtime . io . ModelInput ; import com . asakusafw . runtime . io . RecordParser ; public final class MockKeyValue1Input implements ModelInput < MockKeyValue1 > { private final RecordParser parser ; public MockKeyValue1Input ( RecordParser parser ) { if ( parser == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . parser = parser ; } @ Override public boolean readTo ( MockKeyValue1 model ) throws IOException { if ( parser . next ( ) == false ) {'}]",return false; } model. setKey ( parser. readString() ); model. setValue( parser.readString() ); return true; } @Override public void close() throws IOException { // No-op } },6.961000575716609e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . components ; import java . io . File ; import junit . framework . TestCase ; import org . apache . log4j . Logger ; import org . oddjob . Helper ; import org . oddjob . OddjobDescriptorFactory ; import org . oddjob . OurDirs ; import org . oddjob . arooa . ArooaDescriptor ; import org . oddjob . arooa . ArooaParseException ; import org . oddjob . arooa . ArooaType ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob .'}]","designer. DesignComponentTestCase; public class FileComponentTestCase extends DesignComponentTestCase { private static final Logger LOG = Helper.getLogger(FileComponentTestCase.class); public void testFile() throws ArooaParseException { File file = new File(""test.xml""); DesignInstance design = OddjobDescriptorFactory.loadDesign(file); } }",9.471956547414381e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . windgate ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . net . URLClassLoader ; import java . text . MessageFormat ; import java . util . Properties ; import org . junit . rules . ExternalResource ; import org . junit . rules . TemporaryFolder ; public class ProfileContext extends ExternalResource { private final TemporaryFolder folder = new TemporaryFolder ( ) ; private ClassLoader context ; @ Override protected void before ( ) throws Throwable { folder . create ( ) ; ClassLoader classLoader = new URLClassLoader ( new URL [ ] { folder . getRoot ( ) . toURI ( ) . toURL ( ) , } , getClass ( ) . getClassLoader ( ) ) ; context = Thread . currentThread ( ) . getContextClassLoader ( ) ; boolean green = false ; try { Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; green = true ; } finally { if ( green == false ) { after ( ) ; } } } @ Override protected void after ( ) { try { Thread . currentThread ( ) . setContextClassLoader ( context ) ; System . gc ( ) ; } finally { folder . delete ( ) ; } } public Properties getTemplate ( ) { Properties p = new Properties ( ) ; InputStream in = ProfileContext . class . getResourceAsStream ( ""<STR_LIT>"" ) ; assertThat'}]","in!= null, is(true); p.load(in); in.close(); return p; } }",4.511335882799723e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . ui . editor . actions ; import java . util . List ; import java . util . Set ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . SVDBClassDecl ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . SVDBItemBase ; import net . sf . sveditor . core . db . SVDBModIfcDecl ; import net . sf . sveditor . core . db . SVDBTask ; import net . sf . sveditor . core . db . index . ISVDBIndexIterator ; import net . sf . sveditor . core . srcgen . OverrideMethodsFinder ; import net . sf . sveditor . ui . svcp . SVDBDecoratingLabelProvider ; import net . sf . sveditor . ui . svcp . SVTreeLabelProvider ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . dialogs . CheckedTreeSelectionDialog ; public class OverrideMethodsDialog extends CheckedTreeSelectionDialog { private SVDBClassDecl fLeafClass ; private CheckboxTreeViewer fCheckboxTree ; public OverrideMethodsDialog ( Shell parent , SVDBClassDecl leaf_class , ISVDBIndexIterator index_it ) { super ( parent , new SVDBDecoratingLabelProvider ( new SVTreeLabelProvider ( ) ) , new OverrideMethodsContentProvider ( leaf_class , index_it ) ) ; fLeafClass = leaf_class ; setInput ( fLeafClass ) ; updateOKStatus ( ) ; } @ Override protected CheckboxTreeViewer createTreeViewer ( Composite parent ) { fCheckboxTree = super . createTreeViewer ( parent ) ; fCheckboxTree . addCheckStateListener ( new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { Object elem = event . getElement ( ) ; if ( elem instanceof SVDBClassDecl ) { ITreeContentProvider cp = ( ITreeContentProvider ) fCheckboxTree . getContentProvider ( ) ; boolean any_checked = false ; for ( Object c : cp . getChildren ( event . getElement ( ) ) ) { if ( fCheckboxTree . getChecked ( c ) ) { any_checked = true ; break ; } } if ( any_checked ) { for ( Object c : cp . getChildren ( event . getElement ( ) ) ) { fCheckboxTree . setChecked ( c , false ) ; } fCheckboxTree . setChecked ( event . getElement ( ) , false ) ; } else { for ( Object c : cp . getChildren ( event . getElement ( ) ) ) { fCheckboxTree . setChecked ( c , true ) ; } fCheckboxTree . setChecked ( event . getElement ( ) , true ) ; } } else { ITreeContentProvider cp = ( ITreeContentProvider ) fCheckboxTree . getContentProvider ( ) ; Object parent_o = cp . getParent ( elem ) ; if ( parent_o != null && parent_o instanceof SVDBClassDecl ) { } } } } ) ; fCheckboxTree . setSorter ( new OverrideMethodsSorter ( ) ) ; return fCheckboxTree ; } private static class OverrideMethodsContentProvider implements ITreeContentProvider { private Object fEmptyList [ ] = new Object [ <NUM_LIT:0> ] ; OverrideMethodsFinder fMethodsFinder ; private SVDBClassDecl fLeafClass ; public OverrideMethodsContentProvider ( SVDBClassDecl leaf_class , ISVDBIndexIterator index_it ) { fLeafClass = leaf_class ; fMethodsFinder = new OverrideMethodsFinder ( leaf_class , index_it ) ; } public Object [ ] getElements ( Object inputElement ) {'}]","List<SVDBItem> elements = fMethodsFinder.getElements(); if (elements!= null) { return elements.toArray(fEmptyList); } else { return fEmptyList; } } public Object getParent ( Object element ) { return fLeafClass ; } public boolean hasChildren ( Object element ) { return fMethodsFinder.hasChildren(element); } public Object [ ] getChildren ( Object parent ) { return fMethodsFinder.getChildren(parent); } } private class OverrideMethodsSorter extends ViewerSorter { @Override public int compare ( Object a, Object b ) { if ( a instanceof SVDBItemBase && b instanceof SVDBItemBase ) { SVDBItemBase ia = ( SVDBItemBase ) a ; SVDBItemBase ib = ( SVDBItemBase ) b ; int result = ia. getName ( ). compareTo ( ib. getName ( ) ) ; if ( result!= 0 ) { return result ; } else { result = ia. getModifiers ( ). compareTo ( ib. getModifiers ( ) ) ; return result ; } } else { return 0 ; } } }",0.00034016008499286604
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db ; public class SVDBTypeInfoClassItem extends SVDBTypeInfo { public SVDBParamValueAssignList fParamAssign ; public SVDBTypeInfoClassItem ( ) { this ( ""<STR_LIT>"" ) ; } public SVDBTypeInfoClassItem ( String name ) { super ( name , SVDBItemType . TypeInfoClassItem ) ; } public SVDBTypeInfoClassItem ( String name , SVDBItemType type ) { super ( name , type ) ; } public boolean hasParameters ( ) { return ( fParamAssign != null && fParamAssign . getParameters ( ) . size ( ) > <NUM_LIT:0> ) ; } public void setParamAssignList ( SVDBParamValueAssignList assign ) { fParamAssign = assign ; } public SVDBParamValueAssignList'}]",getParamAssignList ( ) { return fParamAssign ; },3.193093587921292e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index ; import java . util . Map ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCache ; import net . sf . sveditor . core . log . LogFactory ; import org . eclipse . core . runtime . IProgressMonitor ;'}]",import org.eclipse.core.runtime.IStatus;,2.667308307467309e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . rule ; import java . text . MessageFormat ; public class FloatRange implements ValuePredicate < Number > { private final double lowerBound ; private final double upperBound ; public FloatRange ( double lowerBound , double upperBound ) { this . lowerBound = lowerBound ; this . upperBound = upperBound ; } @ Override public boolean accepts ( Number expected , Number actual ) { if ( expected == null || actual == null ) { throw new'}]","IllegalArgumentException ( MessageFormat. format ( ""expected=%s, actual=%s"", expected, actual ) ) ; if ( expected instanceof Number && actual instanceof Number ) { Number expectedNumber = ( Number ) expected ; Number actualNumber = ( Number ) actual ; return expectedNumber. doubleValue () >= lowerBound && expectedNumber. doubleValue () <= upperBound && actualNumber. doubleValue () >= lowerBound && actualNumber. doubleValue () <= upperBound ; } else { return false ; } } }",0.0001467672167091596
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package handson . springbatch ; import static org . junit . Assert . assertEquals ; import org . junit . Assert ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . batch . core . BatchStatus ; import org . springframework . batch . core . JobExecution ; import org . springframework . batch . core . JobParameter ; import org . springframework . batch . core . JobParameters ; import org . springframework . batch . core . JobParametersBuilder ; import org . springframework . batch . core . StepExecution ; import org . springframework . batch . test . JobLauncherTestUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . core . JdbcTemplate ; import org . springframework . test . annotation . DirtiesContext ; import org . springframework . test . annotation . DirtiesContext . ClassMode ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration @ DirtiesContext ( classMode = ClassMode . AFTER_EACH_TEST_METHOD ) public class EmployeeStep1Test { @ Autowired private JobLauncherTestUtils jobLauncherTestUtils ;'}]","private StepExecution stepExecution; @Test public void test() throws Exception { JobParameters jobParameters = new JobParametersBuilder(). addString(""employeeName"", ""John Doe""). toJobParameters(); JobExecution execution = jobLauncherTestUtils.launchJob(jobParameters); assertEquals(BatchStatus.COMPLETED, execution.getStatus()); JdbcTemplate jdbcTemplate = new JdbcTemplate(execution.getStepContext().getStep().getJobRepository().getJobExecution(execution.getId()).getExecutionContext().getExecutionContext().getDataSource()); }",0.00015376286619812654
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . ggtools . grand . ui . actions ; import net . ggtools . grand . ui . widgets . AboutDialog ; import net . ggtools . grand . ui . widgets . GraphWindow ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . eclipse . jface . action . Action ; public class AboutAction extends Action { private static final Log log = LogFactory . getLog ( AboutAction .'}]","class ); public AboutAction ( ) { super ( ""About"" ); } @Override public void run ( ) { AboutDialog dialog = new AboutDialog ( GraphWindow.getActiveWindow ( ) ); dialog. open ( ); } }",7.194319097486456e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . ui . text . ruby ; import org . eclipse . jface . text . Assert ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . ITextViewer ; import org . rubypeople . rdt . core . RubyConventions ; public class ContentAssistInvocationContext { private final ITextViewer fViewer ; private final IDocument fDocument ; private final int fOffset ; private CharSequence fPrefix ; private String fStatementPrefix ; public ContentAssistInvocationContext ( ITextViewer viewer ) { this ( viewer , viewer . getSelectedRange ( ) . x ) ; } public ContentAssistInvocationContext ( ITextViewer viewer , int offset ) { Assert . isNotNull ( viewer ) ; fViewer = viewer ; fDocument = null ; fOffset = offset ; } protected ContentAssistInvocationContext ( ) { fDocument = null ; fViewer = null ; fOffset = - <NUM_LIT:1> ; } public ContentAssistInvocationContext ( IDocument document , int offset ) { Assert . isNotNull ( document ) ; Assert . isTrue ( offset >= <NUM_LIT:0> ) ; fViewer = null ; fDocument = document ; fOffset = offset ; } public final int getInvocationOffset ( ) { return fOffset ; } public final ITextViewer getViewer ( ) { return fViewer ; } public IDocument getDocument ( ) { if ( fDocument == null ) { if ( fViewer == null ) return null ; return fViewer . getDocument ( ) ; } return fDocument ; } public CharSequence computeIdentifierPrefix ( ) throws BadLocationException { if ( fPrefix == null ) { IDocument document = getDocument ( ) ; if ( document =='}]","null) { fPrefix = RubyConventions.EMPTY_CHAR_SEQUENCE; } else { int offset = getInvocationOffset(); fPrefix = document.getCharSequence(offset, document.getLength() - offset); } return fPrefix; } public String computeStatementPrefix() throws BadLocationException { if (fStatementPrefix == null) { IDocument document = getDocument(); if (document == null) { fStatementPrefix = RubyConventions.EMPTY_STRING; } else { int offset = getInvocationOffset(); int line = document.getLineOfOffset(offset); if (line!= -1) { int start = document.getLineOffset(line); int end = document.getLineOffset(line + 1); fStatementPrefix = document.getChars(start, end - start, new char[end - start], 0); } } } return fStatementPrefix; }",0.00023976956392128903
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . search ; import net . sf . sveditor .'}]",core.db.DatabaseConnection; import java.util.List; public class SearchEngine { private DatabaseConnection dbConnection; public SearchEngine(DatabaseConnection dbConnection) { this.dbConnection = dbConnection; } public List<String> search(String query) { // implementation } },7.686299173774063e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . state ; import org . oddjob . images . IconHelper ; import org . oddjob . persist'}]",".Persistable; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.oddjob.state.State; import org.oddjob.state.StateHelper; import org.oddjob.state.StateProvider; public class StateProviderImpl implements StateProvider { private static final Logger LOGGER = LoggerFactory.getLogger(StateProviderImpl.class); private final State state; public StateProviderImpl(State state) { this.state = state; } @Override public IconHelper getIcon() { return StateHelper.getIcon(state); } @Override public State getState() { return state; } @Override public String toString() { return ""StateProviderImpl [state="" + state + ""]""; } }",0.00017973288808506048
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . pogofish . jadt . samples . ast . data ; import java . util . List ; public abstract class Type { private Type ( ) { } private static final Type _Int = new Int ( ) ; public static final Type _Int ( ) { return _Int ; } private static final Type _Long = new Long ( ) ; public static final Type _Long ( ) { return _Long ; } public static interface MatchBlock < ResultType > { ResultType _case ( Int x ) ; ResultType _case ( Long x ) ; } public static abstract class MatchBlockWithDefault < ResultType > implements MatchBlock < ResultType > { @ Override public ResultType _case ( Int x ) { return _default ( x ) ; } @ Override public ResultType _case ( Long x ) { return _default'}]",( x ) ; protected abstract ResultType _default ( Int x ) ; protected abstract ResultType _default ( Long x ) ; public static class Int extends Type { } public static class Long extends Type { } },7.184976391477285e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testdriver . core ; import java . io . IOException ; import com . asakusafw . runtime . io . ModelOutput ; import com . asakusafw . vocabulary . external . ExporterDescription ; public abstract class AbstractExporterRetriever < T extends ExporterDescription > extends BaseExporterRetriever < T > { public abstract void truncate ( T description ) throws IOException ; @ Override public void truncate ( T description , TestContext context ) throws IOException { truncate ( description ) ; } public abstract < V > ModelOutput < V > createOutput ( DataModelDefinition < V > definition , T description ) throws IOException ; @ Override public < V > ModelOutput < V > createOutput ( DataModelDefinition < V > definition , T description , TestContext context ) throws IOException { return createOutput ( definition , description'}]",) ; } },2.3568486934889083e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . parser ; import net . sf . sveditor . core . db . SVDBLocation ; public class SVToken { protected String fImage ; protected boolean fIsString ; protected boolean fIsOperator ; protected boolean fIsNumber ; protected boolean fIsTime ; protected boolean fIsIdentifier ; protected boolean fIsKeyword ; protected SVDBLocation fStartLocation ; public SVToken duplicate ( ) { SVToken ret = new SVToken ( ) ; ret . fImage = fImage ;'}]",ret.fIsString = fIsString; ret.fIsOperator = fIsOperator; ret.fIsNumber = fIsNumber; ret.fIsTime = fIsTime; ret.fIsIdentifier = fIsIdentifier; ret.fIsKeyword = fIsKeyword; ret.fStartLocation = fStartLocation; return ret; },0.00010716443609319102
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . dmdl . directio . sequencefile . driver ; import java . util . Map ; import com . asakusafw . dmdl . directio . sequencefile . driver . SequenceFileFormatTrait . Configuration ; import com . asakusafw . dmdl . model . AstAttribute ; import com . asakusafw . dmdl . model . AstAttributeElement ; import com . asakusafw . dmdl . semantics . DmdlSemantics ; import com . asakusafw . dmdl . semantics . ModelDeclaration ; import com . asakusafw . dmdl . spi . ModelAttributeDriver ; import com . asakusafw . dmdl . util . AttributeUtil ; public class SequenceFileFormatDriver extends ModelAttributeDriver { public static final String TARGET_NAME = ""<STR_LIT>"" ; @ Override public String'}]",getName() { return TARGET_NAME; },2.888933899875592e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . ui . wizards . buildpaths . newsourcepage ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . IWorkbenchSite ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . part . ISetSelectionTarget ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyProject ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . ISourceFolder ; import org . rubypeople . rdt . core . ISourceFolderRoot ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . corext . buildpath . LoadpathModifier ; import org . rubypeople . rdt . internal . ui . RubyPlugin ; import org . rubypeople . rdt . internal . ui . RubyPluginImages ; import org . rubypeople . rdt . internal . ui . wizards . NewWizardMessages ; import org . rubypeople . rdt . internal . ui . wizards . buildpaths . CPListElement ; public class ExcludeFromBuildpathAction extends Action implements ISelectionChangedListener { private final IWorkbenchSite fSite ; private final List fSelectedElements ; public ExcludeFromBuildpathAction ( IWorkbenchSite site ) { super ( NewWizardMessages . NewSourceContainerWorkbookPage_ToolBar_Exclude_label , RubyPluginImages . DESC_ELCL_EXCLUDE_FROM_BUILDPATH ) ; setToolTipText ( NewWizardMessages . NewSourceContainerWorkbookPage_ToolBar_Exclude_tooltip ) ; setDisabledImageDescriptor ( RubyPluginImages . DESC_DLCL_EXCLUDE_FROM_BUILDPATH ) ; fSite = site ; fSelectedElements = new ArrayList ( ) ; } public void run ( ) { final IRubyProject project ; Object object = fSelectedElements . get ( <NUM_LIT:0> ) ; if ( object instanceof IRubyScript ) { project = ( ( IRubyScript ) object ) . getRubyProject ( ) ; } else { project ='}]","( ( IStructuredSelection ) fSite. getWorkbenchPage ( ). getActivePage ( ). getActivePart ( ). getSite ( ). getSelection ( ) ). getFirstElement ( ). getRubyProject ( ) ; } if ( project!= null ) { LoadpathModifier. excludeFromBuildpath ( project, fSelectedElements ) ; } } public void selectionChanged ( SelectionChangedEvent event ) { IStructuredSelection selection = event. getStructuredSelection ( ) ; if ( selection!= null &&! selection. isEmpty ( ) ) { fSelectedElements. clear ( ) ; fSelectedElements. addAll ( selection ) ; setEnabled ( true ) ; } else { setEnabled ( false ) ; } } }",0.0002296655477603998
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . index ; import net . sf . sveditor . core . db . index . cache . ISVDBIndexCache ; public class SVDBLibPathIndexFactory implements ISVDBIndexFactory { public static final String TYPE = ""<STR_LIT>"" ;'}]",private ISVDBIndexCache cache;,2.6855670802934337e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . db . stmt ; import java . util . List ; import net . sf . sveditor . core . db . ISVDBChildItem ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . ISVDBNamedItem ; import net . sf . sveditor . core . db . SVDBItemType ; import net . sf . sveditor . core . db . expr . SVDBExpr ; public class SVDBVarDeclItem extends SVDBStmt implements ISVDBNamedItem { public String fName ; public int fAttr ; public int fVarAttr ; public List < SVDBVarDimItem > fArrayDim ; public SVDBExpr fInitExpr ; public SVDBVarDeclItem ( ) { super ( SVDBItemType . VarDeclItem ) ; } public SVDBVarDeclItem ( String name ) { super ( SVDBItemType . VarDeclItem ) ; fName = name ; } public void setName ( String name ) { fName = name ; } public String getName ( ) { return fName ; } public void setInitExpr ( SVDBExpr expr ) { fInitExpr = expr ; } public SVDBExpr getInitExpr ( ) { return fInitExpr ; } public int getAttr ( ) { return fAttr ; } public void setAttr ( int attr ) { fAttr |= attr ; } public void resetAttr ( int attr ) { fAttr = attr ; } public List < SVDBVarDimItem > getArrayDim ( ) { return fArrayDim ; } public void setArrayDim ( List <'}]",> fArrayDim ) { fArrayDim = fArrayDim ; } public void addArrayDim ( SVDBVarDimItem dim ) { if ( fArrayDim == null ) { fArrayDim = new ArrayList <> ( ) ; } fArrayDim. add ( dim ) ; } },9.411603610896435e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . yaess . flowlog ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Writer ; import java . nio . charset . Charset ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . util . Date ; import java . util . ResourceBundle ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . yaess . core . ExecutionContext ; import com . asakusafw . yaess . core . ExecutionPhase ; import com . asakusafw . yaess . core . PhaseMonitor ; import com . asakusafw . yaess . core . YaessLogger ; public class FlowLogger extends PhaseMonitor { static final YaessLogger YSLOG = new YaessFlowLogLogger ( FlowLogger . class ) ; static final Logger LOG = LoggerFactory . getLogger ( FlowLogger . class ) ; private static final ResourceBundle BUNDLE = ResourceBundle . getBundle ( ""<STR_LIT>"" ) ; private static final double MIN_STEP_UNIT = <NUM_LIT> ; private static final double DELTA_STEP_UNIT = <NUM_LIT> ; private final ExecutionContext context ; private final String label ; private final double stepUnit ; private double totalTaskSize ; private double workedTaskSize ; private int workedStep = <NUM_LIT:0> ; private boolean opened ; private boolean closed ; private final File file ; private final File escapeFile ; private PrintWriter writer ; private final boolean reportJob ; private final boolean deleteOnCleanup ; private JobStatus worstStatus ; private Throwable occurredException ; private final DateFormat dateFormat ; private final Charset encoding ; private final boolean deleteOnSetup ; public FlowLogger ( ExecutionContext context , FlowLoggerProfile profile ) { if ( context == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . context = context ; this . label = MessageFormat . format ( ""<STR_LIT>"" , context . getBatchId ( ) , context . getFlowId ( ) , context . getExecutionId ( ) , context . getPhase ( ) ) ; if ( profile . getStepUnit ( ) <= <NUM_LIT:0> ) { this . stepUnit = Double . MAX_VALUE ; } else { this . stepUnit = Math . max ( profile . getStepUnit ( ) , MIN_STEP_UNIT ) - DELTA_STEP_UNIT ; } this . file = profile . getLogFile ( context ) ; this . escapeFile = profile . getEscapeFile ( context ) ; this . encoding = profile . getEncoding ( ) ; this . dateFormat = profile . getDateFormat ( ) ; this . reportJob = profile . isReportJob ( ) ; this . deleteOnSetup = profile . isDeleteOnSetup ( ) ; this . deleteOnCleanup = profile . isDeleteOnCleanup ( ) ; this . worstStatus = JobStatus . SUCCESS ; this . occurredException = null ; } @ Override public synchronized void open ( double taskSize ) throws IOException { if ( opened ) { throw new IllegalStateException ( MessageFormat . format ( ""<STR_LIT>"" , label ) ) ; } opened = true ; prepareParentDirectory ( file ) ; boolean keepLogs = deleteOnSetup == false || context . getPhase ( ) != ExecutionPhase . SETUP ; if ( keepLogs == false ) { cleanEscapedLog ( ) ; } OutputStream output = new FileOutputStream ( file , keepLogs ) ; boolean succeed = false ; try { Writer w = new OutputStreamWriter ( output , encoding ) ; this . writer = new PrintWriter ( new BufferedWriter ( w ) ) ; succeed = true ; } finally { if ( succeed == false ) { output . close ( ) ; } } this . totalTaskSize = taskSize ; record ( Level . INFO , Target . PHASE , Trigger . START ) ; } @ Override public synchronized void progressed ( double deltaSize ) { set ( workedTaskSize + deltaSize ) ; } @ Override public synchronized void setProgress ( double workedSize ) { set ( workedSize ) ; } @ Override protected void onJobMonitorOpened ( String jobId ) { if ( jobId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } record ( Level . INFO , Target . JOB , Trigger . START , jobId ) ; } @ Override protected void onJobMonitorClosed ( String jobId ) { return ; } @ Override public void reportJobStatus ( String jobId , JobStatus status , Throwable cause ) throws IOException { if ( jobId == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } if ( status == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } record ( cause , toLevel ( status ) , Target . JOB , Trigger . FINISH , jobId , status ) ; if ( status . compareTo ( worstStatus ) > <NUM_LIT:0> ) { worstStatus = status ; } if ( cause != null && occurredException == null ) { occurredException = cause ; } } @ Override public synchronized void close ( ) throws IOException { if ( closed ) { if ( writer != null ) { writer . close ( ) ; writer = null ; } return ; } closed = true ; set ( totalTaskSize ) ; record ( occurredException , toLevel ( worstStatus ) , Target . PHASE , Trigger . FINISH , worstStatus ) ; if ( writer != null ) { writer . close ( ) ; writer = null ; } if ( context . getPhase ( ) == ExecutionPhase . CLEANUP && worstStatus == JobStatus . SUCCESS ) { if ( deleteOnCleanup ) { cleanCurrentLog ( ) ; } else { cleanEscapedLog ( ) ; escapeCurrentLog ( ) ; } } } private void prepareParentDirectory ( File f ) { assert f != null ; File parent = f . getParentFile ( ) ; if ( parent . mkdirs ( ) == false ) { if ( parent . isDirectory ( ) == false ) { YSLOG . warn ( ""<STR_LIT>"" , label , parent . getAbsolutePath ( ) ) ; } } } private void cleanCurrentLog ( ) { if ( file . exists ( ) ) { YSLOG . info ( ""<STR_LIT>"" , label , file . getAbsolutePath ( ) ) ; if ( file'}]",".delete()) { YSLOG.info(""<STR_LIT>"", label, file.getAbsolutePath()); } } private void cleanEscapedLog() { if (escapeFile.exists()) { YSLOG.info(""<STR_LIT>"", label, escapeFile.getAbsolutePath()); if (escapeFile.delete()) { YSLOG.info(""<STR_LIT>"", label, escapeFile.getAbsolutePath()); } } } private void escapeCurrentLog() { if (file.exists()) { if (file.renameTo(escapeFile)) { YSLOG.info(""<STR_LIT>"", label, escapeFile.getAbsolutePath()); } } } private void record(Throwable cause, Level level, Target target, Trigger trigger, Object... args) { if (cause!= null) { LOG.error(cause.getMessage(), cause); } LOG.log(level, MessageFormat.format(""<STR_LIT>"", args)); } private Level toLevel(JobStatus status) { switch (status) { case SUCCESS: return Level.INFO; case WARNING: return Level.WARN; case ERROR: return Level.ERROR; default: return Level.INFO; } }",0.00034495482453957514
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IResource ; import org . rubypeople . rdt . core . RubyModelException ; public class SourceFolderInfo extends OpenableElementInfo {'}]",private IContainer sourceFolder;,2.455982426586944e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . vocabulary . operator ; import java . lang . annotation . Documented ; import java . lang .'}]",annotation. Retention ; import java. lang. annotation. Target ; import java. lang. annotation. ElementType ; @Documented @Retention ( RetentionPolicy. RUNTIME ) @Target ( ElementType. METHOD ) public @interface VocabularyOperator { },7.370494173053929e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . io ; import java . io . IOException ; import javax . annotation . Generated ; import test . modelgen . table . model . ImportRecordLock ; import com . asakusafw . runtime . io . ModelInput ;'}]",public class ImportRecordLockInput extends ModelInput<ImportRecordLock> { @Generated public static ImportRecordLockInput of(Class<? extends ImportRecordLock> modelClass) throws IOException { return new ImportRecordLockInput(modelClass); } public ImportRecordLockInput(Class<? extends ImportRecordLock> modelClass) throws IOException { super(modelClass); } },0.00010389742444811614
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . flow . join . operator ; import java . lang . annotation . Documented ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation'}]",".target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.TYPE}) public @interface JoinOperator {};",4.5210176243649634e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . jobs . structural ; import org . oddjob . Stoppable ; import org . oddjob . Structural ; import org . oddjob . arooa . deploy . annotations . ArooaComponent ; import org . oddjob . framework . StructuralJob ; import org . oddjob . framework . Transient ; import org . oddjob . state . SequentialHelper ; import org . oddjob . state . ServiceManagerStateOp ; import org . oddjob . state . StateOperator ; public class ServiceManager extends StructuralJob < Object > implements Structural , Stoppable , Transient { private static final long serialVersionUID = <NUM_LIT> ; @ Override protected StateOperator getStateOp'}]",() { return new ServiceManagerStateOp(); } @Override public void stop() throws Exception { ServiceManagerStateOp op = new ServiceManagerStateOp(); op.setSequential(SequentialHelper.isSequential(this)); op.execute(); } @ArooaComponent @Transient public SequentialHelper getSequentialHelper() { return SequentialHelper.isSequential(this)? new SequentialHelper(this) : null; },0.00011410586190210376
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . bioclipse . opentox . qsar ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { public static final String PLUGIN_ID = ""<STR_LIT>"" ; private static Activator plugin ; public Activator ( ) { } public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; } public void stop ( BundleContext context'}]",) throws Exception { super. stop ( context ) ; plugin = null ; } public static Activator getDefault ( ) { return plugin ; } },6.0556988301127135e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package net . sf . sveditor . core . tests . index . persistence ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . PrintStream ; import junit . framework . TestCase ; import net . sf . sveditor . core . SVCorePlugin ; import net . sf . sveditor . core . db . ISVDBItemBase ; import net . sf . sveditor . core . db . SVDBItem ; import net . sf . sveditor . core . db . index . ISVDBIndex ; import net . sf . sveditor . core . db . index . ISVDBItemIterator ; import net . sf . sveditor . core . db . index . SVDBIndexRegistry ; import net . sf . sveditor . core . db . index . SVDBLibPathIndexFactory ; import net . sf . sveditor . core . log . LogFactory ; import net . sf . sveditor . core . log . LogHandle ; import net . sf . sveditor . core . tests . SVCoreTestsPlugin ; import net . sf . sveditor . core . tests . TestIndexCacheFactory ; import net . sf . sveditor . core . tests . utils . BundleUtils ; import net . sf . sveditor . core . tests . utils . TestUtils ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Path ; public class TestWorkspaceLibPersistence extends TestCase { private File fTmpDir ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; fTmpDir = TestUtils . createTempDir ( ) ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; SVDBIndexRegistry rgy = SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) ; rgy . save_state ( ) ; if ( fTmpDir != null ) { TestUtils . delete ( fTmpDir ) ; fTmpDir = null ; } } public void testTimestampChangeDetected ( ) { LogHandle log = LogFactory . getLogHandle ( ""<STR_LIT>"" ) ; BundleUtils utils = new BundleUtils ( SVCoreTestsPlugin . getDefault ( ) . getBundle ( ) ) ; SVCorePlugin . getDefault ( ) . enableDebug ( false ) ; IProject project_dir = TestUtils . createProject ( ""<STR_LIT>"" ) ; utils . copyBundleDirToWS ( ""<STR_LIT>"" , project_dir ) ; File db = new File ( fTmpDir , ""<STR_LIT>"" ) ; if ( db . exists ( ) ) { db . delete ( ) ; } SVDBIndexRegistry rgy = SVCorePlugin . getDefault ( ) . getSVDBIndexRegistry ( ) ; rgy . init ( TestIndexCacheFactory . instance ( fTmpDir ) ) ; ISVDBIndex index = rgy . findCreateIndex ( new NullProgressMonitor ( ) , ""<STR_LIT>"" , ""<STR_LIT>"" , SVDBLibPathIndexFactory . TYPE , null ) ; ISVDBItemIterator it = index . getItemIterator ( new NullProgressMonitor ( ) ) ; ISVDBItemBase target_it = null ; while ( it . hasNext ( ) ) { ISVDBItemBase tmp_it = it . nextItem ( ) ; log . debug ( ""<STR_LIT>"" + SVDBItem . getName ( tmp_it ) ) ; if ( SVDBItem . getName ( tmp_it ) . equals ( ""<STR_LIT>"" ) ) { target_it = tmp_it ; break ; } } assertNotNull ( ""<STR_LIT>"" , target_it ) ; assertEquals ( ""<STR_LIT>"" , SVDBItem . getName ( target_it ) ) ; rgy . save_state ( ) ; rgy . init ( TestIndexCacheFactory . instance ( fTmpDir ) ) ; try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } ByteArrayOutputStream out = utils . readBundleFile ( ""<STR_LIT>"" ) ; PrintStream ps = new PrintStream ( out ) ; ps . println ( ""<STR_LIT>"" ) ; ps . println'}]","( System. currentTimeMillis ( ) + <NUM_LIT> ) ; ps. close ( ) ; rgy = SVCorePlugin. getDefault ( ). getSVDBIndexRegistry ( ) ; rgy. load_state ( ) ; it = rgy. findIndex ( new NullProgressMonitor ( ), ""<STR_LIT>"", ""<STR_LIT>"", SVDBLibPathIndexFactory. TYPE ). getItemIterator ( new NullProgressMonitor ( ) ) ; target_it = null ; while ( it. hasNext ( ) ) { tmp_it = it. nextItem ( ) ; log. debug ( ""<STR_LIT>"" + SVDBItem. getName ( tmp_it ) ) ; if ( SVDBItem. getName ( tmp_it ). equals ( ""<STR_LIT>"" ) ) { target_it = tmp_it ; break ; } } assertNotNull ( ""<STR_LIT>"", target_it ) ; assertEquals ( ""<STR_LIT>"", SVDBItem. getName ( target_it ) ) ; assertEquals ( ""<STR_LIT>"", target_it. getTimestamp ( ) ) ; }",0.00033515558395978175
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . refactoring . core . extractconstant ; import org . jruby . ast . ArrayNode ; import org . jruby . ast . BignumNode ; import org . jruby . ast . FalseNode ; import org . jruby . ast . FixnumNode ; import org . jruby . ast . HashNode ; import org . jruby . ast . NilNode ; import org . jruby . ast . StrNode ; import org . jruby . ast . TrueNode ; import org . jruby . ast . ZArrayNode ; import org . rubypeople . rdt . refactoring . core . IRefactoringConfig ; import org . rubypeople . rdt . refactoring . core . NodeProvider ; import org . rubypeople . rdt . refactoring . core . RefactoringConditionChecker ; public class ExtractConstantConditionChecker extends RefactoringConditionChecker { private ExtractConstantConfig config ; public ExtractConstantConditionChecker ( IRefactoringConfig config2 ) { super ( config2 ) ; } protected void checkInitialConditions ( ) { if ( ! existSelectedNodes ( ) ) { addError ( ""<STR_LIT>"" ) ; } else if ( ! isPrimitive ( ) ) { addError ( ""<STR_LIT>"" ) ; } } private boolean isPrimitive ( ) { return ( config . getSelectedNodes ( ) instanceof ZArrayNode ) || ( config . getSelectedNodes ( ) instanceof ArrayNode ) || ( config . getSelectedNodes ( ) instanceof HashNode ) || ( config . getSelectedNodes ( ) instanceof FixnumNode ) || ( config . getSelectedNodes ( ) instanceof BignumNode ) || ( config . getSelectedNodes ( ) instanceof NilNode ) || ( config . getSelectedNodes ( ) instanceof TrueNode ) || ( config . getSelectedNodes ( ) instanceof FalseNode ) || ( config .'}]",config.getSelectedNodes() instanceof StrNode); },3.395527989610896e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . tests . all ; import junit . framework . Test ; import junit . framework . TestSuite ; import org . rubypeople . rdt . TS_RdtCore ; import org . rubypeople . rdt . debug . ui . tests . TS_DebugUi ; import org . rubypeople . rdt . internal . launching . TS_InternalLaunching ; import org . rubypeople . rdt . internal . ui . TS_InternalUi ; import org . rubypeople . rdt . refactoring . tests . TS_All ; import com . aptana . rdt . TS_Aptana ; public'}]",class AllTests extends TestSuite { public AllTests() { addTest(new TS_DebugUi()); addTest(new TS_InternalLaunching()); addTest(new TS_InternalUi()); addTest(new TS_RdtCore()); addTest(new TS_Aptana()); } public static void main(String[] args) { junit.textui.TestRunner.run(new AllTests()); } },0.00010428189571678357
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . designer . elements . schedule ; import org . oddjob . arooa . design . DesignFactory ; import org . oddjob . arooa . design . DesignInstance ; import org . oddjob . arooa . design . DesignProperty ; import org . oddjob . arooa . design . SimpleTextAttribute ; import org . oddjob . arooa . design . screem . BorderedGroup ; import org . oddjob . arooa . design . screem . FieldGroup ; import org . oddjob . arooa . design . screem . FieldSelection ; import org . oddjob . arooa . design . screem . Form ; import org . oddjob . arooa . design . screem . StandardForm ; import org . oddjob . arooa . parsing . ArooaContext ; import org . oddjob . arooa . parsing . ArooaElement ; public class YearlyScheduleDE implements DesignFactory { public DesignInstance createDesign ( ArooaElement element , ArooaContext parentContext ) { return new YearlyScheduleDesign ( element , parentContext ) ; } } class YearlyScheduleDesign extends ParentSchedule { private final SimpleTextAttribute onDate ; private final SimpleTextAttribute fromDate ; private final SimpleTextAttribute toDate ; private final SimpleTextAttribute inMonth ;'}]",private final FieldSelection onDateField;,2.9571999338152237e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . compiler . operator ; import static com . asakusafw . utils . java . model . syntax . ModifierKind . * ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . List ; import javax . lang . model . element . PackageElement ; import org . junit . Test ; import com . asakusafw . utils . java . jsr269 . bridge . Jsr269 ; import com . asakusafw . utils . java . model . syntax . FieldDeclaration ; import com . asakusafw . utils . java . model . syntax . FormalParameterDeclaration ; import com . asakusafw . utils . java . model . syntax . MethodDeclaration ; import com . asakusafw . utils . java . model . syntax . ModelFactory ; import com . asakusafw . utils . java . model . syntax . ModelKind ; import com . asakusafw . utils . java . model . syntax . TypeDeclaration ; import com . asakusafw . utils . java . model . util . ImportBuilder ; import com . asakusafw . utils . java . model . util . ImportBuilder . Strategy ; import com . asakusafw . utils . java . model . util . Models ; public class OperatorFactoryClassGeneratorTest extends OperatorCompilerTestRoot { @ Test public void simple ( ) { add ( ""<STR_LIT>"" ) ; TypeDeclaration tree = generate ( new MockOperatorProcessor ( ) ) ; assertThat ( tree . getName ( ) . getToken ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( Find . modifiers ( tree ) , hasItem ( PUBLIC ) ) ; assertThat ( Find . modifiers ( tree ) , not ( hasItem ( ABSTRACT ) ) ) ; TypeDeclaration type = Find . type ( tree , ""<STR_LIT>"" ) ; assertThat ( type . getModelKind ( ) , is ( ModelKind . CLASS_DECLARATION ) ) ; assertThat ( Find . modifiers ( type ) , hasItem ( PUBLIC ) ) ; FieldDeclaration field = Find . field ( type , ""<STR_LIT>"" ) ; assertThat ( Find . modifiers ( field ) , hasItems ( PUBLIC , FINAL ) ) ; assertThat ( field . getType ( ) . toString ( ) , is ( ""<STR_LIT>"" ) ) ; MethodDeclaration method = Find . method ( tree , ""<STR_LIT>"" ) ; assertThat ( Find . modifiers ( method ) , hasItem ( PUBLIC ) ) ; assertThat ( method . getReturnType ( ) . toString ( ) , is ( ""<STR_LIT>"" ) ) ; List < ? extends FormalParameterDeclaration > params = method . getFormalParameters ( ) ; assertThat ( params . size ( ) , is ( <NUM_LIT:2> ) ) ; assertThat ( params . get ( <NUM_LIT:0> ) . getType ( ) . toString ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( params . get ( <NUM_LIT:0> ) . getName ( ) . getToken ( ) , is ( ""<STR_LIT>"" ) ) ; assertThat ( params . get ( <NUM_LIT:1> ) . getType ( ) . toString ( ) , is ( ""<STR_LIT:int>"" ) ) ; assertThat ( params . get ( <NUM_LIT:1> ) . getName ( ) . getToken ( ) , is ( ""<STR_LIT>"" ) ) ; } private TypeDeclaration generate ( OperatorProcessor ... procs ) { Engine engine = new Engine ( procs ) ; start'}]",Engine engine = new Engine ( procs ) ; engine. setOutput ( new ModelFactory ( ) ) ; return ( TypeDeclaration ) engine. execute ( new ModelFactory ( ) ). getRoot ( ) ; },8.66319755576571e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core ; import java . io . ByteArrayInputStream ; import java . io . UnsupportedEncodingException ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . rubypeople . rdt . core . IBuffer ; import org . rubypeople . rdt . core . IRubyElement ; import org . rubypeople . rdt . core . IRubyModelStatus ; import org . rubypeople . rdt . core . IRubyModelStatusConstants ; import org . rubypeople . rdt . core . IRubyScript ; import org . rubypeople . rdt . core . RubyModelException ; import org . rubypeople . rdt . internal . core . util . Messages ; import org . rubypeople . rdt . internal . core . util . Util ; public class CommitWorkingCopyOperation extends RubyModelOperation { public CommitWorkingCopyOperation ( IRubyScript element , boolean force ) { super ( new IRubyElement [ ] { element } , force ) ; } protected void executeOperation ( ) throws RubyModelException { try { beginTask ( Messages . workingCopy_commit , <NUM_LIT:2> ) ; RubyScript workingCopy = getRubyScript ( ) ; IFile resource = ( IFile ) workingCopy . getResource ( ) ; if ( resource == null ) { workingCopy . getBuffer ( ) . save ( this . progressMonitor , this . force ) ; return ; } IRubyScript primary = workingCopy . getPrimary ( ) ; boolean isPrimary = workingCopy . isPrimary ( ) ; RubyElementDeltaBuilder deltaBuilder = null ; boolean isIncluded = ! Util . isExcluded ( workingCopy ) ; if ( isPrimary || ( isIncluded && resource . isAccessible ( ) && Util . isValidRubyScriptName ( workingCopy . getElementName ( ) ) ) ) { if ( ! isPrimary && ! primary . isOpen ( ) ) { primary . open ( null ) ; } if ( isIncluded && ( ! isPrimary || ! workingCopy . isConsistent ( ) ) ) { deltaBuilder = new RubyElementDeltaBuilder ( primary ) ; } IBuffer primaryBuffer = primary . getBuffer ( ) ; if ( ! isPrimary ) { if ( primaryBuffer == null ) return ; char [ ] primaryContents = primaryBuffer . getCharacters ( ) ; boolean hasSaved = false ; try { IBuffer workingCopyBuffer = workingCopy . getBuffer ( ) ; if ( workingCopyBuffer == null ) return ; primaryBuffer . setContents ( workingCopyBuffer . getCharacters ( ) ) ; primaryBuffer . save ( this . progressMonitor , this . force ) ; primary . makeConsistent ( this ) ; hasSaved = true ; } finally { if ( ! hasSaved ) { primaryBuffer . setContents ( primaryContents ) ; } } } else { primaryBuffer . save ( this . progressMonitor , this . force ) ; primary . makeConsistent ( this ) ; } } else { String encoding = null ; try { encoding = resource . getCharset ( ) ; } catch ( CoreException ce ) { } String contents = workingCopy . getSource ( ) ; if'}]",( contents!= null &&! contents. isEmpty ( ) ) { workingCopy. getBuffer ( ). setContents ( contents ) ; } } finally { endTask ( ) ; } } catch ( RubyModelException e ) { throw e ; } catch ( Exception e ) { throw new RubyModelException ( e ) ; } } },0.0001227695389085937
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': ""<s> package org . rubypeople . rdt . internal . core . util ; import org . rubypeople . rdt . internal . compiler . parser . ScannerHelper ; public class CharOperation { public static final char [ ] NO_CHAR = new char [ <NUM_LIT:0> ] ; public static final String [ ] NO_STRINGS = new String [ <NUM_LIT:0> ] ; public static final char [ ] [ ] NO_CHAR_CHAR = new char [ <NUM_LIT:0> ] [ ] ; public static final int indexOf ( char toBeFound , char [ ] array , int start ) { for ( int i = start ; i < array . length ; i ++ ) if ( toBeFound == array [ i ] ) return i ; return - <NUM_LIT:1> ; } public static final char [ ] replace ( char [ ] array , char [ ] toBeReplaced , char [ ] replacementChars ) { int max = array . length ; int replacedLength = toBeReplaced . length ; int replacementLength = replacementChars . length ; int [ ] starts = new int [ <NUM_LIT:5> ] ; int occurrenceCount = <NUM_LIT:0> ; if ( ! equals ( toBeReplaced , replacementChars ) ) { next : for ( int i = <NUM_LIT:0> ; i < max ; i ++ ) { int j = <NUM_LIT:0> ; while ( j < replacedLength ) { if ( i + j == max ) continue next ; if ( array [ i + j ] != toBeReplaced [ j ++ ] ) continue next ; } if ( occurrenceCount == starts . length ) { System . arraycopy ( starts , <NUM_LIT:0> , starts = new int [ occurrenceCount * <NUM_LIT:2> ] , <NUM_LIT:0> , occurrenceCount ) ; } starts [ occurrenceCount ++ ] = i ; } } if ( occurrenceCount == <NUM_LIT:0> ) return array ; char [ ] result = new char [ max + occurrenceCount * ( replacementLength - replacedLength ) ] ; int inStart = <NUM_LIT:0> , outStart = <NUM_LIT:0> ; for ( int i = <NUM_LIT:0> ; i < occurrenceCount ; i ++ ) { int offset = starts [ i ] - inStart ; System . arraycopy ( array , inStart , result , outStart , offset ) ; inStart += offset ; outStart += offset ; System . arraycopy ( replacementChars , <NUM_LIT:0> , result , outStart , replacementLength ) ; inStart += replacedLength ; outStart += replacementLength ; } System . arraycopy ( array , inStart , result , outStart , max - inStart ) ; return result ; } public static final boolean equals ( char [ ] first , char [ ] second ) { if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= <NUM_LIT:0> ; ) if ( first [ i ] != second [ i ] ) return false ; return true ; } public static final boolean pathMatch ( char [ ] pattern , char [ ] filepath , boolean isCaseSensitive , char pathSeparator ) { if ( filepath == null ) return false ; if ( pattern == null ) return true ; int pSegmentStart = pattern [ <NUM_LIT:0> ] == pathSeparator ? <NUM_LIT:1> : <NUM_LIT:0> ; int pLength = pattern . length ; int pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart + <NUM_LIT:1> ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; boolean freeTrailingDoubleStar = pattern [ pLength - <NUM_LIT:1> ] == pathSeparator ; int fSegmentStart , fLength = filepath . length ; if ( filepath [ <NUM_LIT:0> ] != pathSeparator ) { fSegmentStart = <NUM_LIT:0> ; } else { fSegmentStart = <NUM_LIT:1> ; } if ( fSegmentStart != pSegmentStart ) { return false ; } int fSegmentEnd = CharOperation . indexOf ( pathSeparator , filepath , fSegmentStart + <NUM_LIT:1> ) ; if ( fSegmentEnd < <NUM_LIT:0> ) fSegmentEnd = fLength ; while ( pSegmentStart < pLength && ! ( pSegmentEnd == pLength && freeTrailingDoubleStar || ( pSegmentEnd == pSegmentStart + <NUM_LIT:2> && pattern [ pSegmentStart ] == '<CHAR_LIT>' && pattern [ pSegmentStart + <NUM_LIT:1> ] == '<CHAR_LIT>' ) ) ) { if ( fSegmentStart >= fLength ) return false ; if ( ! CharOperation . match ( pattern , pSegmentStart , pSegmentEnd , filepath , fSegmentStart , fSegmentEnd , isCaseSensitive ) ) { return false ; } pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentEnd + <NUM_LIT:1> ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; fSegmentEnd = CharOperation . indexOf ( pathSeparator , filepath , fSegmentStart = fSegmentEnd + <NUM_LIT:1> ) ; if ( fSegmentEnd < <NUM_LIT:0> ) fSegmentEnd = fLength ; } int pSegmentRestart ; if ( ( pSegmentStart >= pLength && freeTrailingDoubleStar ) || ( pSegmentEnd == pSegmentStart + <NUM_LIT:2> && pattern [ pSegmentStart ] == '<CHAR_LIT>' && pattern [ pSegmentStart + <NUM_LIT:1> ] == '<CHAR_LIT>' ) ) { pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentEnd + <NUM_LIT:1> ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; pSegmentRestart = pSegmentStart ; } else { if ( pSegmentStart >= pLength ) return fSegmentStart >= fLength ; pSegmentRestart = <NUM_LIT:0> ; } int fSegmentRestart = fSegmentStart ; checkSegment : while ( fSegmentStart < fLength ) { if ( pSegmentStart >= pLength ) { if ( freeTrailingDoubleStar ) return true ; pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentRestart ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; fSegmentRestart = CharOperation . indexOf ( pathSeparator , filepath , fSegmentRestart + <NUM_LIT:1> ) ; if ( fSegmentRestart < <NUM_LIT:0> ) { fSegmentRestart = fLength ; } else { fSegmentRestart ++ ; } fSegmentEnd = CharOperation . indexOf ( pathSeparator , filepath , fSegmentStart = fSegmentRestart ) ; if ( fSegmentEnd < <NUM_LIT:0> ) fSegmentEnd = fLength ; continue checkSegment ; } if ( pSegmentEnd == pSegmentStart + <NUM_LIT:2> && pattern [ pSegmentStart ] == '<CHAR_LIT>' && pattern [ pSegmentStart + <NUM_LIT:1> ] == '<CHAR_LIT>' ) { pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentEnd + <NUM_LIT:1> ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; pSegmentRestart = pSegmentStart ; fSegmentRestart = fSegmentStart ; if ( pSegmentStart >= pLength ) return true ; continue checkSegment ; } if ( ! CharOperation . match ( pattern , pSegmentStart , pSegmentEnd , filepath , fSegmentStart , fSegmentEnd , isCaseSensitive ) ) { pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentRestart ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; fSegmentRestart = CharOperation . indexOf ( pathSeparator , filepath , fSegmentRestart + <NUM_LIT:1> ) ; if ( fSegmentRestart < <NUM_LIT:0> ) { fSegmentRestart = fLength ; } else { fSegmentRestart ++ ; } fSegmentEnd = CharOperation . indexOf ( pathSeparator , filepath , fSegmentStart = fSegmentRestart ) ; if ( fSegmentEnd < <NUM_LIT:0> ) fSegmentEnd = fLength ; continue checkSegment ; } pSegmentEnd = CharOperation . indexOf ( pathSeparator , pattern , pSegmentStart = pSegmentEnd + <NUM_LIT:1> ) ; if ( pSegmentEnd < <NUM_LIT:0> ) pSegmentEnd = pLength ; fSegmentEnd = CharOperation . indexOf ( pathSeparator , filepath , fSegmentStart = fSegmentEnd + <NUM_LIT:1> ) ; if ( fSegmentEnd < <NUM_LIT:0> ) fSegmentEnd = fLength ; } return ( pSegmentRestart >= pSegmentEnd ) || ( fSegmentStart >= fLength && pSegmentStart >= pLength ) || ( pSegmentStart == pLength - <NUM_LIT:2> && pattern [ pSegmentStart ] == '<CHAR_LIT>' && pattern [ pSegmentStart + <NUM_LIT:1> ] == '<CHAR_LIT>' ) || ( pSegmentStart == pLength && freeTrailingDoubleStar ) ; } public static final boolean match ( char [ ] pattern , int patternStart , int patternEnd , char [ ] name , int nameStart , int nameEnd , boolean isCaseSensitive ) { if ( name == null ) return false ; if ( pattern == null ) return true ; int iPattern = patternStart ; int iName = nameStart ; if ( patternEnd < <NUM_LIT:0> ) patternEnd = pattern . length ; if ( nameEnd < <NUM_LIT:0> ) nameEnd = name . length ; char patternChar = <NUM_LIT:0> ; while ( ( iPattern < patternEnd ) && ( patternChar = pattern [ iPattern ] ) != '<CHAR_LIT>' ) { if ( iName == nameEnd ) return false ; if ( patternChar != ( isCaseSensitive ? name [ iName ] : Character . toLowerCase ( name [ iName ] ) ) && patternChar != '<CHAR_LIT>' ) { return false ; } iName ++ ; iPattern ++ ; } int segmentStart ; if ( patternChar == '<CHAR_LIT>' ) { segmentStart = ++ iPattern ; } else { segmentStart = <NUM_LIT:0> ; } int prefixStart = iName ; checkSegment : while ( iName < nameEnd ) { if ( iPattern == patternEnd ) { iPattern = segmentStart ; iName = ++ prefixStart ; continue checkSegment ; } if ( ( patternChar = pattern [ iPattern ] ) == '<CHAR_LIT>' ) { segmentStart = ++ iPattern ; if ( segmentStart == patternEnd ) { return true ; } prefixStart = iName ; continue checkSegment ; } if ( ( isCaseSensitive ? name [ iName ] : Character . toLowerCase ( name [ iName ] ) ) != patternChar && patternChar != '<CHAR_LIT>' ) { iPattern = segmentStart ; iName = ++ prefixStart ; continue checkSegment ; } iName ++ ; iPattern ++ ; } return ( segmentStart == patternEnd ) || ( iName == nameEnd && iPattern == patternEnd ) || ( iPattern == patternEnd - <NUM_LIT:1> && pattern [ iPattern ] == '<CHAR_LIT>' ) ; } public static final char [ ] subarray ( char [ ] array , int start , int end ) { if ( end == - <NUM_LIT:1> ) end = array . length ; if ( start > end ) return null ; if ( start < <NUM_LIT:0> ) return null ; if ( end > array . length ) return null ; char [ ] result = new char [ end - start ] ; System . arraycopy ( array , start , result , <NUM_LIT:0> , end - start ) ; return result ; } public static final char [ ] concat ( char [ ] first , char [ ] second , char separator ) { if ( first == null ) return second ; if ( second == null ) return first ; int length1 = first . length ; if ( length1 == <NUM_LIT:0> ) return second ; int length2 = second . length ; if ( length2 == <NUM_LIT:0> ) return first ; char [ ] result = new char [ length1 + length2 + <NUM_LIT:1> ] ; System . arraycopy ( first , <NUM_LIT:0> , result , <NUM_LIT:0> , length1 ) ; result [ length1 ] = separator ; System . arraycopy ( second , <NUM_LIT:0> , result , length1 + <NUM_LIT:1> , length2 ) ; return result ; } public static final int lastIndexOf ( char toBeFound , char [ ] array ) { for ( int i = array . length ; -- i >= <NUM_LIT:0> ; ) if ( toBeFound == array [ i ] ) return i ; return - <NUM_LIT:1> ; } public static final boolean equals ( char [ ] [ ] first , char [ ] [ ] second ) { if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= <NUM_LIT:0> ; ) if ( ! equals ( first [ i ] , second [ i ] ) ) return false ; return true ; } public static final boolean equals ( String [ ] first , String [ ] second ) { if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= <NUM_LIT:0> ; ) if ( ! first [ i ] . equals ( second [ i ] ) ) return false ; return true ; } public static final int hashCode ( char [ ] array ) { int length = array . length ; int hash = length == <NUM_LIT:0> ? <NUM_LIT:31> : array [ <NUM_LIT:0> ] ; if ( length < <NUM_LIT:8> ) { for ( int i = length ; -- i > <NUM_LIT:0> ; ) hash = ( hash * <NUM_LIT:31> ) + array [ i ] ; } else { for ( int i = length - <NUM_LIT:1> , last = i > <NUM_LIT:16> ? i - <NUM_LIT:16> : <NUM_LIT:0> ; i > last ; i -= <NUM_LIT:2> ) hash = ( hash * <NUM_LIT:31> ) + array [ i ] ; } return hash & <NUM_LIT> ; } public static final char [ ] concatWith ( char [ ] [ ] array , char separator ) { int length = array == null ? <NUM_LIT:0> : array . length ; if ( length == <NUM_LIT:0> ) return CharOperation . NO_CHAR ; int size = length - <NUM_LIT:1> ; int index = length ; while ( -- index >= <NUM_LIT:0> ) { if ( array [ index ] . length == <NUM_LIT:0> ) size -- ; else size += array [ index ] . length ; } if ( size <= <NUM_LIT:0> ) return CharOperation . NO_CHAR ; char [ ] result = new char [ size ] ; index = length ; while ( -- index >= <NUM_LIT:0> ) { length = array [ index ] . length ; if ( length > <NUM_LIT:0> ) { System . arraycopy ( array [ index ] , <NUM_LIT:0> , result , ( size -= length ) , length ) ; if ( -- size >= <NUM_LIT:0> ) result [ size ] = separator ; } } return result ; } public static final char [ ] [ ] splitOn ( char divider , char [ ] array ) { int length = array == null ? <NUM_LIT:0> : array . length ; if ( length == <NUM_LIT:0> ) return NO_CHAR_CHAR ; int wordCount = <NUM_LIT:1> ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) if ( array [ i ] == divider ) wordCount ++ ; char [ ] [ ] split = new char [ wordCount ] [ ] ; int last = <NUM_LIT:0> , currentWord = <NUM_LIT:0> ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { if ( array [ i ] == divider ) { split [ currentWord ] = new char [ i - last ] ; System . arraycopy ( array , last , split [ currentWord ++ ] , <NUM_LIT:0> , i - last ) ; last = i + <NUM_LIT:1> ; } } split [ currentWord ] = new char [ length - last ] ; System . arraycopy ( array , last , split [ currentWord ] , <NUM_LIT:0> , length - last ) ; return split ; } public static final boolean prefixEquals ( char [ ] prefix , char [ ] name ) { int max = prefix . length ; if ( name . length < max ) return false ; for ( int i = max ; -- i >= <NUM_LIT:0> ; ) if ( prefix [ i ] != name [ i ] ) return false ; return true ; } public static final boolean camelCaseMatch ( char [ ] pattern , char [ ] name ) { if ( pattern == null ) return true ; if ( name == null ) return false ; return camelCaseMatch ( pattern , <NUM_LIT:0> , pattern . length , name , <NUM_LIT:0> , name . length ) ; } public static final boolean camelCaseMatch ( char [ ] pattern , int patternStart , int patternEnd , char [ ] name , int nameStart , int nameEnd ) { if ( name == null ) return false ; if ( pattern == null ) return true ; if ( patternEnd < <NUM_LIT:0> ) patternEnd = pattern . length ; if ( nameEnd < <NUM_LIT:0> ) nameEnd = name . length ; if ( patternEnd <= patternStart ) return nameEnd <= nameStart ; if ( nameEnd <= nameStart ) return false ; if ( name [ nameStart ] != pattern [ patternStart ] ) { return false ; } char patternChar , nameChar ; int iPattern = patternStart ; int iName = nameStart ; while ( true ) { iPattern ++ ; iName ++ ; if ( iPattern == patternEnd ) { return true ; } if ( iName == nameEnd ) { return false ; } if ( ( patternChar = pattern [ iPattern ] ) == name [ iName ] ) { continue ; } if ( patternChar < ScannerHelper . MAX_OBVIOUS ) { if ( ( ScannerHelper . OBVIOUS_IDENT_CHAR_NATURES [ patternChar ] & ScannerHelper . C_UPPER_LETTER ) == <NUM_LIT:0> ) { return false ; } } else if ( Character . isJavaIdentifierPart ( patternChar ) && ! Character . isUpperCase ( patternChar ) ) { return false ; } while ( true ) { if ( iName == nameEnd ) { return false ; } nameChar = name [ iName ] ; if ( nameChar < ScannerHelper . MAX_OBVIOUS ) { if ( ( ScannerHelper . OBVIOUS_IDENT_CHAR_NATURES [ nameChar ] & ( ScannerHelper . C_LOWER_LETTER | ScannerHelper . C_SPECIAL | ScannerHelper . C_DIGIT ) ) != <NUM_LIT:0> ) { iName ++ ; } else if ( patternChar != nameChar ) { return false ; } else { break ; } } else if ( Character . isJavaIdentifierPart ( nameChar ) && ! Character . isUpperCase ( nameChar ) ) { iName ++ ; } else if ( patternChar != nameChar ) { return false ; } else { break ; } } } } public static final boolean equals ( char [ ] first , char [ ] second , boolean isCaseSensitive ) { if ( isCaseSensitive ) { return equals ( first , second ) ; } if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= <NUM_LIT:0> ; ) if ( ScannerHelper . toLowerCase ( first [ i ] ) != ScannerHelper . toLowerCase ( second [ i ] ) ) return false ; return true ; } public static final boolean prefixEquals ( char [ ] prefix , char [ ] name , boolean isCaseSensitive ) { int max = prefix . length ; if ( name . length < max ) return false ; if ( isCaseSensitive ) { for ( int i = max ; -- i >= <NUM_LIT:0> ; ) if ( prefix [ i ] != name [ i ] ) return false ; return true ; } for ( int i = max ; -- i >= <NUM_LIT:0> ; ) if ( ScannerHelper . toLowerCase ( prefix [ i ] ) != ScannerHelper . toLowerCase ( name [ i ] ) ) return false ; return true ; } public static final boolean match ( char [ ] pattern , char [ ] name , boolean isCaseSensitive ) { if ( name == null ) return false ; if ( pattern == null ) return true ; return match ( pattern , <NUM_LIT:0> , pattern . length , name , <NUM_LIT:0> , name . length , isCaseSensitive ) ; } final static public char [ ] toLowerCase ( char [ ] chars ) { if ( chars == null ) return null ; int length = chars . length ; char [ ] lowerChars = null ; for ( int i = <NUM_LIT:0> ; i < length ; i ++ ) { char c = chars [ i ] ; char lc = ScannerHelper . toLowerCase ( c ) ; if ( ( c != lc ) || ( lowerChars != null ) ) { if ( lowerChars == null ) { System . arraycopy ( chars , <NUM_LIT:0> , lowerChars = new char [ length ] , <NUM_LIT:0> , i ) ; } lowerChars [ i ] = lc ; } } return lowerChars == null ? chars : lowerChars ; } public static final char [ ] [ ] subarray ( char [ ] [ ] array , int start , int end ) { if ( end == - <NUM_LIT:1> ) end = array . length ; if ( start > end ) return null ; if ( start < <NUM_LIT:0> ) return null ; if ( end > array . length ) return null ; char [ ] [ ] result = new char [ end - start ] [ ] ; System . arraycopy ( array""}]","public static final char [ ] [ ] subarray ( char [ ] [ ] array, int start, int end ) { if ( end == - 1 ) end = array. length ; if ( start > end ) return null ; if ( start < 0 ) return null ; if ( end > array. length ) return null ; char [ ] [ ] result = new char [ end - start ] [ ] ; System. arraycopy ( array, start, result, 0, end - start ) ; return result ; }",0.0003286839231345287
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . common ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; public enum TsvDeleteType { FALSE ( ""<STR_LIT>"" , ""<STR_LIT:0>"" , ""<STR_LIT>"" ) , TRUE ( ""<STR_LIT>"" , ""<STR_LIT:1>"" , ""<STR_LIT>"" ) ; private String symbol ; Set < String > keys ; private TsvDeleteType ( String symbol , String ... alternatives ) { this . symbol = symbol ; this . keys = new HashSet < String > ( ) ; this . keys . add ( symbol ) ; Collections . addAll ( this . keys , alternatives ) ; } public String getSymbol ( ) { return symbol ; } public static TsvDeleteType find ( String key ) { return DeleteTypeToTsvDeleteType . REVERSE_DICTIONARY . get ( key ) ; } private static class DeleteTypeToTsvDeleteType { static final Map < String'}]",", TsvDeleteType > DICTIONARY = new TreeMap < String, TsvDeleteType > ( ) ; static { Collections. addAll ( DICTIONARY. entrySet ( ), new Object [ ] { new AbstractMap. SimpleEntry ( ""<STR_LIT>"", FALSE ), new AbstractMap. SimpleEntry ( ""<STR_LIT:0>"", FALSE ), new AbstractMap. SimpleEntry ( ""<STR_LIT:1>"", TRUE ) } ) ; } static final Map < String, TsvDeleteType > REVERSE_DICTIONARY = Collections. unmodifiableMap ( new TreeMap < String, TsvDeleteType > ( DICTIONARY. reverse () ) ) ; } }",0.00019399463494596317
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . core . search . processing ; import org . eclipse . core . runtime . IProgressMonitor ; public interface IJob { int ForceImmediate = <NUM_LIT:1> ; int CancelIfNotReady'}]",= <NUM_LIT:2>; void run ( IProgressMonitor monitor ); },3.7336740831368774e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . core . vocabulary ; import java . io . Flushable ; import java . io . IOException ; import java . io . InputStream ; import java . io .'}]","OutputStream; public interface Vocabulary extends Flushable { void configure ( InputStream in, OutputStream out ) throws IOException ; }",4.3581134086095805e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . rubypeople . rdt . internal . testunit . ui ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . Vector ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IMenuListener ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . dnd . Clipboard ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . rubypeople . rdt . core . RubyConventions ; import org . rubypeople . rdt . testunit . ITestRunListener ; public class TestHierarchyTab extends TestRunTab implements IMenuListener { private Tree fTree ; private TreeItem fCachedParent ; private TreeItem [ ] fCachedItems ; private TreeItem fLastParent ; private List < TreeItem > fExecutionPath ; private boolean fMoveSelection = false ; private static class SuiteInfo { public int fTestCount ; public TreeItem fTreeItem ; public SuiteInfo ( TreeItem treeItem , int testCount ) { fTreeItem = treeItem ; fTestCount = testCount ; } } private Vector < SuiteInfo > fSuiteInfos = new Vector < SuiteInfo > ( ) ; private Map < String , TreeItem > fTreeItemMap = new HashMap < String , TreeItem > ( ) ; private TestUnitView fTestRunnerPart ; private final Image fOkIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fErrorIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fFailureIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fHierarchyIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fSuiteIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fSuiteErrorIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fSuiteFailIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fTestIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fTestRunningIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private final Image fSuiteRunningIcon = TestUnitView . createImage ( ""<STR_LIT>"" ) ; private class ExpandAllAction extends Action { public ExpandAllAction ( ) { setText ( TestUnitMessages . ExpandAllAction_text ) ; setToolTipText ( TestUnitMessages . ExpandAllAction_tooltip ) ; } public void run ( ) { expandAll ( ) ; } } public TestHierarchyTab ( ) { } public void createTabControl ( CTabFolder tabFolder , Clipboard clipboard , TestUnitView runner ) { fTestRunnerPart = runner ; CTabItem hierarchyTab = new CTabItem ( tabFolder , SWT . NONE ) ; hierarchyTab . setText ( getName ( ) ) ; hierarchyTab . setImage ( fHierarchyIcon ) ; Composite testTreePanel = new Composite ( tabFolder , SWT . NONE ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . marginHeight = <NUM_LIT:0> ; gridLayout . marginWidth = <NUM_LIT:0> ; testTreePanel . setLayout ( gridLayout ) ; GridData gridData = new GridData ( GridData . GRAB_HORIZONTAL | GridData . GRAB_VERTICAL ) ; testTreePanel . setLayoutData ( gridData ) ; hierarchyTab . setControl ( testTreePanel ) ; hierarchyTab . setToolTipText ( TestUnitMessages . HierarchyRunView_tab_tooltip ) ; fTree = new Tree ( testTreePanel , SWT . V_SCROLL | SWT . SINGLE ) ; gridData = new GridData ( GridData . FILL_BOTH | GridData . GRAB_HORIZONTAL | GridData . GRAB_VERTICAL ) ; fTree . setLayoutData ( gridData ) ; initMenu ( ) ; addListeners ( ) ; } void disposeIcons ( ) { fErrorIcon . dispose ( ) ; fFailureIcon . dispose ( ) ; fOkIcon . dispose ( ) ; fHierarchyIcon . dispose ( ) ; fTestIcon . dispose ( ) ; fTestRunningIcon . dispose ( ) ; fSuiteRunningIcon . dispose ( ) ; fSuiteIcon . dispose ( ) ; fSuiteErrorIcon . dispose ( ) ; fSuiteFailIcon . dispose ( ) ; } private void initMenu ( ) { MenuManager menuMgr = new MenuManager ( ) ; menuMgr . setRemoveAllWhenShown ( true ) ; menuMgr . addMenuListener ( this ) ; Menu menu = menuMgr . createContextMenu ( fTree ) ; fTree . setMenu ( menu ) ; } private String getTestMethod ( ) { return getTestInfo ( ) . getTestMethodName ( ) ; } private TestRunInfo getTestInfo ( ) { TreeItem [ ] treeItems = fTree . getSelection ( ) ; if ( treeItems . length == <NUM_LIT:0> ) return null ; return ( ( TestRunInfo ) treeItems [ <NUM_LIT:0> ] . getData ( ) ) ; } private boolean isSuiteSelected ( ) { TreeItem [ ] treeItems = fTree . getSelection ( ) ; if ( treeItems . length != <NUM_LIT:1> ) return false ; return treeItems [ <NUM_LIT:0> ] . getItemCount ( ) > <NUM_LIT:0> ; } private String getClassName ( ) { return getTestInfo ( ) . getClassName ( ) ; } public String getSelectedTestId ( ) { TestRunInfo testInfo = getTestInfo ( ) ; if ( testInfo == null ) return null ; return testInfo . getTestId ( ) ; } public String getName ( ) { return TestUnitMessages . HierarchyRunView_tab_title ; } public void setSelectedTest ( String testId ) { TreeItem treeItem = findTreeItem ( testId ) ; if ( treeItem != null ) fTree . setSelection ( new TreeItem [ ] { treeItem } ) ; } public void startTest ( String testId ) { TreeItem treeItem = findTreeItem ( testId ) ; if ( treeItem == null ) return ; TreeItem parent = treeItem . getParentItem ( ) ; if ( fLastParent != parent ) { updatePath ( parent ) ; fLastParent = parent ; } setCurrentItem ( treeItem ) ; } private void updatePath ( TreeItem parent ) { List < TreeItem > newPath = new ArrayList < TreeItem > ( ) ; while ( parent != null ) { newPath . add ( parent ) ; parent = parent . getParentItem ( ) ; } Collections . reverse ( newPath ) ; ListIterator < TreeItem > old = fExecutionPath . listIterator ( ) ; ListIterator < TreeItem > np = newPath . listIterator ( ) ; int c = <NUM_LIT:0> ; while ( old . hasNext ( ) && np . hasNext ( ) ) { if ( old . next ( ) != np . next ( ) ) break ; c ++ ; } for ( ListIterator < TreeItem > iter = fExecutionPath . listIterator ( c ) ; iter . hasNext ( ) ; ) refreshItem ( iter . next ( ) , false ) ; for ( ListIterator < TreeItem > iter = newPath . listIterator ( c ) ; iter . hasNext ( ) ; ) refreshItem ( iter . next ( ) , true ) ; fExecutionPath = newPath ; } private void refreshItem ( TreeItem item , boolean onPath ) { if ( onPath ) item . setImage ( fSuiteRunningIcon ) ; else { TestRunInfo info = getTestRunInfo ( item ) ; switch ( info . getStatus ( ) ) { case ITestRunListener . STATUS_ERROR : item . setImage ( fSuiteErrorIcon ) ; break ; case ITestRunListener . STATUS_FAILURE : item . setImage ( fSuiteFailIcon ) ; break ; default : item . setImage ( fSuiteIcon ) ; } } } private void setCurrentItem ( TreeItem treeItem ) { treeItem . setImage ( fTestRunningIcon ) ; TreeItem parent = treeItem . getParentItem ( ) ; if ( fTestRunnerPart . isAutoScroll ( ) ) { fTree . showItem ( treeItem ) ; while ( parent != null ) { if ( parent . getExpanded ( ) ) break ; parent . setExpanded ( true ) ; parent = parent . getParentItem ( ) ; } } } public void endTest ( String testId ) { TreeItem treeItem = findTreeItem ( testId ) ; if ( treeItem == null ) return ; TestRunInfo testInfo = fTestRunnerPart . getTestInfo ( testId ) ; if ( testInfo == null ) return ; updateItem ( treeItem , testInfo ) ; if ( fTestRunnerPart . isAutoScroll ( ) ) { fTree . showItem ( treeItem ) ; cacheItems ( treeItem ) ; collapsePassedTests ( treeItem ) ; } } private void cacheItems ( TreeItem treeItem ) { TreeItem parent = treeItem . getParentItem ( ) ; if ( parent == fCachedParent ) return ; fCachedItems = parent . getItems ( ) ; fCachedParent = parent ; } private void collapsePassedTests ( TreeItem treeItem ) { TreeItem parent = treeItem . getParentItem ( ) ; if ( parent != null ) { TreeItem [ ] items = null ; if ( parent == fCachedParent ) items = fCachedItems ; else items = parent . getItems ( ) ; if ( isLast ( treeItem , items ) ) { boolean ok = true ; for ( int i = <NUM_LIT:0> ; i < items . length ; i ++ ) { if ( isFailure ( items [ i ] ) ) { ok = false ; break ; } } if ( ok ) { parent . setExpanded ( false ) ; collapsePassedTests ( parent ) ; } } } } private boolean isLast ( TreeItem treeItem , TreeItem [ ] items ) { return items [ items . length - <NUM_LIT:1> ] == treeItem ; } private void updateItem ( TreeItem treeItem , TestRunInfo testInfo ) { treeItem . setData ( testInfo ) ; if ( testInfo . getStatus ( ) == ITestRunListener . STATUS_OK ) { treeItem . setImage ( fOkIcon ) ; return ; } if ( testInfo . getStatus ( ) == ITestRunListener . STATUS_FAILURE ) treeItem . setImage ( fFailureIcon ) ; else if ( testInfo . getStatus ( ) == ITestRunListener . STATUS_ERROR ) treeItem . setImage ( fErrorIcon ) ; propagateStatus ( treeItem , testInfo . getStatus ( ) ) ; } private void propagateStatus ( TreeItem item , int status ) { TreeItem parent = item . getParentItem ( ) ; TestRunInfo testRunInfo = getTestRunInfo ( item ) ; if ( parent == null ) return ; TestRunInfo parentInfo = getTestRunInfo ( parent ) ; int parentStatus = parentInfo . getStatus ( ) ; if ( status == ITestRunListener . STATUS_FAILURE ) { if ( parentStatus == ITestRunListener . STATUS_ERROR || parentStatus == ITestRunListener . STATUS_FAILURE ) return ; parentInfo . setStatus ( ITestRunListener . STATUS_FAILURE ) ; testRunInfo . setStatus ( ITestRunListener . STATUS_FAILURE ) ; } else { if ( parentStatus == ITestRunListener . STATUS_ERROR ) return ; parentInfo . setStatus ( ITestRunListener . STATUS_ERROR ) ; testRunInfo . setStatus ( ITestRunListener . STATUS_ERROR ) ; } propagateStatus ( parent , status ) ; } private TestRunInfo getTestRunInfo ( TreeItem item ) { return ( TestRunInfo ) item . getData ( ) ; } public void activate ( ) { fMoveSelection = false ; testSelected ( ) ; } public void setFocus ( ) { fTree . setFocus ( ) ; } public void aboutToStart ( ) { fTree . removeAll ( ) ; fSuiteInfos . removeAllElements ( ) ; fTreeItemMap = new HashMap < String , TreeItem > ( ) ; fCachedParent = null ; fCachedItems = null ; fMoveSelection = false ; fExecutionPath = new ArrayList < TreeItem > ( ) ; } private void testSelected ( ) { fTestRunnerPart . handleTestSelected ( getSelectedTestId ( ) ) ; } private void addListeners ( ) { fTree . addSelectionListener ( new SelectionListener ( ) { public void widgetSelected ( SelectionEvent e ) { activate ( ) ; } public void widgetDefaultSelected ( SelectionEvent e ) { activate ( ) ; } } ) ; fTree . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { disposeIcons ( ) ; } } ) ; fTree . addMouseListener ( new MouseAdapter ( ) { public void mouseDoubleClick ( MouseEvent e ) { handleDoubleClick ( e ) ; } } ) ; } void handleDoubleClick ( MouseEvent e ) { TestRunInfo testInfo = getTestInfo ( ) ; if ( testInfo == null ) return ; IAction action = null ; if ( isSuiteSelected ( ) ) action = new OpenTestAction ( fTestRunnerPart , getClassName ( ) ) ; else action = new OpenTestAction ( fTestRunnerPart , getClassName ( ) , getTestMethod ( ) ) ; if ( action != null && action . isEnabled ( ) ) action . run ( ) ; } public void menuAboutToShow ( IMenuManager'}]","menu) { MenuManager suiteMenuMgr = new MenuManager(menu, ""Suite""); suiteMenuMgr.add(""Suite""); suiteMenuMgr.add(""Suite""); suiteMenuMgr.add(new Separator()); suiteMenuMgr.add(""Suite""); suiteMenuMgr.add(""Suite""); suiteMenuMgr.add(new Separator()); suiteMenuMgr.add(""Suite""); suiteMenuMgr.add(""Suite""); }",0.00019591578131406066
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . bootstrap ; import java . io . File ; import java . net . URI ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . List ; import java . util . Properties ; import org . apache . commons . cli . BasicParser ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . cli . CommandLineParser ; import org . apache . commons . cli . HelpFormatter ; import org . apache . commons . cli . Option ; import org . apache . commons . cli . Options ; import org . apache . commons . cli . ParseException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . asakusafw . runtime . core . context . RuntimeContext ; import com . asakusafw . windgate . core . AbortTask ; import com . asakusafw . windgate . core . GateProfile ; import com . asakusafw . windgate . core . ProfileContext ; import com . asakusafw . windgate . core . WindGateLogger ; public final class WindGateAbort { static final WindGateLogger WGLOG = new WindGateBootstrapLogger ( WindGateAbort . class ) ; static final Logger LOG = LoggerFactory .'}]",.getInstance(WindGateAbort.class);public static void main(String[] args) {    //... (rest of the code remains the same)},5.591047125256683e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package test . modelgen . table . model ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import javax . annotation . Generated ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . vocabulary . model . DataModel ; import com . asakusafw . vocabulary . model . Property ; import com . asakusafw . vocabulary . model . TableModel ; @ Generated ( ""<STR_LIT>"" ) @ DataModel @ TableModel ( name = ""<STR_LIT>"" , columns = { ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" , ""<STR_LIT>"" } , primary = { ""<STR_LIT>"" } ) @ SuppressWarnings ( ""<STR_LIT:deprecation>"" ) public class PurchaseTranError2 implements Writable { @ Property ( name = ""<STR_LIT>"" ) private LongOption sid = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption versionNo = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption rgstDatetime = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateTimeOption updtDatetime = new DateTimeOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeType = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tradeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption lineNo = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption deliveryDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption storeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption buyerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption purchaseTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption sellerCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption tenantCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption netPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private LongOption sellingPriceTotal = new LongOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentStoreCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption shipmentSalesTypeCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption deductionCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption accountCode = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption ownershipDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption cutoffDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption payoutDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption ownershipFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption cutoffFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption payoutFlag = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption disposeNo = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private DateOption disposeDate = new DateOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption errorCause = new StringOption ( ) ; @ Property ( name = ""<STR_LIT>"" ) private StringOption errorCode = new StringOption ( ) ; public long getSid ( ) { return this . sid . get ( ) ; } public void setSid ( long sid ) { this . sid . modify ( sid ) ; } public LongOption getSidOption ( ) { return this . sid ; } public void setSidOption ( LongOption sid ) { this . sid . copyFrom ( sid ) ; } public long getVersionNo ( ) { return this . versionNo . get ( ) ; } public void setVersionNo ( long versionNo ) { this . versionNo . modify ( versionNo ) ; } public LongOption getVersionNoOption ( ) { return this . versionNo ; } public void setVersionNoOption ( LongOption versionNo ) { this . versionNo . copyFrom ( versionNo ) ; } public DateTime getRgstDatetime ( ) { return this . rgstDatetime . get ( ) ; } public void setRgstDatetime ( DateTime rgstDatetime ) { this . rgstDatetime . modify ( rgstDatetime ) ; } public DateTimeOption getRgstDatetimeOption ( ) { return this . rgstDatetime ; } public void setRgstDatetimeOption ( DateTimeOption rgstDatetime ) { this . rgstDatetime . copyFrom ( rgstDatetime ) ; } public DateTime getUpdtDatetime ( ) { return this . updtDatetime . get ( ) ; } public void setUpdtDatetime ( DateTime updtDatetime ) { this . updtDatetime . modify ( updtDatetime ) ; } public DateTimeOption getUpdtDatetimeOption ( ) { return this . updtDatetime ; } public void setUpdtDatetimeOption ( DateTimeOption updtDatetime ) { this . updtDatetime . copyFrom ( updtDatetime ) ; } public Text getPurchaseNo ( ) { return this . purchaseNo . get ( ) ; } public void setPurchaseNo ( Text purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public String getPurchaseNoAsString ( ) { return this . purchaseNo . getAsString ( ) ; } public void setPurchaseNoAsString ( String purchaseNo ) { this . purchaseNo . modify ( purchaseNo ) ; } public StringOption getPurchaseNoOption ( ) { return this . purchaseNo ; } public void setPurchaseNoOption ( StringOption purchaseNo ) { this . purchaseNo . copyFrom ( purchaseNo ) ; } public Text getPurchaseType ( ) { return this . purchaseType . get ( ) ; } public void setPurchaseType ( Text purchaseType ) { this . purchaseType . modify ( purchaseType ) ; } public String getPurchaseTypeAsString ( ) { return this . purchaseType . getAsString ( ) ; } public void setPurchaseTypeAsString ( String purchaseType ) { this . purchaseType . modify ( purchaseType ) ; } public StringOption getPurchaseTypeOption ( ) { return this . purchaseType ; } public void setPurchaseTypeOption ( StringOption purchaseType ) { this . purchaseType . copyFrom ( purchaseType ) ; } public Text getTradeType ( ) { return this . tradeType . get ( ) ; } public void setTradeType ( Text tradeType ) { this . tradeType . modify ( tradeType ) ; } public String getTradeTypeAsString ( ) { return this . tradeType . getAsString ( ) ; } public void setTradeTypeAsString ( String tradeType ) { this . tradeType . modify ( tradeType ) ; } public StringOption getTradeTypeOption ( ) { return this . tradeType ; } public void setTradeTypeOption ( StringOption tradeType ) { this . tradeType . copyFrom ( tradeType ) ; } public Text getTradeNo ( ) { return this . tradeNo . get ( ) ; } public void setTradeNo ( Text tradeNo ) { this . tradeNo . modify ( tradeNo ) ; } public String getTradeNoAsString ( ) { return this . tradeNo . getAsString ( ) ; } public void setTradeNoAsString ( String tradeNo ) { this . tradeNo . modify ( tradeNo ) ; } public StringOption getTradeNoOption ( ) { return this . tradeNo ; } public void setTradeNoOption ( StringOption tradeNo ) { this . tradeNo . copyFrom ( tradeNo ) ; } public long getLineNo ( ) { return this . lineNo . get ( ) ; } public void setLineNo ( long lineNo ) { this . lineNo . modify ( lineNo ) ; } public LongOption getLineNoOption ( ) { return this . lineNo ; } public void setLineNoOption ( LongOption lineNo ) { this . lineNo . copyFrom ( lineNo ) ; } public Date getDeliveryDate ( ) { return this . deliveryDate . get ( ) ; } public void setDeliveryDate ( Date deliveryDate ) { this . deliveryDate . modify ( deliveryDate ) ; } public DateOption getDeliveryDateOption ( ) { return this . deliveryDate ; } public void setDeliveryDateOption ( DateOption deliveryDate ) { this . deliveryDate . copyFrom ( deliveryDate ) ; } public Text getStoreCode ( ) { return this . storeCode . get ( ) ; } public void setStoreCode ( Text storeCode ) { this . storeCode . modify ( storeCode ) ; } public String getStoreCodeAsString ( ) { return this . storeCode . getAsString ( ) ; } public void setStoreCodeAsString ( String storeCode ) { this . storeCode . modify ( storeCode ) ; } public StringOption getStoreCodeOption ( ) { return this . storeCode ; } public void setStoreCodeOption ( StringOption storeCode ) { this . storeCode . copyFrom ( storeCode ) ; } public Text getBuyerCode ( ) { return this . buyerCode . get ( ) ; } public void setBuyerCode ( Text buyerCode ) { this . buyerCode . modify ( buyerCode ) ; } public String getBuyerCodeAsString ( ) { return this . buyerCode . getAsString ( ) ; } public void setBuyerCodeAsString ( String buyerCode ) { this . buyerCode . modify ( buyerCode ) ; } public StringOption getBuyerCodeOption ( ) { return this . buyerCode ; } public void setBuyerCodeOption ( StringOption buyerCode ) { this . buyerCode . copyFrom ( buyerCode ) ; } public Text getPurchaseTypeCode ( ) { return this . purchaseTypeCode . get ( ) ; } public void setPurchaseTypeCode ( Text purchaseTypeCode ) { this . purchaseTypeCode . modify ( purchaseTypeCode ) ; } public String getPurchaseTypeCodeAsString ( ) { return this . purchaseTypeCode . getAsString ( ) ; } public void setPurchaseTypeCodeAsString ( String purchaseTypeCode ) { this . purchaseTypeCode . modify ( purchaseTypeCode ) ; } public StringOption getPurchaseTypeCodeOption ( ) { return this . purchaseTypeCode ; } public void setPurchaseTypeCodeOption ( StringOption purchaseTypeCode ) { this . purchaseTypeCode . copyFrom ( purchaseTypeCode ) ; } public Text getSellerCode ( ) { return this . sellerCode . get ( ) ; } public void setSellerCode ( Text sellerCode ) { this . sellerCode . modify ( sellerCode ) ; } public String getSellerCodeAsString ( ) { return this . sellerCode . getAsString ( ) ; } public void setSellerCodeAsString ( String sellerCode ) { this . sellerCode . modify ( sellerCode ) ; } public StringOption getSellerCodeOption ( ) { return this . sellerCode ; } public void setSellerCodeOption ( StringOption sellerCode ) { this . sellerCode . copyFrom ( sellerCode ) ; } public Text getTenantCode ( ) { return this . tenantCode . get ( ) ; } public void setTenantCode ( Text tenantCode ) { this . tenantCode . modify ( tenantCode ) ; } public String getTenantCodeAsString ( ) { return this . tenantCode . getAsString ( ) ; } public void setTenantCodeAsString ( String tenantCode ) { this . tenantCode . modify ( tenantCode ) ; } public StringOption getTenantCodeOption ( ) { return this . tenantCode ; } public void setTenantCodeOption ( StringOption tenantCode ) { this . tenantCode . copyFrom ( tenantCode ) ; } public long getNetPriceTotal ( ) { return this . netPriceTotal . get ( ) ; } public void setNetPriceTotal ( long netPriceTotal ) { this . netPriceTotal . modify ( netPriceTotal ) ; } public LongOption getNetPriceTotalOption ( ) { return this . netPriceTotal ; } public void setNetPriceTotalOption ( LongOption netPriceTotal ) { this . netPriceTotal . copyFrom ( netPriceTotal ) ; } public long getSellingPriceTotal ( ) { return this . sellingPriceTotal . get ( ) ; } public void setSellingPriceTotal ( long sellingPriceTotal ) { this . sellingPriceTotal . modify ( sellingPriceTotal ) ; } public LongOption getSellingPriceTotalOption ( ) { return this . sellingPriceTotal ; } public void setSellingPriceTotalOption ( LongOption sellingPriceTotal ) { this . sellingPriceTotal . copyFrom ( sellingPriceTotal ) ; } public Text getShipmentStoreCode ( ) { return this . shipmentStoreCode . get ( ) ; } public void setShipmentStoreCode ( Text shipmentStoreCode ) { this . shipmentStoreCode . modify ( shipmentStoreCode ) ; } public String getShipmentStoreCodeAsString ( ) { return this . shipmentStoreCode . getAsString ( ) ; } public void setShipmentStoreCodeAsString ( String shipmentStoreCode ) { this . shipmentStoreCode . modify ( shipmentStoreCode ) ; } public StringOption getShipmentStoreCodeOption ( ) { return this . shipmentStoreCode ; } public void setShipmentStoreCodeOption ( StringOption shipmentStoreCode ) { this . shipmentStoreCode . copyFrom ( shipmentStoreCode ) ; } public Text getShipmentSalesTypeCode ( ) { return this . shipmentSalesTypeCode . get ( ) ; } public void setShipmentSalesTypeCode ( Text shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . modify ( shipmentSalesTypeCode ) ; } public String getShipmentSalesTypeCodeAsString ( ) { return this . shipmentSalesTypeCode . getAsString ( ) ; } public void setShipmentSalesTypeCodeAsString ( String shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . modify ( shipmentSalesTypeCode ) ; } public StringOption getShipmentSalesTypeCodeOption ( ) { return this . shipmentSalesTypeCode ; } public void setShipmentSalesTypeCodeOption ( StringOption shipmentSalesTypeCode ) { this . shipmentSalesTypeCode . copyFrom ( shipmentSalesTypeCode ) ; } public Text getDeductionCode ( ) { return this . deductionCode . get ( ) ; } public void setDeductionCode ( Text deductionCode ) { this . deductionCode . modify ( deductionCode ) ; } public String getDeductionCodeAsString ( ) { return this . deductionCode . getAsString ( ) ; } public void setDeductionCodeAsString ( String deductionCode ) { this . deductionCode . modify ( deductionCode ) ; } public StringOption getDeductionCodeOption ( ) { return this . deductionCode ; } public void setDeductionCodeOption ( StringOption deductionCode ) { this . deductionCode . copyFrom ( deductionCode ) ; } public Text getAccountCode ( ) { return this . accountCode . get ( ) ; } public void setAccountCode ( Text accountCode ) { this . accountCode . modify ( accountCode ) ; } public String getAccountCodeAsString ( ) { return this . accountCode . getAsString ( ) ; } public void setAccountCodeAsString ( String accountCode ) { this . accountCode . modify ( accountCode ) ; } public StringOption getAccountCodeOption ( ) { return this . accountCode ; } public void setAccountCodeOption ( StringOption accountCode ) { this . accountCode . copyFrom ( accountCode ) ; } public Date getOwnershipDate ( ) { return this . ownershipDate . get ( ) ; } public void setOwnershipDate ( Date ownershipDate ) { this . ownershipDate . modify ( ownershipDate ) ; } public DateOption getOwnershipDateOption ( ) { return this . ownershipDate ; } public void setOwnershipDateOption ( DateOption ownershipDate ) { this . ownershipDate . copyFrom ( ownershipDate ) ; } public Date getCutoffDate ( ) { return this . cutoffDate . get ( ) ; } public void setCutoffDate ( Date cutoffDate ) { this . cutoffDate . modify ( cutoffDate ) ; } public DateOption getCutoffDateOption ( ) { return this . cutoffDate ; } public void setCutoffDateOption ( DateOption cutoffDate ) { this . cutoffDate . copyFrom ( cutoffDate ) ; } public Date getPayoutDate ( ) { return this . payoutDate . get ( ) ; } public void setPayoutDate ( Date payoutDate ) { this . payoutDate . modify ( payoutDate ) ; } public DateOption getPayoutDateOption ( ) { return this . payoutDate ; } public void setPayoutDateOption ( DateOption payoutDate ) { this . payoutDate . copyFrom ( payoutDate ) ; } public Text getOwnershipFlag ( ) { return this . ownershipFlag . get ( ) ; } public void setOwnershipFlag ( Text ownershipFlag ) { this . ownershipFlag . modify ( ownershipFlag ) ; } public String getOwnershipFlagAsString ( ) { return this . ownershipFlag . getAsString ( ) ; } public void setOwnershipFlagAsString ( String ownershipFlag ) { this . ownershipFlag . modify ( ownershipFlag ) ; } public StringOption getOwnershipFlagOption ( ) { return this . ownershipFlag ; } public void setOwnershipFlagOption ( StringOption ownershipFlag ) { this . ownershipFlag . copyFrom ( ownershipFlag ) ; } public Text getCutoffFlag ( ) { return this . cutoffFlag . get ( ) ; } public void setCutoffFlag ( Text cutoffFlag ) { this . cutoffFlag . modify ( cutoffFlag ) ; } public String getCutoffFlagAsString'}]",(String cutoffFlag) { this. cutoffFlag. modify ( cutoffFlag ) ; } public StringOption getCutoffFlagOption ( ) { return this. cutoffFlag ; } public void setCutoffFlagOption ( StringOption cutoffFlag ) { this. cutoffFlag. copyFrom ( cutoffFlag ) ; } public Text getPayoutFlag ( ) { return this. payoutFlag. get ( ) ; } public void setPayoutFlag ( Text payoutFlag ) { this. payoutFlag. modify ( payoutFlag ) ; } public String getPayoutFlagAsString ( ) { return this. payoutFlag. getAsString ( ) ; } public void setPayoutFlagAsString ( String payoutFlag ) { this. payoutFlag. modify ( payoutFlag ) ; } public StringOption getPayoutFlagOption ( ) { return this. payoutFlag ; } public void setPayoutFlagOption ( StringOption payoutFlag ) { this. payoutFlag. copyFrom ( payoutFlag ) ; } public Text getDisposeNo ( ) { return this. disposeNo. get ( ) ; } public void setDisposeNo ( Text disposeNo ) { this. disposeNo. modify ( disposeNo ) ; } public String getDisposeNoAsString ( ) { return this. disposeNo. getAsString ( ) ; },0.0005678247351092912
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . aptana . rdt . internal . core . parser . warnings ; import org . rubypeople . rdt . core . RubyCore ; import org . rubypeople . rdt . core . parser . warnings . RubyLintVisitor ; import com . aptana . rdt . internal . parser . warnings . EnumerableInclusionVisitor ; public class TC_EnumerableInclusionVisitor extends WarningVisitorTest { @ Override protected RubyLintVisitor createVisitor ( String code ) { return new EnumerableInclusionVisitor ( code ) { @ Override protected String getSeverity ( ) { return RubyCore . WARNING ; } } ; } public void testBasicCase ( ) { parse ( ""<STR_LIT>""'}]",); } },2.1518836377209477e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . bulkloader . importer ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . asakusafw . bulkloader . bean . ImportBean ; import com . asakusafw . bulkloader . bean . ImportTargetTableBean ; import com . asakusafw . bulkloader . common . ConfigurationLoader ; import com . asakusafw . bulkloader . common . Constants ; import com . asakusafw . bulkloader . common . FileCompType ; import com . asakusafw . bulkloader . exception . BulkLoaderSystemException ; import com . asakusafw . bulkloader . log . Log ; import com . asakusafw . bulkloader . transfer . FileList ; import com . asakusafw . bulkloader . transfer . FileListProvider ; import com . asakusafw . bulkloader . transfer . FileProtocol ; import com . asakusafw . bulkloader . transfer . OpenSshFileListProvider ; import com . asakusafw . runtime . core . context . RuntimeContext ; public class ImportFileSend { static final Log LOG = new Log ( ImportFileSend . class ) ; public boolean sendImportFile ( ImportBean bean ) { String strCompType = ConfigurationLoader . getProperty ( Constants . PROP_KEY_IMP_FILE_COMP_TYPE ) ; FileCompType compType = FileCompType . find ( strCompType ) ; FileListProvider provider = null ; FileList . Writer writer = null ; long totalStartTime = System . currentTimeMillis ( ) ; try { provider = openFileList ( bean . getTargetName ( ) , bean . getBatchId ( ) , bean . getJobflowId ( ) , bean . getExecutionId ( ) ) ; provider . discardReader ( ) ; writer = provider . openWriter ( compType == FileCompType . DEFLATED ) ; List < String > list = arrangeSendOrder ( bean ) ; for ( String tableName : list ) { long tableStartTime = System . currentTimeMillis ( ) ; ImportTargetTableBean targetTable = bean . getTargetTable ( tableName ) ; LOG . info ( ""<STR_LIT>"" , tableName , targetTable . getImportFile ( ) . getAbsolutePath ( ) , compType . getSymbol ( ) ) ; long dumpFileSize = sendTableFile ( writer , tableName , targetTable ) ; LOG . info ( ""<STR_LIT>"" , bean . getTargetName ( ) , bean . getBatchId ( ) , bean . getJobflowId ( ) , bean . getExecutionId ( ) , tableName , dumpFileSize , System . currentTimeMillis ( ) - tableStartTime ) ; LOG . info ( ""<STR_LIT>"" , tableName , targetTable . getImportFile ( ) . getAbsolutePath ( ) , compType . getSymbol ( ) ) ; } writer . close ( ) ; provider . waitForComplete ( ) ; LOG . info ( ""<STR_LIT>"" , bean . getTargetName ( ) , bean . getBatchId ( ) , bean . getJobflowId ( ) , bean . getExecutionId ( ) , writer . getByteCount ( ) , System . currentTimeMillis ( ) - totalStartTime ) ; } catch ( BulkLoaderSystemException e ) { LOG . log ( e ) ; return false ; } catch ( Exception e ) { LOG . error ( e , ""<STR_LIT>"" ) ; return false ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException ignored ) { ignored . printStackTrace ( ) ; } } if ( provider != null ) { try { provider . close ( ) ; } catch ( IOException ignored ) { ignored . printStackTrace ( ) ; } } } return true ; } private List < String > arrangeSendOrder ( ImportBean bean ) { assert bean != null ; final Map < String , ImportTargetTableBean > tables = new HashMap < String , ImportTargetTableBean > ( ) ; final Map < String , Long > sizes = new HashMap < String , Long > ( ) ; List < String > tableNames = new ArrayList < String > ( bean . getImportTargetTableList ( ) ) ; for ( String tableName : tableNames ) { ImportTargetTableBean tableBean = bean . getTargetTable ( tableName ) ; tables . put ( tableName , tableBean ) ; sizes . put ( tableName , tableBean . getImportFile ( ) . length ( ) ) ; }'}]","private FileListProvider openFileList(String targetName, String batchId, String jobflowId, String executionId) throws BulkLoaderSystemException {",6.818685529704285e-05
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package org . oddjob . schedules ; import java . text . ParseException ; import java . util . Date ; import junit . framework . TestCase ; import org . oddjob . arooa . utils . DateHelper ; public class SimpleIntervalTest extends TestCase { public void testOn ( ) throws ParseException { Date date = DateHelper . parseDateTime ( ""<STR_LIT>"" ) ; SimpleInterval test = new SimpleInterval ( date ) ; assertEquals ( date , test . getFromDate ( ) ) ; assertEquals ( DateUtils . oneMillisAfter ( date ) , test . getToDate ( ) ) ; } public void testEquals ( ) throws ParseException { Interval i1 , i2 ; i1 = new SimpleInterval ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; i2 = new SimpleInterval ( DateHelper . parseDateTime ( ""<STR_LIT>"" ) , DateHelper . parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( i1 , i2 ) ; i1 = new SimpleInterval'}]","( DateHelper.parseDateTime(""<STR_LIT>""), DateHelper.parseDateTime(""<STR_LIT>"")); i2 = new SimpleInterval(DateHelper.parseDateTime(""<STR_LIT>""), DateHelper.parseDateTime(""<STR_LIT>"")); i1 = new SimpleInterval(DateHelper.parseDateTime(""<STR_LIT>""), DateHelper.parseDateTime(""<STR_LIT>"")); i2 = new SimpleInterval(DateHelper.parseDateTime(""<STR_LIT>""), DateHelper.parseDateTime(""<STR_LIT>"")); } public void testHashCode ( ) throws ParseException { Interval i1, i2 ; i1 = new SimpleInterval ( DateHelper. parseDateTime ( ""<STR_LIT>"" ), DateHelper. parseDateTime ( ""<STR_LIT>"" ) ) ; i2 = new SimpleInterval ( DateHelper. parseDateTime ( ""<STR_LIT>"" ), DateHelper. parseDateTime ( ""<STR_LIT>"" ) ) ; assertEquals ( i1. hashCode ( ), i2. hashCode ( ) ) ; } }",0.0002711906650068213
"[{'role': 'system', 'content': 'You are an AI assistant specialized in code completion for Java. Your task is to complete the provided Java code segment with one line. Give only the code completion.'}, {'role': 'user', 'content': '<s> package com . asakusafw . windgate . hadoopfs . ssh ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipInputStream ; public class ZipEntryInputStream extends InputStream { private final ZipInputStream zipped ; private boolean closed = false ; public ZipEntryInputStream ( ZipInputStream zipped ) { if ( zipped == null ) { throw new IllegalArgumentException ( ""<STR_LIT>"" ) ; } this . zipped = zipped ; } @ Override public void close ( ) throws IOException { if ( closed == false ) { zipped . closeEntry ( ) ; } closed = true ; } @ Override public int read ( byte [ ] b ) throws IOException { return zipped . read ( b ) ; } @ Override public int read ( ) throws IOException { return zipped . read ( ) ; } @ Override public int available ( ) throws IOException { return zipped . available ( ) ; } @ Override public int read ('}, {'role': 'assistant', 'content': 'byte [ ] b , int off , int len ) throws IOException'}, {'role': 'user', 'content': '<s> package com . asakusafw . testtools . excel ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . math . BigDecimal ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import org . apache . hadoop . io . Writable ; import org . apache . poi . hssf . usermodel . HSSFCell ; import org . apache . poi . hssf . usermodel . HSSFRow ; import org . apache . poi . hssf . usermodel . HSSFSheet ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . DateUtil ; import org . apache . poi . ss . usermodel . Row ; import com . asakusafw . modelgen . emitter . JavaName ; import com . asakusafw . modelgen . source . MySqlDataType ; import com . asakusafw . runtime . value . ByteOption ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateTimeOption ; import com . asakusafw . runtime . value . DecimalOption ; import com . asakusafw . runtime . value . IntOption ; import com . asakusafw . runtime . value . LongOption ; import com . asakusafw . runtime . value . ShortOption ; import com . asakusafw . runtime . value . StringOption ; import com . asakusafw . runtime . value . ValueOption ; import com . asakusafw . testtools . ColumnInfo ; import com . asakusafw . testtools . ColumnMatchingCondition ; import com . asakusafw . testtools . ConditionSheetItem ; import com . asakusafw . testtools . Configuration ; import com . asakusafw . testtools . Constants ; import com . asakusafw . testtools . NullValueCondition ; import com . asakusafw . testtools . RowMatchingCondition ; import com . asakusafw . testtools . TestDataHolder ; public class ExcelUtils { public static final long EXCEL_MAX_LONG = <NUM_LIT> ; public static final long EXCEL_MIN_LONG = - <NUM_LIT> ; private final String filename ; private final String tablename ; private final RowMatchingCondition rowMatchingCondition ; private final HSSFWorkbook workbook ; private final HSSFSheet inputDataSheet ; private final HSSFSheet outputDataSheet ; private final HSSFSheet testConditionSheet ; private final DateFormat dateFormat = new SimpleDateFormat ( com . asakusafw . runtime . value . Date . FORMAT ) ; private final DateFormat dateTimeFormat = new SimpleDateFormat ( DateTime . FORMAT ) ; private final List < ColumnInfo > columnInfos ; public ExcelUtils ( String filename ) throws IOException { this . filename = filename ; InputStream is = new FileInputStream ( filename ) ; workbook = new HSSFWorkbook ( is ) ; inputDataSheet = workbook . getSheet ( Constants . INPUT_DATA_SHEET_NAME ) ; if ( inputDataSheet == null ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } outputDataSheet = workbook . getSheet ( Constants . OUTPUT_DATA_SHEET_NAME ) ; if ( outputDataSheet == null ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } testConditionSheet = workbook . getSheet ( Constants . TEST_CONDITION_SHEET_NAME ) ; if ( testConditionSheet == null ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } HSSFCell tableNameCell = getCell ( testConditionSheet , ConditionSheetItem . TABLE_NAME . getRow ( ) , ConditionSheetItem . TABLE_NAME . getCol ( ) + <NUM_LIT:1> ) ; tablename = tableNameCell . getStringCellValue ( ) ; if ( tablename == null || tablename . length ( ) == <NUM_LIT:0> ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } HSSFCell rowMatchingConditionCell = getCell ( testConditionSheet , ConditionSheetItem . ROW_MATCHING_CONDITION . getRow ( ) , ConditionSheetItem . ROW_MATCHING_CONDITION . getCol ( ) + <NUM_LIT:1> ) ; String rowMatchingConditionStr = rowMatchingConditionCell . getStringCellValue ( ) ; if ( rowMatchingConditionStr == null || rowMatchingConditionStr . length ( ) == <NUM_LIT:0> ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } rowMatchingCondition = RowMatchingCondition . getConditonByJapanseName ( rowMatchingConditionStr ) ; if ( rowMatchingCondition == null ) { throw new IOException ( ""<STR_LIT>"" + filename + ""<STR_LIT>"" ) ; } columnInfos = createColumnInfos ( ) ; } private HSSFCell getCell ( HSSFSheet sheet , HSSFRow row , int col ) { HSSFCell cell = row . getCell ( col ) ; if ( cell == null ) { String fmt = ""<STR_LIT>"" ; String msg = String . format ( fmt , filename , sheet . getSheetName ( ) , row . getRowNum ( ) + <NUM_LIT:1> , col + <NUM_LIT:1> ) ; throw new InvalidExcelBookException ( msg ) ; } return cell ; } private HSSFCell getCell ( HSSFSheet sheet , int rownum , int col ) { HSSFRow row = sheet . getRow ( rownum ) ; if ( isEmpty ( row ) ) { String fmt = ""<STR_LIT>"" ; String msg = String . format ( fmt , filename , sheet . getSheetName ( ) , rownum ) ; throw new InvalidExcelBookException ( msg ) ; } HSSFCell cell = getCell ( sheet , row , col ) ; return cell ; } private HSSFCell getCell ( ConditionSheetItem item , HSSFRow row ) { int col = item . getCol ( ) ; HSSFCell cell = getCell ( testConditionSheet , row , col ) ; return cell ; } private String getStringCellValue ( HSSFSheet sheet , ConditionSheetItem item , HSSFRow row ) { HSSFCell cell = getCell ( item , row ) ; String ret ; if ( cell . getCellType ( ) == Cell . CELL_TYPE_NUMERIC ) { double dval = cell . getNumericCellValue ( ) ; ret = Double . toString ( dval ) ; ret = ret . replaceAll ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BLANK ) { ret = ""<STR_LIT>"" ; } else if ( cell . getCellType ( ) != Cell . CELL_TYPE_STRING ) { String fmt = ""<STR_LIT>"" ; int rownum = row . getRowNum ( ) + <NUM_LIT:1> ; int col = item . getCol ( ) + <NUM_LIT:1> ; String msg = String . format ( fmt , filename , sheet . getSheetName ( ) , rownum , col ) ; throw new InvalidExcelBookException ( msg ) ; } else { ret = cell . getStringCellValue ( ) ; } return ret ; } private Double getDubleCellValue ( HSSFSheet sheet , ConditionSheetItem item , HSSFRow row ) { HSSFCell cell = getCell ( item , row ) ; Double ret ; if ( cell . getCellType ( ) == Cell . CELL_TYPE_STRING ) { String str = cell . getStringCellValue ( ) ; if ( str == null || str . length ( ) == <NUM_LIT:0> ) { ret = null ; } else { try { ret = Double . parseDouble ( str ) ; } catch ( NumberFormatException e ) { String fmt = ""<STR_LIT>"" ; int rownum = row . getRowNum ( ) + <NUM_LIT:1> ; int col = item . getCol ( ) + <NUM_LIT:1> ; String msg = String . format ( fmt , filename , sheet . getSheetName ( ) , rownum , col ) ; throw new InvalidExcelBookException ( msg ) ; } } } else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BLANK ) { ret = null ; } else if ( cell . getCellType ( ) != Cell . CELL_TYPE_NUMERIC ) { String fmt = ""<STR_LIT>"" ; int rownum = row . getRowNum ( ) + <NUM_LIT:1> ; int col = item . getCol ( ) + <NUM_LIT:1> ; String msg = String . format ( fmt , filename , sheet . getSheetName ( ) , rownum , col ) ; throw new InvalidExcelBookException ( msg ) ; } else { ret = cell . getNumericCellValue ( ) ; } return ret ; } private String creaetExceptionMessage ( ConditionSheetItem item , HSSFRow row ) { String fmt = ""<STR_LIT>"" ; String msg = String . format ( fmt , filename , row . getRowNum ( ) + <NUM_LIT:1> , item . getName ( ) ) ; return msg ; } private List < ColumnInfo > createColumnInfos ( ) throws IOException { List < ColumnInfo > list = new ArrayList < ColumnInfo > ( ) ; int rownum = ConditionSheetItem . NO . getRow ( ) ; for ( ; ; ) { rownum ++ ; HSSFRow row = testConditionSheet . getRow ( rownum ) ; if ( isEmpty ( row ) ) { break ; } String columnName = getStringCellValue ( testConditionSheet , ConditionSheetItem . COLUMN_NAME , row ) ; if ( columnName . length ( ) == <NUM_LIT:0> ) { String msg = creaetExceptionMessage ( ConditionSheetItem . COLUMN_NAME , row ) ; throw new InvalidExcelBookException ( msg ) ; } String columnComment = getStringCellValue ( testConditionSheet , ConditionSheetItem . COLUMN_COMMENT , row ) ; String dataTypeStr = getStringCellValue ( testConditionSheet , ConditionSheetItem . DATA_TYPE , row ) ; MySqlDataType dataType = MySqlDataType . getDataTypeByString ( dataTypeStr ) ; if ( dataType == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . DATA_TYPE , row ) ; throw new InvalidExcelBookException ( msg ) ; } Double dWidth = getDubleCellValue ( testConditionSheet , ConditionSheetItem . WIDTH , row ) ; Double dScale = getDubleCellValue ( testConditionSheet , ConditionSheetItem . SCALE , row ) ; long characterMaximumLength = <NUM_LIT:0> ; int numericPrecision = <NUM_LIT:0> ; int numericScale = <NUM_LIT:0> ; switch ( dataType ) { case CHAR : case VARCHAR : if ( dWidth == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . WIDTH , row ) ; throw new InvalidExcelBookException ( msg ) ; } characterMaximumLength = dWidth . longValue ( ) ; break ; case DECIMAL : if ( dWidth == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . WIDTH , row ) ; throw new InvalidExcelBookException ( msg ) ; } numericPrecision = dWidth . intValue ( ) ; if ( dScale == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . SCALE , row ) ; throw new InvalidExcelBookException ( msg ) ; } numericScale = dScale . intValue ( ) ; break ; default : break ; } String keyStr = getStringCellValue ( testConditionSheet , ConditionSheetItem . KEY_FLAG , row ) ; boolean key = true ; if ( keyStr . trim ( ) . length ( ) == <NUM_LIT:0> ) { key = false ; } String nullableStr = getStringCellValue ( testConditionSheet , ConditionSheetItem . NULLABLE , row ) ; boolean nullable = true ; if ( nullableStr . trim ( ) . length ( ) == <NUM_LIT:0> ) { nullable = false ; } String columnMatchingConditionStr = getStringCellValue ( testConditionSheet , ConditionSheetItem . MATCHING_CONDITION , row ) ; ColumnMatchingCondition columnMatchingCondition = ColumnMatchingCondition . getConditonByJapanseName ( columnMatchingConditionStr ) ; if ( columnMatchingCondition == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . MATCHING_CONDITION , row ) ; throw new InvalidExcelBookException ( msg ) ; } String nullValueConditionStr = getStringCellValue ( testConditionSheet , ConditionSheetItem . NULL_VALUE_CONDITION , row ) ; NullValueCondition nullValueCondition = NullValueCondition . getConditonByJapanseName ( nullValueConditionStr ) ; if ( nullValueCondition == null ) { String msg = creaetExceptionMessage ( ConditionSheetItem . NULL_VALUE_CONDITION , row ) ; throw new InvalidExcelBookException ( msg ) ; } ColumnInfo info = new ColumnInfo ( tablename , columnName , columnComment , dataType , characterMaximumLength , numericPrecision , numericScale , nullable , key , columnMatchingCondition , nullValueCondition ) ; list . add ( info ) ; } return list ; } public Class < ? extends Writable > getModelClass ( ) { Configuration conf = Configuration . getInstance ( ) ; String pkgName = conf . getModelPackage ( ) ; String simpleName = JavaName . of ( tablename ) . toTypeName ( ) ; Class < ? extends Writable > cl ; cl = findModelClass ( pkgName , null , simpleName ) ; if ( cl != null ) { return cl ; } cl = findModelClass ( pkgName , com . asakusafw . modelgen . Constants . SOURCE_TABLE , simpleName ) ; if ( cl != null ) { return cl ; } cl = findModelClass ( pkgName , com . asakusafw . modelgen . Constants . SOURCE_VIEW , simpleName ) ; if ( cl != null ) { return cl ; } throw new RuntimeException ( new ClassNotFoundException ( buildModelClassName ( pkgName , null , simpleName ) ) ) ; } private Class < ? extends Writable > findModelClass ( String pkgName , String sourceOrNull , String simpleName ) { assert pkgName != null ; assert simpleName != null ; String qualifiedName = buildModelClassName ( pkgName , sourceOrNull , simpleName ) ; Class < ? extends Writable > cl ; try { cl = Class . forName ( qualifiedName ) . asSubclass ( Writable . class ) ; } catch ( ClassNotFoundException e ) { return null ; } return cl ; } private String buildModelClassName ( String pkgName , String sourceOrNull , String simpleName ) { assert pkgName != null ; assert simpleName != null ; StringBuilder modelClassName = new StringBuilder ( ) ; modelClassName . append ( pkgName ) ; modelClassName . append ( \'<CHAR_LIT:.>\' ) ; if ( sourceOrNull != null ) { modelClassName . append ( sourceOrNull ) ; modelClassName . append ( \'<CHAR_LIT:.>\' ) ; } modelClassName . append ( com . asakusafw . modelgen . Constants . CATEGORY_MODEL ) ; modelClassName . append ( \'<CHAR_LIT:.>\' ) ; modelClassName . append ( simpleName ) ; String qualifiedName = modelClassName . toString ( ) ; return qualifiedName ; } private List < Writable > createDatalList ( HSSFSheet sheet ) { List < Writable > list = new ArrayList < Writable > ( ) ; Class < ? > modelClass = getModelClass ( ) ; int rownum = <NUM_LIT:0> ; for ( ; ; ) { rownum ++ ; HSSFRow row = sheet . getRow ( rownum ) ; if ( isEmpty ( row ) ) { break ; } Writable model ; try { model = ( Writable ) modelClass . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } for ( int col = <NUM_LIT:0> ; col < columnInfos . size ( ) ; col ++ ) { HSSFCell cell = row . getCell ( col , Row . CREATE_NULL_AS_BLANK ) ; MySqlDataType type = columnInfos . get ( col ) . getDataType ( ) ; ValueOption < ? > vo ; switch ( type ) { case CHAR : case VARCHAR : vo = getStringOption ( cell ) ; break ; case DATE : vo = getDateOption ( cell ) ; break ; case DATETIME : case TIMESTAMP : vo = getDateTimeOption ( cell ) ; break ; case DECIMAL : vo = getDecimalOption ( cell ) ; break ; case TINY_INT : vo = getByteOption ( cell ) ; break ; case SMALL_INT : vo = getShortOption ( cell ) ; break ; case INT : vo = getIntOption ( cell ) ; break ; case LONG : vo = getLongOption ( cell ) ; break ; default : throw new RuntimeException ( ""<STR_LIT>"" + type ) ; } try { String setterName = columnInfos . get ( col ) . getSetterName ( ) ; Method setter = model . getClass ( ) . getMethod ( setterName , vo . getClass ( ) ) ; setter . invoke ( model , vo ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } } list . add ( model ) ; } return list ; } private boolean isEmpty ( HSSFRow row ) { if ( row == null ) { return true ; } for ( Iterator < Cell > iter = row . cellIterator ( ) ; iter . hasNext ( ) ; ) { if ( iter . next ( ) . getCellType ( ) != Cell . CELL_TYPE_BLANK ) { return false ; } } return true ; } private ByteOption getByteOption ( HSSFCell cell ) { Long l = getLong ( cell ) ; ByteOption op = new ByteOption ( ) ; if ( l == null ) { op . setNull ( ) ; } else { if ( l < Byte . MIN_VALUE || Byte . MAX_VALUE < l ) { String msg = createExceptionMsg ( cell , ""<STR_LIT>"" + l + ""<STR_LIT:)>"" ) ; throw new NumberFormatException ( msg ) ; } op . modify ( l . byteValue ( ) ) ; } return op ; } private ShortOption getShortOption ( HSSFCell cell ) { Long l = getLong ( cell ) ; ShortOption op = new ShortOption ( ) ; if ( l == null ) { op . setNull ( ) ; } else { if ( l < Short . MIN_VALUE || Short . MAX_VALUE < l ) { String msg = createExceptionMsg ( cell , ""<STR_LIT>"" + l + ""<STR_LIT:)>"" ) ; throw new NumberFormatException ( msg ) ; } op . modify ( l . shortValue ( ) ) ; } return op ; } private IntOption getIntOption ( HSSFCell cell ) { Long l = getLong ( cell ) ; IntOption op = new IntOption ( ) ; if ( l == null ) { op . setNull ( ) ; } else { if ( l < Integer . MIN_VALUE || Integer . MAX_VALUE < l ) { String msg = createExceptionMsg ( cell , ""<STR_LIT>"" + l + ""<STR_LIT:)>"" ) ; throw new NumberFormatException ( msg ) ; } op . modify ( l . intValue ( ) ) ; } return op ; } private LongOption getLongOption ( HSSFCell cell ) { Long l = getLong ( cell ) ; LongOption op = new LongOption ( ) ; if ( l == null ) { op . setNull ( ) ; } else { op . modify ( l ) ; } return op ; } private DateOption getDateOption ( HSSFCell cell ) { Date date = getDate ( cell ) ; DateOption op = new DateOption ( ) ; if ( date == null ) { op . setNull ( ) ; } else { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int y = cal . get ( Calendar . YEAR ) ; int m = cal . get ( Calendar . MONTH ) ; int d = cal . get ( Calendar . DAY_OF_MONTH ) ; int h = cal . get ( Calendar . HOUR_OF_DAY ) ; int min = cal . get ( Calendar . MINUTE ) ; int s = cal . get ( Calendar . SECOND ) ; if ( h != <NUM_LIT:0> || min != <NUM_LIT:0> || s != <NUM_LIT:0> ) { String msg = createExceptionMsg ( cell , ""<STR_LIT>"" ) ; throw new CellTypeMismatchException ( msg ) ; } int days = com . asakusafw . runtime . value . DateUtil . getDayFromDate ( y , m + <NUM_LIT:1> , d ) ; op . modify ( days ) ; } return op ; } private DateTimeOption getDateTimeOption ( HSSFCell cell ) { Date date = getDate ( cell ) ; DateTimeOption op = new DateTimeOption ( ) ; if ( date == null ) { op . setNull ( ) ; } else { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int y = cal . get ( Calendar . YEAR ) ; int m = cal . get ( Calendar . MONTH ) ; int d = cal . get ( Calendar . DAY_OF_MONTH ) ; int h = cal . get ( Calendar . HOUR_OF_DAY ) ; int min = cal . get ( Calendar . MINUTE ) ; int s = cal . get ( Calendar . SECOND ) ; int days = com . asakusafw . runtime . value . DateUtil . getDayFromDate ( y , m + <NUM_LIT:1> , d ) ; int secs = com . asakusafw . runtime . value . DateUtil . getSecondFromTime ( h , min , s ) ; DateTime dt = new DateTime ( ) ; dt . setElapsedSeconds ( ( long ) days * <NUM_LIT> + secs ) ; op . modify ( dt ) ; } return op ; } private StringOption getStringOption ( HSSFCell cell ) { String str ; switch ( cell . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : str = null ; break ; case Cell . CELL_TYPE_BOOLEAN : if ( cell . getBooleanCellValue ( ) ) { str = ""<STR_LIT:1>"" ; } else { str = ""<STR_LIT:0>"" ; } break ; case Cell . CELL_TYPE_NUMERIC : if ( DateUtil . isCellDateFormatted ( cell ) ) { double d = cell . getNumericCellValue ( ) ; Date date = DateUtil . getJavaDate ( d ) ; str = dateTimeFormat . format ( date ) ; } else { double d = cell . getNumericCellValue ( ) ; str = Double . toString ( d ) ; str = str . replaceAll ( ""<STR_LIT>"" , ""<STR_LIT>"" ) ; } break ; case Cell . CELL_TYPE_STRING : str = cell . getStringCellValue ('}]","byte [ ] b, int off, int len ) throws IOException",0.00013068352323377001
